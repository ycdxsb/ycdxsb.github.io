<!doctype html><html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>CodeQL之CWE-401(2) - 食兔人的博客</title><meta description="在写第二类CWE-401的查询脚本前，我们需要补充一些东西、在能找到的codeql文档里，大部分都只强推了它的DataFlow模块，而在写第二类查询脚本时，需要用到它的可达性分析模块import semmle.code.cpp.controlflow.StackVariableReachability"><meta property="og:type" content="blog"><meta property="og:title" content="食兔人的博客"><meta property="og:url" content="https://blog.ycdxsb.cn/aaf64f84.html"><meta property="og:site_name" content="食兔人的博客"><meta property="og:description" content="在写第二类CWE-401的查询脚本前，我们需要补充一些东西、在能找到的codeql文档里，大部分都只强推了它的DataFlow模块，而在写第二类查询脚本时，需要用到它的可达性分析模块import semmle.code.cpp.controlflow.StackVariableReachability"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.ycdxsb.cn/img/og_image.png"><meta property="article:published_time" content="2021-01-05T10:59:34.996Z"><meta property="article:modified_time" content="2021-01-05T10:59:34.996Z"><meta property="article:author" content="ycdxsb"><meta property="article:tag" content="research"><meta property="article:tag" content="codeql"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.ycdxsb.cn/aaf64f84.html"},"headline":"食兔人的博客","image":["https://blog.ycdxsb.cn/img/og_image.png"],"datePublished":"2021-01-05T10:59:34.996Z","dateModified":"2021-01-05T10:59:34.996Z","author":{"@type":"Person","name":"ycdxsb"},"description":"在写第二类CWE-401的查询脚本前，我们需要补充一些东西、在能找到的codeql文档里，大部分都只强推了它的DataFlow模块，而在写第二类查询脚本时，需要用到它的可达性分析模块import semmle.code.cpp.controlflow.StackVariableReachability"}</script><link rel="canonical" href="https://blog.ycdxsb.cn/aaf64f84.html"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><link rel="alternate" href="/atom.xml" title="食兔人的博客" type="application/atom+xml">
<link rel="alternate" href="/rss2.xml" title="食兔人的博客" type="application/rss+xml">
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">食兔人的博客</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" datetime="2021-01-05T10:59:34.996Z" title="2021-01-05T10:59:34.996Z">2021-01-05</time><span class="level-item"> ycdxsb </span><span class="level-item"><a class="link-muted" href="/categories/research/">research</a><span> / </span><a class="link-muted" href="/categories/research/codeql/">codeql</a></span><span class="level-item">21 分钟 读完 (大约 3164 个字)</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">CodeQL之CWE-401(2)</h1><div class="content"><blockquote><p>在写第二类<code>CWE-401</code>的查询脚本前，我们需要补充一些东西、在能找到的<code>codeql</code>文档里，大部分都只强推了它的<code>DataFlow</code>模块，而在写第二类查询脚本时，需要用到它的可达性分析模块<code>import semmle.code.cpp.controlflow.StackVariableReachability</code></p></blockquote><a id="more"></a><h3><span id="pcodeql-ke-da-xing-fen-xi-mo-kuai">CodeQL可达性分析模块</span><a href="#pcodeql-ke-da-xing-fen-xi-mo-kuai" class="header-anchor">#</a></h3><p>在这个模块里，存在三个抽象类<code>StackVariableReachability</code>、<code>StackVariableReachabilityWithReassignment</code>和<code>StackVariableReachabilityExt</code></p><h4><span id="pstackvariablereachability">StackVariableReachability</span><a href="#pstackvariablereachability" class="header-anchor">#</a></h4><p><code>StackVariableReachability</code>存在三个抽象函数，需要自己实现具体内容。<code>isSource</code>和<code>isSink</code>很好理解。<code>isBarrier</code>是指中间不允许出现的某个节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Holds if `node` is a source for the reachability analysis using variable `v`. */</span></span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> predicate <span class="title">isSource</span><span class="params">(ControlFlowNode node, StackVariable v)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Holds if `sink` is a (potential) sink for the reachability analysis using variable `v`. */</span></span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> predicate <span class="title">isSink</span><span class="params">(ControlFlowNode node, StackVariable v)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Holds if `node` is a barrier for the reachability analysis using variable `v`. */</span></span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> predicate <span class="title">isBarrier</span><span class="params">(ControlFlowNode node, StackVariable v)</span></span>;</span><br></pre></td></tr></table></figure><p>同时也有可达性分析的函数<code>reaches</code>的描述为<code>Holds if the source node can reach the sink node without crossing a barrier</code>，也就是说可达是指，我从<code>source</code>点到<code>sink</code>点，但是不想经过<code>barrier</code>。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">predicate reaches(ControlFlowNode source, SemanticStackVariable v, ControlFlowNode sink) &#123;</span><br><span class="line">   exists(BasicBlock bb, int i |</span><br><span class="line">     isSource(source, v) and</span><br><span class="line">     bb.getNode(i) = source and</span><br><span class="line">     not bb.isUnreachable()</span><br><span class="line">   |</span><br><span class="line">     exists(int j |</span><br><span class="line">       j &gt; i and</span><br><span class="line">       sink = bb.getNode(j) and</span><br><span class="line">       isSink(sink, v) and</span><br><span class="line">       not exists(int k | isBarrier(bb.getNode(k), v) | k in [i + 1 .. j - 1])</span><br><span class="line">     )</span><br><span class="line">     or</span><br><span class="line">     not exists(int k | isBarrier(bb.getNode(k), v) | k &gt; i) and</span><br><span class="line">     bbSuccessorEntryReaches(bb, v, sink, _)</span><br><span class="line">   )</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><code>reaches</code>函数是在一个函数内判断的，它其实是分为两类进行的。</p><ul><li>第一类：<code>source、sink、barrier</code>在一个基本块内。那么就是判断source点、sink都点在基本块内，且满足前后控制流关系，并且不存在一个barrier点。</li><li>第二类：<code>source、sink、barrier</code>是跨基本块的。还是先判断source点存在于当前基本块，然后在它的后继基本块里继续找<code>sink</code>点和<code>barrier</code>点，即调用<code>bbSuccessorEntryReaches</code>函数，具体细节就不多说啦。</li></ul><h4><span id="pstackvariablereachabilityext">StackVariableReachabilityExt</span><a href="#pstackvariablereachabilityext" class="header-anchor">#</a></h4><p><code>StackVariableReachabilityExt</code>和<code>StackVariableReachability</code>类似，从注释里我们可以看出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Same as `StackVariableReachability`, but `isBarrier` works on control-flow</span></span><br><span class="line"><span class="comment"> * edges rather than nodes and is therefore parameterized by the original</span></span><br><span class="line"><span class="comment"> * source node as well. Otherwise, this class is used like</span></span><br><span class="line"><span class="comment"> * `StackVariableReachability`.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>它和<code>StackVariableReachability</code>的区别在于<code>isBarrier</code>函数作用于边而不是控制流结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** `node` is a barrier for the reachability analysis using variable `v` and starting from `source`. */</span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> predicate <span class="title">isBarrier</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  ControlFlowNode source, ControlFlowNode node, ControlFlowNode next, StackVariable v</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h4><span id="pstackvariablereachabilitywithreassignment">StackVariableReachabilityWithReassignment</span><a href="#pstackvariablereachabilitywithreassignment" class="header-anchor">#</a></h4><p><code>StackVariableReachabilityWithReassignment</code>和之前的类似，区别在于这个类将重新赋值的情况考虑了进去</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reachability analysis for control-flow nodes involving stack variables.</span></span><br><span class="line"><span class="comment"> * Unlike `StackVariableReachability`, this analysis takes variable</span></span><br><span class="line"><span class="comment"> * reassignments into account.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This class is used like `StackVariableReachability`, except that</span></span><br><span class="line"><span class="comment"> * subclasses should override `isSourceActual` and `isSinkActual` instead of</span></span><br><span class="line"><span class="comment"> * `isSource` and `isSink`, and that there is a `reachesTo` predicate in</span></span><br><span class="line"><span class="comment"> * addition to `reaches`.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>同时使用<code>reachTo</code>替代父类的<code>reaches</code>条件，加入了其余的判断</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * As `reaches`, but also specifies the last variable it was reassigned to (`v0`).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">predicate reachesTo(</span><br><span class="line">  ControlFlowNode source, SemanticStackVariable v, ControlFlowNode sink, SemanticStackVariable v0</span><br><span class="line">) &#123;</span><br><span class="line">  exists(ControlFlowNode def |</span><br><span class="line">    actualSourceReaches(source, v, def, v0) and</span><br><span class="line">    StackVariableReachability.super.reaches(def, v0, sink) and</span><br><span class="line">    isSinkActual(sink, v0)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="pjin-yi-bu-shou-xi-ke-da-xing-fen-xi-mo-kuai">进一步熟悉可达性分析模块</span><a href="#pjin-yi-bu-shou-xi-ke-da-xing-fen-xi-mo-kuai" class="header-anchor">#</a></h3><p>CodeQL开发者在示例代码中有两处可以让我们更好的了解上面的三个类的使用，一个是<code>https://github.com/github/codeql/blob/main/cpp/ql/src/Critical/MemoryMayNotBeFreed.ql</code>另一个是<code>https://github.com/github/codeql/blob/main/cpp/ql/src/Critical/FileMayNotBeClosed.ql</code></p><p>分别用于寻找<code>CWE-401</code>和<code>CWE-755</code>，而在我看来这两类其实都属于函数调用失配的情况，即调用了<code>malloc</code>没有调用<code>free</code>，调用了<code>fopen</code>，没有调用<code>fclose</code>。这里我们通过<code>MemoryMayNotBeFreed</code>进一步熟悉可达性分析模块。</p><h4><span id="pzhi-jie-diao-yong-or-jian-jie-diao-yong">直接调用or间接调用</span><a href="#pzhi-jie-diao-yong-or-jian-jie-diao-yong" class="header-anchor">#</a></h4><p>我们知道对一个函数的调用一般分为两种，第一种是直接调用，第二种是通过函数指针进行间接调用，为了同时考虑这两种情况，首先我们需要实现函数调用的函数如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * call is either a direct call to f, or a possible call to f</span></span><br><span class="line"><span class="comment"> * via a function pointer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">predicate <span class="title">mayCallFunction</span><span class="params">(Expr call, Function f)</span> </span>&#123;</span><br><span class="line">  call.(FunctionCall).getTarget() = f or</span><br><span class="line">  call.(VariableCall).getVariable().getAnAssignedValue().getAChild*().(FunctionAccess).getTarget() =</span><br><span class="line">    f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FunctionCall</code>是直接调用，而<code>VariableCall</code>就是间接调用了，用来处理下面这类情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A C/C++ call which is performed through a variable of function pointer type.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * int call_via_ptr(int (*pfn)(int)) &#123;</span></span><br><span class="line"><span class="comment"> *   return pfn(5);</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>直接找到变量，然后看它是不是在某处获得了函数的地址即可。</p><blockquote><p>虽然<code>codeQL</code>的文档不多，但是通过看示例和它已有的注释，可以学到很多文档里没有的东西，不仅限于一些思路的写法和一些已有的API</p></blockquote><h4><span id="pfu-zhi-gei-quan-ju-or-mou-ge-lei-de-yu">赋值给全局or某个类的域</span><a href="#pfu-zhi-gei-quan-ju-or-mou-ge-lei-de-yu" class="header-anchor">#</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">predicate <span class="title">assignedToFieldOrGlobal</span><span class="params">(StackVariable v, Expr e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// assigned to anything except a StackVariable</span></span><br><span class="line">  <span class="comment">// (typically a field or global, but for example also *ptr = v)</span></span><br><span class="line">  e.(Assignment).getRValue() = v.getAnAccess() and</span><br><span class="line">  not e.(Assignment).getLValue().(VariableAccess).getTarget() <span class="keyword">instanceof</span> StackVariable</span><br><span class="line">  or</span><br><span class="line">  exists(Expr midExpr, Function mid, <span class="keyword">int</span> arg |</span><br><span class="line">    <span class="comment">// indirect assignment</span></span><br><span class="line">    e.(FunctionCall).getArgument(arg) = v.getAnAccess() and</span><br><span class="line">    mayCallFunction(e, mid) and</span><br><span class="line">    midExpr.getEnclosingFunction() = mid and</span><br><span class="line">    assignedToFieldOrGlobal(mid.getParameter(arg), midExpr)</span><br><span class="line">  )</span><br><span class="line">  or</span><br><span class="line">  <span class="comment">// assigned to a field via constructor field initializer</span></span><br><span class="line">  e.(ConstructorFieldInit).getExpr() = v.getAnAccess()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下，有这么两类内存分配是不一定在当前函数释放，第一类是全局的变量，它的内存释放可以在程序退出后自行释放，第二类是类内的局部变量，是由类在析构的时候释放的。</p><p><code>assignedToFieldOrGlobal</code>函数用于判断这两种情况，避免误报产生。第一种是：一个表达式，右侧是局部变量，左侧不是局部变量(也就是全局变量)，这是直接赋值的情况；第三种是：在类的初始化时进行赋值；第二种是间接赋值，比如说通过参数调用函数，然后在函数内对这个参数进行了赋值。</p><h4><span id="palloccallorindirect">allocCallOrIndirect</span><a href="#palloccallorindirect" class="header-anchor">#</a></h4><p><code>allocCallOrIndirect</code>是用来找<code>source</code>点的，因为我们要找<code>MemoryMayNotBeFreed</code>的情况，所以我们的<code>source</code>点肯定是对分配内存函数的调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">predicate <span class="title">allocCallOrIndirect</span><span class="params">(Expr e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// direct alloc call</span></span><br><span class="line">  e.(AllocationExpr).requiresDealloc() and</span><br><span class="line">  <span class="comment">// We are only interested in alloc calls that are</span></span><br><span class="line">  <span class="comment">// actually freed somehow, as MemoryNeverFreed</span></span><br><span class="line">  <span class="comment">// will catch those that aren't.</span></span><br><span class="line">  allocMayBeFreed(e)</span><br><span class="line">  or</span><br><span class="line">  exists(ReturnStmt rtn |</span><br><span class="line">    <span class="comment">// indirect alloc call</span></span><br><span class="line">    mayCallFunction(e, rtn.getEnclosingFunction()) and</span><br><span class="line">    (</span><br><span class="line">      <span class="comment">// return alloc</span></span><br><span class="line">      allocCallOrIndirect(rtn.getExpr())</span><br><span class="line">      or</span><br><span class="line">      <span class="comment">// return variable assigned with alloc</span></span><br><span class="line">      exists(Variable v |</span><br><span class="line">        v = rtn.getExpr().(VariableAccess).getTarget() and</span><br><span class="line">        allocCallOrIndirect(v.getAnAssignedValue()) and</span><br><span class="line">        <span class="function">not <span class="title">assignedToFieldOrGlobal</span><span class="params">(v, _)</span></span></span><br><span class="line"><span class="function">      )</span></span><br><span class="line"><span class="function">    )</span></span><br><span class="line"><span class="function">  )</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h4><span id="pfreecallorindirect">freeCallOrIndirect</span><a href="#pfreecallorindirect" class="header-anchor">#</a></h4><p>在找内存未释放漏洞时，我们肯定要判断是不是有释放点，因此<code>freeCallOrIndirect</code>就是为了找内存释放的点，同时realloc也是一种内存释放</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The point at which a call to 'realloc' on 'v' has been verified to</span></span><br><span class="line"><span class="comment"> * succeed.  A failed realloc does *not* free the input pointer, which</span></span><br><span class="line"><span class="comment"> * can cause memory leaks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">predicate <span class="title">verifiedRealloc</span><span class="params">(FunctionCall reallocCall, Variable v, ControlFlowNode verified)</span> </span>&#123;</span><br><span class="line">  reallocCall.(AllocationExpr).getReallocPtr() = v.getAnAccess() and</span><br><span class="line">  (</span><br><span class="line">    exists(Variable newV, ControlFlowNode node |</span><br><span class="line">      <span class="comment">// a realloc followed by a null check at 'node' (return the non-null</span></span><br><span class="line">      <span class="comment">// successor, i.e. where the realloc is confirmed to have succeeded)</span></span><br><span class="line">      newV.getAnAssignedValue() = reallocCall and</span><br><span class="line">      node.(AnalysedExpr).getNonNullSuccessor(newV) = verified and</span><br><span class="line">      <span class="comment">// note: this case uses naive flow logic (getAnAssignedValue).</span></span><br><span class="line">      <span class="comment">// special case: if the result of the 'realloc' is assigned to the</span></span><br><span class="line">      <span class="comment">// same variable, we don't descriminate properly between the old</span></span><br><span class="line">      <span class="comment">// and the new allocation; better to not consider this a free at</span></span><br><span class="line">      <span class="comment">// all in that case.</span></span><br><span class="line">      newV != v</span><br><span class="line">    )</span><br><span class="line">    or</span><br><span class="line">    <span class="comment">// a realloc(ptr, 0), which always succeeds and frees</span></span><br><span class="line">    <span class="comment">// (return the realloc itself)</span></span><br><span class="line">    reallocCall.(AllocationExpr).getReallocPtr().getValue() = <span class="string">"0"</span> and</span><br><span class="line">    verified = reallocCall</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">predicate <span class="title">freeCallOrIndirect</span><span class="params">(ControlFlowNode n, Variable v)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// direct free call</span></span><br><span class="line">  n.(DeallocationExpr).getFreedExpr() = v.getAnAccess() and</span><br><span class="line">  <span class="function">not <span class="title">exists</span><span class="params">(n.(AllocationExpr)</span>.<span class="title">getReallocPtr</span><span class="params">()</span>)</span></span><br><span class="line"><span class="function">  or</span></span><br><span class="line"><span class="function">  <span class="comment">// verified realloc call</span></span></span><br><span class="line"><span class="function">  <span class="title">verifiedRealloc</span><span class="params">(_, v, n)</span></span></span><br><span class="line"><span class="function">  or</span></span><br><span class="line"><span class="function">  <span class="title">exists</span><span class="params">(FunctionCall midcall, Function mid, <span class="keyword">int</span> arg |</span></span></span><br><span class="line"><span class="function"><span class="params">    // indirect free call</span></span></span><br><span class="line"><span class="function"><span class="params">    n.(Call)</span>.<span class="title">getArgument</span><span class="params">(arg)</span> </span>= v.getAnAccess() and</span><br><span class="line">    mayCallFunction(n, mid) and</span><br><span class="line">    midcall.getEnclosingFunction() = mid and</span><br><span class="line">    freeCallOrIndirect(midcall, mid.getParameter(arg))</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="pallocvariablereachability">AllocVariableReachability</span><a href="#pallocvariablereachability" class="header-anchor">#</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">predicate <span class="title">allocationDefinition</span><span class="params">(StackVariable v, ControlFlowNode def)</span> </span>&#123;</span><br><span class="line">  exists(Expr expr | exprDefinition(v, def, expr) <span class="function">and <span class="title">allocCallOrIndirect</span><span class="params">(expr)</span>)</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">class AllocVariableReachability extends StackVariableReachabilityWithReassignment </span>&#123;</span><br><span class="line">  AllocVariableReachability() &#123; <span class="keyword">this</span> = <span class="string">"AllocVariableReachability"</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">override predicate <span class="title">isSourceActual</span><span class="params">(ControlFlowNode node, StackVariable v)</span> </span>&#123;</span><br><span class="line">    allocationDefinition(v, node)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">override predicate <span class="title">isSinkActual</span><span class="params">(ControlFlowNode node, StackVariable v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// node may be used in allocationReaches</span></span><br><span class="line">    exists(node.(AnalysedExpr).getNullSuccessor(v)) or</span><br><span class="line">    freeCallOrIndirect(node, v) or</span><br><span class="line">    assignedToFieldOrGlobal(v, node) or</span><br><span class="line">    <span class="comment">// node may be used directly in query</span></span><br><span class="line">    v.getFunction() = node.(ReturnStmt).getEnclosingFunction()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">override predicate <span class="title">isBarrier</span><span class="params">(ControlFlowNode node, StackVariable v)</span> </span>&#123; definitionBarrier(v, node) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AllocVariableReachability</code>是对<code>StackVariableReachabilityWithReassignment</code>的继承。<code>source</code>点是：存在一个表达式，它调用了分配内存的函数并赋值给了局部变量<code>v</code>。<code>sink</code>点可以是free或者是赋值给了全局的变量。<code>barrier</code>是通过库中的函数实现的，目的是判断重新赋值的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Holds if `barrier` is either a (potential) definition of `v` or follows an</span></span><br><span class="line"><span class="comment"> * access that gets the address of `v`. In both cases, the value of</span></span><br><span class="line"><span class="comment"> * `v` after `barrier` cannot be assumed to be the same as before.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">predicate <span class="title">definitionBarrier</span><span class="params">(SemanticStackVariable v, ControlFlowNode barrier)</span></span></span><br></pre></td></tr></table></figure><h4><span id="pallocreachability">AllocReachability</span><a href="#pallocreachability" class="header-anchor">#</a></h4><p><code>AllocReachability</code>继承<code>StackVariableReachabilityExt</code>，source点同上，sink点是需要是和变量存在在一盒函数内的return语句，<code>barrier</code>是找被<code>free</code>、被赋值给全局变量或者已经经过了NULL检查的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The value from allocation `def` is still held in Variable `v` upon entering `node`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">predicate <span class="title">allocatedVariableReaches</span><span class="params">(StackVariable v, ControlFlowNode def, ControlFlowNode node)</span> </span>&#123;</span><br><span class="line">  exists(AllocVariableReachability r |</span><br><span class="line">    <span class="comment">// reachability</span></span><br><span class="line">    r.reachesTo(def, _, node, v)</span><br><span class="line">    or</span><br><span class="line">    <span class="comment">// accept def node itself</span></span><br><span class="line">    r.isSource(def, v) and</span><br><span class="line">    node = def</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AllocReachability</span> <span class="keyword">extends</span> <span class="title">StackVariableReachabilityExt</span> </span>&#123;</span><br><span class="line">  AllocReachability() &#123; <span class="keyword">this</span> = <span class="string">"AllocReachability"</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">override predicate <span class="title">isSource</span><span class="params">(ControlFlowNode node, StackVariable v)</span> </span>&#123;</span><br><span class="line">    allocationDefinition(v, node)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">override predicate <span class="title">isSink</span><span class="params">(ControlFlowNode node, StackVariable v)</span> </span>&#123;</span><br><span class="line">    v.getFunction() = node.(ReturnStmt).getEnclosingFunction()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">override predicate <span class="title">isBarrier</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    ControlFlowNode source, ControlFlowNode node, ControlFlowNode next, StackVariable v</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span> </span>&#123;</span><br><span class="line">    isSource(source, v) and</span><br><span class="line">    next = node.getASuccessor() and</span><br><span class="line">    <span class="comment">// the memory (stored in any variable `v0`) allocated at `source` is freed or</span></span><br><span class="line">    <span class="comment">// assigned to a global at node, or NULL checked on the edge node -&gt; next.</span></span><br><span class="line">    exists(StackVariable v0 | allocatedVariableReaches(v0, source, node) |</span><br><span class="line">      node.(AnalysedExpr).getNullSuccessor(v0) = next or</span><br><span class="line">      freeCallOrIndirect(node, v0) or</span><br><span class="line">      assignedToFieldOrGlobal(v0, node)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="plian-he-cha-xun">联合查询</span><a href="#plian-he-cha-xun" class="header-anchor">#</a></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from ControlFlowNode def, ReturnStmt ret</span><br><span class="line">where</span><br><span class="line">  allocationReaches(def, ret) and</span><br><span class="line">  not exists(StackVariable v |</span><br><span class="line">    allocatedVariableReaches(v, def, ret) and</span><br><span class="line">    ret.getAChild*() = v.getAnAccess()</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">def</span>, <span class="string">"The memory allocated here may not be released at $@."</span>, ret, <span class="string">"this exit point"</span></span><br></pre></td></tr></table></figure><p>在有了前面的铺垫后，最终的查询用自然语言描述就是：</p><ol><li>从一个控制流结点到一个返回语句可达</li><li>且不存在一个变量保存了分配的内存的指针且最后被释放或者被赋值给全局变量等，并且申请的空间也没有作为函数返回值被返回到上层函数。</li></ol><h3><span id="pfu-lu-memorymaynotbefreed-ql">附录：MemoryMayNotBeFreed.ql</span><a href="#pfu-lu-memorymaynotbefreed-ql" class="header-anchor">#</a></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @name Memory may not be freed</span></span><br><span class="line"><span class="comment"> * @description A function may return before freeing memory that was allocated in the function. Freeing all memory allocated in the function before returning ties the lifetime of the memory blocks to that of the function call, making it easier to avoid and detect memory leaks.</span></span><br><span class="line"><span class="comment"> * @kind problem</span></span><br><span class="line"><span class="comment"> * @id cpp/memory-may-not-be-freed</span></span><br><span class="line"><span class="comment"> * @problem.severity warning</span></span><br><span class="line"><span class="comment"> * @tags efficiency</span></span><br><span class="line"><span class="comment"> *       security</span></span><br><span class="line"><span class="comment"> *       external/cwe/cwe-401</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">import MemoryFreed</span><br><span class="line">import semmle.code.cpp.controlflow.StackVariableReachability</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 'call' is either a direct call to f, or a possible call to f</span></span><br><span class="line"><span class="comment"> * via a function pointer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">predicate mayCallFunction(Expr <span class="keyword">call</span>, <span class="keyword">Function</span> f) &#123;</span><br><span class="line">  call.(FunctionCall).getTarget() = f <span class="keyword">or</span></span><br><span class="line">  call.(VariableCall).getVariable().getAnAssignedValue().getAChild*().(FunctionAccess).getTarget() =</span><br><span class="line">    f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">predicate allocCallOrIndirect(Expr e) &#123;</span><br><span class="line">  // direct alloc <span class="keyword">call</span></span><br><span class="line">  e.(AllocationExpr).requiresDealloc() <span class="keyword">and</span></span><br><span class="line">  // We <span class="keyword">are</span> <span class="keyword">only</span> interested <span class="keyword">in</span> alloc calls that <span class="keyword">are</span></span><br><span class="line">  // actually freed somehow, <span class="keyword">as</span> MemoryNeverFreed</span><br><span class="line">  // will catch those that aren<span class="string">'t.</span></span><br><span class="line"><span class="string">  allocMayBeFreed(e)</span></span><br><span class="line"><span class="string">  or</span></span><br><span class="line"><span class="string">  exists(ReturnStmt rtn |</span></span><br><span class="line"><span class="string">    // indirect alloc call</span></span><br><span class="line"><span class="string">    mayCallFunction(e, rtn.getEnclosingFunction()) and</span></span><br><span class="line"><span class="string">    (</span></span><br><span class="line"><span class="string">      // return alloc</span></span><br><span class="line"><span class="string">      allocCallOrIndirect(rtn.getExpr())</span></span><br><span class="line"><span class="string">      or</span></span><br><span class="line"><span class="string">      // return variable assigned with alloc</span></span><br><span class="line"><span class="string">      exists(Variable v |</span></span><br><span class="line"><span class="string">        v = rtn.getExpr().(VariableAccess).getTarget() and</span></span><br><span class="line"><span class="string">        allocCallOrIndirect(v.getAnAssignedValue()) and</span></span><br><span class="line"><span class="string">        not assignedToFieldOrGlobal(v, _)</span></span><br><span class="line"><span class="string">      )</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  )</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/**</span></span><br><span class="line"><span class="string"> * The point at which a call to '</span>realloc<span class="string">' on '</span>v<span class="string">' has been verified to</span></span><br><span class="line"><span class="string"> * succeed.  A failed realloc does *not* free the input pointer, which</span></span><br><span class="line"><span class="string"> * can cause memory leaks.</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">predicate verifiedRealloc(FunctionCall reallocCall, Variable v, ControlFlowNode verified) &#123;</span></span><br><span class="line"><span class="string">  reallocCall.(AllocationExpr).getReallocPtr() = v.getAnAccess() and</span></span><br><span class="line"><span class="string">  (</span></span><br><span class="line"><span class="string">    exists(Variable newV, ControlFlowNode node |</span></span><br><span class="line"><span class="string">      // a realloc followed by a null check at '</span>node<span class="string">' (return the non-null</span></span><br><span class="line"><span class="string">      // successor, i.e. where the realloc is confirmed to have succeeded)</span></span><br><span class="line"><span class="string">      newV.getAnAssignedValue() = reallocCall and</span></span><br><span class="line"><span class="string">      node.(AnalysedExpr).getNonNullSuccessor(newV) = verified and</span></span><br><span class="line"><span class="string">      // note: this case uses naive flow logic (getAnAssignedValue).</span></span><br><span class="line"><span class="string">      // special case: if the result of the '</span>realloc<span class="string">' is assigned to the</span></span><br><span class="line"><span class="string">      // same variable, we don'</span>t descriminate properly <span class="keyword">between</span> the <span class="keyword">old</span></span><br><span class="line">      // <span class="keyword">and</span> the <span class="keyword">new</span> allocation; better to not consider this a free at</span><br><span class="line">      // all in that case.</span><br><span class="line">      newV != v</span><br><span class="line">    )</span><br><span class="line">    or</span><br><span class="line">    // a realloc(ptr, 0), which always succeeds and frees</span><br><span class="line">    // (return the realloc itself)</span><br><span class="line">    reallocCall.(AllocationExpr).getReallocPtr().getValue() = "0" and</span><br><span class="line">    verified = reallocCall</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">predicate freeCallOrIndirect(ControlFlowNode n, Variable v) &#123;</span><br><span class="line">  // direct free <span class="keyword">call</span></span><br><span class="line">  n.(DeallocationExpr).getFreedExpr() = v.getAnAccess() <span class="keyword">and</span></span><br><span class="line">  <span class="keyword">not</span> <span class="keyword">exists</span>(n.(AllocationExpr).getReallocPtr())</span><br><span class="line">  <span class="keyword">or</span></span><br><span class="line">  // verified realloc <span class="keyword">call</span></span><br><span class="line">  verifiedRealloc(_, v, n)</span><br><span class="line">  <span class="keyword">or</span></span><br><span class="line">  <span class="keyword">exists</span>(FunctionCall midcall, <span class="keyword">Function</span> <span class="keyword">mid</span>, <span class="built_in">int</span> arg |</span><br><span class="line">    // indirect free <span class="keyword">call</span></span><br><span class="line">    n.(<span class="keyword">Call</span>).getArgument(arg) = v.getAnAccess() <span class="keyword">and</span></span><br><span class="line">    mayCallFunction(n, <span class="keyword">mid</span>) <span class="keyword">and</span></span><br><span class="line">    midcall.getEnclosingFunction() = <span class="keyword">mid</span> <span class="keyword">and</span></span><br><span class="line">    freeCallOrIndirect(midcall, mid.getParameter(arg))</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">predicate allocationDefinition(StackVariable v, ControlFlowNode <span class="keyword">def</span>) &#123;</span><br><span class="line">  <span class="keyword">exists</span>(Expr expr | exprDefinition(v, <span class="keyword">def</span>, expr) <span class="keyword">and</span> allocCallOrIndirect(expr))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> AllocVariableReachability extends StackVariableReachabilityWithReassignment &#123;</span><br><span class="line">  AllocVariableReachability() &#123; this = <span class="string">"AllocVariableReachability"</span> &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSourceActual(ControlFlowNode node, StackVariable v) &#123;</span><br><span class="line">    allocationDefinition(v, node)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSinkActual(ControlFlowNode node, StackVariable v) &#123;</span><br><span class="line">    // node may be used <span class="keyword">in</span> allocationReaches</span><br><span class="line">    <span class="keyword">exists</span>(node.(AnalysedExpr).getNullSuccessor(v)) <span class="keyword">or</span></span><br><span class="line">    freeCallOrIndirect(node, v) <span class="keyword">or</span></span><br><span class="line">    assignedToFieldOrGlobal(v, node) <span class="keyword">or</span></span><br><span class="line">    // node may be used directly <span class="keyword">in</span> <span class="keyword">query</span></span><br><span class="line">    v.getFunction() = node.(ReturnStmt).getEnclosingFunction()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isBarrier(ControlFlowNode node, StackVariable v) &#123; definitionBarrier(v, node) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The value from allocation `def` is still held in Variable `v` upon entering `node`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">predicate allocatedVariableReaches(StackVariable v, ControlFlowNode <span class="keyword">def</span>, ControlFlowNode node) &#123;</span><br><span class="line">  <span class="keyword">exists</span>(AllocVariableReachability r |</span><br><span class="line">    // reachability</span><br><span class="line">    r.reachesTo(<span class="keyword">def</span>, _, node, v)</span><br><span class="line">    <span class="keyword">or</span></span><br><span class="line">    // <span class="keyword">accept</span> <span class="keyword">def</span> node itself</span><br><span class="line">    r.isSource(<span class="keyword">def</span>, v) <span class="keyword">and</span></span><br><span class="line">    node = <span class="keyword">def</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> AllocReachability extends StackVariableReachabilityExt &#123;</span><br><span class="line">  AllocReachability() &#123; this = <span class="string">"AllocReachability"</span> &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSource(ControlFlowNode node, StackVariable v) &#123;</span><br><span class="line">    allocationDefinition(v, node)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSink(ControlFlowNode node, StackVariable v) &#123;</span><br><span class="line">    v.getFunction() = node.(ReturnStmt).getEnclosingFunction()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isBarrier(</span><br><span class="line">    ControlFlowNode <span class="keyword">source</span>, ControlFlowNode node, ControlFlowNode <span class="keyword">next</span>, StackVariable v</span><br><span class="line">  ) &#123;</span><br><span class="line">    isSource(<span class="keyword">source</span>, v) <span class="keyword">and</span></span><br><span class="line">    <span class="keyword">next</span> = node.getASuccessor() <span class="keyword">and</span></span><br><span class="line">    // the <span class="keyword">memory</span> (<span class="keyword">stored</span> <span class="keyword">in</span> <span class="keyword">any</span> <span class="keyword">variable</span> <span class="string">`v0`</span>) allocated <span class="keyword">at</span> <span class="string">`source`</span> <span class="keyword">is</span> freed <span class="keyword">or</span></span><br><span class="line">    // assigned <span class="keyword">to</span> a <span class="keyword">global</span> <span class="keyword">at</span> node, <span class="keyword">or</span> <span class="literal">NULL</span> checked <span class="keyword">on</span> the edge node -&gt; next.</span><br><span class="line">    <span class="keyword">exists</span>(StackVariable v0 | allocatedVariableReaches(v0, <span class="keyword">source</span>, node) |</span><br><span class="line">      node.(AnalysedExpr).getNullSuccessor(v0) = <span class="keyword">next</span> <span class="keyword">or</span></span><br><span class="line">      freeCallOrIndirect(node, v0) <span class="keyword">or</span></span><br><span class="line">      assignedToFieldOrGlobal(v0, node)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The value returned by allocation `def` has not been freed, confirmed to be null,</span></span><br><span class="line"><span class="comment"> * or potentially leaked globally upon reaching `node`  (regardless of what variable</span></span><br><span class="line"><span class="comment"> * it's still held in, if any).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">predicate allocationReaches(ControlFlowNode <span class="keyword">def</span>, ControlFlowNode node) &#123;</span><br><span class="line">  <span class="keyword">exists</span>(AllocReachability r | r.reaches(<span class="keyword">def</span>, _, node))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">predicate assignedToFieldOrGlobal(StackVariable v, Expr e) &#123;</span><br><span class="line">  // assigned <span class="keyword">to</span> anything <span class="keyword">except</span> a StackVariable</span><br><span class="line">  // (typically a <span class="keyword">field</span> <span class="keyword">or</span> <span class="keyword">global</span>, but <span class="keyword">for</span> example also *ptr = v)</span><br><span class="line">  e.(Assignment).getRValue() = v.getAnAccess() <span class="keyword">and</span></span><br><span class="line">  <span class="keyword">not</span> e.(Assignment).getLValue().(VariableAccess).getTarget() instanceof StackVariable</span><br><span class="line">  <span class="keyword">or</span></span><br><span class="line">  <span class="keyword">exists</span>(Expr midExpr, <span class="keyword">Function</span> <span class="keyword">mid</span>, <span class="built_in">int</span> arg |</span><br><span class="line">    // indirect assignment</span><br><span class="line">    e.(FunctionCall).getArgument(arg) = v.getAnAccess() <span class="keyword">and</span></span><br><span class="line">    mayCallFunction(e, <span class="keyword">mid</span>) <span class="keyword">and</span></span><br><span class="line">    midExpr.getEnclosingFunction() = <span class="keyword">mid</span> <span class="keyword">and</span></span><br><span class="line">    assignedToFieldOrGlobal(mid.getParameter(arg), midExpr)</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">or</span></span><br><span class="line">  // assigned <span class="keyword">to</span> a <span class="keyword">field</span> via <span class="keyword">constructor</span> <span class="keyword">field</span> initializer</span><br><span class="line">  e.(ConstructorFieldInit).getExpr() = v.getAnAccess()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> ControlFlowNode <span class="keyword">def</span>, ReturnStmt ret</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">  allocationReaches(<span class="keyword">def</span>, ret) <span class="keyword">and</span></span><br><span class="line">  <span class="keyword">not</span> <span class="keyword">exists</span>(StackVariable v |</span><br><span class="line">    allocatedVariableReaches(v, <span class="keyword">def</span>, ret) <span class="keyword">and</span></span><br><span class="line">    ret.getAChild*() = v.getAnAccess()</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">def</span>, <span class="string">"The memory allocated here may not be released at $@."</span>, ret, <span class="string">"this exit point"</span></span><br></pre></td></tr></table></figure></div><div class="article-tags size-small mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/research/">research</a><a class="link-muted mr-2" rel="tag" href="/tags/codeql/">codeql</a></div><div class="a2a_kit a2a_kit_size_32 a2a_default_style"><a class="a2a_dd" href="https://www.addtoany.com/share"></a><a class="a2a_button_facebook"></a><a class="a2a_button_twitter"></a><a class="a2a_button_telegram"></a><a class="a2a_button_whatsapp"></a><a class="a2a_button_reddit"></a></div><script src="https://static.addtoany.com/menu/page.js" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/images/alipay.jpeg" alt="支付宝"></span></a><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/images/wechatpay.jpeg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/b3ed7ec5.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">CodeQL之CWE-401(3)</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/81db1c47.html"><span class="level-item">CodeQL之CWE-401(1)</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script><script>new Valine({el:"#valine-thread",appId:"arzLjs0uhdNidwVh9BC6XEl2-gzGzoHsz",appKey:"UTxl8VuzUJM8vVhRdRKuNIM6",placeholder:"ヾﾉ≧∀≦)o 来呀！快活呀！~",avatar:"mm",meta:["nick","mail","link"],pageSize:10,lang:"zh-CN",highlight:!0,requiredFields:[]})</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen order-1 is-sticky"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://www.gravatar.com/avatar/9b722a00f4fc188a2dbfa47ac65b8773?s=128" alt="食兔人"></figure><p class="title is-size-4 is-block line-height-inherit">食兔人</p><p class="is-size-6 is-block">学生,信息安全爱好者</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>北京,中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">78</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">29</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">29</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ycdxsb" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ycdxsb"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/ycdxsb"><i class="fab fa-twitter"></i></a></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="http://m0te.top/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Mote</span></span><span class="level-right"><span class="level-item tag">m0te.top</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://yurisec.cn/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Yuri</span></span><span class="level-right"><span class="level-item tag">yurisec.cn</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://nullpointer.me/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Mad</span></span><span class="level-right"><span class="level-item tag">nullpointer.me</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/11/"><span class="level-start"><span class="level-item">十一月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/10/"><span class="level-start"><span class="level-item">十月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">28</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=ycdxsb/fVNc&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="ycdxsb/fVNc" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="订阅"></div></div><p class="help">邮件订阅，更新早知道</p></form></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/AI/"><span class="level-start"><span class="level-item">AI</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/AI/NLP/"><span class="level-start"><span class="level-item">NLP</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/AI/machine-learning/"><span class="level-start"><span class="level-item">machine_learning</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/CTF/"><span class="level-start"><span class="level-item">CTF</span></span><span class="level-end"><span class="level-item tag">43</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/CTF/CVE/"><span class="level-start"><span class="level-item">CVE</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CTF/crypto/"><span class="level-start"><span class="level-item">crypto</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CTF/pentest/"><span class="level-start"><span class="level-item">pentest</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CTF/pwn/"><span class="level-start"><span class="level-item">pwn</span></span><span class="level-end"><span class="level-item tag">24</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/CTF/pwn/pwnable-kr/"><span class="level-start"><span class="level-item">pwnable.kr</span></span><span class="level-end"><span class="level-item tag">21</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/CTF/pwn/pwnable-kr/Toddler-sBottle/"><span class="level-start"><span class="level-item">Toddler&#039;sBottle</span></span><span class="level-end"><span class="level-item tag">21</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/CTF/pwn/stack-overflow/"><span class="level-start"><span class="level-item">stack_overflow</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/CTF/pwn/stack-overflow/ROP-Emporium/"><span class="level-start"><span class="level-item">ROP_Emporium</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/CTF/re/"><span class="level-start"><span class="level-item">re</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CTF/writeup/"><span class="level-start"><span class="level-item">writeup</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/PyQt5/"><span class="level-start"><span class="level-item">PyQt5</span></span><span class="level-end"><span class="level-item tag">12</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/PyQt5/Web/"><span class="level-start"><span class="level-item">Web</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/PyQt5/%E5%9B%BE%E4%B9%A6%E9%A6%86%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">图书馆管理系统</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/life/"><span class="level-start"><span class="level-item">life</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/papers/"><span class="level-start"><span class="level-item">papers</span></span><span class="level-end"><span class="level-item tag">12</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/papers/security/"><span class="level-start"><span class="level-item">security</span></span><span class="level-end"><span class="level-item tag">12</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/papers/security/automatic-analyse/"><span class="level-start"><span class="level-item">automatic_analyse</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/papers/security/fuzz/"><span class="level-start"><span class="level-item">fuzz</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/papers/security/mobile-security/"><span class="level-start"><span class="level-item">mobile_security</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/papers/security/others/"><span class="level-start"><span class="level-item">others</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/papers/security/security-situation-awareness/"><span class="level-start"><span class="level-item">security_situation_awareness</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/research/"><span class="level-start"><span class="level-item">research</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/research/codeql/"><span class="level-start"><span class="level-item">codeql</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/research/linux-kernel/"><span class="level-start"><span class="level-item">linux_kernel</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/tools/"><span class="level-start"><span class="level-item">tools</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time datetime="2021-01-08T09:19:00.000Z">2021-01-08</time></p><p class="title is-6"><a class="link-muted" href="/77e17aac.html">ROP Emporium (中)</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/CTF/">CTF</a> / <a class="link-muted" href="/categories/CTF/pwn/">pwn</a> / <a class="link-muted" href="/categories/CTF/pwn/stack-overflow/">stack_overflow</a> / <a class="link-muted" href="/categories/CTF/pwn/stack-overflow/ROP-Emporium/">ROP_Emporium</a></p></div></article><article class="media"><div class="media-content size-small"><p><time datetime="2021-01-05T10:59:50.988Z">2021-01-05</time></p><p class="title is-6"><a class="link-muted" href="/fcace802.html">CodeQL之CWE-401(4)</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/research/">research</a> / <a class="link-muted" href="/categories/research/codeql/">codeql</a></p></div></article><article class="media"><div class="media-content size-small"><p><time datetime="2021-01-05T10:59:43.804Z">2021-01-05</time></p><p class="title is-6"><a class="link-muted" href="/b3ed7ec5.html">CodeQL之CWE-401(3)</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/research/">research</a> / <a class="link-muted" href="/categories/research/codeql/">codeql</a></p></div></article><article class="media"><div class="media-content size-small"><p><time datetime="2021-01-05T10:59:34.996Z">2021-01-05</time></p><p class="title is-6"><a class="link-muted" href="/aaf64f84.html">CodeQL之CWE-401(2)</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/research/">research</a> / <a class="link-muted" href="/categories/research/codeql/">codeql</a></p></div></article><article class="media"><div class="media-content size-small"><p><time datetime="2021-01-05T10:59:27.168Z">2021-01-05</time></p><p class="title is-6"><a class="link-muted" href="/81db1c47.html">CodeQL之CWE-401(1)</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/research/">research</a> / <a class="link-muted" href="/categories/research/codeql/">codeql</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/AI/"><span class="tag">AI</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CTF/"><span class="tag">CTF</span><span class="tag is-grey-lightest">43</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CVE/"><span class="tag">CVE</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NLP/"><span class="tag">NLP</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PyQt5/"><span class="tag">PyQt5</span><span class="tag is-grey-lightest">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ROP-Emporium/"><span class="tag">ROP Emporium</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Toddler-s-Bottle/"><span class="tag">Toddler&#039;s Bottle</span><span class="tag is-grey-lightest">21</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Web/"><span class="tag">Web</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/automatic-analyse/"><span class="tag">automatic analyse</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/codeql/"><span class="tag">codeql</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/crypto/"><span class="tag">crypto</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/fuzz/"><span class="tag">fuzz</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/life/"><span class="tag">life</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux-kernel/"><span class="tag">linux kernel</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/machine-learning/"><span class="tag">machine learning</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mobile-security/"><span class="tag">mobile security</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/others/"><span class="tag">others</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/paper/"><span class="tag">paper</span><span class="tag is-grey-lightest">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pentest/"><span class="tag">pentest</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pwn/"><span class="tag">pwn</span><span class="tag is-grey-lightest">24</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pwnable-kr/"><span class="tag">pwnable.kr</span><span class="tag is-grey-lightest">21</span></a></div><div class="control"><a class="tags has-addons" href="/tags/re/"><span class="tag">re</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/research/"><span class="tag">research</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/security/"><span class="tag">security</span><span class="tag is-grey-lightest">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/security-situation-awareness/"><span class="tag">security situation awareness</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/stack-overflow/"><span class="tag">stack overflow</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tools/"><span class="tag">tools</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/writeup/"><span class="tag">writeup</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="tag">数据库</span><span class="tag is-grey-lightest">11</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">食兔人的博客</a><p class="size-small"><span>&copy; 2021 ycdxsb</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={site:{url:"https://blog.ycdxsb.cn",external_link:{enable:!0,exclude:[]}},article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){loadInsight({contentUrl:"/content.json"},{hint:"想要查找什么...",untitled:"(无标题)",posts:"文章",pages:"页面",categories:"分类",tags:"标签"})})</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":200,"height":400},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>